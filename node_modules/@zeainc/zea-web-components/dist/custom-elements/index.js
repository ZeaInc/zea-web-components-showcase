import { getAssetPath, attachShadow, Build, h as h$4, Host, createEvent, proxyCustomElement } from '@stencil/core/internal/client';
export { setAssetPath } from '@stencil/core/internal/client';

let CACHED_MAP;
const getIconMap = () => {
    if (typeof window === 'undefined') {
        return new Map();
    }
    else {
        if (!CACHED_MAP) {
            const win = window;
            win.Ionicons = win.Ionicons || {};
            CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();
        }
        return CACHED_MAP;
    }
};
const getUrl = (i) => {
    let url = getSrc(i.src);
    if (url) {
        return url;
    }
    url = getName(i.name, i.icon, i.mode, i.ios, i.md);
    if (url) {
        return getNamedUrl(url);
    }
    if (i.icon) {
        url = getSrc(i.icon);
        if (url) {
            return url;
        }
        url = getSrc(i.icon[i.mode]);
        if (url) {
            return url;
        }
    }
    return null;
};
const getNamedUrl = (iconName) => {
    const url = getIconMap().get(iconName);
    if (url) {
        return url;
    }
    return getAssetPath(`svg/${iconName}.svg`);
};
const getName = (iconName, icon, mode, ios, md) => {
    // default to "md" if somehow the mode wasn't set
    mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';
    // if an icon was passed in using the ios or md attributes
    // set the iconName to whatever was passed in
    if (ios && mode === 'ios') {
        iconName = toLower(ios);
    }
    else if (md && mode === 'md') {
        iconName = toLower(md);
    }
    else {
        if (!iconName && icon && !isSrc(icon)) {
            iconName = icon;
        }
        if (isStr(iconName)) {
            iconName = toLower(iconName);
        }
    }
    if (!isStr(iconName) || iconName.trim() === '') {
        return null;
    }
    // only allow alpha characters and dash
    const invalidChars = iconName.replace(/[a-z]|-|\d/gi, '');
    if (invalidChars !== '') {
        return null;
    }
    return iconName;
};
const getSrc = (src) => {
    if (isStr(src)) {
        src = src.trim();
        if (isSrc(src)) {
            return src;
        }
    }
    return null;
};
const isSrc = (str) => str.length > 0 && /(\/|\.)/.test(str);
const isStr = (val) => typeof val === 'string';
const toLower = (val) => val.toLowerCase();

const validateContent = (svgContent) => {
    if (svgContent && typeof document !== 'undefined') {
        const div = document.createElement('div');
        div.innerHTML = svgContent;
        // setup this way to ensure it works on our buddy IE
        for (let i = div.childNodes.length - 1; i >= 0; i--) {
            if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {
                div.removeChild(div.childNodes[i]);
            }
        }
        // must only have 1 root element
        const svgElm = div.firstElementChild;
        if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {
            const svgClass = svgElm.getAttribute('class') || '';
            svgElm.setAttribute('class', (svgClass + ' s-ion-icon').trim());
            // root element must be an svg
            // lets double check we've got valid elements
            // do not allow scripts
            if (isValid(svgElm)) {
                return div.innerHTML;
            }
        }
    }
    return '';
};
const isValid = (elm) => {
    if (elm.nodeType === 1) {
        if (elm.nodeName.toLowerCase() === 'script') {
            return false;
        }
        for (let i = 0; i < elm.attributes.length; i++) {
            const val = elm.attributes[i].value;
            if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {
                return false;
            }
        }
        for (let i = 0; i < elm.childNodes.length; i++) {
            if (!isValid(elm.childNodes[i])) {
                return false;
            }
        }
    }
    return true;
};

const ioniconContent = new Map();
const requests = new Map();
const getSvgContent = (url) => {
    // see if we already have a request for this url
    let req = requests.get(url);
    if (!req) {
        if (typeof fetch !== 'undefined') {
            // we don't already have a request
            req = fetch(url).then(rsp => {
                if (rsp.ok) {
                    return rsp.text().then(svgContent => {
                        ioniconContent.set(url, validateContent(svgContent));
                    });
                }
                ioniconContent.set(url, '');
            });
            // cache for the same requests
            requests.set(url, req);
        }
        else {
            // set to empty for ssr scenarios and resolve promise
            ioniconContent.set(url, '');
            return Promise.resolve();
        }
    }
    return req;
};

const iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}";

const Icon = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.isVisible = false;
    /**
     * The mode determines which platform styles to use.
     */
    this.mode = getIonMode();
    /**
     * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.
     * Default, `false`.
     */
    this.lazy = false;
  }
  connectedCallback() {
    // purposely do not return the promise here because loading
    // the svg file should not hold up loading the app
    // only load the svg if it's visible
    this.waitUntilVisible(this.el, '50px', () => {
      this.isVisible = true;
      this.loadIcon();
    });
  }
  disconnectedCallback() {
    if (this.io) {
      this.io.disconnect();
      this.io = undefined;
    }
  }
  waitUntilVisible(el, rootMargin, cb) {
    if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && window.IntersectionObserver) {
      const io = this.io = new window.IntersectionObserver((data) => {
        if (data[0].isIntersecting) {
          io.disconnect();
          this.io = undefined;
          cb();
        }
      }, { rootMargin });
      io.observe(el);
    }
    else {
      // browser doesn't support IntersectionObserver
      // so just fallback to always show it
      cb();
    }
  }
  loadIcon() {
    if (Build.isBrowser && this.isVisible) {
      const url = getUrl(this);
      if (url) {
        if (ioniconContent.has(url)) {
          // sync if it's already loaded
          this.svgContent = ioniconContent.get(url);
        }
        else {
          // async if it hasn't been loaded
          getSvgContent(url).then(() => this.svgContent = ioniconContent.get(url));
        }
      }
    }
    if (!this.ariaLabel) {
      const label = getName(this.name, this.icon, this.mode, this.ios, this.md);
      // user did not provide a label
      // come up with the label based on the icon name
      if (label) {
        this.ariaLabel = label.replace(/\-/g, ' ');
      }
    }
  }
  render() {
    const mode = this.mode || 'md';
    const flipRtl = this.flipRtl || (this.ariaLabel && (this.ariaLabel.indexOf('arrow') > -1 || this.ariaLabel.indexOf('chevron') > -1) && this.flipRtl !== false);
    return (h$4(Host, { role: "img", class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), { [`icon-${this.size}`]: !!this.size, 'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl' }) }, ((Build.isBrowser && this.svgContent)
      ? h$4("div", { class: "icon-inner", innerHTML: this.svgContent })
      : h$4("div", { class: "icon-inner" }))));
  }
  static get assetsDirs() { return ["svg"]; }
  get el() { return this; }
  static get watchers() { return {
    "name": ["loadIcon"],
    "src": ["loadIcon"],
    "icon": ["loadIcon"]
  }; }
  static get style() { return iconCss; }
};
const getIonMode = () => (Build.isBrowser && typeof document !== 'undefined' && document.documentElement.getAttribute('mode')) || 'md';
const createColorClasses = (color) => {
  return (color) ? {
    'ion-color': true,
    [`ion-color-${color}`]: true
  } : null;
};

const zeaButtonCss = ":host{display:inline-block}:host,input,button,select,textarea{font-family:'Roboto', sans-serif;font-size:13px}.small{font-size:11px}.zea-button{border-radius:2px;outline:none;padding:0;width:100%}.zea-button-label{padding:0.5em 1em;white-space:nowrap}.zea-button-content-wrap{display:flex;align-items:center;justify-content:center}.zea-button{color:var(--color-foreground-1);background-color:var(--color-background-1);border:1px solid var(--color-background-1)}.zea-button:hover{background-color:var(--color-primary-3)}.zea-button:disabled{background-color:var(--color-disabled-2);border:1px solid var(--color-disabled-2);color:var(--color-disabled-1)}.zea-button.solid{color:var(--color-foreground-1);background-color:var(--color-secondary-1);border:1px solid var(--color-secondary-1)}.zea-button.solid:hover{background-color:var(--color-secondary-2);border:1px solid var(--color-secondary-2)}.zea-button.solid:disabled{background-color:var(--color-disabled-2);border:1px solid var(--color-disabled-2);color:var(--color-disabled-1)}.zea-button.outlined{color:var(--color-secondary-1);background-color:transparent;border:1px solid var(--color-secondary-1)}.zea-button.outlined:hover{background-color:var(--color-secondary-3)}.zea-button.outlined:disabled{background-color:var(--color-disabled-2);border:1px solid var(--color-disabled-2);color:var(--color-disabled-1)}.zea-button.pill{color:var(--color-button-text-1);background-color:var(--color-primary-1);border:1px solid var(--color-primary-1);border-radius:20px;min-height:40px}.zea-button.pill.small{min-height:initial}.zea-button.pill:hover{background-color:var(--color-primary-2);border:1px solid var(--color-primary-2)}.zea-button.pill:disabled{background-color:var(--color-disabled-2);border:1px solid var(--color-disabled-2);color:var(--color-foreground-1)}.zea-start-icon ::slotted(zea-icon){vertical-align:middle;padding-left:0.5em}.zea-end-icon ::slotted(zea-icon){vertical-align:middle;padding-right:0.5em}";

const ZeaButton = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Style variant for the button
     */
    this.variant = 'solid';
    /**
     * Whether the button should be disabled (true) or not (false)
     */
    this.disabled = false;
    /**
     * Whether the button should be disabled (true) or not (false)
     */
    this.color = false;
    /**
     * Whether the button should be disabled (true) or not (false)
     */
    this.density = 'normal';
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("button", { class: `zea-button ${this.variant} ${this.density}`, disabled: this.disabled }, h$4("span", { class: "zea-button-content-wrap" }, h$4("span", { class: "zea-start-icon" }, h$4("slot", { name: "start-icon" })), this.htmlContent ? (h$4("span", { class: "zea-button-label", innerHTML: this.htmlContent })) : (h$4("span", { class: "zea-button-label" }, h$4("slot", null))), h$4("span", { class: "zea-end-icon" }, h$4("slot", { name: "end-icon" })))));
  }
  static get style() { return zeaButtonCss; }
};

const zeaCheckboxCss = ".zea-checkbox{display:inline-flex;justify-content:center;align-content:center;overflow:hidden;width:16px;height:16px;box-sizing:border-box;border:1px solid var(--color-primary-1);border-radius:3px}.zea-checkbox.checked{background-color:var(--color-primary-1)}.zea-checkbox.isradio{border-radius:1em;border-width:2px;background:none;display:flex}.zea-checkbox.isradio .icon-path{fill:var(--color-primary-1)}.zea-checkbox.isradio svg{width:8px;height:8px}.zea-checkbox.disabled{border:0.1em solid var(--color-disabled-2)}.zea-checkbox.checked.disabled{background-color:var(--color-disabled-2)}.zea-checkbox path.icon-path{fill:var(--color-disabled-2)}.zea-checkbox.checked.disabled path.icon-path{fill:var(--color-disabled-1)}.zea-checkbox-wrap{display:inline-flex;align-items:center;justify-content:center;width:100%;height:100%}.zea-checkbox-icon{display:none;align-items:center;justify-content:center}.zea-checkbox.checked .zea-checkbox-icon{display:inline-flex}input[type='checkbox']{position:absolute;left:-50000px}";

const ZeaCheckbox = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
    /**
     * Whether the checkbox is disabled
     */
    this.disabled = false;
    /**
    /**
     * Whether the checkbox is checked
     */
    this.checked = false;
    /**
     * Whether the checkbox should be presented as a radio button
     */
    this.isRadio = false;
  }
  /**
  /**
   * Listen for changes on the checked prop
   * @param {boolean} checked New value for the checked prop
   */
  onCheckedChanged(checked) {
    this.element.shadowRoot.querySelector('input').checked = checked;
    this.updateElementClass();
  }
  /**
  /**
   * Listen for changes on the disabled prop
   * @param {boolean} disabled New value for the disabled prop
   */
  onDisabledChanged(disabled) {
    this.element.shadowRoot.querySelector('input').disabled = disabled;
    this.updateElementClass();
  }
  /**
  /**
   * Update element class according to checkbox state
   */
  updateElementClass() {
    this.elementClass = this.checked ? 'checked' : '';
    this.elementClass += this.disabled ? ' disabled ' : '';
    this.elementClass += this.isRadio ? ' isradio ' : '';
  }
  /**
   * Change checkbox state on click
   */
  toggleCheck() {
    if (!this.disabled) {
      this.checked = !this.checked;
    }
  }
  /**
   * Called everytime component loads
   */
  componentDidLoad() {
    this.onCheckedChanged(this.checked);
    this.onDisabledChanged(this.disabled);
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("div", { class: 'zea-checkbox ' + this.elementClass, onClick: () => {
        this.toggleCheck();
      } }, h$4("span", { class: "zea-checkbox-wrap" }, h$4("span", { class: "zea-checkbox-icon" }, !this.isRadio && (h$4("svg", { xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", viewBox: "0 0 24 24" }, h$4("path", { class: "icon-path", d: "M9 21.035l-9-8.638 2.791-2.87 6.156 5.874 12.21-12.436 2.843 2.817z" }))), this.isRadio && (h$4("svg", { xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", viewBox: "0 0 512 512" }, h$4("path", { class: "icon-path", d: "M256 464c-114.69 0-208-93.31-208-208S141.31 48 256 48s208 93.31 208 208-93.31 208-208 208z" }))))), h$4("input", { type: "checkbox", name: this.name })));
  }
  get element() { return this; }
  static get watchers() { return {
    "checked": ["onCheckedChanged"],
    "disabled": ["onDisabledChanged"]
  }; }
  static get style() { return zeaCheckboxCss; }
};

const zeaCopyLinkCss = ".zea-copy-link{color:var(--color-foreground-1)}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.label{font-size:1.1em;margin-bottom:5px;margin-top:2em}.link-container{display:flex;align-items:center;background-color:var(--color-background-1);padding:5px}.link{flex-grow:1;border:none;background-color:transparent;outline:none;color:var(--color-foreground-1)}.copy-icon{cursor:pointer;margin:0 1em}.tooltip{position:absolute;width:64px;font-size:10px;transform:translateX(-22px);padding:2px;margin-top:5px;border-radius:3px;text-align:center;background-color:var(--color-secondary-1);min-width:fit-content;display:none}.active .tooltip,.copy-icon:hover .tooltip{color:var(--color-foreground-1);display:block}";

const ZeaCopyLink = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.tooltipDelay = 3000;
    this.link = '';
    this.tooltipIsVisible = false;
    this.tooltipText = 'Copy Link';
  }
  /**
   */
  onCopyClick() {
    /* Select the text field */
    this.linkInput.select();
    this.linkInput.setSelectionRange(0, 99999); /*For mobile devices*/
    /* Copy the text inside the text field */
    document.execCommand('copy');
    this.tooltipIsVisible = true;
    this.tooltipText = 'Link Copied';
    setTimeout(() => {
      this.tooltipIsVisible = false;
      this.tooltipText = 'Copy Link';
    }, this.tooltipDelay);
  }
  /**
   */
  onLinkClick() {
    /* Select the text field */
    this.linkInput.select();
    this.linkInput.setSelectionRange(0, 99999);
  }
  /**
   */
  render() {
    if (!this.link) {
      this.link = window.location.href;
    }
    return (h$4("div", { class: "zea-copy-link" }, h$4("div", { class: "label" }, "Copy Link"), h$4("div", { class: "link-container" }, h$4("input", { onClick: this.onLinkClick.bind(this), readOnly: true, class: "link", ref: (el) => (this.linkInput = el), value: this.link }), h$4("div", { class: { active: this.tooltipIsVisible, 'copy-icon': true }, onClick: this.onCopyClick.bind(this) }, h$4("zea-icon", { name: "copy-outline" }), h$4("div", { class: { tooltip: true } }, this.tooltipText)))));
  }
  static get style() { return zeaCopyLinkCss; }
};

const zeaDialogCss = "@import url('https://unpkg.com/tachyons@4/css/tachyons.min.css');:host{position:relative;z-index:10000000}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-dialog{color:var(--color-foreground-1);display:none;justify-content:center;align-items:center;position:fixed;top:0;left:0;bottom:0;right:0;max-width:100vw;max-height:100vh;font-size:14px;pointer-events:none}.zea-dialog.shown{display:flex}.backdrop{background-color:var(--color-shadow);position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:auto}.scroll-pane-container{max-height:100%;height:100%}.zea-dialog-container{box-sizing:border-box;position:relative;display:flex;flex-direction:column;background-color:var(--color-background-1);box-shadow:2px 6px 10px 5px var(--color-shadow);min-height:fit-content;min-width:fit-content;pointer-events:auto;max-height:100%;max-width:100%}.zea-dialog-title ::slotted([slot='title']){margin:0.5em 0}.zea-dialog-title{color:var(--color-foreground-1);padding:2em 2em 0;display:flex;align-items:center}.zea-dialog-title zea-icon{display:none}.with-padding .zea-dialog-title{padding:20px 20px 0 20px}.zea-dialog-body{flex-grow:1;height:100%;box-sizing:border-box}.with-padding .zea-dialog-body{padding:20px}.zea-dialog-body ::slotted([slot='body']){height:100%;box-sizing:border-box}.zea-dialog-footer{text-align:right}.with-padding .zea-dialog-footer{padding:0 20px 20px}@media only screen and (max-width: 667px), only screen and (max-height: 667px){:host{position:relative;z-index:1000000000000}.zea-dialog-container.full-screen-mobile{height:100% !important;width:100% !important;position:fixed;top:0;left:0}.zea-dialog-title{color:var(--color-foreground-1);background-color:var(--color-grey-2);padding:0.5em 1em}.zea-dialog-title zea-icon{margin-right:1em;display:inline-block}.with-padding .zea-dialog-title{padding:0.5em 1em}.with-padding .zea-dialog-body{padding:20px;height:calc(100% - 3em)}}";

const ZeaDialog = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.dialogClose = createEvent(this, "dialogClose", 7);
    this.shown = false;
    this.width = 'auto';
    this.allowClose = true;
    this.showBackdrop = true;
    this.addPadding = true;
    this.showTitle = true;
    this.fullScreenMobile = true;
  }
  /**
   */
  async prompt() {
    this.shown = true;
  }
  /**
   */
  closeDialog() {
    if (this.allowClose) {
      this.shown = false;
      this.dialogClose.emit(this.hostElement);
    }
  }
  /**
   */
  resetSize() {
    if (!this.dialogContainer)
      return;
    if (this.width) {
      this.dialogContainer.style.width = this.width;
    }
    else {
      this.dialogContainer.style.width = `fit-content`;
    }
    this.dialogContainer.style.height = `fit-content`;
    if (this.dialogContainer.offsetHeight) {
      this.dialogContainer.style.height = `${this.dialogContainer.offsetHeight}px`;
    }
    if (this.dialogContainer.offsetWidth) {
      this.dialogContainer.style.width = `${this.dialogContainer.offsetWidth}px`;
    }
  }
  /**
   */
  componentDidRender() {
    this.resetSize();
  }
  /**
   */
  componentWillLoad() {
    window.addEventListener('resize', () => {
      this.resetSize();
    });
  }
  /**
   */
  setupContainer(el) {
    if (this.dialogContainer)
      return;
    this.dialogContainer = el;
    this.dialogContainer.addEventListener('dialogResize', () => {
      this.resetSize();
    });
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("div", { class: {
        'zea-dialog': true,
        shown: this.shown,
        'with-padding': this.addPadding,
      } }, this.showBackdrop && (h$4("div", { class: "backdrop", onClick: this.closeDialog.bind(this) })), h$4("div", { class: {
        'zea-dialog-container': true,
        'full-screen-mobile': this.fullScreenMobile,
      }, ref: (el) => this.setupContainer(el) }, this.showTitle && (h$4("div", { class: "zea-dialog-title" }, this.allowClose && (h$4("zea-icon", { name: "arrow-back", onClick: this.closeDialog.bind(this) })), h$4("slot", { name: "title" }))), h$4("div", { class: "zea-dialog-body" }, h$4("slot", { name: "body" })), h$4("div", { class: "zea-dialog-footer" }, h$4("slot", { name: "footer" })))));
  }
  get hostElement() { return this; }
  static get style() { return zeaDialogCss; }
};

const zeaDropdownMenuCss = ".zea-dropdown-menu{color:var(--color-foreground-1);font-size:14px}ul,li{display:block;list-style:none;margin:0;padding:0;background-color:var(--color-background-2);cursor:default;position:relative;color:var(--color-foreground-1)}li.flashed>span,li.flashed:hover>span{background-color:var(--color-secondary-3) !important}.menu-root{display:flex;justify-content:left;align-items:center}ul ul{display:none}.leaf-label,.branch-label{display:inline-block;white-space:nowrap}.menu-root>li>.leaf-label,.menu-root>li>.branch-label{padding:16px}.menu-root>li>.branch-label>.branch-arrow{display:none}li .leaf-label,li .branch-label{padding:8px 8px 8px 16px;display:flex}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}ul ul li>.leaf-label{display:flex;align-items:center}.branch-name{flex-grow:1}li:hover>span{background-color:var(--color-grey-3)}li:hover>ul{display:block;position:absolute;box-shadow:0 6px 13px 0 var(--color-shadow)}ul ul ul{margin-left:100%;margin-top:-30px}.action-name{min-width:100px;display:block;flex-grow:1}.keyboard-shortcut{display:block;opacity:0.75;font-size:0.8em;padding-left:10px}.branch-arrow-icon{display:block;opacity:0.5}.keyboard-key{border:1px solid var(--color-grey-3);padding:2px;border-radius:5px;font-size:0.8em;text-align:center;min-width:10px;display:inline-block;background-color:var(--color-background-1);text-transform:uppercase;margin:0 2px}";

const ZeaDropdownMenu = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.hotkeysToActions = {};
    /**
     * Tree representation of the items and actions
     * based on path arrays
     */
    this.menuItems = { children: {} };
  }
  /**
   * Runs once when component first loads
   */
  componentDidLoad() {
    // subscribe to the actionAdded signal
    // Note: the action registry is deprecated.
    if (this.appData && this.appData.actionRegistry) {
      this.appData.actionRegistry.on('actionAdded', () => {
        this.makeMenuTree();
      });
    }
    this.makeMenuTree();
  }
  /**
   * Listen for keyboard shortcuts
   * @param {any} e the event
   */
  keydownHandler(e) {
    if (e.target instanceof HTMLInputElement)
      return;
    const keys = [];
    if (e.shiftKey)
      keys.push('shift');
    if (e.altKey)
      keys.push('alt');
    if (e.metaKey)
      keys.push('ctrl');
    if (e.ctrlKey)
      keys.push('ctrl');
    if (e.key != 'Alt' &&
      e.key != 'Control' &&
      e.key != 'Ctrl' &&
      e.key != 'Shift') {
      keys.push(e.key);
    }
    const comboString = keys.join('+').toLowerCase();
    if (comboString in this.hotkeysToActions) {
      const action = this.hotkeysToActions[comboString];
      action.callback(e);
    }
    e.preventDefault();
  }
  /**
   * Make a hierarchical representation out of
   * the path arrays in the action list
   */
  makeMenuTree() {
    this.actions = this.appData.actionRegistry.getActions();
    this.actions.forEach((action) => {
      const currentItem = this.getMenuTreeItem(action.path);
      currentItem['children'][action.name] = action;
    });
    this.feedHotKeys();
  }
  /**
   * Feed the list of hotkeys
   */
  feedHotKeys() {
    this.actions.forEach((action) => {
      const hotkey = this.keyComboAsText(action);
      if (hotkey)
        this.hotkeysToActions[hotkey] = action;
    });
  }
  /**
   * Get a specific tree location using an action's path
   * @param {any} path the path
   * @return {any} item
   */
  getMenuTreeItem(path) {
    // here menuItems is modified by reference
    let currentItem = this.menuItems;
    path.forEach((pathPart) => {
      if (!(pathPart in currentItem.children)) {
        currentItem.children[pathPart] = { children: {} };
      }
      // the reference runs deep
      currentItem = currentItem.children[pathPart];
    });
    return currentItem;
  }
  /**
   * Generate markup for a branch with children
   * @param {any} key the key
   * @param {any} item the item
   * @return {JSX} the ul
   */
  makeBranch(key, item) {
    return (h$4("li", { key: key }, h$4("span", { class: "branch-label" }, h$4("span", { class: "branch-name" }, key), h$4("span", { class: "branch-arrow" }, this.getBranchArrow())), h$4("ul", null, this.makeBranchItems(item))));
  }
  /**
   * Generate markup for the children of a branch
   * @param {any} item the item
   * @return {JSX} the ul
   */
  makeBranchItems(item) {
    const items = [];
    Object.keys(item.children).forEach((key) => {
      const currentItem = item.children[key];
      if ('children' in currentItem) {
        items.push(this.makeBranch(key, currentItem));
      }
      else {
        items.push(this.makeLeaf(key, currentItem));
      }
    });
    return items;
  }
  /**
   * Generate markup for a leaf item, with an anchor
   * and no children
   * @param {any} key the key
   * @param {any} action the action
   * @return {JSX} the ul
   */
  makeLeaf(key, action) {
    return (h$4("li", { key: key, onClick: (e) => {
        this.hadleLeafClick(e, action);
      } }, h$4("span", { class: "leaf-label" }, h$4("span", { class: "action-name" }, action.name), h$4("span", { class: "keyboard-shortcut" }, this.keyComboAsHtml(action)))));
  }
  /**
   * Handle click events on leafs
   * @param {any} event the event
   * @param {any} action the action
   */
  hadleLeafClick(event, action) {
    if ('callback' in action) {
      action.callback();
    }
    this.flashItem(event.currentTarget);
  }
  /**
   * Rapidly change items bg color to indicate it was clicked
   * @param {any} target the clicked li item
   */
  flashItem(target) {
    target.classList.toggle('flashed');
    const interval = setInterval(() => {
      target.classList.toggle('flashed');
    }, 80);
    setTimeout(() => {
      clearInterval(interval);
      target.classList.remove('flashed');
    }, 100);
  }
  /**
   * Generate markup for keyboard shortcut
   * @param {any} action the action
   * @return {array} the html elements
   */
  keyComboAsHtml(action) {
    const { metaKeys, key } = action;
    const elements = [];
    if (!key && !metaKeys) {
      return null;
    }
    if (metaKeys.control) {
      elements.push(h$4("span", { class: "keyboard-key" }, "Ctrl"));
      elements.push('+');
    }
    if (metaKeys.alt) {
      elements.push(h$4("span", { class: "keyboard-key" }, "Alt"));
      elements.push('+');
    }
    if (metaKeys.shift) {
      elements.push(h$4("span", { class: "keyboard-key" }, "Shift"));
      elements.push('+');
    }
    elements.push(h$4("span", { class: "keyboard-key" }, key));
    return elements;
  }
  /**
   * Generate markup for keyboard shortcut
   * @param {any} action the action
   * @return {string} the html elements
   */
  keyComboAsText(action) {
    const { metaKeys, key } = action;
    const elements = [];
    if (!key && !metaKeys) {
      return '';
    }
    if (metaKeys) {
      if (metaKeys.shift)
        elements.push('shift');
      if (metaKeys.alt)
        elements.push('alt');
      if (metaKeys.control)
        elements.push('ctrl');
    }
    elements.push(key);
    return elements.join('+').toLowerCase();
  }
  /**
   * Get arrow icon svg for branch
   * @return {JSX} the arrow svg
   */
  getBranchArrow() {
    return (h$4("svg", { class: "branch-arrow-icon", xmlns: "http://www.w3.org/2000/svg", height: "16", viewBox: "0 0 24 24", width: "16" }, h$4("path", { d: "M8 5v14l11-7z" }), h$4("path", { d: "M0 0h24v24H0z", fill: "none" })));
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4("div", { class: "zea-dropdown-menu" }, h$4("ul", { class: "menu-root" }, this.makeBranchItems(this.menuItems))));
  }
  static get style() { return zeaDropdownMenuCss; }
};

const zeaFabButtonCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-fab-button{font-size:1em;border-radius:50%;outline:none;text-align:center;padding:0;color:var(--color-button-text-1);background-color:var(--color-primary-1);border:1px solid var(--color-primary-1);box-shadow:0px 5px 5px var(--color-shadow)}.zea-fab-button:hover{background-color:var(--color-primary-2);border:1px solid var(--color-primary-2)}.zea-fab-button:disabled{background-color:var(--color-disabled-2);border:1px solid var(--color-disabled-2);color:var(--color-disabled-1);box-shadow:0px 5px 5px var(--color-shadow)}.zea-fab-button-wrap{display:flex;align-items:center;justify-content:center;padding:0.7em;width:1em;height:1em}";

const ZeaFabButton = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("button", { class: "zea-fab-button", disabled: this.disabled }, h$4("span", { class: "zea-fab-button-wrap" }, h$4("span", { class: "zea-fab-button-icon" }, h$4("slot", null)))));
  }
  static get style() { return zeaFabButtonCss; }
};

const zeaFormCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-form{color:var(--color-foreground-1)}zea-button.submit{margin-top:2em;width:100%}";

const ZeaForm = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     */
    this.submitText = 'SUBMIT';
    /**
     */
    this.validate = true;
    /**
     */
    this.isValid = true;
    /**
     */
    this.formValue = {};
    /**
     */
    this.inputs = [];
  }
  /**
   */
  getFormValue() {
    this.checkValidation();
    this.inputs.forEach((inputElement) => {
      this.formValue[inputElement.name] = inputElement.value;
    });
    return this.formValue;
  }
  /**
   */
  checkValidation() {
    if (!this.validate) {
      return true;
    }
    for (let i = 0; i < this.inputs.length; i++) {
      const inputElement = this.inputs[i];
      if (inputElement.isValid) {
        inputElement.invalidMessageShown = false;
        this.isValid = true;
      }
      else {
        inputElement.invalidMessageShown = true;
        this.isValid = false;
        return false;
      }
    }
    return true;
  }
  /**
   */
  onSubmit() {
    if (this.submitCallback) {
      this.submitCallback(this.getFormValue());
    }
  }
  /**
   */
  componentDidRender() {
    this.setupChildren();
  }
  /**
   * Run some setup for the children items
   */
  setupChildren() {
    this.formContainer
      .querySelector('slot')
      .assignedElements()
      .forEach((element) => {
      if (element.tagName.match(/^ZEA-INPUT/i)) {
        this.inputs.push(element);
      }
    });
  }
  // eslint-disable-next-line require-jsdoc
  render() {
    return (h$4("div", { class: "zea-form", ref: (el) => (this.formContainer = el) }, h$4("slot", null), h$4("zea-button", { onClick: this.onSubmit.bind(this), class: "submit" }, this.submitText)));
  }
  static get style() { return zeaFormCss; }
};

const svg = {};
svg['draw-arrow'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="arrow"><path id="arrow1" serif:id="arrow" d="M118.973,142.33l-30.466,30.467c-6.181,6.181 -16.767,2.264 -17.44,-6.452l-7.037,-91.328c-0.229,-2.976 0.857,-5.909 2.967,-8.02c2.111,-2.11 5.044,-3.196 8.02,-2.967l91.327,7.037c8.729,0.661 12.646,11.247 6.465,17.428l-30.478,30.478l300.835,300.836c6.445,6.445 6.445,16.912 0,23.357c-6.446,6.445 -16.912,6.445 -23.358,0l-300.835,-300.836Z"/><rect id="keep-square" serif:id="keep square" x="0" y="0" width="512" height="512" style="fill:none;fill-rule:nonzero;"/></g></svg>`;
svg['draw-freehand'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="freehand"><path id="pen" d="M324.403,142.611c-3.015,-3.092 -7.153,-4.834 -11.472,-4.829c-4.319,0.005 -8.453,1.756 -11.461,4.856l-187.543,193.243c-1.146,1.181 -2.104,2.532 -2.838,4.006l-26.409,70.002c-3.095,6.21 -1.833,13.707 3.123,18.562c4.957,4.856 12.478,5.962 18.623,2.74l68.378,-27.232c1.48,-0.776 2.83,-1.78 3.999,-2.974l188.421,-192.356c6.082,-6.209 6.094,-16.138 0.026,-22.361l-42.847,-43.657Zm30.305,-54.593l-21.677,22.234c-6.057,6.212 -6.058,16.119 -0.003,22.332l42.847,43.671c3.011,3.09 7.143,4.832 11.457,4.832c4.315,0 8.446,-1.743 11.457,-4.833l21.678,-22.248c14.614,-14.999 8.958,-45.329 -5.656,-60.328c-14.942,-15.315 -45.165,-20.971 -60.099,-5.663l-0.004,0.003Z"/><rect id="keep-square" serif:id="keep square" x="0" y="0" width="512" height="512" style="fill:none;fill-rule:nonzero;"/></g></svg>`;
svg['draw-polygon'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="polygon"><path id="polygon1" serif:id="polygon" d="M266.945,355.799l-136.44,91.653c-5.263,3.536 -11.95,4.192 -17.801,1.747c-5.85,-2.445 -10.082,-7.664 -11.264,-13.894l-40.792,-214.944c-1.268,-6.68 1.156,-13.526 6.344,-17.92l161.322,-136.628c4.965,-4.206 11.747,-5.557 17.945,-3.575l191.685,61.294c7.799,2.494 13.1,9.732 13.124,17.92l0.615,208.352c0.016,5.271 -2.173,10.309 -6.038,13.893c-3.865,3.584 -9.052,5.389 -14.307,4.978l-164.393,-12.876Zm146.933,-26.352l-0.514,-174.147l-168.638,-53.924l-144.944,122.757l33.41,176.044l118.156,-79.371c3.531,-2.371 7.758,-3.481 11.998,-3.149l150.532,11.79Z"/><rect id="keep-square" serif:id="keep square" x="0" y="0" width="512" height="512" style="fill:none;fill-rule:nonzero;"/></g></svg>`;
svg['draw-text'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="text"><path id="text1" serif:id="text" d="M63.725,112l0,-36c0,-6.623 5.377,-12 12,-12l360,0c6.623,0 12,5.377 12,12l0,36l0.275,0l0,50c0,6.623 -5.377,12 -12,12l-24,0c-6.623,0 -12,-5.377 -12,-12l0,-50l-120,0l0,288l45.381,0c6.623,0 12,5.377 12,12l0,24c0,6.623 -5.377,12 -12,12l-139.312,0c-6.623,0 -12,-5.377 -12,-12l0,-24c0,-6.623 5.377,-12 12,-12l45.931,0l0,-288l-119.725,0l0,50c0,6.623 -5.377,12 -12,12l-24,0c-6.623,0 -12,-5.377 -12,-12l0,-50l-0.55,0Z"/><rect id="keep-square" serif:id="keep square" x="0" y="0" width="512" height="512" style="fill:none;fill-rule:nonzero;"/></g></svg>`;
svg['find-user'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="find-user"><g id="person"><path id="body" d="M364.305,393.842l-216.61,0c-5.738,0.074 -11.214,-2.444 -14.892,-6.849c-4,-4.782 -5.612,-11.311 -4.418,-17.914c5.194,-28.811 21.403,-53.014 46.879,-70.004c22.633,-15.083 51.303,-23.384 80.736,-23.384c29.433,0 58.103,8.307 80.736,23.384c25.476,16.984 41.685,41.186 46.879,69.998c1.194,6.603 -0.418,13.132 -4.418,17.913c-3.677,4.408 -9.153,6.929 -14.892,6.856Z" style="fill-rule:nonzero;"/><path id="head" d="M303.162,138.206c-11.975,-12.929 -28.701,-20.049 -47.162,-20.049c-18.559,0 -35.341,7.077 -47.26,19.925c-12.049,12.991 -17.92,30.646 -16.541,49.71c2.732,37.611 31.353,68.207 63.801,68.207c32.448,0 61.02,-30.59 63.795,-68.195c1.397,-18.892 -4.51,-36.51 -16.633,-49.598Z" style="fill-rule:nonzero;"/></g><g id="scan"><path id="_4" serif:id="4" d="M336,464l56,0c39.498,0 72,-32.502 72,-72c0,0 0,-56 0,-56c0,-8.831 -7.169,-16 -16,-16c-8.831,0 -16,7.169 -16,16l0,56c0,21.943 -18.057,40 -40,40l-56,0c-8.831,0 -16,7.169 -16,16c0,8.831 7.169,16 16,16Z"/><path id="_3" serif:id="3" d="M176,432l-56,0c-21.943,0 -40,-18.057 -40,-40c0,0 0,-56 0,-56c0,-8.831 -7.169,-16 -16,-16c-8.831,0 -16,7.169 -16,16l0,56c0,39.498 32.502,72 72,72c0,0 56,0 56,0c8.831,0 16,-7.169 16,-16c0,-8.831 -7.169,-16 -16,-16Z"/><path id="_2" serif:id="2" d="M464,176l0,-56c0,-39.498 -32.502,-72 -72,-72l-56,0c-8.831,0 -16,7.169 -16,16c0,8.831 7.169,16 16,16l56,0c21.943,0 40,18.057 40,40l0,56c0,8.831 7.169,16 16,16c8.831,0 16,-7.169 16,-16Z"/><path id="_1" serif:id="1" d="M80,176l0,-56c0,-21.943 18.057,-40 40,-40c0,0 56,0 56,0c8.831,0 16,-7.169 16,-16c0,-8.831 -7.169,-16 -16,-16l-56,0c-39.498,0 -72,32.502 -72,72l0,56c0,8.831 7.169,16 16,16c8.831,0 16,-7.169 16,-16Z"/></g><rect id="keep-square" serif:id="keep square" x="0" y="0" width="512" height="512" style="fill:none;fill-rule:nonzero;"/></g></svg>`;
svg['undo'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="undo"><path id="undo1" serif:id="undo" d="M173.041,264.618c48.562,-42.459 88.718,-55.437 122.014,-50.683c30.36,4.335 53.985,23.204 71.761,43.697c28.572,32.938 42.372,70.95 42.372,70.95l0,0c3.755,10.38 15.23,15.76 25.61,12.006c10.38,-3.754 15.76,-15.23 12.006,-25.61c0,0 -16.146,-44.792 -49.772,-83.557c-23.69,-27.31 -55.864,-51.308 -96.324,-57.084c-42.091,-6.01 -94.34,7.325 -156.009,61.939l-38.76,-38.76c-8.12,-8.12 -22.029,-2.975 -22.912,8.478l-9.246,119.989c-0.3,3.911 1.126,7.763 3.899,10.536c2.773,2.774 6.626,4.199 10.536,3.899l119.989,-9.246c11.469,-0.867 16.614,-14.776 8.494,-22.896l-43.658,-43.658Z" style="fill-rule:nonzero;"/><rect id="keep-square" serif:id="keep square" x="0" y="0" width="512" height="512" style="fill:none;fill-rule:nonzero;"/></g></svg>`;
svg['redo'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="redo"><path id="redo1" serif:id="redo" d="M348.701,264.618c-48.562,-42.459 -88.718,-55.437 -122.014,-50.683c-30.36,4.335 -53.985,23.204 -71.761,43.697c-28.573,32.938 -42.373,70.95 -42.373,70.95l0,0c-3.754,10.38 -15.229,15.76 -25.609,12.006c-10.381,-3.754 -15.761,-15.23 -12.006,-25.61c0,0 16.145,-44.792 49.772,-83.557c23.69,-27.31 55.864,-51.308 96.323,-57.084c42.092,-6.01 94.341,7.325 156.01,61.939l38.759,-38.76c8.121,-8.12 22.029,-2.975 22.913,8.478l9.246,119.989c0.3,3.911 -1.126,7.763 -3.899,10.536c-2.774,2.774 -6.626,4.199 -10.537,3.899l-119.989,-9.246c-11.468,-0.867 -16.614,-14.776 -8.493,-22.896l43.658,-43.658Z" style="fill-rule:nonzero;"/><rect id="keep-square" serif:id="keep square" x="0" y="0" width="512" height="512" style="fill:none;fill-rule:nonzero;"/></g></svg>`;
svg['settings-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M262.29 192.31a64 64 0 1057.4 57.4 64.13 64.13 0 00-57.4-57.4zM416.39 256a154.34 154.34 0 01-1.53 20.79l45.21 35.46a10.81 10.81 0 012.45 13.75l-42.77 74a10.81 10.81 0 01-13.14 4.59l-44.9-18.08a16.11 16.11 0 00-15.17 1.75A164.48 164.48 0 01325 400.8a15.94 15.94 0 00-8.82 12.14l-6.73 47.89a11.08 11.08 0 01-10.68 9.17h-85.54a11.11 11.11 0 01-10.69-8.87l-6.72-47.82a16.07 16.07 0 00-9-12.22 155.3 155.3 0 01-21.46-12.57 16 16 0 00-15.11-1.71l-44.89 18.07a10.81 10.81 0 01-13.14-4.58l-42.77-74a10.8 10.8 0 012.45-13.75l38.21-30a16.05 16.05 0 006-14.08c-.36-4.17-.58-8.33-.58-12.5s.21-8.27.58-12.35a16 16 0 00-6.07-13.94l-38.19-30A10.81 10.81 0 0149.48 186l42.77-74a10.81 10.81 0 0113.14-4.59l44.9 18.08a16.11 16.11 0 0015.17-1.75A164.48 164.48 0 01187 111.2a15.94 15.94 0 008.82-12.14l6.73-47.89A11.08 11.08 0 01213.23 42h85.54a11.11 11.11 0 0110.69 8.87l6.72 47.82a16.07 16.07 0 009 12.22 155.3 155.3 0 0121.46 12.57 16 16 0 0015.11 1.71l44.89-18.07a10.81 10.81 0 0113.14 4.58l42.77 74a10.8 10.8 0 01-2.45 13.75l-38.21 30a16.05 16.05 0 00-6.05 14.08c.33 4.14.55 8.3.55 12.47z" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['link-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M208 352h-64a96 96 0 010-192h64M304 160h64a96 96 0 010 192h-64M163.29 256h187.42" stroke-linecap="round" stroke-linejoin="round" stroke-width="36" class="ionicon-fill-none"/></svg>`;
svg['copy-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><rect x="128" y="128" width="336" height="336" rx="57" ry="57" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><path d="M383.5 128l.5-24a56.16 56.16 0 00-56-56H112a64.19 64.19 0 00-64 64v216a56.16 56.16 0 0056 56h24" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['arrow-back'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M244 400L100 256l144-144M120 256h292" class="ionicon-fill-none"/></svg>`;
svg['add-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-linejoin="round" d="M256 112v288M400 256H112" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['refresh-circle-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M288 193s12.18-6-32-6a80 80 0 1080 80" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28" class="ionicon-fill-none"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="28" d="M256 149l40 40-40 40" class="ionicon-fill-none"/><path d="M256 64C150 64 64 150 64 256s86 192 192 192 192-86 192-192S362 64 256 64z" stroke-miterlimit="10" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['create-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M384 224v184a40 40 0 01-40 40H104a40 40 0 01-40-40V168a40 40 0 0140-40h167.48" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><path d="M459.94 53.25a16.06 16.06 0 00-23.22-.56L424.35 65a8 8 0 000 11.31l11.34 11.32a8 8 0 0011.34 0l12.06-12c6.1-6.09 6.67-16.01.85-22.38zM399.34 90L218.82 270.2a9 9 0 00-2.31 3.93L208.16 299a3.91 3.91 0 004.86 4.86l24.85-8.35a9 9 0 003.93-2.31L422 112.66a9 9 0 000-12.66l-9.95-10a9 9 0 00-12.71 0z"/></svg>`;
svg['trash-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M112 112l20 320c.95 18.49 14.4 32 32 32h184c17.67 0 30.87-13.51 32-32l20-320" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><path stroke-linecap="round" stroke-miterlimit="10" d="M80 112h352" class="ionicon-stroke-width"/><path d="M192 112V72h0a23.93 23.93 0 0124-24h80a23.93 23.93 0 0124 24h0v40M256 176v224M184 176l8 224M328 176l-8 224" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['checkmark-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-linejoin="round" d="M416 128L192 384l-96-96" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['close-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-linejoin="round" d="M368 368L144 144M368 144L144 368" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['camera-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M350.54 148.68l-26.62-42.06C318.31 100.08 310.62 96 302 96h-92c-8.62 0-16.31 4.08-21.92 10.62l-26.62 42.06C155.85 155.23 148.62 160 140 160H80a32 32 0 00-32 32v192a32 32 0 0032 32h352a32 32 0 0032-32V192a32 32 0 00-32-32h-59c-8.65 0-16.85-4.77-22.46-11.32z" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><circle cx="256" cy="272" r="80" stroke-miterlimit="10" class="ionicon-fill-none ionicon-stroke-width"/><path stroke-linecap="round" stroke-linejoin="round" d="M124 158v-22h-24v22" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['chevron-up-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M112 328l144-144 144 144" class="ionicon-fill-none"/></svg>`;
svg['chevron-down-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="48" d="M112 184l144 144 144-144" class="ionicon-fill-none"/></svg>`;
svg['add'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-linejoin="round" d="M256 112v288M400 256H112" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['layers-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M434.8 137.65l-149.36-68.1c-16.19-7.4-42.69-7.4-58.88 0L77.3 137.65c-17.6 8-17.6 21.09 0 29.09l148 67.5c16.89 7.7 44.69 7.7 61.58 0l148-67.5c17.52-8 17.52-21.1-.08-29.09zM160 308.52l-82.7 37.11c-17.6 8-17.6 21.1 0 29.1l148 67.5c16.89 7.69 44.69 7.69 61.58 0l148-67.5c17.6-8 17.6-21.1 0-29.1l-79.94-38.47" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><path d="M160 204.48l-82.8 37.16c-17.6 8-17.6 21.1 0 29.1l148 67.49c16.89 7.7 44.69 7.7 61.58 0l148-67.49c17.7-8 17.7-21.1.1-29.1L352 204.48" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['duplicate-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><rect x="128" y="128" width="336" height="336" rx="57" ry="57" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><path d="M383.5 128l.5-24a56.16 56.16 0 00-56-56H112a64.19 64.19 0 00-64 64v216a56.16 56.16 0 0056 56h24M296 216v160M376 296H216" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['navigate-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M448 64L64 240.14h200a8 8 0 018 8V448z" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['square-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M416 448H96a32.09 32.09 0 01-32-32V96a32.09 32.09 0 0132-32h320a32.09 32.09 0 0132 32v320a32.09 32.09 0 01-32 32z" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['ellipsis-vertical-circle-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><circle cx="256" cy="256" r="26"/><circle cx="256" cy="346" r="26"/><circle cx="256" cy="166" r="26"/><path d="M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192 192-86 192-192z" stroke-miterlimit="10" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['menu'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="48" d="M88 152h336M88 256h336M88 360h336" class="ionicon-fill-none"/></svg>`;
svg['eye-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns='http://www.w3.org/2000/svg' width='512' height='512' viewBox='0 0 512 512'><title>ionicons-v5-i</title><path d='M255.66,112c-77.94,0-157.89,45.11-220.83,135.33a16,16,0,0,0-.27,17.77C82.92,340.8,161.8,400,255.66,400,348.5,400,429,340.62,477.45,264.75a16.14,16.14,0,0,0,0-17.47C428.89,172.28,347.8,112,255.66,112Z' style='fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:32px'/><circle cx='256' cy='256' r='80' style='fill:none;stroke:#000;stroke-miterlimit:10;stroke-width:32px'/></svg>`;
svg['eye-off-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns='http://www.w3.org/2000/svg' width='512' height='512' viewBox='0 0 512 512'><title>ionicons-v5-i</title><path d='M432,448a15.92,15.92,0,0,1-11.31-4.69l-352-352A16,16,0,0,1,91.31,68.69l352,352A16,16,0,0,1,432,448Z'/><path d='M255.66,384c-41.49,0-81.5-12.28-118.92-36.5-34.07-22-64.74-53.51-88.7-91l0-.08c19.94-28.57,41.78-52.73,65.24-72.21a2,2,0,0,0,.14-2.94L93.5,161.38a2,2,0,0,0-2.71-.12c-24.92,21-48.05,46.76-69.08,76.92a31.92,31.92,0,0,0-.64,35.54c26.41,41.33,60.4,76.14,98.28,100.65C162,402,207.9,416,255.66,416a239.13,239.13,0,0,0,75.8-12.58,2,2,0,0,0,.77-3.31l-21.58-21.58a4,4,0,0,0-3.83-1A204.8,204.8,0,0,1,255.66,384Z'/><path d='M490.84,238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349,110.55,302,96,255.66,96a227.34,227.34,0,0,0-74.89,12.83,2,2,0,0,0-.75,3.31l21.55,21.55a4,4,0,0,0,3.88,1A192.82,192.82,0,0,1,255.66,128c40.69,0,80.58,12.43,118.55,37,34.71,22.4,65.74,53.88,89.76,91a.13.13,0,0,1,0,.16,310.72,310.72,0,0,1-64.12,72.73,2,2,0,0,0-.15,2.95l19.9,19.89a2,2,0,0,0,2.7.13,343.49,343.49,0,0,0,68.64-78.48A32.2,32.2,0,0,0,490.84,238.6Z'/><path d='M256,160a95.88,95.88,0,0,0-21.37,2.4,2,2,0,0,0-1,3.38L346.22,278.34a2,2,0,0,0,3.38-1A96,96,0,0,0,256,160Z'/><path d='M165.78,233.66a2,2,0,0,0-3.38,1,96,96,0,0,0,115,115,2,2,0,0,0,1-3.38Z'/></svg>`;
svg['caret-down'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M98 190.06l139.78 163.12a24 24 0 0036.44 0L414 190.06c13.34-15.57 2.28-39.62-18.22-39.62h-279.6c-20.5 0-31.56 24.05-18.18 39.62z"/></svg>`;
svg['caret-forward'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M190.06 414l163.12-139.78a24 24 0 000-36.44L190.06 98c-15.57-13.34-39.62-2.28-39.62 18.22v279.6c0 20.5 24.05 31.56 39.62 18.18z"/></svg>`;
svg['phone-portrait-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><rect x="128" y="16" width="256" height="480" rx="48" ry="48" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><path d="M176 16h24a8 8 0 018 8h0a16 16 0 0016 16h64a16 16 0 0016-16h0a8 8 0 018-8h24" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['mail-outline'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><rect x="48" y="96" width="416" height="320" rx="40" ry="40" stroke-linecap="round" stroke-linejoin="round" class="ionicon-fill-none ionicon-stroke-width"/><path stroke-linecap="round" stroke-linejoin="round" d="M112 160l144 112 144-112" class="ionicon-fill-none ionicon-stroke-width"/></svg>`;
svg['create'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M459.94 53.25a16.06 16.06 0 00-23.22-.56L424.35 65a8 8 0 000 11.31l11.34 11.32a8 8 0 0011.34 0l12.06-12c6.1-6.09 6.67-16.01.85-22.38zM399.34 90L218.82 270.2a9 9 0 00-2.31 3.93L208.16 299a3.91 3.91 0 004.86 4.86l24.85-8.35a9 9 0 003.93-2.31L422 112.66a9 9 0 000-12.66l-9.95-10a9 9 0 00-12.71 0z"/><path d="M386.34 193.66L264.45 315.79A41.08 41.08 0 01247.58 326l-25.9 8.67a35.92 35.92 0 01-44.33-44.33l8.67-25.9a41.08 41.08 0 0110.19-16.87l122.13-121.91a8 8 0 00-5.65-13.66H104a56 56 0 00-56 56v240a56 56 0 0056 56h240a56 56 0 0056-56V199.31a8 8 0 00-13.66-5.65z"/></svg>`;
svg['cash'] = `<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg xmlns="http://www.w3.org/2000/svg" class="ionicon" viewBox="0 0 512 512"><path d="M448 400H64a16 16 0 010-32h384a16 16 0 010 32zM416 448H96a16 16 0 010-32h320a16 16 0 010 32zM32 272H16v48a32 32 0 0032 32h48v-16a64.07 64.07 0 00-64-64z"/><path d="M480 240h16v-64h-16a96.11 96.11 0 01-96-96V64H128v16a96.11 96.11 0 01-96 96H16v64h16a96.11 96.11 0 0196 96v16h256v-16a96.11 96.11 0 0196-96zm-224 64a96 96 0 1196-96 96.11 96.11 0 01-96 96z"/><circle cx="256" cy="208" r="64"/><path d="M416 336v16h48a32 32 0 0032-32v-48h-16a64.07 64.07 0 00-64 64zM480 144h16V96a32 32 0 00-32-32h-48v16a64.07 64.07 0 0064 64zM96 80V64H48a32 32 0 00-32 32v48h16a64.07 64.07 0 0064-64z"/></svg>`;
const getSvg = (name) => {
  return svg[name];
};

const zeaIconCss = ":host,zea-icon,.zea-icon{display:inline-block;vertical-align:middle;}ion-icon{display:block}.zea-custom-icon svg{width:100%;height:100%;fill:currentColor}.zea-custom-icon svg *{}.zea-custom-icon-inner{width:1em;height:1em}";

const ZeaIcon = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * The library to load the icon from
     */
    this.type = 'ionic';
    /**
     * The icon size in pixels
     */
    this.size = 24;
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    if (this.type == 'ionic') {
      return (h$4("div", { class: "zea-icon ionic" }, h$4("ion-icon", { name: this.name, style: { fontSize: `${this.size}px` } })));
    }
    else if (this.type == 'zea') {
      return (h$4("div", { class: `zea-icon zea-custom-icon zea-icon-${this.name}` }, h$4("div", { class: "zea-custom-icon-inner", style: { fontSize: `${this.size}px` }, innerHTML: getSvg(this.name) })));
    }
  }
  static get style() { return zeaIconCss; }
};

const zeaImagesGalleryCss = ":host{width:100%;height:100%}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-ig-container{display:grid;width:100%;height:100%;grid-template-rows:repeat(5, 1fr);grid-template-columns:repeat(4, 1fr);gap:0.7em}.zea-ig-image.featured{grid-column:span 2;grid-row:span 2}.zea-ig-image{background-repeat:no-repeat;background-size:cover;background-position:center}.zea-ig-image:hover{filter:brightness(1.15);box-shadow:0px 0.25em 0.5em var(--color-shadow);z-index:1}.zea-ig-zoomed.inactive{display:none}.zea-ig-zoomed.active{display:block;position:fixed;background-color:var(--color-background-1);padding:1%;box-sizing:border-box;transition:all 0.5s;z-index:1000}.zea-ig-zoomed-inner{background-size:cover;background-position:center;background-repeat:no-repeat;width:100%;height:100%}.zea-ig-zoomed.active.animate .zea-ig-zoomed-inner{background-size:contain}";

const ZeaImagesGallery = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Number of featured images
     */
    this.featured = 2;
    /**
     * Number of columns
     */
    this.columns = 4;
    /**
     * Folder from which to take the files to display.
     */
    this.folder = {
      children: [],
    };
    this.zoomedImageClass = 'zea-ig-zoomed inactive';
    this.zoomedImageUrl = '';
  }
  /**
   * Number of featured images
   * @param {any} file The file object
   * @return {boolean} Whether or not the file extension is included in the imagesMediaTypes
   */
  static isFileImage(file) {
    return ZeaImagesGallery.imagesMediaTypes.includes(file.type);
  }
  /**
   * Take image back to original location
   */
  resetImageLocation() {
    this.zoomedTop = this.bbox.top + 'px';
    this.zoomedLeft = this.bbox.left + 'px';
    this.zoomedWidth = this.bbox.width + 'px';
    this.zoomedHeight = this.bbox.height + 'px';
    this.zoomedOpacity = '0';
  }
  /**
   * Zoom image in
   * @param {any} event The event
   * @param {any} image The image
   */
  zoomImageIn(event, image) {
    this.zoomedImageUrl = image.url;
    this.bbox = event.target.getBoundingClientRect();
    this.zoomedImageClass = 'zea-ig-zoomed active';
    this.resetImageLocation();
    setTimeout(() => {
      this.zoomedImageClass = 'zea-ig-zoomed active animate';
      this.zoomedTop = '0px';
      this.zoomedLeft = '0px';
      this.zoomedWidth = '100%';
      this.zoomedHeight = '100%';
      this.zoomedOpacity = '1';
    }, 100);
  }
  /**
   * Zoom image out
   */
  zoomImageOut() {
    this.resetImageLocation();
    setTimeout(() => {
      this.zoomedImageClass = 'zea-ig-zoomed inactive';
    }, 400);
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    const onlyImages = Object.values(this.folder.children).filter(ZeaImagesGallery.isFileImage);
    const rowsCount = Math.ceil((onlyImages.length + this.featured * 3) / this.columns);
    console.log(onlyImages);
    return (h$4(Host, { class: "ZeaImagesGallery" }, h$4("div", { class: this.zoomedImageClass, style: {
        top: this.zoomedTop,
        left: this.zoomedLeft,
        width: this.zoomedWidth,
        height: this.zoomedHeight,
        opacity: this.zoomedOpacity,
      } }, h$4("div", { class: "zea-ig-zoomed-inner", style: {
        backgroundImage: 'url(' + this.zoomedImageUrl + ')',
      }, onClick: () => {
        this.zoomImageOut();
      } })), h$4("div", { class: "zea-ig-container", style: {
        gridTemplateColumns: 'repeat(' + this.columns + ', 1fr)',
        gridTemplateRows: 'repeat(' + rowsCount + ', 1fr)',
      } }, onlyImages.map((image, i) => (h$4("div", { style: {
        backgroundImage: `url(${image.url})`,
      }, class: `zea-ig-image ${i < this.featured ? ' featured' : ''}`, onClick: (event) => {
        this.zoomImageIn(event, image);
      }, title: image.name }))))));
  }
  static get style() { return zeaImagesGalleryCss; }
};
ZeaImagesGallery.imagesMediaTypes = ['image/jpeg', 'image/png', 'image/svg+xml'];

const zeaInputCss = ".zea-input{color:var(--color-foreground-1)}.input-label{font-size:11px;color:var(--color-grey-3)}.input-wrap{display:block;}input[type='text']{box-sizing:border-box;width:100%;color:var(--color-foreground-2);background-color:transparent;border:none;outline:none;font-size:1em;border-bottom:1px solid var(--color-grey-3)}input[type='text'].invalid{border-bottom:1px solid var(--color-warning-2)}.invalid-message{color:var(--color-warning-2);padding:0.3em 0;font-size:12px}.photo-input{display:flex;overflow:hidden}.photo-input input{position:absolute;left:-100000px}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.photo-input .input-label{display:block}.photo-thumb{flex-shrink:0;display:block;width:54px;height:54px;border-radius:30px;margin-right:10px;background-color:var(--color-secondary-1);display:flex;align-items:center;justify-content:center;font-size:12px;position:relative}.photo-copy{font-size:12px;color:var(--color-foreground-2)}#photo-preview{position:absolute;width:100%;height:100%;background-size:cover;border-radius:30px}.color-input{display:flex;overflow:hidden}.color-input .input-label{display:block}.color-thumb{flex-shrink:0;display:block;width:54px;height:54px;border-radius:30px;margin-right:10px;display:flex;align-items:center;justify-content:center;font-size:12px}.color-copy{font-size:12px;color:var(--color-foreground-2)}.color-popup{padding:7px;position:absolute;grid-template-columns:1fr 1fr 1fr 1fr;margin-top:-70px;margin-left:43px;border-radius:10px;background-color:var(--color-background-2);display:none;z-index:1000}.color-popup.top-left{margin-top:110px;margin-left:-54px}.color-popup.shown{display:grid}.color-option{padding:8px}.color-option.active{padding:0}.color-option.active .color-sample{width:32px;height:32px;border-radius:20px}.color-sample{width:16px;height:16px;border-radius:10px}.choosen-color{width:32px;height:32px;border-radius:20px}";

const ZeaInput = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     */
    this.name = 'zea-input';
    /**
     */
    this.type = 'text';
    /**
     */
    this.label = 'Enter text...';
    /**
     */
    this.invalidMessage = 'Not valid';
    /**
     */
    this.required = false;
    /**
     */
    this.isValid = true;
    /**
     */
    this.autoValidate = false;
    /**
     */
    this.invalidMessageShown = false;
    /**
     */
    this.showLabel = false;
    /**
     */
    this.photoBase64 = '';
    /**
     */
    this.colorPopupShown = false;
    /**
     */
    this.colorPopupAlign = 'bottom-right';
    /**
     */
    this.colorOptions = [
      '#F34235',
      '#E81D62',
      '#000000',
      '#9B26AF',
      '#6639B6',
      '#3E50B4',
      '#2095F2',
      '#02A8F3',
      '#00BBD3',
      '#009587',
      '#4BAE4F',
      '#8AC249',
      '#CCDB38',
      '#FEEA3A',
      '#FEC006',
      '#FE9700',
      '#FE5621',
      '#785447',
      '#9D9D9D',
      '#5F7C8A',
    ];
  }
  /**
   * Listen to click events on the whole document
   * @param {any} e The event
   */
  handleClick(e) {
    if (!e.composedPath().includes(this.colorPopup) &&
      !e.composedPath().includes(this.selectedColorContainer)) {
      this.colorPopupShown = false;
    }
  }
  /**
   */
  checkValue() {
    if (!this.inputElement)
      return;
    if (this.type == 'photo') {
      this.value = this.photoBase64;
    }
    else if (this.type == 'color') {
      this.value = this.selectedColor;
    }
    else {
      this.value = this.inputElement.value;
      this.value.replace(/(^\s+|\s+$)/, ''); // trim
    }
    if (this.required) {
      if (!this.value) {
        this.invalidMessage = 'Field is required';
        this.isValid = false;
        if (this.autoValidate)
          this.invalidMessageShown = true;
      }
      else {
        this.isValid = true;
        this.invalidMessageShown = false;
      }
    }
  }
  /**
   */
  onKeyUp(e) {
    this.checkValue();
    e.stopPropagation();
  }
  /**
   */
  onKeyDown(e) {
    e.stopPropagation();
  }
  /**
   */
  onColorClick(e) {
    this.selectColor(e.currentTarget.dataset.color);
  }
  /**
   */
  selectColor(color) {
    const colorElement = this.inputWrapElement.querySelector(`.color-option[data-color="${color}"]`);
    if (!colorElement)
      return;
    this.selectedColor = colorElement.dataset.color;
    if (this.currentColorElement)
      this.currentColorElement.classList.remove('active');
    colorElement.classList.add('active');
    this.currentColorElement = colorElement;
    this.value = this.selectedColor;
  }
  /**
   */
  onPhotoChange(e) {
    const file = e.currentTarget.files[0];
    const reader = new FileReader();
    reader.addEventListener('load', () => {
      this.photoBase64 = `${reader.result}`;
      this.value = this.photoBase64;
      this.checkValue();
    }, false);
    if (file) {
      reader.readAsDataURL(file);
    }
  }
  /**
   */
  componentDidRender() {
    // this.checkValue()
  }
  /**
   */
  componentWillLoad() {
    if (this.type == 'color' && !this.selectedColor && !this.value) {
      this.selectedColor = this.colorOptions[Math.floor(Math.random() * this.colorOptions.length)];
      this.value = this.selectedColor;
    }
    else if (this.type == 'color' && this.value) {
      this.selectedColor = this.value;
    }
    if (this.type == 'photo' && this.value) {
      this.photoBase64 = this.value; // TODO: check it's actually base64
    }
  }
  /**
   */
  componentDidLoad() {
    this.selectColor(this.selectedColor);
  }
  /**
   */
  render() {
    const inputTypes = {
      text: [
        this.showLabel && h$4("label", { class: "input-label" }, this.label),
        h$4("input", { ref: (el) => (this.inputElement = el), placeholder: this.showLabel ? '' : this.label, type: "text", value: this.value, onKeyDown: this.onKeyDown.bind(this), onKeyUp: this.onKeyUp.bind(this), class: {
            invalid: (this.autoValidate || this.invalidMessageShown) && !this.isValid,
          } }),
      ],
      photo: (h$4("div", { class: "photo-input" }, h$4("div", { class: "photo-thumb", onClick: () => {
          this.inputElement.dispatchEvent(new MouseEvent('click'));
        } }, h$4("zea-icon", { name: "camera-outline", size: 30 }), h$4("div", { id: "photo-preview", style: { backgroundImage: `url(${this.value})` } })), h$4("div", { class: "photo-copy" }, h$4("label", { class: "input-label" }, this.label), "Your photo lets people recognize you while working together."), h$4("input", { ref: (el) => (this.inputElement = el), type: "file", onChange: this.onPhotoChange.bind(this), class: {
          invalid: (this.autoValidate || this.invalidMessageShown) &&
            !this.isValid,
        } }))),
      color: (h$4("div", { class: "color-input" }, h$4("div", { class: "color-thumb" }, h$4("div", { ref: (el) => (this.selectedColorContainer = el), class: "choosen-color", style: { backgroundColor: this.selectedColor }, onClick: () => {
          this.colorPopupShown = !this.colorPopupShown;
        } }), h$4("div", { ref: (el) => (this.colorPopup = el), class: `color-popup ${this.colorPopupShown ? 'shown' : ''} ${this.colorPopupAlign}` }, this.colorOptions.map((colorOption) => (h$4("div", { class: "color-option", "data-color": colorOption, onMouseDown: this.onColorClick.bind(this), onMouseUp: () => {
          this.colorPopupShown = false;
        } }, h$4("div", { class: "color-sample", style: { backgroundColor: colorOption } })))))), this.showLabel && (h$4("div", { class: "color-copy" }, h$4("label", { class: "input-label" }, this.label), "Your color helps you stand out from other people.")))),
    };
    return (h$4("div", { class: "input-wrap", ref: (el) => (this.inputWrapElement = el) }, inputTypes[this.type], !this.isValid && this.invalidMessageShown && (h$4("div", { class: "invalid-message" }, this.invalidMessage))));
  }
  static get style() { return zeaInputCss; }
};

const zeaInputColorCss = ".color-input{display:flex;overflow:hidden}.color-input .input-label{display:block}.color-thumb{flex-shrink:0;display:block;width:54px;height:54px;border-radius:30px;margin-right:10px;display:flex;align-items:center;justify-content:center;font-size:12px}.color-copy{font-size:12px;color:var(--color-foreground-2)}.color-popup{padding:7px;position:absolute;grid-template-columns:1fr 1fr 1fr 1fr;margin-top:-70px;margin-left:43px;border-radius:10px;background-color:var(--color-background-2);display:none;z-index:1000}.color-popup.top-left{margin-top:110px;margin-left:-54px}.color-popup.shown{display:grid}.color-option{padding:8px}.color-option:hover{padding:0px}.color-option.active:hover,.color-option.active{padding:0}.color-option:hover .color-sample{border:8px solid var(--color-background-1);border-radius:20px}.color-option.active:hover .color-sample,.color-option.active .color-sample{width:32px;height:32px;border-radius:20px;border:none}.color-sample{width:16px;height:16px;border-radius:10px}.choosen-color{width:32px;height:32px;border-radius:20px}";

const ZeaInputColor = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     */
    this.showLabel = false;
    /**
     */
    this.invalidMessage = 'Not valid';
    /**
     */
    this.invalidMessageShown = false;
    /**
     */
    this.required = false;
    /**
     */
    this.isValid = true;
    /**
     */
    this.colorPopupShown = false;
    /**
     */
    this.colorPopupAlign = 'bottom-right';
    /**
     */
    this.label = 'Color';
    /**
     */
    this.name = 'zea-input';
    /**
     */
    this.colorOptions = [
      '#F34235',
      '#E81D62',
      '#000000',
      '#9B26AF',
      '#6639B6',
      '#3E50B4',
      '#2095F2',
      '#02A8F3',
      '#00BBD3',
      '#009587',
      '#4BAE4F',
      '#8AC249',
      '#CCDB38',
      '#FEEA3A',
      '#FEC006',
      '#FE9700',
      '#FE5621',
      '#785447',
      '#9D9D9D',
      '#5F7C8A',
    ];
  }
  /**
   * Listen to click events on the whole document
   * @param {any} e The event
   */
  handleClick(e) {
    if (!e.composedPath().includes(this.colorPopup) &&
      !e.composedPath().includes(this.selectedColorContainer)) {
      this.colorPopupShown = false;
    }
  }
  /**
   */
  onColorClick(e) {
    this.selectColor(e.currentTarget.dataset.color);
  }
  /**
   */
  selectColor(color) {
    const colorElement = this.inputWrapElement.querySelector(`.color-option[data-color="${color}"]`);
    if (!colorElement)
      return;
    this.selectedColor = colorElement.dataset.color;
    if (this.currentColorElement)
      this.currentColorElement.classList.remove('active');
    colorElement.classList.add('active');
    this.currentColorElement = colorElement;
    this.value = this.selectedColor;
  }
  /**
   */
  componentWillLoad() {
    if (!this.selectedColor && !this.value) {
      this.selectedColor = this.colorOptions[Math.floor(Math.random() * this.colorOptions.length)];
      this.value = this.selectedColor;
    }
    else if (this.value) {
      this.selectedColor = this.value;
    }
  }
  /**
   */
  componentDidLoad() {
    if (this.value) {
      const colorElement = this.inputWrapElement.querySelector(`.color-option[data-color="${this.value}"]`);
      if (!colorElement)
        return;
      if (this.currentColorElement)
        this.currentColorElement.classList.remove('active');
      colorElement.classList.add('active');
      this.currentColorElement = colorElement;
    }
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "input-wrap", ref: (el) => (this.inputWrapElement = el) }, h$4("div", { class: "color-input" }, h$4("div", { class: "color-thumb" }, h$4("div", { ref: (el) => (this.selectedColorContainer = el), class: "choosen-color", style: { backgroundColor: this.selectedColor }, onClick: () => {
        this.colorPopupShown = !this.colorPopupShown;
      } }), h$4("div", { ref: (el) => (this.colorPopup = el), class: `color-popup ${this.colorPopupShown ? 'shown' : ''} ${this.colorPopupAlign}` }, this.colorOptions.map((colorOption) => (h$4("div", { class: "color-option", "data-color": colorOption, onMouseDown: this.onColorClick.bind(this), onMouseUp: () => {
        this.colorPopupShown = false;
      } }, h$4("div", { class: "color-sample", style: { backgroundColor: colorOption } })))))), this.showLabel && (h$4("div", { class: "color-copy" }, h$4("label", { class: "input-label" }, this.label), "Your color helps you stand out from other people."))), !this.isValid && this.invalidMessageShown && (h$4("div", { class: "invalid-message" }, this.invalidMessage))));
  }
  static get style() { return zeaInputColorCss; }
};

const zeaInputDateCss = ".zea-input-date{color:var(--color-freground-1)}";

const ZeaInputDate = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * A test prop.
     */
    this.test = 'Hello World';
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    return h$4("div", { class: "zea-input-date" }, this.test);
  }
  static get style() { return zeaInputDateCss; }
};

const zeaInputPhotoCss = ".zea-input-photo{color:var(--color-freground-1)}";

const ZeaInputPhoto = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * A test prop.
     */
    this.test = 'Hello World';
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    return h$4("div", { class: "zea-input-photo" }, this.test);
  }
  static get style() { return zeaInputPhotoCss; }
};

const zeaInputSearchCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-input-search{color:var(--color-foreground-1);display:inline-flex;justify-content:flex-end;align-items:center;width:2em;border-radius:3px;transition:all 0.5s;background-color:transparent;border:1px solid transparent}path.icon{fill:var(--color-foreground-1)}.zea-input-search.active{width:100%;border:1px solid var(--color-grey-3);background-color:var(--color-background-1)}.zea-input-search-icon{height:2em;width:2em;display:inline-block;vertical-align:middle;border-radius:1em;box-sizing:border-box;padding:0.2em;flex-grow:0;flex-shrink:0}.zea-input-search-icon:hover{background-color:var(--color-grey-3);color:var(--color-button-text-1)}.zea-input-search.active .zea-input-search-icon:hover{background-color:var(--color-background-1)}input{display:block;height:100%;width:100%;border:none;background-color:transparent;outline:none;font-size:1em;color:var(--color-foreground-1)}.zea-input-search-text-container{height:2em;flex-grow:1;opacity:0;transition:all 0.5s}.zea-input-search.active .zea-input-search-text-container{opacity:1}.zea-input-cancel{display:none;height:1.5em;width:1.5em;border-radius:1em;box-sizing:border-box;flex-shrink:0}.active .zea-input-cancel{display:block;visibility:hidden}.tainted .zea-input-cancel{visibility:visible}";

const ZeaInputSearch = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.placeholder = '';
  }
  /**
   * Toggle 'active' class of the search box
   */
  toggleSearchBox() {
    this.mainContainer.classList.toggle('active');
    this.mainInput.focus();
  }
  /**
   */
  cancelSearch() {
    this.mainInput.value = '';
  }
  /**
   */
  componentDidLoad() {
    this.mainInput.addEventListener('keyup', () => {
      const q = this.mainInput.value.replace(/(^\s+|\s+$)/, '');
      if (q) {
        this.mainContainer.classList.add('tainted');
      }
      else {
        this.mainContainer.classList.remove('tainted');
      }
    });
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("div", { class: "zea-input-search", ref: (el) => {
        this.mainContainer = el;
      } }, h$4("span", { class: "zea-input-search-icon", onClick: () => {
        this.toggleSearchBox();
      } }, h$4("svg", { xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", viewBox: "0 0 24 24" }, h$4("path", { class: "icon", d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }), h$4("path", { d: "M0 0h24v24H0z", fill: "none" }))), h$4("span", { class: "zea-input-search-text-container" }, h$4("input", { ref: (el) => {
        this.mainInput = el;
      }, onBlur: () => {
        setTimeout(() => {
          this.mainContainer.classList.remove('active');
        }, 100);
      }, onKeyDown: (e) => {
        e.stopPropagation();
      }, onKeyUp: (e) => {
        e.stopPropagation();
      }, class: "zea-input-search-text", type: "text", placeholder: this.placeholder })), h$4("span", { class: "zea-input-cancel", onClick: () => {
        this.cancelSearch();
      } }, h$4("svg", { xmlns: "http://www.w3.org/2000/svg", width: "100%", height: "100%", viewBox: "0 0 512 512" }, h$4("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z", class: "icon" })))));
  }
  get mainElement() { return this; }
  static get style() { return zeaInputSearchCss; }
};

const zeaInputSelectCss = ":host{display:inline-block;width:100%;box-sizing:border-box;font-size:13px}.zea-input{color:var(--color-foreground-1)}.input-label{color:var(--color-grey-3);position:relative;transition:all 0.2s linear;pointer-events:none}.empty .input-label{top:18px;font-size:13px}.not-empty .input-label,.focused .input-label{top:0;font-size:11px}.focused .input-label{color:var(--color-secondary-1)}.input-wrap{display:block;position:relative}.invalid-message{color:var(--color-warning-2);padding:0.3em 0;font-size:12px}.underliner{text-align:center;height:1px;background-color:var(--color-grey-3);overflow:hidden;display:flex;justify-content:center}.underliner .expander{height:1px;background-color:var(--color-secondary-1);overflow:hidden;display:inline-block;width:0;transition:width 0.2s linear}.focused .underliner .expander{width:100%}.selection-container{min-height:22px;display:flex;align-items:center}.selection{flex-grow:1;user-select:none}.options-container{display:none;position:absolute;width:100%;height:210px;max-height:initial;overflow:hidden;padding:2px;box-sizing:border-box;box-shadow:2px 2px 13px 0px var(--color-background-4);background-color:var(--color-background-1);user-select:none;z-index:1000;margin-top:1px}.options-container.shown{display:block}.discipline-row{display:flex;width:100%;align-items:center}.discipline-name{flex-grow:1}.discipline-abbreviation{text-transform:uppercase;padding:8px;width:15px;height:15px;line-height:15px;text-align:center;border-radius:20px;margin:5px 10px 5px 5px;display:flex;justify-content:center;white-space:nowrap}";

const ZeaInputSelect = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     */
    this.name = 'zea-input';
    /**
     */
    this.label = 'Enter text...';
    /**
     */
    this.invalidMessage = 'Not valid';
    /**
     */
    this.required = false;
    /**
     */
    this.isValid = true;
    /**
     */
    this.autoValidate = false;
    /**
     */
    this.invalidMessageShown = false;
    /**
     */
    this.showLabel = true;
    /**
     */
    this.optionsShown = false;
  }
  /**
   * Listen to click events on the whole document
   * @param {any} e The event
   */
  handleClick(e) {
    if (!e.composedPath().includes(this.inputWrapElement)) {
      this.optionsShown = false;
    }
  }
  /**
   */
  checkValue() {
    if (!this.inputElement)
      return;
    this.value = this.inputElement.value;
    this.value.replace(/(^\s+|\s+$)/, ''); // trim
    if (this.required) {
      if (!this.value) {
        this.invalidMessage = 'Field is required';
        this.isValid = false;
        if (this.autoValidate)
          this.invalidMessageShown = true;
      }
      else {
        this.isValid = true;
        this.invalidMessageShown = false;
      }
    }
  }
  /**
   */
  onContainerClick() {
    this.optionsShown = !this.optionsShown;
  }
  /**
   */
  onBlur() {
    this.inputWrapElement.classList.remove('focused');
  }
  /**
   */
  onFocus() {
    this.inputWrapElement.classList.add('focused');
  }
  /**
   */
  componentDidLoad() {
    this.optionsContainer.addEventListener('click', (e) => {
      e.composedPath().forEach((element) => {
        if (element.tagName == 'ZEA-INPUT-SELECT-ITEM') {
          this.value = element.value;
          this.optionsShown = false;
          const selContainer = this.selectionContainer.querySelector('.selection');
          selContainer.innerHTML = '';
          selContainer.appendChild(element.cloneNode(true));
          if (this.selectCallback)
            this.selectCallback(this.value);
        }
      });
    });
  }
  /**
   */
  placeOptionsContainer() {
    if (this.optionsShown) {
      const minHeight = 105;
      const maxHeight = 210;
      const wrapRect = this.inputWrapElement.getBoundingClientRect();
      const defaultTop = wrapRect.top + wrapRect.height;
      const winHeight = window.innerHeight;
      let optionsHeight = maxHeight;
      this.optionsContainer.style.height = `${optionsHeight}px`;
      this.optionsContainer.style.top = `${wrapRect.height}px`;
      if (defaultTop + optionsHeight > winHeight) {
        const spaceBelow = winHeight - defaultTop;
        optionsHeight = spaceBelow;
        if (spaceBelow < minHeight) {
          const spaceAbove = wrapRect.top;
          if (spaceAbove > minHeight) {
            optionsHeight = Math.min(spaceAbove, maxHeight);
            this.optionsContainer.style.top = `${-optionsHeight}px`;
          }
        }
        this.optionsContainer.style.height = `${optionsHeight}px`;
      }
    }
  }
  /**
   */
  componentDidRender() {
    this.placeOptionsContainer();
    this.optionsScrollPane.refreshScrollbar();
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: `input-wrap ${this.value ? 'not-empty' : 'empty'} ${this.optionsShown ? 'focused' : ''}`, ref: (el) => (this.inputWrapElement = el) }, this.showLabel && h$4("label", { class: "input-label" }, this.label), h$4("div", { ref: (el) => (this.selectionContainer = el), class: "selection-container", onClick: this.onContainerClick.bind(this) }, h$4("div", { class: "selection" }), h$4("zea-icon", { name: this.optionsShown ? 'chevron-up-outline' : 'chevron-down-outline', size: 13 })), h$4("div", { ref: (el) => (this.optionsContainer = el), class: { 'options-container': true, shown: this.optionsShown } }, h$4("zea-scroll-pane", { ref: (el) => (this.optionsScrollPane = el) }, h$4("slot", null))), h$4("div", { class: "underliner" }, h$4("div", { class: "expander" })), !this.isValid && this.invalidMessageShown && (h$4("div", { class: "invalid-message" }, this.invalidMessage))));
  }
  static get style() { return zeaInputSelectCss; }
};

const zeaInputSelectItemCss = ":host{display:block}.zea-input-select-item{color:var(--color-freground-1)}::slotted(.select-item-wrap){padding:5px}";

const ZeaInputSelectItem = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-input-select-item" }, h$4("slot", null)));
  }
  static get style() { return zeaInputSelectItemCss; }
};

const zeaInputTextCss = ":host{display:inline-block;width:100%;box-sizing:border-box}:host(.hidden){display:none}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-input{color:var(--color-foreground-1)}.input-label{color:var(--color-foreground-3);position:relative;transition:all 0.2s linear;pointer-events:none}.empty .input-label{top:18px;font-size:13px}.not-empty .input-label,.focused .input-label{top:0;font-size:11px}.focused .input-label{color:var(--color-secondary-1)}.input-wrap{display:block;position:relative}input[type='text']{box-sizing:border-box;width:100%;color:var(--color-foreground-1);background-color:transparent;border:none;outline:none;font-size:1em;font-size:13px}.invalid-message{color:var(--color-warning-1);padding:0.3em 0;font-size:12px}.underliner{text-align:center;height:1px;background-color:var(--color-grey-3);overflow:hidden;display:flex;justify-content:center}.underliner .expander{height:1px;background-color:var(--color-secondary-1);overflow:hidden;display:inline-block;width:0;transition:width 0.2s linear}.focused .underliner .expander{width:100%}.invalid .underliner .expander{background-color:var(--color-warning-1);width:100%}.disabled .underliner{background-color:transparent;border-bottom:1px dotted var(--color-grey-3)}.hidden{display:none}";

const ZeaInputText = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     */
    this.name = 'zea-input';
    /**
     */
    this.label = 'Enter text...';
    /**
     */
    this.invalidMessage = 'Not valid';
    /**
     */
    this.required = false;
    /**
     */
    this.disabled = false;
    /**
     */
    this.isValid = true;
    /**
     */
    this.autoValidate = false;
    /**
     */
    this.invalidMessageShown = false;
    /**
     */
    this.showLabel = true;
    /**
     */
    this.hidden = false;
  }
  /**
   */
  checkValue() {
    if (!this.inputElement)
      return;
    this.value = this.inputElement.value;
    this.value.replace(/(^\s+|\s+$)/, ''); // trim
    if (this.required) {
      if (!this.value) {
        this.invalidMessage = 'Field is required';
        this.isValid = false;
        if (this.autoValidate)
          this.invalidMessageShown = true;
      }
      else {
        this.isValid = true;
        this.invalidMessageShown = false;
      }
    }
  }
  /**
   */
  onKeyUp(e) {
    this.checkValue();
    e.stopPropagation();
  }
  /**
   */
  onKeyDown(e) {
    e.stopPropagation();
  }
  /**
   */
  onBlur() {
    this.inputWrapElement.classList.remove('focused');
  }
  /**
   */
  onFocus() {
    this.inputWrapElement.classList.add('focused');
  }
  /**
   */
  componentDidRender() {
    this.checkValue();
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    return (h$4(Host, { class: `${this.hidden ? 'hidden' : ''}` }, h$4("div", { class: `input-wrap ${this.value ? 'not-empty' : 'empty'} ${!this.invalidMessageShown ? 'valid' : 'invalid'} ${this.disabled ? 'disabled' : ''} ${this.hidden ? 'hidden' : ''}`, ref: (el) => (this.inputWrapElement = el) }, this.showLabel && h$4("label", { class: "input-label" }, this.label), h$4("input", { ref: (el) => (this.inputElement = el),
      // placeholder={this.showLabel ? '' : this.label}
      type: "text", value: this.value, onKeyDown: this.onKeyDown.bind(this), onKeyUp: this.onKeyUp.bind(this), onBlur: this.onBlur.bind(this), onFocus: this.onFocus.bind(this), disabled: this.disabled, class: {
        invalid: (this.autoValidate || this.invalidMessageShown) &&
          !this.isValid,
      } }), h$4("div", { class: "underliner" }, h$4("div", { class: "expander" })), !this.isValid && this.invalidMessageShown && (h$4("div", { class: "invalid-message" }, this.invalidMessage)))));
  }
  static get style() { return zeaInputTextCss; }
};

const zeaLayoutCss = ":host{height:100%}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-layout{color:var(--color-foreground-1);display:flex;width:100%;height:100%}.zea-layout.vertical{flex-direction:column}.zea-layout-cell{flex-grow:1;position:relative;box-sizing:border-box;background-color:var(--color-background-1);width:100%;height:100%}.with-borders .zea-layout-cell{border:1px solid var(--color-grey-1)}.zea-layout-cell:nth-child(1){flex-grow:0;width:100px;height:auto}.zea-layout-cell:nth-child(3){flex-grow:0;width:100px;height:auto}.vertical .zea-layout-cell:nth-child(1){flex-grow:0;height:100px;width:auto}.vertical .zea-layout-cell:nth-child(3){flex-grow:0;height:100px;width:auto}.zea-resize-handle{position:absolute;display:block;content:'';width:6px;height:100%;background-color:transparent;background-repeat:no-repeat;background-position:center center;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAXCAYAAAAoRj52AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEFJREFUeNpinDRp0v+XL18yLF26lFFMTIwhJiYGzGf6/fs3w58/fxhgAMZnYsABRiWGrwQLCwsDMzMzXADGBwgwAF78GJLqRabNAAAAAElFTkSuQmCC);z-index:1000000;top:0;opacity:0.5;cursor:col-resize}.zea-resize-handle:hover{background-color:var(--color-background-2);opacity:1}.vertical .zea-resize-handle{left:0 !important;right:0 !important;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAGCAYAAAAooAWeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAD1JREFUeNpinDhx4v8/f/4wUBuwsrIysLx8+ZLh79+/VDechYWFgVFBQYGBVoBFTEyMdoZHR0cPzTAHCDAAG7UW+bsxwNcAAAAASUVORK5CYII=')}.zea-layout-cell:nth-child(1) .zea-resize-handle{right:-1px}.zea-layout-cell:nth-child(3) .zea-resize-handle{left:-1px}.vertical .zea-resize-handle{position:absolute;width:100%;height:6px;cursor:row-resize;margin-left:0;left:0;background-repeat:no-repeat}.vertical .zea-layout-cell:nth-child(1) .zea-resize-handle{bottom:-1px;top:auto}.vertical .zea-layout-cell:nth-child(3) .zea-resize-handle{top:-1px}";

const ZeaLayout = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.cellCount = 3;
    this.orientation = 'horizontal';
    this.resizeCellA = true;
    this.resizeCellC = true;
    this.cellASize = 100;
    this.cellCSize = 100;
    this.resizeInterval = 50;
    this.showBorders = true;
    this.error = '';
    this.minimumGap = 20;
    this.maximunGap = 50;
  }
  /**
   * Listen for dragstart events
   * @param {any} event The event
   */
  handleMouseDown(event) {
    this.activeHandle = event.target;
    document.getElementsByTagName('body')[0].style.cursor =
      this.orientation === 'vertical' ? 'row-resize' : 'col-resize';
    document.getElementsByTagName('body')[0].style.userSelect = 'none';
  }
  /**
   */
  onMouseUp() {
    this.handleMouseUp();
  }
  /**
   */
  onTouchEnd() {
    this.handleMouseUp();
  }
  /**
   */
  handleMouseUp() {
    this.activeHandle = null;
    document.getElementsByTagName('body')[0].style.cursor = 'default';
    document.getElementsByTagName('body')[0].style.userSelect = 'initial';
  }
  /**
   */
  onMouseMove(event) {
    this.handleMouseMove.call(this, event);
  }
  /**
   */
  onTouchMove(event) {
    this.handleMouseMove.call(this, event);
  }
  /**
   */
  handleMouseMove(event) {
    if (this.activeHandle) {
      const isA = this.activeHandle.classList.contains('zea-handle-a');
      if (this.orientation === 'vertical') {
        if (isA) {
          this.processDrag(event, 'Y', 'a');
        }
        else {
          this.processDrag(event, 'Y', 'c');
        }
      }
      else {
        if (isA) {
          this.processDrag(event, 'X', 'a');
        }
        else {
          this.processDrag(event, 'X', 'c');
        }
      }
    }
  }
  /**
   * Process drag
   * @param {any} event The event
   * @param {any} axis The axis
   * @param {any} cell The cell
   */
  processDrag(event, axis, cell) {
    const handle = this.activeHandle;
    const parent = handle.parentElement;
    const parentRect = parent.getBoundingClientRect();
    const handleRect = handle.getBoundingClientRect();
    const cellBREct = this.cellB.getBoundingClientRect();
    const side = axis == 'X' ? 'left' : 'top';
    const prop = axis == 'X' ? 'width' : 'height';
    const cellBSize = cellBREct[prop];
    let offset;
    if (event.touches) {
      const touch = event.touches[0];
      offset = handleRect[side] - touch['page' + axis];
    }
    else {
      offset = handleRect[side] - event['client' + axis];
    }
    // change offset sign for the following sum, according to cell
    offset = cell == 'a' ? -offset : offset;
    let newDimension = parentRect[prop] + offset;
    parent.style[prop] = `${newDimension}px`;
    if (newDimension < this.minimumGap) {
      newDimension = this.minimumGap;
    }
    const maxDimension = parentRect[prop] + cellBSize - this.minimumGap;
    if (newDimension > maxDimension) {
      newDimension = maxDimension;
    }
    const cellSizeVar = cell == 'a' ? 'cellASize' : 'cellCSize';
    this[cellSizeVar] = newDimension;
    parent.style[prop] = `${newDimension}px`;
    this.triggerResize(newDimension);
  }
  /**
   * Trigger window resize event
   * @param {any} newDimension The new dimension
   */
  triggerResize(newDimension) {
    window.dispatchEvent(new CustomEvent('resize', {
      bubbles: true,
      detail: newDimension,
    }));
  }
  /**
   */
  layout() {
    let dimension;
    let availableLength;
    if (this.orientation === 'vertical') {
      dimension = 'height';
      availableLength = this.layoutContainer.clientHeight;
    }
    else {
      dimension = 'width';
      availableLength = this.layoutContainer.clientWidth;
    }
    const cellBSize = availableLength - this.cellASize - this.cellCSize;
    if (cellBSize >= 0) {
      this.cellB.style[dimension] = `${cellBSize}px`;
    }
    else {
      // hack for flex grow
      this.cellB.style[dimension] = `1px`;
    }
    this.cellA.style[dimension] = `${this.cellASize}px`;
    this.cellC.style[dimension] = `${this.cellCSize}px`;
  }
  /**
   * Prevent the browser drag event from triggering
   * as it hinders the mousemove event
   */
  componentDidLoad() {
    this.mainElement.addEventListener('dragstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    window.addEventListener('resize', () => {
      this.layout();
    });
  }
  /**
   * Prevent the browser drag event from triggering
   * as it hinders the mousemove event
   */
  componentDidRender() {
    this.layout();
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    const cellAStyle = {};
    const cellCStyle = {};
    if (!this.cellASize) {
      this.resizeCellA = false;
    }
    if (!this.cellCSize) {
      this.resizeCellC = false;
    }
    if (this.cellASize !== undefined) {
      if (this.orientation === 'vertical') {
        cellAStyle.height = `${this.cellASize}px`;
      }
      else {
        cellAStyle.width = `${this.cellASize}px`;
      }
    }
    if (this.cellCSize !== undefined) {
      if (this.orientation === 'vertical') {
        cellCStyle.height = `${this.cellCSize}px`;
      }
      else {
        cellCStyle.width = `${this.cellCSize}px`;
      }
    }
    const cellA = (h$4("div", { class: "zea-layout-cell cell-a", style: cellAStyle, ref: (el) => (this.cellA = el) }, this.resizeCellA && (h$4("div", { class: "zea-resize-handle zea-handle-a", onMouseDown: this.handleMouseDown.bind(this), onTouchStart: this.handleMouseDown.bind(this) })), h$4("slot", { name: "a" })));
    const cellB = (h$4("div", { class: "zea-layout-cell cell-b", ref: (el) => (this.cellB = el) }, h$4("slot", { name: "b" })));
    const cellC = this.cellCount > 2 && (h$4("div", { class: "zea-layout-cell cell-c", style: cellCStyle, ref: (el) => (this.cellC = el) }, this.resizeCellC && (h$4("div", { class: "zea-resize-handle zea-handle-c", onMouseDown: this.handleMouseDown.bind(this), onTouchStart: this.handleMouseDown.bind(this) })), h$4("slot", { name: "c" })));
    return (h$4("div", { ref: (el) => (this.layoutContainer = el), class: `zea-layout ${this.orientation} ${this.showBorders ? 'with-borders' : ''}` }, this.error || [cellA, cellB, cellC]));
  }
  get mainElement() { return this; }
  static get style() { return zeaLayoutCss; }
};

var textarea;

function decodeEntity(name) {
  textarea = textarea || document.createElement('textarea');
  textarea.innerHTML = '&' + name;
  return textarea.value;
}

var hasOwn = Object.prototype.hasOwnProperty;

function has(object, key) {
  return object
    ? hasOwn.call(object, key)
    : false;
}

// Extend objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = [].slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

////////////////////////////////////////////////////////////////////////////////

var UNESCAPE_MD_RE = /\\([\\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

function replaceEntityPattern(match, name) {
  var code = 0;
  var decoded = decodeEntity(name);

  if (name !== decoded) {
    return decoded;
  } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16)
    :
      parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }
  return match;
}

function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

/**
 * Renderer rules cache
 */

var rules = {};

/**
 * Blockquotes
 */

rules.blockquote_open = function(/* tokens, idx, options, env */) {
  return '<blockquote>\n';
};

rules.blockquote_close = function(tokens, idx /*, options, env */) {
  return '</blockquote>' + getBreak(tokens, idx);
};

/**
 * Code
 */

rules.code = function(tokens, idx /*, options, env */) {
  if (tokens[idx].block) {
    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);
  }
  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';
};

/**
 * Fenced code blocks
 */

rules.fence = function(tokens, idx, options, env, instance) {
  var token = tokens[idx];
  var langClass = '';
  var langPrefix = options.langPrefix;
  var langName = '', fences, fenceName;
  var highlighted;

  if (token.params) {

    //
    // ```foo bar
    //
    // Try custom renderer "foo" first. That will simplify overwrite
    // for diagrams, latex, and any other fenced block with custom look
    //

    fences = token.params.split(/\s+/g);
    fenceName = fences.join(' ');

    if (has(instance.rules.fence_custom, fences[0])) {
      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);
    }

    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));
    langClass = ' class="' + langPrefix + langName + '"';
  }

  if (options.highlight) {
    highlighted = options.highlight.apply(options.highlight, [ token.content ].concat(fences))
      || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  return '<pre><code' + langClass + '>'
        + highlighted
        + '</code></pre>'
        + getBreak(tokens, idx);
};

rules.fence_custom = {};

/**
 * Headings
 */

rules.heading_open = function(tokens, idx /*, options, env */) {
  return '<h' + tokens[idx].hLevel + '>';
};
rules.heading_close = function(tokens, idx /*, options, env */) {
  return '</h' + tokens[idx].hLevel + '>\n';
};

/**
 * Horizontal rules
 */

rules.hr = function(tokens, idx, options /*, env */) {
  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);
};

/**
 * Bullets
 */

rules.bullet_list_open = function(/* tokens, idx, options, env */) {
  return '<ul>\n';
};
rules.bullet_list_close = function(tokens, idx /*, options, env */) {
  return '</ul>' + getBreak(tokens, idx);
};

/**
 * List items
 */

rules.list_item_open = function(/* tokens, idx, options, env */) {
  return '<li>';
};
rules.list_item_close = function(/* tokens, idx, options, env */) {
  return '</li>\n';
};

/**
 * Ordered list items
 */

rules.ordered_list_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  var order = token.order > 1 ? ' start="' + token.order + '"' : '';
  return '<ol' + order + '>\n';
};
rules.ordered_list_close = function(tokens, idx /*, options, env */) {
  return '</ol>' + getBreak(tokens, idx);
};

/**
 * Paragraphs
 */

rules.paragraph_open = function(tokens, idx /*, options, env */) {
  return tokens[idx].tight ? '' : '<p>';
};
rules.paragraph_close = function(tokens, idx /*, options, env */) {
  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);
  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');
};

/**
 * Links
 */

rules.link_open = function(tokens, idx, options /* env */) {
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var target = options.linkTarget ? (' target="' + options.linkTarget + '"') : '';
  return '<a href="' + escapeHtml(tokens[idx].href) + '"' + title + target + '>';
};
rules.link_close = function(/* tokens, idx, options, env */) {
  return '</a>';
};

/**
 * Images
 */

rules.image = function(tokens, idx, options /*, env */) {
  var src = ' src="' + escapeHtml(tokens[idx].src) + '"';
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var alt = ' alt="' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '"';
  var suffix = options.xhtmlOut ? ' /' : '';
  return '<img' + src + alt + title + suffix + '>';
};

/**
 * Tables
 */

rules.table_open = function(/* tokens, idx, options, env */) {
  return '<table>\n';
};
rules.table_close = function(/* tokens, idx, options, env */) {
  return '</table>\n';
};
rules.thead_open = function(/* tokens, idx, options, env */) {
  return '<thead>\n';
};
rules.thead_close = function(/* tokens, idx, options, env */) {
  return '</thead>\n';
};
rules.tbody_open = function(/* tokens, idx, options, env */) {
  return '<tbody>\n';
};
rules.tbody_close = function(/* tokens, idx, options, env */) {
  return '</tbody>\n';
};
rules.tr_open = function(/* tokens, idx, options, env */) {
  return '<tr>';
};
rules.tr_close = function(/* tokens, idx, options, env */) {
  return '</tr>\n';
};
rules.th_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<th'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.th_close = function(/* tokens, idx, options, env */) {
  return '</th>';
};
rules.td_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<td'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.td_close = function(/* tokens, idx, options, env */) {
  return '</td>';
};

/**
 * Bold
 */

rules.strong_open = function(/* tokens, idx, options, env */) {
  return '<strong>';
};
rules.strong_close = function(/* tokens, idx, options, env */) {
  return '</strong>';
};

/**
 * Italicize
 */

rules.em_open = function(/* tokens, idx, options, env */) {
  return '<em>';
};
rules.em_close = function(/* tokens, idx, options, env */) {
  return '</em>';
};

/**
 * Strikethrough
 */

rules.del_open = function(/* tokens, idx, options, env */) {
  return '<del>';
};
rules.del_close = function(/* tokens, idx, options, env */) {
  return '</del>';
};

/**
 * Insert
 */

rules.ins_open = function(/* tokens, idx, options, env */) {
  return '<ins>';
};
rules.ins_close = function(/* tokens, idx, options, env */) {
  return '</ins>';
};

/**
 * Highlight
 */

rules.mark_open = function(/* tokens, idx, options, env */) {
  return '<mark>';
};
rules.mark_close = function(/* tokens, idx, options, env */) {
  return '</mark>';
};

/**
 * Super- and sub-script
 */

rules.sub = function(tokens, idx /*, options, env */) {
  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';
};
rules.sup = function(tokens, idx /*, options, env */) {
  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';
};

/**
 * Breaks
 */

rules.hardbreak = function(tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
rules.softbreak = function(tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};

/**
 * Text
 */

rules.text = function(tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

/**
 * Content
 */

rules.htmlblock = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
rules.htmltag = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * Abbreviations, initialism
 */

rules.abbr_open = function(tokens, idx /*, options, env */) {
  return '<abbr title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '">';
};
rules.abbr_close = function(/* tokens, idx, options, env */) {
  return '</abbr>';
};

/**
 * Footnotes
 */

rules.footnote_ref = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return '<sup class="footnote-ref"><a href="#fn' + n + '" id="' + id + '">[' + n + ']</a></sup>';
};
rules.footnote_block_open = function(tokens, idx, options) {
  var hr = options.xhtmlOut
    ? '<hr class="footnotes-sep" />\n'
    : '<hr class="footnotes-sep">\n';
  return hr + '<section class="footnotes">\n<ol class="footnotes-list">\n';
};
rules.footnote_block_close = function() {
  return '</ol>\n</section>\n';
};
rules.footnote_open = function(tokens, idx) {
  var id = Number(tokens[idx].id + 1).toString();
  return '<li id="fn' + id + '"  class="footnote-item">';
};
rules.footnote_close = function() {
  return '</li>\n';
};
rules.footnote_anchor = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return ' <a href="#' + id + '" class="footnote-backref"></a>';
};

/**
 * Definition lists
 */

rules.dl_open = function() {
  return '<dl>\n';
};
rules.dt_open = function() {
  return '<dt>';
};
rules.dd_open = function() {
  return '<dd>';
};
rules.dl_close = function() {
  return '</dl>\n';
};
rules.dt_close = function() {
  return '</dt>\n';
};
rules.dd_close = function() {
  return '</dd>\n';
};

/**
 * Helper functions
 */

function nextToken(tokens, idx) {
  if (++idx >= tokens.length - 2) {
    return idx;
  }
  if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&
      (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&
      (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {
    return nextToken(tokens, idx + 2);
  }
  return idx;
}

/**
 * Check to see if `\n` is needed before the next token.
 *
 * @param  {Array} `tokens`
 * @param  {Number} `idx`
 * @return {String} Empty string or newline
 * @api private
 */

var getBreak = rules.getBreak = function getBreak(tokens, idx) {
  idx = nextToken(tokens, idx);
  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {
    return '';
  }
  return '\n';
};

/**
 * Renderer class. Renders HTML and exposes `rules` to allow
 * local modifications.
 */

function Renderer() {
  this.rules = assign({}, rules);

  // exported helper, for custom rules only
  this.getBreak = rules.getBreak;
}

/**
 * Render a string of inline HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.renderInline = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = 0;
  var result = '';

  while (len--) {
    result += _rules[tokens[i].type](tokens, i++, options, env, this);
  }

  return result;
};

/**
 * Render a string of HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.render = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = -1;
  var result = '';

  while (++i < len) {
    if (tokens[i].type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else {
      result += _rules[tokens[i].type](tokens, i, options, env, this);
    }
  }
  return result;
};

/**
 * Ruler is a helper class for building responsibility chains from
 * parse rules. It allows:
 *
 *   - easy stack rules chains
 *   - getting main chain and named chains content (as arrays of functions)
 *
 * Helper methods, should not be used directly.
 * @api private
 */

function Ruler() {
  // List of added rules. Each element is:
  //
  // { name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ] }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - digital anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

/**
 * Find the index of a rule by `name`.
 *
 * @param  {String} `name`
 * @return {Number} Index of the given `name`
 * @api private
 */

Ruler.prototype.__find__ = function (name) {
  var len = this.__rules__.length;
  var i = -1;

  while (len--) {
    if (this.__rules__[++i].name === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Build the rules lookup cache
 *
 * @api private
 */

Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler public methods
 * ------------------------------------------------
 */

/**
 * Replace rule function
 *
 * @param  {String} `name` Rule name
 * @param  {Function `fn`
 * @param  {Object} `options`
 * @api private
 */

Ruler.prototype.at = function (name, fn, options) {
  var idx = this.__find__(name);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[idx].fn = fn;
  this.__rules__[idx].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Add a rule to the chain before given the `ruleName`.
 *
 * @param  {String}   `beforeName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var idx = this.__find__(beforeName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(idx, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the chain after the given `ruleName`.
 *
 * @param  {String}   `afterName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var idx = this.__find__(afterName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(idx + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the end of chain.
 *
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @return {String}
 */

Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Enable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to enable
 * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.
 * @api private
 */

Ruler.prototype.enable = function (list, strict) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // In strict mode disable all existing rules first
  if (strict) {
    this.__rules__.forEach(function (rule) {
      rule.enabled = false;
    });
  }

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
  }, this);

  this.__cache__ = null;
};


/**
 * Disable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to disable
 * @api private
 */

Ruler.prototype.disable = function (list) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
  }, this);

  this.__cache__ = null;
};

/**
 * Get a rules list as an array of functions.
 *
 * @param  {String} `chainName`
 * @return {Object}
 * @api private
 */

Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};

function block(state) {

  if (state.inlineMode) {
    state.tokens.push({
      type: 'inline',
      content: state.src.replace(/\n/g, ' ').trim(),
      level: 0,
      lines: [ 0, 1 ],
      children: []
    });

  } else {
    state.block.parse(state.src, state.options, state.env, state.tokens);
  }
}

// Inline parser state

function StateInline(src, parserInline, options, env, outTokens) {
  this.src = src;
  this.env = env;
  this.options = options;
  this.parser = parserInline;
  this.tokens = outTokens;
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack
                          // optimization of pairs parse (emphasis, strikes).

  // Link parser state vars

  this.isInLabel = false; // Set true when seek link label - we should disable
                          // "paired" rules (emphasis, strikes) to not skip
                          // tailing `]`

  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent
                          // nesting in definitions

  this.linkContent = '';  // Temporary storage for link url

  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels
                                 // (backtrack optimization)
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  this.tokens.push({
    type: 'text',
    content: this.pending,
    level: this.pendingLevel
  });
  this.pending = '';
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (token) {
  if (this.pending) {
    this.pushPending();
  }

  this.tokens.push(token);
  this.pendingLevel = this.level;
};

// Store value to cache.
// !!! Implementation has parser-specific optimizations
// !!! keys MUST be integer, >= 0; values MUST be integer, > 0
//
StateInline.prototype.cacheSet = function (key, val) {
  for (var i = this.cache.length; i <= key; i++) {
    this.cache.push(0);
  }

  this.cache[key] = val;
};

// Get cache value
//
StateInline.prototype.cacheGet = function (key) {
  return key < this.cache.length ? this.cache[key] : 0;
};

/**
 * Parse link labels
 *
 * This function assumes that first character (`[`) already matches;
 * returns the end of the label.
 *
 * @param  {Object} state
 * @param  {Number} start
 * @api private
 */

function parseLinkLabel(state, start) {
  var level, found, marker,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos,
      oldFlag = state.isInLabel;

  if (state.isInLabel) { return -1; }

  if (state.labelUnmatchedScopes) {
    state.labelUnmatchedScopes--;
    return -1;
  }

  state.pos = start + 1;
  state.isInLabel = true;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5B /* [ */) {
      level++;
    } else if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    state.parser.skipToken(state);
  }

  if (found) {
    labelEnd = state.pos;
    state.labelUnmatchedScopes = 0;
  } else {
    state.labelUnmatchedScopes = level - 1;
  }

  // restore old state
  state.pos = oldPos;
  state.isInLabel = oldFlag;

  return labelEnd;
}

// Parse abbreviation definitions, i.e. `*[abbr]: description`


function parseAbbr(str, parserInline, options, env) {
  var state, labelEnd, pos, max, label, title;

  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }
  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parserInline, options, env, []);
  labelEnd = parseLinkLabel(state, 1);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // abbr title is always one line, so looking for ending "\n" here
  for (pos = labelEnd + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x0A) { break; }
  }

  label = str.slice(2, labelEnd);
  title = str.slice(labelEnd + 2, pos).trim();
  if (title.length === 0) { return -1; }
  if (!env.abbreviations) { env.abbreviations = {}; }
  // prepend ':' to avoid conflict with Object.prototype members
  if (typeof env.abbreviations[':' + label] === 'undefined') {
    env.abbreviations[':' + label] = title;
  }

  return pos;
}

function abbr(state) {
  var tokens = state.tokens, i, l, content, pos;

  if (state.inlineMode) {
    return;
  }

  // Parse inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i - 1].type === 'paragraph_open' &&
        tokens[i].type === 'inline' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseAbbr(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
}

function normalizeLink(url) {
  var normalized = replaceEntities(url);
  // We shouldn't care about the result of malformed URIs,
  // and should not throw an exception.
  try {
    normalized = decodeURI(normalized);
  } catch (err) {}
  return encodeURI(normalized);
}

/**
 * Parse link destination
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

function parseLinkDestination(state, pos) {
  var code, level, link,
      start = pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = state.src.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return false; }
      if (code === 0x3E /* > */) {
        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));
        if (!state.parser.validateLink(link)) { return false; }
        state.pos = pos + 1;
        state.linkContent = link;
        return true;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return false;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = state.src.charCodeAt(pos);

    if (code === 0x20) { break; }

    // ascii control chars
    if (code < 0x20 || code === 0x7F) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 1) { break; }
    }

    if (code === 0x29 /* ) */) {
      level--;
      if (level < 0) { break; }
    }

    pos++;
  }

  if (start === pos) { return false; }

  link = unescapeMd(state.src.slice(start, pos));
  if (!state.parser.validateLink(link)) { return false; }

  state.linkContent = link;
  state.pos = pos;
  return true;
}

/**
 * Parse link title
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

function parseLinkTitle(state, pos) {
  var code,
      start = pos,
      max = state.posMax,
      marker = state.src.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = state.src.charCodeAt(pos);
    if (code === marker) {
      state.pos = pos + 1;
      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));
      return true;
    }
    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    pos++;
  }

  return false;
}

function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

function parseReference(str, parser, options, env) {
  var state, labelEnd, pos, max, code, start, href, title, label;

  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parser, options, env, []);
  labelEnd = parseLinkLabel(state, 0);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  if (!parseLinkDestination(state, pos)) { return -1; }
  href = state.linkContent;
  pos = state.pos;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (pos = pos + 1; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
    title = state.linkContent;
    pos = state.pos;
  } else {
    title = '';
    pos = start;
  }

  // ensure that the end of the line is empty
  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }
  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }

  label = normalizeReference(str.slice(1, labelEnd));
  if (typeof env.references[label] === 'undefined') {
    env.references[label] = { title: title, href: href };
  }

  return pos;
}


function references(state) {
  var tokens = state.tokens, i, l, content, pos;

  state.env.references = state.env.references || {};

  if (state.inlineMode) {
    return;
  }

  // Scan definitions in paragraph inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i].type === 'inline' &&
        tokens[i - 1].type === 'paragraph_open' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseReference(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
}

function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.inline.parse(tok.content, state.options, state.env, tok.children);
    }
  }
}

function footnote_block(state) {
  var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,
      level = 0,
      insideRef = false,
      refTokens = {};

  if (!state.env.footnotes) { return; }

  state.tokens = state.tokens.filter(function(tok) {
    if (tok.type === 'footnote_reference_open') {
      insideRef = true;
      current = [];
      currentLabel = tok.label;
      return false;
    }
    if (tok.type === 'footnote_reference_close') {
      insideRef = false;
      // prepend ':' to avoid conflict with Object.prototype members
      refTokens[':' + currentLabel] = current;
      return false;
    }
    if (insideRef) { current.push(tok); }
    return !insideRef;
  });

  if (!state.env.footnotes.list) { return; }
  list = state.env.footnotes.list;

  state.tokens.push({
    type: 'footnote_block_open',
    level: level++
  });
  for (i = 0, l = list.length; i < l; i++) {
    state.tokens.push({
      type: 'footnote_open',
      id: i,
      level: level++
    });

    if (list[i].tokens) {
      tokens = [];
      tokens.push({
        type: 'paragraph_open',
        tight: false,
        level: level++
      });
      tokens.push({
        type: 'inline',
        content: '',
        level: level,
        children: list[i].tokens
      });
      tokens.push({
        type: 'paragraph_close',
        tight: false,
        level: --level
      });
    } else if (list[i].label) {
      tokens = refTokens[':' + list[i].label];
    }

    state.tokens = state.tokens.concat(tokens);
    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {
      lastParagraph = state.tokens.pop();
    } else {
      lastParagraph = null;
    }

    t = list[i].count > 0 ? list[i].count : 1;
    for (j = 0; j < t; j++) {
      state.tokens.push({
        type: 'footnote_anchor',
        id: i,
        subId: j,
        level: level
      });
    }

    if (lastParagraph) {
      state.tokens.push(lastParagraph);
    }

    state.tokens.push({
      type: 'footnote_close',
      level: --level
    });
  }
  state.tokens.push({
    type: 'footnote_block_close',
    level: --level
  });
}

// Enclose abbreviations in <abbr> tags
//

var PUNCT_CHARS = ' \n()[]\'".,!?-';


// from Google closure library
// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021
function regEscape(s) {
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
}


function abbr2(state) {
  var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,
      blockTokens = state.tokens;

  if (!state.env.abbreviations) { return; }
  if (!state.env.abbrRegExp) {
    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'
            + '(' + Object.keys(state.env.abbreviations).map(function (x) {
                      return x.substr(1);
                    }).sort(function (a, b) {
                      return b.length - a.length;
                    }).map(regEscape).join('|') + ')'
            + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';
    state.env.abbrRegExp = new RegExp(regText, 'g');
  }
  reg = state.env.abbrRegExp;

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') { continue; }
    tokens = blockTokens[j].children;

    // We scan from the end, to keep position when new tags added.
    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];
      if (token.type !== 'text') { continue; }

      pos = 0;
      text = token.content;
      reg.lastIndex = 0;
      level = token.level;
      nodes = [];

      while ((m = reg.exec(text))) {
        if (reg.lastIndex > pos) {
          nodes.push({
            type: 'text',
            content: text.slice(pos, m.index + m[1].length),
            level: level
          });
        }

        nodes.push({
          type: 'abbr_open',
          title: state.env.abbreviations[':' + m[2]],
          level: level++
        });
        nodes.push({
          type: 'text',
          content: m[2],
          level: level
        });
        nodes.push({
          type: 'abbr_close',
          level: --level
        });
        pos = reg.lastIndex - m[3].length;
      }

      if (!nodes.length) { continue; }

      if (pos < text.length) {
        nodes.push({
          type: 'text',
          content: text.slice(pos),
          level: level
        });
      }

      // replace current node
      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
    }
  }
}

// Simple typographical replacements
//
// TODO:
// - fractionals 1/2, 1/4, 3/4 -> , , 
// - miltiplication 2 x 4 -> 2  4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  'c': '',
  'r': '',
  'p': '',
  'tm': ''
};

function replaceScopedAbbr(str) {
  if (str.indexOf('(') < 0) { return str; }

  return str.replace(SCOPED_ABBR_RE, function(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  });
}


function replace(state) {
  var i, token, text, inlineTokens, blkIdx;

  if (!state.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    inlineTokens = state.tokens[blkIdx].children;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === 'text') {
        text = token.content;

        text = replaceScopedAbbr(text);

        if (RARE_RE.test(text)) {
          text = text
            .replace(/\+-/g, '')
            // .., ..., ....... -> 
            // but ?..... & !..... -> ?.. & !..
            .replace(/\.{2,}/g, '').replace(/([?!])/g, '$1..')
            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
            // em-dash
            .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
            // en-dash
            .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2')
            .replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
        }

        token.content = text;
      }
    }
  }
}

// Convert straight quotation marks to typographic ones
//

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var PUNCT_RE = /[-\s()\[\]]/;
var APOSTROPHE = '';

// This function returns true if the character at `pos`
// could be inside a word.
function isLetter(str, pos) {
  if (pos < 0 || pos >= str.length) { return false; }
  return !PUNCT_RE.test(str[pos]);
}


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}


function smartquotes(state) {
  /*eslint max-depth:0*/
  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,
      canOpen, canClose, j, isSingle, blkIdx, tokens,
      stack;

  if (!state.options.typographer) { return; }

  stack = [];

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    tokens = state.tokens[blkIdx].children;
    stack.length = 0;

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];

      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }

      thisLevel = tokens[i].level;

      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) { break; }
      }
      stack.length = j + 1;

      text = token.content;
      pos = 0;
      max = text.length;

      /*eslint no-labels:0,block-scoped-var:0*/
      OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);
        if (!t) { break; }

        lastSpace = !isLetter(text, t.index - 1);
        pos = t.index + 1;
        isSingle = (t[0] === "'");
        nextSpace = !isLetter(text, pos);

        if (!nextSpace && !lastSpace) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }

        canOpen = !nextSpace;
        canClose = !lastSpace;

        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) { break; }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);
              } else {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);
              }
              stack.length = j;
              continue OUTER;
            }
          }
        }

        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
    }
  }
}

/**
 * Core parser `rules`
 */

var _rules = [
  [ 'block',          block          ],
  [ 'abbr',           abbr           ],
  [ 'references',     references     ],
  [ 'inline',         inline         ],
  [ 'footnote_tail',  footnote_block  ],
  [ 'abbr2',          abbr2          ],
  [ 'replacements',   replace   ],
  [ 'smartquotes',    smartquotes    ],
];

/**
 * Class for top level (`core`) parser rules
 *
 * @api private
 */

function Core() {
  this.options = {};
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Process rules with the given `state`
 *
 * @param  {Object} `state`
 * @api private
 */

Core.prototype.process = function (state) {
  var i, l, rules;
  rules = this.ruler.getRules('');
  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

// Parser state class

function StateBlock(src, parser, options, env, tokens) {
  var ch, s, start, pos, len, indent, indent_found;

  this.src = src;

  // Shortcuts to simplify nested calls
  this.parser = parser;

  this.options = options;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // indent for each line

  // block parser variables
  this.blkIndent  = 0; // required block content indent
                       // (for example, if we are in list)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.parentType = 'root'; // if `list`, block parser stops on two newlines
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent = 0;
  indent_found = false;

  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (ch === 0x20/* space */) {
        indent++;
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);

      indent_found = false;
      indent = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, first, last, queue, shift,
      line = begin;

  if (begin >= end) {
    return '';
  }

  // Opt: don't use push queue for single line;
  if (line + 1 === end) {
    first = this.bMarks[line] + Math.min(this.tShift[line], indent);
    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];
    return this.src.slice(first, last);
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    shift = this.tShift[line];
    if (shift > indent) { shift = indent; }
    if (shift < 0) { shift = 0; }

    first = this.bMarks[line] + shift;

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    queue[i] = this.src.slice(first, last);
  }

  return queue.join('');
};

// Code block (4 spaces padded)

function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last;

  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'code',
    content: state.getLines(startLine, last, 4 + state.blkIndent, true),
    block: true,
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
}

// fences (``` lang, ~~~ lang)

function fences(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  params = state.src.slice(pos, max).trim();

  if (params.indexOf('`') >= 0) { return false; }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.tShift[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.tShift[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);
  state.tokens.push({
    type: 'fence',
    params: params,
    content: state.getLines(startLine + 1, nextLine, len, true),
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
}

// Block quotes

function blockquote(state, startLine, endLine, silent) {
  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,
      terminatorRules,
      i, l, terminate,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos > max) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20) { pos++; }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  // check if we have an empty blockquote
  pos = pos < max ? state.skipSpaces(pos) : pos;
  lastLineEmpty = pos >= max;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.parser.ruler.getRules('blockquote');

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {
      // This line is inside the blockquote.

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20) { pos++; }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      pos = pos < max ? state.skipSpaces(pos) : pos;
      lastLineEmpty = pos >= max;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    oldBMarks.push(state.bMarks[nextLine]);
    oldTShift.push(state.tShift[nextLine]);

    // A negative number means that this is a paragraph continuation;
    //
    // Any negative number will do the job here, but it's better for it
    // to be large enough to make any bugs obvious.
    state.tShift[nextLine] = -1337;
  }

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  state.tokens.push({
    type: 'blockquote_open',
    lines: lines = [ startLine, 0 ],
    level: state.level++
  });
  state.parser.tokenize(state, startLine, nextLine);
  state.tokens.push({
    type: 'blockquote_close',
    level: --state.level
  });
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
  }
  state.blkIndent = oldIndent;

  return true;
}

// Horizontal rule

function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine];

  pos += state.tShift[startLine];

  if (pos > max) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 one

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && ch !== 0x20/* space */) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;
  state.tokens.push({
    type: 'hr',
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
}

// Lists

// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  if (pos >= max) { return -1; }

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {
    // " 1.test " - is not a list item
    return -1;
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {
      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {
    // " 1.test " - is not a list item
    return -1;
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}


function list(state, startLine, endLine, silent) {
  var nextLine,
      indent,
      oldTShift,
      oldIndent,
      oldTight,
      oldParentType,
      start,
      posAfterMarker,
      max,
      indentAfterMarker,
      markerValue,
      markerCharCode,
      isOrdered,
      contentStart,
      listTokIdx,
      prevEmptyEnd,
      listLines,
      itemLines,
      tight = true,
      terminatorRules,
      i, l, terminate;

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    state.tokens.push({
      type: 'ordered_list_open',
      order: markerValue,
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });

  } else {
    state.tokens.push({
      type: 'bullet_list_open',
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });
  }

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.parser.ruler.getRules('list');

  while (nextLine < endLine) {
    contentStart = state.skipSpaces(posAfterMarker);
    max = state.eMarks[nextLine];

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = contentStart - posAfterMarker;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // If indent is less than 1, assume that it's one, example:
    //  "-\n  test"
    if (indentAfterMarker < 1) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;

    // Run subparser & write tokens
    state.tokens.push({
      type: 'list_item_open',
      lines: itemLines = [ startLine, 0 ],
      level: state.level++
    });

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldParentType = state.parentType;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.parentType = 'list';

    state.parser.tokenize(state, startLine, endLine, true);

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.tight = oldTight;
    state.parentType = oldParentType;

    state.tokens.push({
      type: 'list_item_close',
      level: --state.level
    });

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    if (state.isEmpty(nextLine)) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finilize list
  state.tokens.push({
    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
}

// Process footnote reference list

function footnote(state, startLine, endLine, silent) {
  var oldBMark, oldTShift, oldParentType, pos, label,
      start = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // line should be at least 5 chars - "[^x]:"
  if (start + 4 > max) { return false; }

  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }
  if (silent) { return true; }
  pos++;

  if (!state.env.footnotes) { state.env.footnotes = {}; }
  if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }
  label = state.src.slice(start + 2, pos - 2);
  state.env.footnotes.refs[':' + label] = -1;

  state.tokens.push({
    type: 'footnote_reference_open',
    label: label,
    level: state.level++
  });

  oldBMark = state.bMarks[startLine];
  oldTShift = state.tShift[startLine];
  oldParentType = state.parentType;
  state.tShift[startLine] = state.skipSpaces(pos) - pos;
  state.bMarks[startLine] = pos;
  state.blkIndent += 4;
  state.parentType = 'footnote';

  if (state.tShift[startLine] < state.blkIndent) {
    state.tShift[startLine] += state.blkIndent;
    state.bMarks[startLine] -= state.blkIndent;
  }

  state.parser.tokenize(state, startLine, endLine, true);

  state.parentType = oldParentType;
  state.blkIndent -= 4;
  state.tShift[startLine] = oldTShift;
  state.bMarks[startLine] = oldBMark;

  state.tokens.push({
    type: 'footnote_reference_close',
    level: --state.level
  });

  return true;
}

// heading (#, ##, ...)

function heading(state, startLine, endLine, silent) {
  var ch, level, tmp,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos >= max) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipCharsBack(max, 0x20, pos); // space
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {
    max = tmp;
  }

  state.line = startLine + 1;

  state.tokens.push({ type: 'heading_open',
    hLevel: level,
    lines: [ startLine, state.line ],
    level: state.level
  });

  // only if header is not empty
  if (pos < max) {
    state.tokens.push({
      type: 'inline',
      content: state.src.slice(pos, max).trim(),
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
  }
  state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });

  return true;
}

// lheading (---, ===)

function lheading(state, startLine, endLine/*, silent*/) {
  var marker, pos, max,
      next = startLine + 1;

  if (next >= endLine) { return false; }
  if (state.tShift[next] < state.blkIndent) { return false; }

  // Scan next line

  if (state.tShift[next] - state.blkIndent > 3) { return false; }

  pos = state.bMarks[next] + state.tShift[next];
  max = state.eMarks[next];

  if (pos >= max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }

  pos = state.skipChars(pos, marker);

  pos = state.skipSpaces(pos);

  if (pos < max) { return false; }

  pos = state.bMarks[startLine] + state.tShift[startLine];

  state.line = next + 1;
  state.tokens.push({
    type: 'heading_open',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    lines: [ startLine, state.line ],
    level: state.level
  });
  state.tokens.push({
    type: 'inline',
    content: state.src.slice(pos, state.eMarks[startLine]).trim(),
    level: state.level + 1,
    lines: [ startLine, state.line - 1 ],
    children: []
  });
  state.tokens.push({
    type: 'heading_close',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    level: state.level
  });

  return true;
}

// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks

var html_blocks = {};

[
  'article',
  'aside',
  'button',
  'blockquote',
  'body',
  'canvas',
  'caption',
  'col',
  'colgroup',
  'dd',
  'div',
  'dl',
  'dt',
  'embed',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'hr',
  'iframe',
  'li',
  'map',
  'object',
  'ol',
  'output',
  'p',
  'pre',
  'progress',
  'script',
  'section',
  'style',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'tr',
  'thead',
  'ul',
  'video'
].forEach(function (name) { html_blocks[name] = true; });

// HTML block


var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\s\/>]/;
var HTML_TAG_CLOSE_RE = /^<\/([a-zA-Z]{1,15})[\s>]/;

function isLetter$1(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}

function htmlblock(state, startLine, endLine, silent) {
  var ch, match, nextLine,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine],
      shift = state.tShift[startLine];

  pos += shift;

  if (!state.options.html) { return false; }

  if (shift > 3 || pos + 2 >= max) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  ch = state.src.charCodeAt(pos + 1);

  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {
    // Directive start / comment start / processing instruction start
    if (silent) { return true; }

  } else if (ch === 0x2F/* / */ || isLetter$1(ch)) {

    // Probably start or end of tag
    if (ch === 0x2F/* \ */) {
      // closing tag
      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);
      if (!match) { return false; }
    } else {
      // opening tag
      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);
      if (!match) { return false; }
    }
    // Make sure tag name is valid
    if (html_blocks[match[1].toLowerCase()] !== true) { return false; }
    if (silent) { return true; }

  } else {
    return false;
  }

  // If we are here - we detected HTML block.
  // Let's roll down till empty line (block end).
  nextLine = startLine + 1;
  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {
    nextLine++;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'htmlblock',
    level: state.level,
    lines: [ startLine, state.line ],
    content: state.getLines(startLine, nextLine, 0, true)
  });

  return true;
}

// GFM table, non-standard

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, rows, cell,
      aligns, t, tableLines, tbodyLines;

  // should have at least three lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.tShift[nextLine] < state.blkIndent) { return false; }

  // first character of the second line should be '|' or '-'

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  ch = state.src.charCodeAt(pos);
  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }

  lineText = getLine(state, startLine + 1);
  if (!/^[-:| ]+$/.test(lineText)) { return false; }

  rows = lineText.split('|');
  if (rows <= 2) { return false; }
  aligns = [];
  for (i = 0; i < rows.length; i++) {
    t = rows[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === rows.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  rows = lineText.replace(/^\||\|$/g, '').split('|');
  if (aligns.length !== rows.length) { return false; }
  if (silent) { return true; }

  state.tokens.push({
    type: 'table_open',
    lines: tableLines = [ startLine, 0 ],
    level: state.level++
  });
  state.tokens.push({
    type: 'thead_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });

  state.tokens.push({
    type: 'tr_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });
  for (i = 0; i < rows.length; i++) {
    state.tokens.push({
      type: 'th_open',
      align: aligns[i],
      lines: [ startLine, startLine + 1 ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: rows[i].trim(),
      lines: [ startLine, startLine + 1 ],
      level: state.level,
      children: []
    });
    state.tokens.push({ type: 'th_close', level: --state.level });
  }
  state.tokens.push({ type: 'tr_close', level: --state.level });
  state.tokens.push({ type: 'thead_close', level: --state.level });

  state.tokens.push({
    type: 'tbody_open',
    lines: tbodyLines = [ startLine + 2, 0 ],
    level: state.level++
  });

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) { break; }
    rows = lineText.replace(/^\||\|$/g, '').split('|');

    state.tokens.push({ type: 'tr_open', level: state.level++ });
    for (i = 0; i < rows.length; i++) {
      state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });
      // 0x7c === '|'
      cell = rows[i].substring(
          rows[i].charCodeAt(0) === 0x7c ? 1 : 0,
          rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length
      ).trim();
      state.tokens.push({
        type: 'inline',
        content: cell,
        level: state.level,
        children: []
      });
      state.tokens.push({ type: 'td_close', level: --state.level });
    }
    state.tokens.push({ type: 'tr_close', level: --state.level });
  }
  state.tokens.push({ type: 'tbody_close', level: --state.level });
  state.tokens.push({ type: 'table_close', level: --state.level });

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
}

// Definition lists

// Search `[:~][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipMarker(state, line) {
  var pos, marker,
      start = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  if (start >= max) { return -1; }

  // Check bullet
  marker = state.src.charCodeAt(start++);
  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }

  pos = state.skipSpaces(start);

  // require space after ":"
  if (start === pos) { return -1; }

  // no empty definitions, e.g. "  : "
  if (pos >= max) { return -1; }

  return pos;
}

function markTightParagraphs$1(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}

function deflist(state, startLine, endLine, silent) {
  var contentStart,
      ddLine,
      dtLine,
      itemLines,
      listLines,
      listTokIdx,
      nextLine,
      oldIndent,
      oldDDIndent,
      oldParentType,
      oldTShift,
      oldTight,
      prevEmptyEnd,
      tight;

  if (silent) {
    // quirk: validation mode validates a dd block only, not a whole deflist
    if (state.ddIndent < 0) { return false; }
    return skipMarker(state, startLine) >= 0;
  }

  nextLine = startLine + 1;
  if (state.isEmpty(nextLine)) {
    if (++nextLine > endLine) { return false; }
  }

  if (state.tShift[nextLine] < state.blkIndent) { return false; }
  contentStart = skipMarker(state, nextLine);
  if (contentStart < 0) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // Start list
  listTokIdx = state.tokens.length;

  state.tokens.push({
    type: 'dl_open',
    lines: listLines = [ startLine, 0 ],
    level: state.level++
  });

  //
  // Iterate list items
  //

  dtLine = startLine;
  ddLine = nextLine;

  // One definition list can contain multiple DTs,
  // and one DT can be followed by multiple DDs.
  //
  // Thus, there is two loops here, and label is
  // needed to break out of the second one
  //
  /*eslint no-labels:0,block-scoped-var:0*/
  OUTER:
  for (;;) {
    tight = true;
    prevEmptyEnd = false;

    state.tokens.push({
      type: 'dt_open',
      lines: [ dtLine, dtLine ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),
      level: state.level + 1,
      lines: [ dtLine, dtLine ],
      children: []
    });
    state.tokens.push({
      type: 'dt_close',
      level: --state.level
    });

    for (;;) {
      state.tokens.push({
        type: 'dd_open',
        lines: itemLines = [ nextLine, 0 ],
        level: state.level++
      });

      oldTight = state.tight;
      oldDDIndent = state.ddIndent;
      oldIndent = state.blkIndent;
      oldTShift = state.tShift[ddLine];
      oldParentType = state.parentType;
      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;
      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
      state.tight = true;
      state.parentType = 'deflist';

      state.parser.tokenize(state, ddLine, endLine, true);

      // If any of list item is tight, mark list as tight
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish
      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);

      state.tShift[ddLine] = oldTShift;
      state.tight = oldTight;
      state.parentType = oldParentType;
      state.blkIndent = oldIndent;
      state.ddIndent = oldDDIndent;

      state.tokens.push({
        type: 'dd_close',
        level: --state.level
      });

      itemLines[1] = nextLine = state.line;

      if (nextLine >= endLine) { break OUTER; }

      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }
      contentStart = skipMarker(state, nextLine);
      if (contentStart < 0) { break; }

      ddLine = nextLine;

      // go to the next loop iteration:
      // insert DD tag and repeat checking
    }

    if (nextLine >= endLine) { break; }
    dtLine = nextLine;

    if (state.isEmpty(dtLine)) { break; }
    if (state.tShift[dtLine] < state.blkIndent) { break; }

    ddLine = dtLine + 1;
    if (ddLine >= endLine) { break; }
    if (state.isEmpty(ddLine)) { ddLine++; }
    if (ddLine >= endLine) { break; }

    if (state.tShift[ddLine] < state.blkIndent) { break; }
    contentStart = skipMarker(state, ddLine);
    if (contentStart < 0) { break; }

    // go to the next loop iteration:
    // insert DT and DD tags and repeat checking
  }

  // Finilize list
  state.tokens.push({
    type: 'dl_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs$1(state, listTokIdx);
  }

  return true;
}

// Paragraph

function paragraph(state, startLine/*, endLine*/) {
  var endLine, content, terminate, i, l,
      nextLine = startLine + 1,
      terminatorRules;

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  if (nextLine < endLine && !state.isEmpty(nextLine)) {
    terminatorRules = state.parser.ruler.getRules('paragraph');

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }

      // Some tags can terminate paragraph without empty line.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;
  if (content.length) {
    state.tokens.push({
      type: 'paragraph_open',
      tight: false,
      lines: [ startLine, state.line ],
      level: state.level
    });
    state.tokens.push({
      type: 'inline',
      content: content,
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
    state.tokens.push({
      type: 'paragraph_close',
      tight: false,
      level: state.level
    });
  }

  return true;
}

/**
 * Parser rules
 */

var _rules$1 = [
  [ 'code',       code ],
  [ 'fences',     fences,     [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'blockquote', blockquote, [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'hr',         hr,         [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'list',       list,       [ 'paragraph', 'blockquote' ] ],
  [ 'footnote',   footnote,   [ 'paragraph' ] ],
  [ 'heading',    heading,    [ 'paragraph', 'blockquote' ] ],
  [ 'lheading',   lheading ],
  [ 'htmlblock',  htmlblock,  [ 'paragraph', 'blockquote' ] ],
  [ 'table',      table,      [ 'paragraph' ] ],
  [ 'deflist',    deflist,    [ 'paragraph' ] ],
  [ 'paragraph',  paragraph ]
];

/**
 * Block Parser class
 *
 * @api private
 */

function ParserBlock() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {
      alt: (_rules$1[i][2] || []).slice()
    });
  }
}

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc
 * @param  {Number} `startLine`
 * @param  {Number} `endLine`
 * @api private
 */

ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var line = startLine;
  var hasEmptyLines = false;
  var ok, i;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.tShift[line] < state.blkIndent) {
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;

      // two empty lines should stop the parser in list mode
      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }
      state.line = line;
    }
  }
};

var TABS_SCAN_RE = /[\n\t]/g;
var NEWLINES_RE  = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
var SPACES_RE    = /\u00a0/g;

/**
 * Tokenize the given `str`.
 *
 * @param  {String} `str` Source string
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserBlock.prototype.parse = function (str, options, env, outTokens) {
  var state, lineStart = 0, lastTabPos = 0;
  if (!str) { return []; }

  // Normalize spaces
  str = str.replace(SPACES_RE, ' ');

  // Normalize newlines
  str = str.replace(NEWLINES_RE, '\n');

  // Replace tabs with proper number of spaces (1..4)
  if (str.indexOf('\t') >= 0) {
    str = str.replace(TABS_SCAN_RE, function (match, offset) {
      var result;
      if (str.charCodeAt(offset) === 0x0A) {
        lineStart = offset + 1;
        lastTabPos = 0;
        return match;
      }
      result = '    '.slice((offset - lineStart - lastTabPos) % 4);
      lastTabPos = offset - lineStart + 1;
      return result;
    });
  }

  state = new StateBlock(str, this, options, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};

// Skip text characters for text token, place those to pending buffer
// and increment current pos

// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x5C/* \ */:
    case 0x60/* ` */:
    case 0x2A/* * */:
    case 0x5F/* _ */:
    case 0x5E/* ^ */:
    case 0x5B/* [ */:
    case 0x5D/* ] */:
    case 0x21/* ! */:
    case 0x26/* & */:
    case 0x3C/* < */:
    case 0x3E/* > */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x40/* @ */:
    case 0x7E/* ~ */:
    case 0x2B/* + */:
    case 0x3D/* = */:
    case 0x3A/* : */:
      return true;
    default:
      return false;
  }
}

function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
}

// Proceess '\n'

function newline(state, silent) {
  var pmax, max, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Strip out all trailing spaces on this line.
        for (var i = pmax - 2; i >= 0; i--) {
          if (state.pending.charCodeAt(i) !== 0x20) {
            state.pending = state.pending.substring(0, i + 1);
            break;
          }
        }
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push({
          type: 'softbreak',
          level: state.level
        });
      }

    } else {
      state.push({
        type: 'softbreak',
        level: state.level
      });
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

  state.pos = pos;
  return true;
}

// Proceess escaped chars and hardbreaks

var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
}

// Parse backticks

function backticks(state, silent) {
  var start, max, marker, matchStart, matchEnd,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        state.push({
          type: 'code',
          content: state.src.slice(pos, matchStart)
                              .replace(/[ \n]+/g, ' ')
                              .trim(),
          block: false,
          level: state.level
        });
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) { state.pending += marker; }
  state.pos += marker.length;
  return true;
}

// Process ~~deleted text~~

function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }
  if (pos > start + 3) {
    // sequence of 4+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '~~'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '~~'
            stack++;
          } // else {
            //  // standalone ' ~~ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'del_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'del_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
}

// Process ++inserted text++

function ins(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '++'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '++'
            stack++;
          } // else {
            //  // standalone ' ++ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'ins_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'ins_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
}

// Process ==highlighted text==

function mark(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '=='
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '=='
            stack++;
          } // else {
            //  // standalone ' == ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'mark_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'mark_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
}

// Process *this* and _that_

function isAlphaNum(code) {
  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||
         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||
         (code >= 0x61 /* a */ && code <= 0x7A /* z */);
}

// parse sequence of emphasis markers,
// "start" should point at a valid marker
function scanDelims(state, start) {
  var pos = start, lastChar, nextChar, count,
      can_open = true,
      can_close = true,
      max = state.posMax,
      marker = state.src.charCodeAt(start);

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;

  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }
  if (pos >= max) { can_open = false; }
  count = pos - start;

  if (count >= 4) {
    // sequence of four or more unescaped markers can't start/end an emphasis
    can_open = can_close = false;
  } else {
    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;

    // check whitespace conditions
    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }
    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }

    if (marker === 0x5F /* _ */) {
      // check if we aren't inside the word
      if (isAlphaNum(lastChar)) { can_open = false; }
      if (isAlphaNum(nextChar)) { can_close = false; }
    }
  }

  return {
    can_open: can_open,
    can_close: can_close,
    delims: count
  };
}

function emphasis(state, silent) {
  var startCount,
      count,
      found,
      oldCount,
      newCount,
      stack,
      res,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode

  res = scanDelims(state, start);
  startCount = res.delims;
  if (!res.can_open) {
    state.pos += startCount;
    if (!silent) { state.pending += state.src.slice(start, state.pos); }
    return true;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + startCount;
  stack = [ startCount ];

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === marker) {
      res = scanDelims(state, state.pos);
      count = res.delims;
      if (res.can_close) {
        oldCount = stack.pop();
        newCount = count;

        while (oldCount !== newCount) {
          if (newCount < oldCount) {
            stack.push(oldCount - newCount);
            break;
          }

          // assert(newCount > oldCount)
          newCount -= oldCount;

          if (stack.length === 0) { break; }
          state.pos += oldCount;
          oldCount = stack.pop();
        }

        if (stack.length === 0) {
          startCount = oldCount;
          found = true;
          break;
        }
        state.pos += count;
        continue;
      }

      if (res.can_open) { stack.push(count); }
      state.pos += count;
      continue;
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + startCount;

  if (!silent) {
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_open', level: state.level++ });
    }
    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_open', level: state.level++ });
    }

    state.parser.tokenize(state);

    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_close', level: --state.level });
    }
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_close', level: --state.level });
    }
  }

  state.pos = state.posMax + startCount;
  state.posMax = max;
  return true;
}

// Process ~subscript~

// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function sub(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sub',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}

// Process ^superscript^

// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE$1 = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function sup(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sup',
      level: state.level,
      content: content.replace(UNESCAPE_RE$1, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}

// Process [links](<to> "stuff")


function links(state, silent) {
  var labelStart,
      labelEnd,
      label,
      href,
      title,
      pos,
      ref,
      code,
      isImage = false,
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker === 0x21/* ! */) {
    isImage = true;
    marker = state.src.charCodeAt(++start);
  }

  if (marker !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 1;
  labelEnd = parseLinkLabel(state, start);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    if (parseLinkDestination(state, pos)) {
      href = state.linkContent;
      pos = state.pos;
    } else {
      href = '';
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
      title = state.linkContent;
      pos = state.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (code !== 0x20 && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //

    // do not allow nested reference links
    if (state.linkLevel > 0) { return false; }

    // [foo]  [bar]
    //      ^^ optional whitespace (can include newlines)
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = start - 1;
      }
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      if (typeof label === 'undefined') {
        pos = labelEnd + 1;
      }
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    if (isImage) {
      state.push({
        type: 'image',
        src: href,
        title: title,
        alt: state.src.substr(labelStart, labelEnd - labelStart),
        level: state.level
      });
    } else {
      state.push({
        type: 'link_open',
        href: href,
        title: title,
        level: state.level++
      });
      state.linkLevel++;
      state.parser.tokenize(state);
      state.linkLevel--;
      state.push({ type: 'link_close', level: --state.level });
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
}

// Process inline footnotes (^[...])


function footnote_inline(state, silent) {
  var labelStart,
      labelEnd,
      footnoteId,
      oldLength,
      max = state.posMax,
      start = state.pos;

  if (start + 2 >= max) { return false; }
  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 2;
  labelEnd = parseLinkLabel(state, start + 1);

  // parser failed to find ']', so it's not a valid note
  if (labelEnd < 0) { return false; }

  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    if (!state.env.footnotes) { state.env.footnotes = {}; }
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }
    footnoteId = state.env.footnotes.list.length;

    state.pos = labelStart;
    state.posMax = labelEnd;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      level: state.level
    });
    state.linkLevel++;
    oldLength = state.tokens.length;
    state.parser.tokenize(state);
    state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };
    state.linkLevel--;
  }

  state.pos = labelEnd + 1;
  state.posMax = max;
  return true;
}

// Process footnote references ([^...])

function footnote_ref(state, silent) {
  var label,
      pos,
      footnoteId,
      footnoteSubId,
      max = state.posMax,
      start = state.pos;

  // should be at least 4 chars - "[^x]"
  if (start + 3 > max) { return false; }

  if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }
  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x0A) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos >= max) { return false; }
  pos++;

  label = state.src.slice(start + 2, pos - 1);
  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }

  if (!silent) {
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }

    if (state.env.footnotes.refs[':' + label] < 0) {
      footnoteId = state.env.footnotes.list.length;
      state.env.footnotes.list[footnoteId] = { label: label, count: 0 };
      state.env.footnotes.refs[':' + label] = footnoteId;
    } else {
      footnoteId = state.env.footnotes.refs[':' + label];
    }

    footnoteSubId = state.env.footnotes.list[footnoteId].count;
    state.env.footnotes.list[footnoteId].count++;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      subId: footnoteSubId,
      level: state.level
    });
  }

  state.pos = pos;
  state.posMax = max;
  return true;
}

// List of valid url schemas, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#autolinks

var url_schemas = [
  'coap',
  'doi',
  'javascript',
  'aaa',
  'aaas',
  'about',
  'acap',
  'cap',
  'cid',
  'crid',
  'data',
  'dav',
  'dict',
  'dns',
  'file',
  'ftp',
  'geo',
  'go',
  'gopher',
  'h323',
  'http',
  'https',
  'iax',
  'icap',
  'im',
  'imap',
  'info',
  'ipp',
  'iris',
  'iris.beep',
  'iris.xpc',
  'iris.xpcs',
  'iris.lwz',
  'ldap',
  'mailto',
  'mid',
  'msrp',
  'msrps',
  'mtqp',
  'mupdate',
  'news',
  'nfs',
  'ni',
  'nih',
  'nntp',
  'opaquelocktoken',
  'pop',
  'pres',
  'rtsp',
  'service',
  'session',
  'shttp',
  'sieve',
  'sip',
  'sips',
  'sms',
  'snmp',
  'soap.beep',
  'soap.beeps',
  'tag',
  'tel',
  'telnet',
  'tftp',
  'thismessage',
  'tn3270',
  'tip',
  'tv',
  'urn',
  'vemmi',
  'ws',
  'wss',
  'xcon',
  'xcon-userid',
  'xmlrpc.beep',
  'xmlrpc.beeps',
  'xmpp',
  'z39.50r',
  'z39.50s',
  'adiumxtra',
  'afp',
  'afs',
  'aim',
  'apt',
  'attachment',
  'aw',
  'beshare',
  'bitcoin',
  'bolo',
  'callto',
  'chrome',
  'chrome-extension',
  'com-eventbrite-attendee',
  'content',
  'cvs',
  'dlna-playsingle',
  'dlna-playcontainer',
  'dtn',
  'dvb',
  'ed2k',
  'facetime',
  'feed',
  'finger',
  'fish',
  'gg',
  'git',
  'gizmoproject',
  'gtalk',
  'hcp',
  'icon',
  'ipn',
  'irc',
  'irc6',
  'ircs',
  'itms',
  'jar',
  'jms',
  'keyparc',
  'lastfm',
  'ldaps',
  'magnet',
  'maps',
  'market',
  'message',
  'mms',
  'ms-help',
  'msnim',
  'mumble',
  'mvn',
  'notes',
  'oid',
  'palm',
  'paparazzi',
  'platform',
  'proxy',
  'psyc',
  'query',
  'res',
  'resource',
  'rmi',
  'rsync',
  'rtmp',
  'secondlife',
  'sftp',
  'sgn',
  'skype',
  'smb',
  'soldat',
  'spotify',
  'ssh',
  'steam',
  'svn',
  'teamspeak',
  'things',
  'udp',
  'unreal',
  'ut2004',
  'ventrilo',
  'view-source',
  'webcal',
  'wtai',
  'wyciwyg',
  'xfire',
  'xri',
  'ymsgr'
];

// Process autolinks '<protocol:...>'


/*eslint max-len:0*/
var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;


function autolink(state, silent) {
  var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) { return false; }

  linkMatch = tail.match(AUTOLINK_RE);

  if (linkMatch) {
    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }

    url = linkMatch[0].slice(1, -1);
    fullUrl = normalizeLink(url);
    if (!state.parser.validateLink(url)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  emailMatch = tail.match(EMAIL_RE);

  if (emailMatch) {

    url = emailMatch[0].slice(1, -1);

    fullUrl = normalizeLink('mailto:' + url);
    if (!state.parser.validateLink(fullUrl)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
}

// Regexps to match html elements

function replace$1(regex, options) {
  regex = regex.source;
  options = options || '';

  return function self(name, val) {
    if (!name) {
      return new RegExp(regex, options);
    }
    val = val.source || val;
    regex = regex.replace(name, val);
    return self;
  };
}


var attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;

var unquoted      = /[^"'=<>`\x00-\x20]+/;
var single_quoted = /'[^']*'/;
var double_quoted = /"[^"]*"/;

/*eslint no-spaced-func:0*/
var attr_value  = replace$1(/(?:unquoted|single_quoted|double_quoted)/)
                    ('unquoted', unquoted)
                    ('single_quoted', single_quoted)
                    ('double_quoted', double_quoted)
                    ();

var attribute   = replace$1(/(?:\s+attr_name(?:\s*=\s*attr_value)?)/)
                    ('attr_name', attr_name)
                    ('attr_value', attr_value)
                    ();

var open_tag    = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\s*\/?>/)
                    ('attribute', attribute)
                    ();

var close_tag   = /<\/[A-Za-z][A-Za-z0-9]*\s*>/;
var comment     = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
var processing  = /<[?].*?[?]>/;
var declaration = /<![A-Z]+\s+[^>]*>/;
var cdata       = /<!\[CDATA\[[\s\S]*?\]\]>/;

var HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)
  ('open_tag', open_tag)
  ('close_tag', close_tag)
  ('comment', comment)
  ('processing', processing)
  ('declaration', declaration)
  ('cdata', cdata)
  ();

// Process html tags


function isLetter$2(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


function htmltag(state, silent) {
  var ch, match, max, pos = state.pos;

  if (!state.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter$2(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    state.push({
      type: 'htmltag',
      content: state.src.slice(pos, pos + match[0].length),
      level: state.level
    });
  }
  state.pos += match[0].length;
  return true;
}

// Process html entity - &#123;, &#xAF;, &quot;, ...


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        var decoded = decodeEntity(match[1]);
        if (match[1] !== decoded) {
          if (!silent) { state.pending += decoded; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
}

/**
 * Inline Parser `rules`
 */

var _rules$2 = [
  [ 'text',            text ],
  [ 'newline',         newline ],
  [ 'escape',          escape ],
  [ 'backticks',       backticks ],
  [ 'del',             del ],
  [ 'ins',             ins ],
  [ 'mark',            mark ],
  [ 'emphasis',        emphasis ],
  [ 'sub',             sub ],
  [ 'sup',             sup ],
  [ 'links',           links ],
  [ 'footnote_inline', footnote_inline ],
  [ 'footnote_ref',    footnote_ref ],
  [ 'autolink',        autolink ],
  [ 'htmltag',         htmltag ],
  [ 'entity',          entity ]
];

/**
 * Inline Parser class. Note that link validation is stricter
 * in Remarkable than what is specified by CommonMark. If you
 * want to change this you can use a custom validator.
 *
 * @api private
 */

function ParserInline() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }

  // Can be overridden with a custom validator
  this.validateLink = validateLink;
}

/**
 * Skip a single token by running all rules in validation mode.
 * Returns `true` if any rule reports success.
 *
 * @param  {Object} `state`
 * @api privage
 */

ParserInline.prototype.skipToken = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var pos = state.pos;
  var i, cached_pos;

  if ((cached_pos = state.cacheGet(pos)) > 0) {
    state.pos = cached_pos;
    return;
  }

  for (i = 0; i < len; i++) {
    if (rules[i](state, true)) {
      state.cacheSet(pos, state.pos);
      return;
    }
  }

  state.pos++;
  state.cacheSet(pos, state.pos);
};

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state`
 * @api private
 */

ParserInline.prototype.tokenize = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var end = state.posMax;
  var ok, i;

  while (state.pos < end) {

    // Try all possible rules.
    // On success, the rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true
    for (i = 0; i < len; i++) {
      ok = rules[i](state, false);

      if (ok) {
        break;
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * Parse the given input string.
 *
 * @param  {String} `str`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserInline.prototype.parse = function (str, options, env, outTokens) {
  var state = new StateInline(str, this, options, env, outTokens);
  this.tokenize(state);
};

/**
 * Validate the given `url` by checking for bad protocols.
 *
 * @param  {String} `url`
 * @return {Boolean}
 */

function validateLink(url) {
  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];
  var str = url.trim().toLowerCase();
  // Care about digital entities "javascript&#x3A;alert(1)"
  str = replaceEntities(str);
  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {
    return false;
  }
  return true;
}

// Remarkable default options

var defaultConfig = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: '',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'replacements',
        'smartquotes',
        'references',
        'abbr2',
        'footnote_tail'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'footnote',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph',
        'table'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'del',
        'emphasis',
        'entity',
        'escape',
        'footnote_ref',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};

// Remarkable default options

var fullConfig = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes:       '',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight:     null,

    maxNesting:    20            // Internal protection, recursion limit
  },

  components: {
    // Don't restrict core/block/inline rules
    core: {},
    block: {},
    inline: {}
  }
};

// Commonmark default options

var commonmarkConfig = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: '',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'abbr2'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};

/**
 * Preset configs
 */

var config = {
  'default': defaultConfig,
  'full': fullConfig,
  'commonmark': commonmarkConfig
};

/**
 * The `StateCore` class manages state.
 *
 * @param {Object} `instance` Remarkable instance
 * @param {String} `str` Markdown string
 * @param {Object} `env`
 */

function StateCore(instance, str, env) {
  this.src = str;
  this.env = env;
  this.options = instance.options;
  this.tokens = [];
  this.inlineMode = false;

  this.inline = instance.inline;
  this.block = instance.block;
  this.renderer = instance.renderer;
  this.typographer = instance.typographer;
}

/**
 * The main `Remarkable` class. Create an instance of
 * `Remarkable` with a `preset` and/or `options`.
 *
 * @param {String} `preset` If no preset is given, `default` is used.
 * @param {Object} `options`
 */

function Remarkable(preset, options) {
  if (typeof preset !== 'string') {
    options = preset;
    preset = 'default';
  }

  if (options && options.linkify != null) {
    console.warn(
      'linkify option is removed. Use linkify plugin instead:\n\n' +
      'import Remarkable from \'remarkable\';\n' +
      'import linkify from \'remarkable/linkify\';\n' +
      'new Remarkable().use(linkify)\n'
    );
  }

  this.inline   = new ParserInline();
  this.block    = new ParserBlock();
  this.core     = new Core();
  this.renderer = new Renderer();
  this.ruler    = new Ruler();

  this.options  = {};
  this.configure(config[preset]);
  this.set(options || {});
}

/**
 * Set options as an alternative to passing them
 * to the constructor.
 *
 * ```js
 * md.set({typographer: true});
 * ```
 * @param {Object} `options`
 * @api public
 */

Remarkable.prototype.set = function (options) {
  assign(this.options, options);
};

/**
 * Batch loader for components rules states, and options
 *
 * @param  {Object} `presets`
 */

Remarkable.prototype.configure = function (presets) {
  var self = this;

  if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }
  if (presets.options) { self.set(presets.options); }
  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enable(presets.components[name].rules, true);
      }
    });
  }
};

/**
 * Use a plugin.
 *
 * ```js
 * var md = new Remarkable();
 *
 * md.use(plugin1)
 *   .use(plugin2, opts)
 *   .use(plugin3);
 * ```
 *
 * @param  {Function} `plugin`
 * @param  {Object} `options`
 * @return {Object} `Remarkable` for chaining
 */

Remarkable.prototype.use = function (plugin, options) {
  plugin(this, options);
  return this;
};


/**
 * Parse the input `string` and return a tokens array.
 * Modifies `env` with definitions data.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parse = function (str, env) {
  var state = new StateCore(this, str, env);
  this.core.process(state);
  return state.tokens;
};

/**
 * The main `.render()` method that does all the magic :)
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {String} Rendered HTML.
 */

Remarkable.prototype.render = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parse(str, env), this.options, env);
};

/**
 * Parse the given content `string` as a single string.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parseInline = function (str, env) {
  var state = new StateCore(this, str, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};

/**
 * Render a single content `string`, without wrapping it
 * to paragraphs
 *
 * @param  {String} `str`
 * @param  {Object} `env`
 * @return {String}
 */

Remarkable.prototype.renderInline = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(str, env), this.options, env);
};

const zeaMarkdownViewerCss = ":host{display:block;color:var(--color-foreground-1)}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}a{color:var(--color-primary-1)}";

const ZeaMarkdownViewer = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  /**
   * Convert the MD markup to html
   * @return {string} the generated html
   */
  convertMdToHtml() {
    const mdConverter = new Remarkable();
    return mdConverter.render(this.mdText);
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    const convertedText = this.convertMdToHtml();
    return h$4("div", { innerHTML: convertedText });
  }
  static get style() { return zeaMarkdownViewerCss; }
};

const zeaMenuCss = "*{cursor:default;user-select:none}:host{display:inline-block;vertical-align:middle}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-menu{color:var(--color-foreground-1);flex-direction:column}.zea-menu .items{display:none}.menu-anchor{color:var(--color-foreground-1)}.zea-menu.shown{color:var(--color-foreground-1);display:flex;flex-direction:column}.zea-menu.shown .items{display:inline-flex;flex-direction:column}.dropdown slot{display:flex}.zea-menu.contextual{position:relative}.contextual.menu-wrap{display:inline-block;position:relative;vertical-align:middle}.contextual .items{position:absolute;z-index:1000}.contextual.show-anchor .items{margin-top:25px}.contextual.top-right .items{transform:translateX(-100%);margin-left:100%}.toolbar.horizontal .items{flex-direction:row}.toolbar{background-color:var(--color-background-2);position:fixed;border-radius:30px}.dropdown .items,.contextual .items{background-color:var(--color-background-2)}";

const ZeaMenu = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.offset = [0, 0];
    this.leftOffset = '';
    this.topOffset = '';
    this.type = 'dropdown';
    // for the toolbar type
    this.orientation = 'vertical';
    this.shown = false;
    this.showAnchor = false;
    this.anchorIcon = 'ellipsis-vertical-circle-outline';
    this.contextualAlign = 'top-left';
    this.anchorIconSize = 14;
  }
  /**
   * Listen to click (mouse up) events on the whole window
   * @param {any} ev the event
   */
  handleClick(ev) {
    if (ev.currentTarget == this.anchorElement) {
      this.shown = !this.shown;
      return;
    }
    else if (this.type == 'contextual' &&
      !this.isDescendant(this.hostElement, ev.target)) {
      this.shown = false;
    }
    this.mouseIsDown = false;
  }
  /**
   * isDescendant
   * @param {any} parent the parent
   * @param {any} child the parent
   * @return {any} whether or not is parent
   */
  isDescendant(parent, child) {
    let node = child.parentNode;
    while (node != null) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }
  /**
   * Listen to zeaMenuItemClick events on the whole window
   * @param {any} ev The zeaMenuItemClick event
   */
  handleItemClick(ev) {
    if (this.type == 'contextual' && !ev.detail.hasSubitems) {
      this.shown = false;
    }
  }
  /**
   * Listen to mousedown event
   * @param {any} event the event
   */
  mousedownHandler(event) {
    if (this.type == 'toolbar' && event.currentTarget.tagName == 'ZEA-MENU') {
      this.mouseIsDown = true;
      this.offset = [
        this.menuElement.offsetLeft - event.clientX,
        this.menuElement.offsetTop - event.clientY,
      ];
    }
  }
  /**
   * Listen to mousemove event
   * @param {any} event the event
   */
  mousemoveHandler(event) {
    if (this.type == 'toolbar' && this.mouseIsDown) {
      this.menuElement.style.left = `${event.clientX + this.offset[0]}px`;
      this.menuElement.style.top = `${event.clientY + this.offset[1]}px`;
    }
  }
  /**
   * Listen to click events on anchor
   * @param {any} ev the event
   */
  handleAnchorClick(ev) {
    this.handleClick(ev);
    ev.stopPropagation();
  }
  /**
   * Called once when component first loads
   */
  componentDidLoad() {
    // the menu is hidden by default to avoid flashing
    if (this.type != 'contextual') {
      this.shown = true;
    }
  }
  /**
   * Called everytime the component renders
   * Apply the class to children
   */
  componentDidRender() {
    this.setupChildren();
    this.adjustPosition();
  }
  /**
   * Run some setup for the children items
   */
  setupChildren() {
    this.itemsContainer
      .querySelector('slot')
      .assignedNodes()
      .forEach((element) => {
      if ('type' in element) {
        element.type = this.type;
      }
      if ('itemParent' in element) {
        element.itemParent = this.hostElement;
      }
      if ('rootMenu' in element) {
        element.rootMenu = this.hostElement;
      }
    });
  }
  /**
   */
  adjustPosition() {
    if (this.type == 'contextual') {
      this.adjustContextualPosition();
    }
  }
  /**
   */
  adjustContextualPosition() {
    if (this.shown) {
      const winHeight = window.innerHeight;
      const winWidth = window.innerWidth;
      this.itemsContainer.style.transform = `translate(0, 0)`;
      const itemsBox = this.itemsContainer.getBoundingClientRect();
      const menuBox = this.menuElement.getBoundingClientRect();
      let trX = '0';
      let trY = '0';
      if (menuBox.left + itemsBox.width > winWidth) {
        trX = '-100%';
      }
      if (menuBox.top + itemsBox.height > winHeight) {
        trY = '-100%';
      }
      this.itemsContainer.style.transform = `translate(${trX}, ${trY})`;
    }
  }
  /**
   * Render function
   * @return {JSX}
   */
  render() {
    const anchor = this.type == 'contextual' && this.showAnchor ? (h$4("div", { onMouseUp: this.handleAnchorClick.bind(this), class: "menu-anchor", ref: (el) => (this.anchorElement = el) }, h$4("zea-icon", { size: this.anchorIconSize, name: this.anchorIcon }))) : null;
    const menuClass = {};
    menuClass['zea-menu'] = true;
    menuClass[this.type] = true;
    menuClass[this.orientation] = true;
    menuClass['shown'] = this.shown;
    menuClass[this.contextualAlign] = true;
    menuClass['show-anchor'] = this.showAnchor;
    const containerStyle = {
      top: this.topOffset,
      left: this.leftOffset,
    };
    return (h$4("div", { class: menuClass, ref: (el) => (this.menuElement = el) }, anchor, h$4("div", { ref: (el) => (this.itemsContainer = el), class: "items", style: containerStyle }, h$4("slot", null))));
  }
  get hostElement() { return this; }
  static get style() { return zeaMenuCss; }
};

const zeaMenuColorCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-menu-color{--zea-menu-color-color:var(--theme-color);color:var(--zea-menu-color-color)}.zea-menu-color{width:24px;height:24px;border-radius:12px;display:block;margin:0}:host-context(.colorDropdown) .zea-menu-color{width:16px;height:16px;margin:4px}:host(.active) .zea-menu-color{width:24px;height:24px;margin:0px}";

const ZeaMenuColor = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * The color assigned to this item
     */
    this.bgColor = '';
    /**
     * The color of the foreground (icon) for the tool
     */
    this.fgColor = '';
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4("div", { class: "zea-menu-color", style: { backgroundColor: this.bgColor } }));
  }
  static get style() { return zeaMenuColorCss; }
};

const zeaMenuColorpickerCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.currentColor{margin:10px;width:24px;height:24px}.colorDropdown{display:none}.colorDropdown.shown{display:grid;grid-gap:10px;padding:10px;grid-template-columns:1fr 1fr 1fr;position:absolute;margin-top:-42px;margin-left:49px;border-radius:15px;background-color:var(--color-background-2)}.user-color{font-size:11px;grid-column-start:1;grid-column-end:4;display:flex;justify-content:center;border-radius:8px;width:100%;box-sizing:border-box;align-items:center}.user-color zea-menu-color{margin-left:5px}";

const ZeaMenuColorpicker = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.colorElements = [];
    this.shown = false;
    this.userColor = null;
  }
  /**
   * Handler for click events on the whole window
   * @param {any} e the event
   */
  handleDropDownColorClick(e) {
    if (e.target == this.currentColor)
      return;
    if (e.target.tagName == 'ZEA-MENU-COLOR') {
      if (this.currentColorSample) {
        this.currentColorSample.classList.remove('active');
      }
      this.currentColorSample = e.target;
      this.currentColorSample.classList.add('active');
      if (this.currentColor)
        this.currentColor.remove();
      this.currentColor = this.currentColorSample.cloneNode(true);
      this.currentColorContainer.appendChild(this.currentColor);
      this.setActiveColors(this.currentColor.bgColor, this.currentColor.fgColor);
      this.shown = false;
      if ('callback' in this.currentColor)
        this.runCallback(this.currentColor);
    }
  }
  /**
   * Set the active colors through css variables
   */
  setActiveColors(bgColor, fgColor) {
    document.documentElement.style.setProperty('--toolbar-active-bg-color', bgColor);
    document.documentElement.style.setProperty('--toolbar-active-fg-color', fgColor);
  }
  /**
   * Handle click on currently selected color
   */
  handleCurrentColorClick() {
    this.shown = !this.shown;
  }
  /**
   * Called everytime the component renders to run some setup on child elements
   */
  componentDidRender() {
    this.setupChildren();
  }
  /**
   * Run some setup for the children items
   */
  setupChildren() {
    this.dropDownContainer
      .querySelector('slot')
      .assignedElements()
      .forEach((element) => {
      if (element.tagName == 'ZEA-MENU-COLOR') {
        this.colorElements.push(element);
        element.addEventListener('click', this.handleDropDownColorClick.bind(this));
      }
    });
    if (!this.currentColor) {
      if (this.userColorElement) {
        this.currentColor = this.userColorElement;
      }
      else {
        this.currentColor = this.colorElements[0];
      }
      this.setActiveColors(this.currentColor.bgColor, this.currentColor.fgColor);
    }
    this.currentColorContainer.appendChild(this.currentColor);
  }
  /**
   * Run the item's callback
   * @param {any} element The element whose callback to call
   */
  runCallback(element) {
    if (element.callback) {
      if (typeof element.callback == 'string') {
        eval(element.callback);
      }
      else {
        element.callback(element);
      }
    }
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4("div", { class: "zea-menu-colorpicker" }, h$4("div", { onClick: this.handleCurrentColorClick.bind(this), class: "currentColor", ref: (el) => (this.currentColorContainer = el) }), h$4("div", { class: `colorDropdown ${this.shown ? 'shown' : ''}`, ref: (el) => (this.dropDownContainer = el) }, h$4("slot", null), this.userColor && (h$4("div", { class: "user-color" }, "My color:", ' ', h$4("zea-menu-color", { ref: (el) => {
        this.userColorElement = el;
      }, "bg-color": this.userColor, "fg-color": "white", onClick: this.handleDropDownColorClick.bind(this) }))))));
  }
  static get style() { return zeaMenuColorpickerCss; }
};

const zeaMenuItemCss = "*{cursor:default;user-select:none}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-menu-item{position:relative}.outer-wrap{display:flex;align-items:center;color:var(--color-foreground-1);position:relative}.toolbar .outer-wrap{background-color:transparent;border-radius:30px;margin:5px}.pressed .outer-wrap{background-color:var(--color-grey-3)}.active .outer-wrap{background-color:var(--color-grey-3)}.standalone:hover .outer-wrap{background-color:var(--color-grey-3)}.zea-menu-item:hover{background-color:var(--color-grey-3)}.zea-menu-item.toolbar:hover{background-color:transparent}.toolbar.pressed .outer-wrap{background-color:var(--color-background-2)}.toolbar.active .outer-wrap{background-color:var(--toolbar-active-bg-color, var(--color-grey-3));color:var(--toolbar-active-fg-color, var(--color-foreground-1))}.inner-wrap{display:flex;align-items:center;font-size:12px;padding:0 10px;min-height:40px;white-space:nowrap;flex-grow:1}zea-switch{margin-left:0.5em;pointer-events:none}zea-checkbox{margin-right:0.5em;pointer-events:none}::slotted(zea-icon){margin-right:5px;font-size:10px;pointer-events:none}.toolbar .inner-wrap{padding:5px;min-height:auto}.toolbar ::slotted(zea-icon){margin-right:0}.hotkey{display:block;opacity:0.75;font-size:0.8em;padding-left:10px;pointer-events:none}.keyboard-key{border:1px solid var(--color-grey-3);padding:2px;border-radius:5px;font-size:0.8em;text-align:center;min-width:10px;display:inline-block;background-color:var(--color-background-1);text-transform:uppercase;margin:0 2px}";

const ZeaMenuItem = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.zeaMenuItemClick = createEvent(this, "zeaMenuItemClick", 7);
    this.zeaMenuItemPressed = createEvent(this, "zeaMenuItemPressed", 7);
    this.switch = false;
    this.active = false;
    this.hasCheckbox = false;
    this.hasRadio = false;
    this.checked = false;
    this.shown = false;
    this.allowHover = false;
    this.hotkey = '';
    this.type = '';
    this.hasSubitems = false;
    this.isPushButton = false;
  }
  /**
   * Listen to the event emitted when any item is clicked
   * @param {any} e the event data
   */
  windowClickHandler(e) {
    if (e.composedPath().includes(this.rootMenu)) {
      this.active = false;
      e.detail.active = true;
      /* if (this.isDescendant(this.subitemsElement, e.detail)) {
      this.active = true
    } */
      if (!e.detail.hasSubitems && this.type != 'toolbar') {
        this.active = false;
      }
    }
  }
  /**
   * Listen to click (mouse up) events on the whole window
   * and make sure the item is deactivated if the click was
   * on an external element
   * @param {any} ev the event
   */
  handleWindowMouseup(ev) {
    if (this.isPushButton ||
      (!this.isDescendant(this.rootMenu, ev.target) && this.type != 'toolbar')) {
      this.active = false;
    }
  }
  /**
   * Listen to touch end events on the whole window
   * and make sure the item is deactivated if the click was
   * on an external element
   * @param {any} ev the event
   */
  handleWindowTouchend(ev) {
    if (this.isPushButton ||
      (!this.isDescendant(this.rootMenu, ev.target) && this.type != 'toolbar')) {
      this.active = false;
    }
  }
  /**
   * Check if an element is child of another
   * @param {any} parent the parent
   * @param {any} child the child
   * @return {any} whether or not is parent
   */
  isDescendant(parent, child) {
    let node = child.parentNode;
    while (node != null) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }
  /**
   * Called everytime the component renders
   */
  componentDidRender() {
    // this.setupChildren()
  }
  /**
   * Called everytime the component renders
   */
  watchHandler() {
    this.setupChildren();
  }
  /**
   * Run some setup for the children items
   */
  setupChildren() {
    this.container
      .querySelector('slot')
      .assignedElements()
      .forEach((element) => {
      if (element.tagName == 'ZEA-MENU-SUBITEMS') {
        this.hasSubitems = true;
        this.subitemsElement = element;
        this.subitemsElement.rootMenu = this.rootMenu;
        this.subitemsElement.parentItem = this.hostElement;
        this.subitemsElement.type = this.hostElement.parentElement['type'];
        this.outerWrap.appendChild(this.subitemsElement);
        this.container.classList.add('has-subitems');
        if (this.hostElement.parentElement.tagName == 'ZEA-MENU') {
          this.subitemsElement.belongsToRoot = true;
        }
      }
    });
  }
  /**
   * Handle click/tap
   * @param {any} e The event
   */
  handleItemClick(e) {
    this.zeaMenuItemClick.emit(this.hostElement);
    /* const zeaSwitch = this.container.querySelector('ZEA-SWITCH')
    if (zeaSwitch && (!e.target || e.target.tagName != 'ZEA-SWITCH'))
      zeaSwitch.checked = !zeaSwitch.checked */
    /* if (
      this.checkboxElement &&
      (!e.target || e.target.tagName != 'ZEA-CHECKBOX')
    )
      this.checked = !this.checked */
    this.active = true;
    this.runCallback(e);
  }
  /**
   * Handle Mouse down
   * @param {any} e The event
   */
  handleItemMouseDown() {
    this.container.classList.add('pressed');
    this.zeaMenuItemPressed.emit(this.hostElement);
    this.checked = !this.checked;
    if (this.isPushButton) {
      this.active = true;
    }
  }
  /**
   * Handle mouse up
   * @param {any} e The event
   */
  handleItemMouseUp(e) {
    this.container.classList.remove('pressed');
    this.handleItemClick(e);
    if (!this.hasSubitems && this.type != 'toolbar') {
      this.active = false;
    }
  }
  /**
   * Run the item's callback
   * @param {any} payLoad The data to pass to the callback
   */
  runCallback(payLoad) {
    if (this.callback) {
      if (typeof this.callback == 'string') {
        eval(this.callback);
      }
      else {
        this.callback(payLoad);
      }
    }
  }
  /**
   * Listen for keyboard shortcuts
   * @param {any} e the event
   */
  keydownHandler(e) {
    if (e.target instanceof HTMLInputElement)
      return;
    const keys = [];
    if (e.shiftKey)
      keys.push('shift');
    if (e.altKey)
      keys.push('alt');
    if (e.metaKey)
      keys.push('ctrl');
    if (e.ctrlKey)
      keys.push('ctrl');
    if (e.key != 'Alt' &&
      e.key != 'Control' &&
      e.key != 'Ctrl' &&
      e.key != 'Shift') {
      keys.push(e.key);
    }
    const comboString = keys.join('+').toLowerCase();
    if (comboString == this.hotkey.toLowerCase()) {
      this.handleItemClick(new MouseEvent('click'));
    }
    e.preventDefault();
  }
  /**
   * Generate markup for keyboard shortcut
   * @param {any} action the action
   * @return {array} the html elements
   */
  keyComboAsHtml() {
    const hotkeyParts = this.hotkey.split('+');
    const elements = [];
    hotkeyParts.forEach((part) => {
      part = part.toLowerCase();
      if (part == 'ctrl') {
        elements.push(h$4("span", { class: "keyboard-key" }, "Ctrl"));
        elements.push('+');
      }
      else if (part == 'alt') {
        elements.push(h$4("span", { class: "keyboard-key" }, "Alt"));
        elements.push('+');
      }
      else if (part == 'shift') {
        elements.push(h$4("span", { class: "keyboard-key" }, "Shift"));
        elements.push('+');
      }
      else {
        elements.push(h$4("span", { class: "keyboard-key" }, part));
      }
    });
    return elements;
  }
  /**
   * Render function
   * @return {JSX}
   */
  render() {
    return (h$4("div", { ref: (el) => (this.container = el), class: `zea-menu-item ${this.type} ${this.active ? 'active' : ''} ${this.allowHover ? 'allow-hover' : ''}` }, h$4("div", { class: "outer-wrap", ref: (el) => (this.outerWrap = el) }, h$4("div", { class: "inner-wrap", onMouseDown: this.handleItemMouseDown.bind(this), onMouseUp: this.handleItemMouseUp.bind(this), onTouchStart: this.handleItemMouseDown.bind(this), onTouchEnd: this.handleItemMouseUp.bind(this) }, this.hasCheckbox ? (h$4("zea-checkbox", { isRadio: this.hasRadio, checked: this.checked, ref: (el) => (this.checkboxElement = el) })) : null, h$4("slot", null), this.switch ? (h$4("zea-switch", { checked: this.checked })) : null, this.hotkey ? (h$4("span", { class: "hotkey" }, this.keyComboAsHtml())) : null))));
  }
  get hostElement() { return this; }
  static get watchers() { return {
    "rootMenu": ["watchHandler"]
  }; }
  static get style() { return zeaMenuItemCss; }
};

const zeaMenuSeparatorCss = ".ruler{overflow:hidden;margin:0;height:1px;background-color:var(--color-grey-3)}.zea-menu-separator{}.zea-menu-separator.vertical{height:24px;width:21px}.vertical .ruler{width:1px;margin:0 10px;height:100%}.dropdown .ruler{height:100%;width:1px}";

const ZeaMenuSeparator = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     */
    this.class = '';
    /**
     */
    this.orientation = 'horizontal';
  }
  /**
   * Render function
   * @return {JSX}
   */
  render() {
    return (h$4("div", { class: `zea-menu-separator ${this.class} ${this.orientation}` }, h$4("div", { class: "ruler" })));
  }
  static get style() { return zeaMenuSeparatorCss; }
};

const zeaMenuSubitemsCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.fgpath{fill:var(--color-foreground-1)}.arrow{display:flex}.subitems{display:none;position:absolute;left:100%;margin-top:-24px;padding-left:1px;background-color:var(--color-background-2)}.shown .subitems{display:block}.dropdown .subitems{left:0;margin-top:13px;padding-top:1px}";

const ZeaMenuSubitems = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.subitemsArray = [];
    /**
     * Whether it is/should be shown
     */
    this.shown = false;
    /**
     * Menu type
     */
    this.type = '';
    /**
     * Whether the children should have checkboxes and behave as a radio button
     */
    this.radioSelect = false;
  }
  /**
   * zeaMenuItemClickHandler
   * @param {any} e the event data
   */
  windowClickHandler(e) {
    const clickedItem = e.detail;
    const itemIsDescendant = this.isDescendant(this.hostElement, clickedItem);
    if (clickedItem == this.parentItem) {
      this.shown = !this.shown;
    }
    else {
      if (!itemIsDescendant || !clickedItem.hasSubitems) {
        this.shown = false;
      }
    }
  }
  /**
   * zeaMenuItemClickHandler
   * @param {any} e the event data
   */
  windowItemPressHandler(e) {
    const clickedItem = e.detail;
    const itemIsDescendant = this.isDescendant(this.hostElement, clickedItem);
    if (this.radioSelect && itemIsDescendant) {
      this.subitemsArray.forEach((element) => {
        element.checked = false;
      });
    }
  }
  /**
   * Listen to click (mouse up) events on the whole window
   * @param {any} ev the event
   */
  handleWindowMouseup(ev) {
    if (!this.isDescendant(this.rootMenu, ev.target)) {
      this.shown = false;
    }
  }
  /**
   * isDescendant
   * @param {any} parent the parent
   * @param {any} child the parent
   * @return {any} whether or not is parent
   */
  isDescendant(parent, child) {
    let node = child.parentNode;
    while (node != null) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }
  /**
   * Called everytime the component renders
   * Apply the class to children
   */
  componentDidRender() {
    // this.setupChildren()
  }
  /**
   * Called everytime the component renders
   */
  watchHandler() {
    this.setupChildren();
  }
  /**
   * Run some setup for the children items
   */
  setupChildren() {
    this.subitemsElement
      .querySelector('slot')
      .assignedElements()
      .forEach((element) => {
      if ('itemParent' in element) {
        element.itemParent = this.hostElement;
      }
      if ('rootMenu' in element) {
        element.rootMenu = this.rootMenu;
      }
      if (this.radioSelect) {
        element.hasCheckbox = true;
        element.hasRadio = true;
      }
      this.subitemsArray.push(element);
    });
  }
  /**
   * Render function
   * @return {JSX}
   */
  render() {
    return (h$4("div", { class: `zea-menu-subitems ${this.type} ${this.shown ? 'shown' : ''} ` }, h$4("div", { class: "arrow" }, h$4("svg", { class: "branch-arrow-icon", xmlns: "http://www.w3.org/2000/svg", height: "13", viewBox: "0 0 24 24", width: "13" }, h$4("path", { d: "M8 5v14l11-7z", class: "fgpath" }), h$4("path", { d: "M0 0h24v24H0z", fill: "none" }))), h$4("div", { class: "subitems", ref: (el) => (this.subitemsElement = el) }, h$4("slot", null))));
  }
  get hostElement() { return this; }
  static get watchers() { return {
    "rootMenu": ["watchHandler"]
  }; }
  static get style() { return zeaMenuSubitemsCss; }
};

const zeaNavigationDrawerCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-navigation-drawer{color:var(--color-foreground-1);display:inline-block;vertical-align:middle}.drawer{position:fixed;top:0;left:0;transform:translateX(-100%);width:192px;height:100vh;background-color:var(--color-background-1);z-index:10000000;transition:transform 0.3s;transition-timing-function:ease-out}.shown .drawer{left:0;transform:translateX(0);box-shadow:10px 3px 10px var(--color-background-4)}.toggle{position:relative;z-index:10000010;margin-right:12px;margin-left:7px;background-color:transparent;border-radius:50%;padding:4px;display:inline-block}.toggle:hover{background-color:var(--color-grey-3)}.drawer-content{padding-top:80px;padding-left:9px;font-size:14px}@media only screen and (max-width: 667px){.drawer{width:80%}}";

const ZeaNavigationDrawer = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.navDrawerOpen = createEvent(this, "navDrawerOpen", 7);
    this.navDrawerClosed = createEvent(this, "navDrawerClosed", 7);
    /**
     */
    this.shown = false;
  }
  /**
   * Listen to click events on the whole document
   * @param {any} e The event
   */
  handleClick(e) {
    if (!e.composedPath().includes(this.container) ||
      !e.composedPath().includes(this.toggleButton)) {
      this.shown = false;
      this.navDrawerClosed.emit(this);
    }
  }
  /**
   */
  onToggleClick() {
    this.shown = !this.shown;
    if (this.shown) {
      this.navDrawerOpen.emit(this);
    }
    else {
      this.navDrawerClosed.emit(this);
    }
  }
  /**
   */
  render() {
    return (h$4("div", { ref: (el) => (this.container = el), class: { 'zea-navigation-drawer': true, shown: this.shown } }, h$4("div", { class: "drawer" }, h$4("div", { class: "drawer-content" }, h$4("slot", null))), h$4("div", { class: "toggle", ref: (el) => (this.toggleButton = el), onClick: this.onToggleClick.bind(this) }, h$4("zea-icon", { size: 30, name: "menu" }))));
  }
  static get style() { return zeaNavigationDrawerCss; }
};

const zeaPanelProgressBarCss = ".zea-panel-progress-bar{color:var(--color-freground-1);position:absolute;top:0;left:0;right:0;bottom:0;background-color:var(--color-shadow);display:flex;justify-content:center;align-items:center}";

const ZeaPanelProgressBar = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-panel-progress-bar" }, h$4("zea-dialog", { shown: true, allowClose: false, showTitle: false, fullScreenMobile: false, width: '300px' }, h$4("div", { slot: "body" }, h$4("slot", null), h$4("zea-progress-bar", { ref: (el) => (this.progressBar = el), type: "indeterminate" })))));
  }
  static get style() { return zeaPanelProgressBarCss; }
};

/** Class representing a UX factory. */
class UxFactory {
  /**
   * Create a UX factory.
   */
  constructor() {
    this.treeItemFactories = [];
    this.widgetFactories = [];
    this.inspectorFactories = [];
  }

  /**
   * The registerInpector method.
   * @param {any} inspector - The inspector param.
   * @param {any} rule - The rule param.
   */
  registerInpector(inspector, rule) {
    this.inspectorFactories.push({ inspector, rule });
  }

  /**
   * The constructInspector method.
   * @param {...object} ...args - The ...args param
   * @return {any} The return value.
   */
  constructInspector(...args) {
    // Note: Iterate over the factories in reverse order.
    // This allows widgets to override existing widgets in special cases.
    // E.g. display a custom color picker in VR compared to the
    // material editor.
    const baseItem = args[0];
    for (let i = this.inspectorFactories.length; i-- > 0; ) {
      const reg = this.inspectorFactories[i];
      if (reg.rule(baseItem)) {
        return new reg.inspector(...args)
      }
    }

    console.warn(
      `Inspector factory not found for parameter '${baseItem.getName()}' of class '${
        baseItem.constructor.name
      }'`
    );
  }

  /**
   * The registerTreeItemElement method.
   * @param {any} treeItemElement - The treeItemElement param.
   * @param {any} rule - The rule param.
   */
  registerTreeItemElement(treeItemElement, rule) {
    this.treeItemFactories.push({ treeItemElement, rule });
  }

  /**
   * The constructTreeItemElement method.
   * @param {...object} ...args - The ...args param
   * @return {any} The return value.
   */
  constructTreeItemElement(...args) {
    // Note: Iterate over the factories in reverse order.
    // This allows widgets to override existing widgets in special cases.
    // E.g. display a custom color picker in VR compared to the
    // material editor.
    const treeItem = args[0];
    for (let i = this.treeItemFactories.length; i-- > 0; ) {
      const reg = this.treeItemFactories[i];
      if (reg.rule(treeItem)) {
        return new reg.treeItemElement(...args)
      }
    }

    console.warn(
      `Tree item factory not found for parameter '${treeItem.getName()}' of class '${
        treeItem.constructor.name
      }'`
    );
  }

  /**
   * The registerWidget method.
   * @param {any} widget - The treeItemElement param.
   * @param {any} rule - The rule param.
   */
  registerWidget(widget, rule) {
    this.widgetFactories.push({ widget, rule });
  }

  /**
   * The findWidgetReg method.
   * @param {any} param - The param param.
   * @return {any} The return value.
   */
  findWidgetReg(param) {
    for (let i = this.widgetFactories.length; i-- > 0; ) {
      const reg = this.widgetFactories[i];
      if (reg.rule(param)) {
        return reg
      }
    }
  }

  /**
   * The constructWidget method.
   * @param {...object} ...args - The ...args param
   * @return {any} The return value.
   */
  constructWidget(...args) {
    // Note: Iterate over the widgetFactories in reverse order.
    // This allows widgets to override existing widgets in special cases.
    // E.g. display a custom color picker in VR compared to the
    // material editor.
    const param = args[0];
    for (let i = this.widgetFactories.length; i-- > 0; ) {
      const reg = this.widgetFactories[i];
      if (reg.rule(param)) {
        return new reg.widget(...args)
      }
    }

    console.warn(
      `Widget factory not found for parameter '${param.getName()}' of class '${
        param.constructor.name
      }'`
    );
  }
}

const uxFactory = new UxFactory();

const zeaParamWidgetBboxCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-bbox{color:var(--color-foreground-1);background-color:var(--color-background-2);max-width:400px}input{width:100%;box-sizing:border-box;padding:0.3em;font-size:0.9em;border:1px solid var(--color-grey-3);background-color:var(--color-background-3);text-align:right;color:var(--color-foreground-1)}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}.input-wrap{display:flex;align-items:center;margin-bottom:0.5em}.input-wrap label{font-size:0.7em;padding:0.3em 1em 0.3em 0.3em;opacity:0.5;width:1.5em;text-align:center}fieldset{border:1px solid var(--color-grey-3)}legend{color:var(--color-foreground-2);font-size:0.8em}";

const ZeaParamWidgetBBox = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Object that hosts undoRedo instance, parameter class and parameter change class.
     * These last two so we can reconstruct the component dynamically.
     */
    this.appData = {};
    this.onInput = this.onInput.bind(this);
    this.onBlur = this.onBlur.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Called once just after the component fully loaded and the first render() occurs
   */
  componentDidLoad() {
    if (this.parameter) {
      this.handleComponentUpdate();
      this.updateComponent();
    }
  }
  /**
   * Configures the component to react to `valueChanged` events in the parameter.
   */
  handleComponentUpdate() {
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Updates component field values with parameter's.
   */
  updateComponent() {
    if (!this.parameterChange) {
      const bBox = this.parameter.getValue();
      if (bBox.isValid()) {
        this.minXField.value = bBox.p0.x;
        this.minYField.value = bBox.p0.y;
        this.minZField.value = bBox.p0.z;
        this.maxXField.value = bBox.p1.x;
        this.maxYField.value = bBox.p1.y;
        this.maxZField.value = bBox.p1.z;
      }
    }
  }
  /**
   * Handles updates of the input fields
   */
  onInput() {
    // Create parameter instance
    if (!globalThis.zeaEngine) {
      console.log('`zeaEngine` missing from `globalThis` object.');
      return;
    }
    const { Box3 } = globalThis.zeaEngine;
    const value = new Box3();
    value.p0.set(this.minXField.valueAsNumber, this.minYField.valueAsNumber, this.minZField.valueAsNumber);
    value.p1.set(this.maxXField.valueAsNumber, this.maxYField.valueAsNumber, this.maxZField.valueAsNumber);
    this.handleUXChange(value);
  }
  /**
   * Handles the lost of focus of the input field.
   * Used to commit the `ParameterValueChange` object to the `UndoRedoManager`
   */
  onBlur() {
    this.parameterChange = undefined;
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Render method
   *
   * @return {JSX} The generated html
   */
  render() {
    var _a, _b, _c, _d, _e, _f;
    return (h$4("div", { class: "zea-param-widget-bbox" }, h$4("fieldset", null, h$4("legend", null, "Min"), h$4("div", { class: "input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, id: `${((_a = this === null || this === void 0 ? void 0 : this.parameter) === null || _a === void 0 ? void 0 : _a.getName()) || 'Box3Parameter'}_minX`, ref: (el) => (this.minXField = el), type: "number", pattern: "-?[0-9]*(.[0-9]+)?" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, id: `${((_b = this === null || this === void 0 ? void 0 : this.parameter) === null || _b === void 0 ? void 0 : _b.getName()) || 'Box3Parameter'}_minY`, ref: (el) => (this.minYField = el), type: "number", pattern: "-?[0-9]*(.[0-9]+)?" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Z"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, id: `${((_c = this === null || this === void 0 ? void 0 : this.parameter) === null || _c === void 0 ? void 0 : _c.getName()) || 'Box3Parameter'}_minZ`, ref: (el) => (this.minZField = el), type: "number", pattern: "-?[0-9]*(.[0-9]+)?" }))), h$4("fieldset", null, h$4("legend", null, "Max"), h$4("div", { class: "input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, id: `${((_d = this === null || this === void 0 ? void 0 : this.parameter) === null || _d === void 0 ? void 0 : _d.getName()) || 'Box3Parameter'}_maxX`, ref: (el) => (this.maxXField = el), type: "number", pattern: "-?[0-9]*(.[0-9]+)?" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, id: `${((_e = this === null || this === void 0 ? void 0 : this.parameter) === null || _e === void 0 ? void 0 : _e.getName()) || 'Box3Parameter'}_maxY`, ref: (el) => (this.maxYField = el), type: "number", pattern: "-?[0-9]*(.[0-9]+)?" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Z"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, id: `${((_f = this === null || this === void 0 ? void 0 : this.parameter) === null || _f === void 0 ? void 0 : _f.getName()) || 'Box3Parameter'}_maxZ`, ref: (el) => (this.maxZField = el), type: "number", pattern: "-?[0-9]*(.[0-9]+)?" })))));
  }
  static get style() { return zeaParamWidgetBboxCss; }
};
uxFactory.registerWidget('zea-param-widget-bbox', (p) => p.getDataType() === 'Box3');

const zeaParamWidgetBooleanCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-boolean{color:var(--color-foreground-1);background-color:var(--color-background-2)}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}";

const ZeaParamWidgetBoolean = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Whether the checkbox should be checked
     */
    this.checked = false;
    this.onChange = this.onChange.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    if (this.parameter) {
      this.checked = this.parameter.getValue();
      this.parameter.on('valueChanged', () => {
        this.checked = this.parameter.getValue();
      });
    }
  }
  /**
   * Run when input changes
   */
  onChange() {
    if (!globalThis.zeaEngine) {
      console.log('`zeaEngine` missing from `globalThis` object.');
      return;
    }
    this.handleUXChange(this.checkboxInput.checked);
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      this.parameter.setValue(value);
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    const change = new ParameterValueChange(this.parameter, value);
    undoRedoManager.addChange(change);
  }
  /**
   * Render method.
   *
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-param-widget-boolean" }, h$4("input", { onChange: this.onChange, ref: (el) => (this.checkboxInput = el), type: "checkbox", name: this.parameter.getName(), checked: this.checked })));
  }
  static get style() { return zeaParamWidgetBooleanCss; }
};
uxFactory.registerWidget('zea-param-widget-boolean', (p) => p.getDataType() === 'Boolean');

/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

/**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (acequire, exports, module) params
 */

(function() {

var ACE_NAMESPACE = "ace";

var global = (function() { return this; })();
if (!global && typeof window != "undefined") global = window; // strict mode


var define = function(module, deps, payload) {
    if (typeof module !== "string") {
        if (define.original)
            define.original.apply(this, arguments);
        else {
            console.error("dropping module because define wasn\'t a string.");
            console.trace();
        }
        return;
    }
    if (arguments.length == 2)
        payload = deps;
    if (!define.modules[module]) {
        define.payloads[module] = payload;
        define.modules[module] = null;
    }
};

define.modules = {};
define.payloads = {};

/**
 * Get at functionality define()ed using the function above
 */
var _acequire = function(parentId, module, callback) {
    if (typeof module === "string") {
        var payload = lookup(parentId, module);
        if (payload != undefined) {
            callback && callback();
            return payload;
        }
    } else if (Object.prototype.toString.call(module) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined && acequire.original)
                return;
            params.push(dep);
        }
        return callback && callback.apply(null, params) || true;
    }
};

var acequire = function(module, callback) {
    var packagedModule = _acequire("", module, callback);
    if (packagedModule == undefined && acequire.original)
        return acequire.original.apply(this, arguments);
    return packagedModule;
};

var normalizeModule = function(parentId, moduleName) {
    // normalize plugin acequires
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
    }
    // normalize relative acequires
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;

        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }
    return moduleName;
};

/**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */
var lookup = function(parentId, moduleName) {
    moduleName = normalizeModule(parentId, moduleName);

    var module = define.modules[moduleName];
    if (!module) {
        module = define.payloads[moduleName];
        if (typeof module === 'function') {
            var exports = {};
            var mod = {
                id: moduleName,
                uri: '',
                exports: exports,
                packaged: true
            };

            var req = function(module, callback) {
                return _acequire(moduleName, module, callback);
            };

            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
        }
        module = define.modules[moduleName] = exports || module;
    }
    return module;
};

function exportAce(ns) {
    var root = global;
    if (ns) {
        if (!global[ns])
            global[ns] = {};
        root = global[ns];
    }

    if (!root.define || !root.define.packaged) {
        define.original = root.define;
        root.define = define;
        root.define.packaged = true;
    }

    if (!root.acequire || !root.acequire.packaged) {
        acequire.original = root.acequire;
        root.acequire = acequire;
        root.acequire.packaged = true;
    }
}

exportAce(ACE_NAMESPACE);

})();

ace.define("ace/lib/regexp",["require","exports","module"], function(acequire, exports, module) {

    var real = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
        compliantLastIndexIncrement = function () {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
        }();

    if (compliantLastIndexIncrement && compliantExecNpcg)
        return;
    RegExp.prototype.exec = function (str) {
        var match = real.exec.apply(this, arguments),
            name, r2;
        if ( typeof(str) == 'string' && match) {
            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                real.replace.call(str.slice(match.index), r2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined)
                            match[i] = undefined;
                    }
                });
            }
            if (this._xregexp && this._xregexp.captureNames) {
                for (var i = 1; i < match.length; i++) {
                    name = this._xregexp.captureNames[i - 1];
                    if (name)
                       match[name] = match[i];
                }
            }
            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
        }
        return match;
    };
    if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function (str) {
            var match = real.exec.call(this, str);
            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                this.lastIndex--;
            return !!match;
        };
    }

    function getNativeFlags (regex) {
        return (regex.global     ? "g" : "") +
               (regex.ignoreCase ? "i" : "") +
               (regex.multiline  ? "m" : "") +
               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
               (regex.sticky     ? "y" : "");
    }

    function indexOf (array, item, from) {
        if (Array.prototype.indexOf) // Use the native array method if available
            return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
            if (array[i] === item)
                return i;
        }
        return -1;
    }

});

ace.define("ace/lib/es5-shim",["require","exports","module"], function(acequire, exports, module) {

function Empty() {}

if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) { // .length is 1
        var target = this;
        if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
        }
        var args = slice.call(arguments, 1); // for normal call
        var bound = function () {

            if (this instanceof bound) {

                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );

            }

        };
        if(target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
        return bound;
    };
}
var call = Function.prototype.call;
var prototypeOfArray = Array.prototype;
var prototypeOfObject = Object.prototype;
var slice = prototypeOfArray.slice;
var _toString = call.bind(prototypeOfObject.toString);
var owns = call.bind(prototypeOfObject.hasOwnProperty);
var defineGetter;
var defineSetter;
var lookupGetter;
var lookupSetter;
var supportsAccessors;
if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
}
if ([1,2].splice(0).length != 2) {
    if(function() { // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
            var a = new Array(l+2);
            a[0] = a[1] = 0;
            return a;
        }
        var array = [], lengthBefore;
        
        array.splice.apply(array, makeArray(20));
        array.splice.apply(array, makeArray(26));

        lengthBefore = array.length; //46
        array.splice(5, 0, "XXX"); // add one element

        if (lengthBefore + 1 == array.length) {
            return true;// has right splice implementation without bugs
        }
    }()) {//IE 6/7
        var array_splice = Array.prototype.splice;
        Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
                return [];
            } else {
                return array_splice.apply(this, [
                    start === void 0 ? 0 : start,
                    deleteCount === void 0 ? (this.length - start) : deleteCount
                ].concat(slice.call(arguments, 2)))
            }
        };
    } else {//IE8
        Array.prototype.splice = function(pos, removeCount){
            var length = this.length;
            if (pos > 0) {
                if (pos > length)
                    pos = length;
            } else if (pos == void 0) {
                pos = 0;
            } else if (pos < 0) {
                pos = Math.max(length + pos, 0);
            }

            if (!(pos+removeCount < length))
                removeCount = length - pos;

            var removed = this.slice(pos, pos+removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;            
            if (pos === length) {
                if (add) {
                    this.push.apply(this, insert);
                }
            } else {
                var remove = Math.min(removeCount, length - pos);
                var tailOldPos = pos + remove;
                var tailNewPos = tailOldPos + add - remove;
                var tailCount = length - tailOldPos;
                var lengthAfterRemove = length - remove;

                if (tailNewPos < tailOldPos) { // case A
                    for (var i = 0; i < tailCount; ++i) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } else if (tailNewPos > tailOldPos) { // case B
                    for (i = tailCount; i--; ) {
                        this[tailNewPos+i] = this[tailOldPos+i];
                    }
                } // else, add == remove (nothing to do)

                if (add && pos === lengthAfterRemove) {
                    this.length = lengthAfterRemove; // truncate array
                    this.push.apply(this, insert);
                } else {
                    this.length = lengthAfterRemove + add; // reserves space
                    for (i = 0; i < add; ++i) {
                        this[pos+i] = insert[i];
                    }
                }
            }
            return removed;
        };
    }
}
if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
        return _toString(obj) == "[object Array]";
    };
}
var boxedString = Object("a"),
    splitString = boxedString[0] != "a" || !(0 in boxedString);

if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                fun.call(thisp, self[i], i, object);
            }
        }
    };
}
if (!Array.prototype.map) {
    Array.prototype.map = function map(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            result = Array(length),
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self)
                result[i] = fun.call(thisp, self[i], i, object);
        }
        return result;
    };
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                    object,
            length = self.length >>> 0,
            result = [],
            value,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self) {
                value = self[i];
                if (fun.call(thisp, value, i, object)) {
                    result.push(value);
                }
            }
        }
        return result;
    };
}
if (!Array.prototype.every) {
    Array.prototype.every = function every(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
                return false;
            }
        }
        return true;
    };
}
if (!Array.prototype.some) {
    Array.prototype.some = function some(fun /*, thisp */) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0,
            thisp = arguments[1];
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }

        for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
                return true;
            }
        }
        return false;
    };
}
if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
        }

        var i = 0;
        var result;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i++];
                    break;
                }
                if (++i >= length) {
                    throw new TypeError("reduce of empty array with no initial value");
                }
            } while (true);
        }

        for (; i < length; i++) {
            if (i in self) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        }

        return result;
    };
}
if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
        var object = toObject(this),
            self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                object,
            length = self.length >>> 0;
        if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
        }
        if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
        }

        var result, i = length - 1;
        if (arguments.length >= 2) {
            result = arguments[1];
        } else {
            do {
                if (i in self) {
                    result = self[i--];
                    break;
                }
                if (--i < 0) {
                    throw new TypeError("reduceRight of empty array with no initial value");
                }
            } while (true);
        }

        do {
            if (i in this) {
                result = fun.call(void 0, result, self[i], i, object);
            }
        } while (i--);

        return result;
    };
}
if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    };
}
if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
        var self = splitString && _toString(this) == "[object String]" ?
                this.split("") :
                toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }
        var i = length - 1;
        if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
        }
        i = i >= 0 ? i : length - Math.abs(i);
        for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
                return i;
            }
        }
        return -1;
    };
}
if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
        return object.__proto__ || (
            object.constructor ?
            object.constructor.prototype :
            prototypeOfObject
        );
    };
}
if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
                         "non-object: ";
    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
        if (!owns(object, property))
            return;

        var descriptor, getter, setter;
        descriptor =  { enumerable: true, configurable: true };
        if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;

            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;

            if (getter || setter) {
                if (getter) descriptor.get = getter;
                if (setter) descriptor.set = setter;
                return descriptor;
            }
        }
        descriptor.value = object[property];
        return descriptor;
    };
}
if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
        return Object.keys(object);
    };
}
if (!Object.create) {
    var createEmpty;
    if (Object.prototype.__proto__ === null) {
        createEmpty = function () {
            return { "__proto__": null };
        };
    } else {
        createEmpty = function () {
            var empty = {};
            for (var i in empty)
                empty[i] = null;
            empty.constructor =
            empty.hasOwnProperty =
            empty.propertyIsEnumerable =
            empty.isPrototypeOf =
            empty.toLocaleString =
            empty.toString =
            empty.valueOf =
            empty.__proto__ = null;
            return empty;
        };
    }

    Object.create = function create(prototype, properties) {
        var object;
        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
        }
        if (properties !== void 0)
            Object.defineProperties(object, properties);
        return object;
    };
}

function doesDefinePropertyWork(object) {
    try {
        Object.defineProperty(object, "sentinel", {});
        return "sentinel" in object;
    } catch (exception) {
    }
}
if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" ||
        doesDefinePropertyWork(document.createElement("div"));
    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
        var definePropertyFallback = Object.defineProperty;
    }
}

if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
                                      "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
        if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
        if (definePropertyFallback) {
            try {
                return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
            }
        }
        if (owns(descriptor, "value")) {

            if (supportsAccessors && (lookupGetter(object, property) ||
                                      lookupSetter(object, property)))
            {
                var prototype = object.__proto__;
                object.__proto__ = prototypeOfObject;
                delete object[property];
                object[property] = descriptor.value;
                object.__proto__ = prototype;
            } else {
                object[property] = descriptor.value;
            }
        } else {
            if (!supportsAccessors)
                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
                defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
                defineSetter(object, property, descriptor.set);
        }

        return object;
    };
}
if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
        for (var property in properties) {
            if (owns(properties, property))
                Object.defineProperty(object, property, properties[property]);
        }
        return object;
    };
}
if (!Object.seal) {
    Object.seal = function seal(object) {
        return object;
    };
}
if (!Object.freeze) {
    Object.freeze = function freeze(object) {
        return object;
    };
}
try {
    Object.freeze(function () {});
} catch (exception) {
    Object.freeze = (function freeze(freezeObject) {
        return function freeze(object) {
            if (typeof object == "function") {
                return object;
            } else {
                return freezeObject(object);
            }
        };
    })(Object.freeze);
}
if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
        return object;
    };
}
if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
        return false;
    };
}
if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
        return false;
    };
}
if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
        if (Object(object) === object) {
            throw new TypeError(); // TODO message
        }
        var name = '';
        while (owns(object, name)) {
            name += '?';
        }
        object[name] = true;
        var returnValue = owns(object, name);
        delete object[name];
        return returnValue;
    };
}
if (!Object.keys) {
    var hasDontEnumBug = true,
        dontEnums = [
            "toString",
            "toLocaleString",
            "valueOf",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "constructor"
        ],
        dontEnumsLength = dontEnums.length;

    for (var key in {"toString": null}) {
        hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {

        if (
            (typeof object != "object" && typeof object != "function") ||
            object === null
        ) {
            throw new TypeError("Object.keys called on a non-object");
        }

        var keys = [];
        for (var name in object) {
            if (owns(object, name)) {
                keys.push(name);
            }
        }

        if (hasDontEnumBug) {
            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                var dontEnum = dontEnums[i];
                if (owns(object, dontEnum)) {
                    keys.push(dontEnum);
                }
            }
        }
        return keys;
    };

}
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
    "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");
    String.prototype.trim = function trim() {
        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
}

function toInteger(n) {
    n = +n;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}
var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert "+o+" to object");
    }
    return Object(o);
};

});

ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(acequire, exports, module) {

acequire("./regexp");
acequire("./es5-shim");

});

ace.define("ace/lib/dom",["require","exports","module"], function(acequire, exports, module) {

var XHTML_NS = "http://www.w3.org/1999/xhtml";

exports.getDocumentHead = function(doc) {
    if (!doc)
        doc = document;
    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
};

exports.createElement = function(tag, ns) {
    return document.createElementNS ?
           document.createElementNS(ns || XHTML_NS, tag) :
           document.createElement(tag);
};

exports.hasCssClass = function(el, name) {
    var classes = (el.className + "").split(/\s+/g);
    return classes.indexOf(name) !== -1;
};
exports.addCssClass = function(el, name) {
    if (!exports.hasCssClass(el, name)) {
        el.className += " " + name;
    }
};
exports.removeCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g);
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        classes.splice(index, 1);
    }
    el.className = classes.join(" ");
};

exports.toggleCssClass = function(el, name) {
    var classes = el.className.split(/\s+/g), add = true;
    while (true) {
        var index = classes.indexOf(name);
        if (index == -1) {
            break;
        }
        add = false;
        classes.splice(index, 1);
    }
    if (add)
        classes.push(name);

    el.className = classes.join(" ");
    return add;
};
exports.setCssClass = function(node, className, include) {
    if (include) {
        exports.addCssClass(node, className);
    } else {
        exports.removeCssClass(node, className);
    }
};

exports.hasCssString = function(id, doc) {
    var index = 0, sheets;
    doc = doc || document;

    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
        while (index < sheets.length)
            if (sheets[index++].owningElement.id === id) return true;
    } else if ((sheets = doc.getElementsByTagName("style"))) {
        while (index < sheets.length)
            if (sheets[index++].id === id) return true;
    }

    return false;
};

exports.importCssString = function importCssString(cssText, id, doc) {
    doc = doc || document;
    if (id && exports.hasCssString(id, doc))
        return null;
    
    var style;
    
    if (id)
        cssText += "\n/*# sourceURL=ace/css/" + id + " */";
    
    if (doc.createStyleSheet) {
        style = doc.createStyleSheet();
        style.cssText = cssText;
        if (id)
            style.owningElement.id = id;
    } else {
        style = exports.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
            style.id = id;

        exports.getDocumentHead(doc).appendChild(style);
    }
};

exports.importCssStylsheet = function(uri, doc) {
    if (doc.createStyleSheet) {
        doc.createStyleSheet(uri);
    } else {
        var link = exports.createElement('link');
        link.rel = 'stylesheet';
        link.href = uri;

        exports.getDocumentHead(doc).appendChild(link);
    }
};

exports.getInnerWidth = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
        element.clientWidth
    );
};

exports.getInnerHeight = function(element) {
    return (
        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
        element.clientHeight
    );
};

exports.scrollbarWidth = function(document) {
    var inner = exports.createElement("ace_inner");
    inner.style.width = "100%";
    inner.style.minWidth = "0px";
    inner.style.height = "200px";
    inner.style.display = "block";

    var outer = exports.createElement("ace_outer");
    var style = outer.style;

    style.position = "absolute";
    style.left = "-10000px";
    style.overflow = "hidden";
    style.width = "200px";
    style.minWidth = "0px";
    style.height = "150px";
    style.display = "block";

    outer.appendChild(inner);

    var body = document.documentElement;
    body.appendChild(outer);

    var noScrollbar = inner.offsetWidth;

    style.overflow = "scroll";
    var withScrollbar = inner.offsetWidth;

    if (noScrollbar == withScrollbar) {
        withScrollbar = outer.clientWidth;
    }

    body.removeChild(outer);

    return noScrollbar-withScrollbar;
};

if (typeof document == "undefined") {
    exports.importCssString = function() {};
    return;
}

if (window.pageYOffset !== undefined) {
    exports.getPageScrollTop = function() {
        return window.pageYOffset;
    };

    exports.getPageScrollLeft = function() {
        return window.pageXOffset;
    };
}
else {
    exports.getPageScrollTop = function() {
        return document.body.scrollTop;
    };

    exports.getPageScrollLeft = function() {
        return document.body.scrollLeft;
    };
}

if (window.getComputedStyle)
    exports.computedStyle = function(element, style) {
        if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
        return window.getComputedStyle(element, "") || {};
    };
else
    exports.computedStyle = function(element, style) {
        if (style)
            return element.currentStyle[style];
        return element.currentStyle;
    };
exports.setInnerHtml = function(el, innerHtml) {
    var element = el.cloneNode(false);//document.createElement("div");
    element.innerHTML = innerHtml;
    el.parentNode.replaceChild(element, el);
    return element;
};

if ("textContent" in document.documentElement) {
    exports.setInnerText = function(el, innerText) {
        el.textContent = innerText;
    };

    exports.getInnerText = function(el) {
        return el.textContent;
    };
}
else {
    exports.setInnerText = function(el, innerText) {
        el.innerText = innerText;
    };

    exports.getInnerText = function(el) {
        return el.innerText;
    };
}

exports.getParentWindow = function(document) {
    return document.defaultView || document.parentWindow;
};

});

ace.define("ace/lib/oop",["require","exports","module"], function(acequire, exports, module) {

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

ace.define("ace/lib/keys",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop"], function(acequire, exports, module) {

acequire("./fixoldbrowsers");

var oop = acequire("./oop");
var Keys = (function() {
    var ret = {
        MODIFIER_KEYS: {
            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
        },

        KEY_MODS: {
            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
            "super": 8, "meta": 8, "command": 8, "cmd": 8
        },

        FUNCTION_KEYS : {
            8  : "Backspace",
            9  : "Tab",
            13 : "Return",
            19 : "Pause",
            27 : "Esc",
            32 : "Space",
            33 : "PageUp",
            34 : "PageDown",
            35 : "End",
            36 : "Home",
            37 : "Left",
            38 : "Up",
            39 : "Right",
            40 : "Down",
            44 : "Print",
            45 : "Insert",
            46 : "Delete",
            96 : "Numpad0",
            97 : "Numpad1",
            98 : "Numpad2",
            99 : "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
        },

        PRINTABLE_KEYS: {
           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
          219: '[', 220: '\\',221: ']', 222: "'", 111: '/', 106: '*'
        }
    };
    var name, i;
    for (i in ret.FUNCTION_KEYS) {
        name = ret.FUNCTION_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    for (i in ret.PRINTABLE_KEYS) {
        name = ret.PRINTABLE_KEYS[i].toLowerCase();
        ret[name] = parseInt(i, 10);
    }
    oop.mixin(ret, ret.MODIFIER_KEYS);
    oop.mixin(ret, ret.PRINTABLE_KEYS);
    oop.mixin(ret, ret.FUNCTION_KEYS);
    ret.enter = ret["return"];
    ret.escape = ret.esc;
    ret.del = ret["delete"];
    ret[173] = '-';
    
    (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i = Math.pow(2, mods.length); i--;) {            
            ret.KEY_MODS[i] = mods.filter(function(x) {
                return i & ret.KEY_MODS[x];
            }).join("-") + "-";
        }
    })();

    ret.KEY_MODS[0] = "";
    ret.KEY_MODS[-1] = "input-";

    return ret;
})();
oop.mixin(exports, Keys);

exports.keyCodeToString = function(keyCode) {
    var keyString = Keys[keyCode];
    if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
    return keyString.toLowerCase();
};

});

ace.define("ace/lib/useragent",["require","exports","module"], function(acequire, exports, module) {
exports.OS = {
    LINUX: "LINUX",
    MAC: "MAC",
    WINDOWS: "WINDOWS"
};
exports.getOS = function() {
    if (exports.isMac) {
        return exports.OS.MAC;
    } else if (exports.isLinux) {
        return exports.OS.LINUX;
    } else {
        return exports.OS.WINDOWS;
    }
};
if (typeof navigator != "object")
    return;

var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
var ua = navigator.userAgent;
exports.isWin = (os == "win");
exports.isMac = (os == "mac");
exports.isLinux = (os == "linux");
exports.isIE = 
    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
    
exports.isOldIE = exports.isIE && exports.isIE < 9;
exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/)||[])[1], 10) < 4;
exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

exports.isIPad = ua.indexOf("iPad") >= 0;

exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;

if (exports.isIOS) exports.isMac = true;

});

ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {

var keys = acequire("./keys");
var useragent = acequire("./useragent");

var pressedKeys = null;
var ts = 0;

exports.addListener = function(elem, type, callback) {
    if (elem.addEventListener) {
        return elem.addEventListener(type, callback, false);
    }
    if (elem.attachEvent) {
        var wrapper = function() {
            callback.call(elem, window.event);
        };
        callback._wrapper = wrapper;
        elem.attachEvent("on" + type, wrapper);
    }
};

exports.removeListener = function(elem, type, callback) {
    if (elem.removeEventListener) {
        return elem.removeEventListener(type, callback, false);
    }
    if (elem.detachEvent) {
        elem.detachEvent("on" + type, callback._wrapper || callback);
    }
};
exports.stopEvent = function(e) {
    exports.stopPropagation(e);
    exports.preventDefault(e);
    return false;
};

exports.stopPropagation = function(e) {
    if (e.stopPropagation)
        e.stopPropagation();
    else
        e.cancelBubble = true;
};

exports.preventDefault = function(e) {
    if (e.preventDefault)
        e.preventDefault();
    else
        e.returnValue = false;
};
exports.getButton = function(e) {
    if (e.type == "dblclick")
        return 0;
    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
        return 2;
    if (e.preventDefault) {
        return e.button;
    }
    else {
        return {1:0, 2:2, 4:1}[e.button];
    }
};

exports.capture = function(el, eventHandler, releaseCaptureHandler) {
    function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);

        exports.removeListener(document, "mousemove", eventHandler, true);
        exports.removeListener(document, "mouseup", onMouseUp, true);
        exports.removeListener(document, "dragstart", onMouseUp, true);
    }

    exports.addListener(document, "mousemove", eventHandler, true);
    exports.addListener(document, "mouseup", onMouseUp, true);
    exports.addListener(document, "dragstart", onMouseUp, true);
    
    return onMouseUp;
};

exports.addTouchMoveListener = function (el, callback) {
    var startx, starty;
    exports.addListener(el, "touchstart", function (e) {
        var touches = e.touches;
        var touchObj = touches[0];
        startx = touchObj.clientX;
        starty = touchObj.clientY;
    });
    exports.addListener(el, "touchmove", function (e) {
        var touches = e.touches;
        if (touches.length > 1) return;

        var touchObj = touches[0];

        e.wheelX = startx - touchObj.clientX;
        e.wheelY = starty - touchObj.clientY;

        startx = touchObj.clientX;
        starty = touchObj.clientY;

        callback(e);
    });
};

exports.addMouseWheelListener = function(el, callback) {
    if ("onmousewheel" in el) {
        exports.addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
                e.wheelX = -e.wheelDeltaX / factor;
                e.wheelY = -e.wheelDeltaY / factor;
            } else {
                e.wheelX = 0;
                e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
        });
    } else if ("onwheel" in el) {
        exports.addListener(el, "wheel",  function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = e.deltaX * factor || 0;
                    e.wheelY = e.deltaY * factor || 0;
                    break;
                case e.DOM_DELTA_LINE:
                case e.DOM_DELTA_PAGE:
                    e.wheelX = (e.deltaX || 0) * 5;
                    e.wheelY = (e.deltaY || 0) * 5;
                    break;
            }
            
            callback(e);
        });
    } else {
        exports.addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                e.wheelX = (e.detail || 0) * 5;
                e.wheelY = 0;
            } else {
                e.wheelX = 0;
                e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
        });
    }
};

exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
    var clicks = 0;
    var startX, startY, timer; 
    var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
    };

    function onMousedown(e) {
        if (exports.getButton(e) !== 0) {
            clicks = 0;
        } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
                clicks = 1;
        } else {
            clicks = 1;
        }
        if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
                clicks = 1;
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);

            if (clicks == 1) {
                startX = e.clientX;
                startY = e.clientY;
            }
        }
        
        e._clicks = clicks;

        eventHandler[callbackName]("mousedown", e);

        if (clicks > 4)
            clicks = 0;
        else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
    }
    function onDblclick(e) {
        clicks = 2;
        if (timer)
            clearTimeout(timer);
        timer = setTimeout(function() {timer = null;}, timeouts[clicks - 1] || 600);
        eventHandler[callbackName]("mousedown", e);
        eventHandler[callbackName](eventNames[clicks], e);
    }
    if (!Array.isArray(elements))
        elements = [elements];
    elements.forEach(function(el) {
        exports.addListener(el, "mousedown", onMousedown);
        if (useragent.isOldIE)
            exports.addListener(el, "dblclick", onDblclick);
    });
};

var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
    ? function(e) {
        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
    }
    : function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    };

exports.getModifierString = function(e) {
    return keys.KEY_MODS[getModifierHash(e)];
};

function normalizeCommandKeys(callback, e, keyCode) {
    var hashId = getModifierHash(e);

    if (!useragent.isMac && pressedKeys) {
        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
        if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
                pressedKeys.altGr = 0;
            else
                return;
        }
        if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
                if (pressedKeys[keyCode] == 1)
                    ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
                var dt = e.timeStamp - ts;
                if (dt < 50)
                    pressedKeys.altGr = true;
            }
        }
    }
    
    if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
    }
    if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
        keyCode = -1;
    }
    
    if (!hashId && keyCode === 13) {
        var location = "location" in e ? e.location : e.keyLocation;
        if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
                return;
        }
    }
    
    if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
            return;
        else
            hashId &= ~8;
    }
    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
    }
    
    return callback(e, hashId, keyCode);
}


exports.addCommandKeyListener = function(el, callback) {
    var addListener = exports.addListener;
    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
        var lastKeyDownKeyCode = null;
        addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
        });
        addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
        });
    } else {
        var lastDefaultPrevented = null;

        addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        });

        addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        });

        addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
        });

        if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
        }
    }
};
function resetPressedKeys() {
    pressedKeys = Object.create(null);
}

if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
    var postMessageId = 1;
    exports.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId;
        exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
                exports.stopPropagation(e);
                exports.removeListener(win, "message", listener);
                callback();
            }
        });
        win.postMessage(messageName, "*");
    };
}


exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame
    || window.oRequestAnimationFrame);

if (exports.nextFrame)
    exports.nextFrame = exports.nextFrame.bind(window);
else
    exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };
});

ace.define("ace/lib/lang",["require","exports","module"], function(acequire, exports, module) {

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

ace.define("ace/keyboard/textinput_ios",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/lib/keys"], function(acequire, exports, module) {

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
var dom = acequire("../lib/dom");
var lang = acequire("../lib/lang");
var KEYS = acequire("../lib/keys");
var MODS = KEYS.KEY_MODS;
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;

var TextInput = function(parentNode, host) {
    var text = dom.createElement("textarea");
    text.className = useragent.isIOS ? "ace_text-input ace_text-input-ios" : "ace_text-input";

    if (useragent.isTouchPad)
        text.setAttribute("x-palm-disable-auto-cap", true);

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);

    text.style.opacity = "0";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = "\n aaaa a\n";

    var copied = false;
    var cut = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;
    try { var isFocused = document.activeElement === text; } catch(e) {}

    event.addListener(text, "blur", function(e) {
        host.onBlur(e);
        isFocused = false;
    });
    event.addListener(text, "focus", function(e) {
        isFocused = true;
        host.onFocus(e);
        resetSelection();
    });
    this.focus = function() {
        if (tempStyle) return text.focus();
        text.style.position = "fixed";
        text.focus();
    };
    this.blur = function() {
        text.blur();
    };
    this.isFocused = function() {
        return isFocused;
    };
    var syncSelection = lang.delayedCall(function() {
        isFocused && resetSelection(isSelectionEmpty);
    });
    var syncValue = lang.delayedCall(function() {
         if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
         }
    });

    function resetSelection(isEmpty) {
        if (inComposition)
            return;
        inComposition = true;

        if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
        } else {
            var selectionStart = 4;
            var selectionEnd = 5;
        }
        try {
            text.setSelectionRange(selectionStart, selectionEnd);
        } catch(e) {}

        inComposition = false;
    }

    function resetValue() {
        if (inComposition)
            return;
        text.value = PLACEHOLDER;
        if (useragent.isWebKit)
            syncValue.schedule();
    }

    useragent.isWebKit || host.addEventListener('changeSelection', function() {
        if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
        }
    });

    resetValue();
    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };

    var onSelect = function(e) {
        if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
        }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb;};
    this.getInputHandler = function() {return inputHandler;};
    var afterContextMenu = false;

    var sendText = function(data) {
        if (text.selectionStart === 4 && text.selectionEnd === 5) {
          return;
        }
        if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
        }
        if (pasted) {
            resetSelection();
            if (data)
                host.onPaste(data);
            pasted = false;
        } else if (data == PLACEHOLDER.substr(0) && text.selectionStart === 4) {
            if (afterContextMenu)
                host.execCommand("del", {source: "ace"});
            else // some versions of android do not fire keydown when pressing backspace
                host.execCommand("backspace", {source: "ace"});
        } else if (!copied) {
            if (data.substring(0, 9) == PLACEHOLDER && data.length > PLACEHOLDER.length)
                data = data.substr(9);
            else if (data.substr(0, 4) == PLACEHOLDER.substr(0, 4))
                data = data.substr(4, data.length - PLACEHOLDER.length + 1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            if (data == PLACEHOLDER.charAt(0)) ; else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);

            if (data)
                host.onTextInput(data);
        }
        if (copied) {
          copied = false;
        }
        if (afterContextMenu)
            afterContextMenu = false;
    };
    var onInput = function(e) {
        if (inComposition)
            return;
        var data = text.value;
        sendText(data);
        resetValue();
    };

    var handleClipboardData = function(e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
            if (data) {
                return clipboardData.setData(mime, data) !== false;
            } else {
                return clipboardData.getData(mime);
            }
        } catch(e) {
            if (!forceIEMime)
                return handleClipboardData(e, data, true);
        }
    };

    var doCopy = function(e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);

        if (handleClipboardData(e, data)) {
            if (useragent.isIOS) {
                cut = isCut;
                text.value = "\n aa" + data + "a a\n";
                text.setSelectionRange(4, 4 + data.length);
                copied = {
                    value: data
                };
            }
            isCut ? host.onCut() : host.onCopy();
            if (!useragent.isIOS) event.preventDefault(e);
        } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetValue();
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };

    var onCut = function(e) {
        doCopy(e, true);
    };

    var onCopy = function(e) {
        doCopy(e, false);
    };

    var onPaste = function(e) {
        var data = handleClipboardData(e);
        if (typeof data == "string") {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

    event.addListener(text, "select", onSelect);

    event.addListener(text, "input", onInput);

    event.addListener(text, "cut", onCut);
    event.addListener(text, "copy", onCopy);
    event.addListener(text, "paste", onPaste);
    var onCompositionStart = function(e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
        inComposition = {};
        inComposition.canUndo = host.session.$undoManager;
        host.onCompositionStart();
        setTimeout(onCompositionUpdate, 0);
        host.on("mousedown", onCompositionEnd);
        if (inComposition.canUndo && !host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
        }
        host.session.markUndoGroup();
    };

    var onCompositionUpdate = function() {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        var val = text.value.replace(/\x01/g, "");
        if (inComposition.lastValue === val) return;

        host.onCompositionUpdate(val);
        if (inComposition.lastValue)
            host.undo();
        if (inComposition.canUndo)
            inComposition.lastValue = val;
        if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
        }
    };

    var onCompositionEnd = function(e) {
        if (!host.onCompositionEnd || host.$readOnly) return;
        var c = inComposition;
        inComposition = false;
        var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            if (inComposition)
                return;
            else if (str == c.lastValue)
                resetValue();
            else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
            }
        });
        inputHandler = function compositionInputHandler(str) {
            if (timer)
                clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue)
                return "";
            if (c.lastValue && timer)
                host.undo();
            return str;
        };
        host.onCompositionEnd();
        host.removeListener("mousedown", onCompositionEnd);
        if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
        }
        var needsOnInput =
            (!!useragent.isChrome && useragent.isChrome >= 53) ||
            (!!useragent.isWebKit && useragent.isWebKit >= 603);

        if (needsOnInput) {
          onInput();
        }
    };



    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
        event.addListener(text, "text", function(){syncComposition.schedule();});
    } else {
        event.addListener(text, "keyup", function(){syncComposition.schedule();});
        event.addListener(text, "keydown", function(){syncComposition.schedule();});
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    this.getElement = function() {
        return text;
    };

    this.setReadOnly = function(readOnly) {
       text.readOnly = readOnly;
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        resetSelection(host.selection.isEmpty());
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        this.moveToMouse(e, true);
    };

    this.moveToMouse = function(e, bringToFront) {
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + "height:" + text.style.height + ";"
            + (useragent.isIE ? "opacity:0.1;" : "");

        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight -2;
        var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
        };
        move(e);

        if (e.type != "mousedown")
            return;

        if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;

        clearTimeout(closeTimeout);
        if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
            }
        }, 0);
    }

    var onContextMenu = function(e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(text, "mouseup", onContextMenu);
    event.addListener(text, "mousedown", function(e) {
        e.preventDefault();
        onContextMenuClose();
    });
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
    event.addListener(text, "contextmenu", onContextMenu);

    if (useragent.isIOS) {
        var typingResetTimeout = null;
        var typing = false;

        parentNode.addEventListener("keydown", function (e) {
            if (typingResetTimeout) clearTimeout(typingResetTimeout);
            typing = true;
        });

        parentNode.addEventListener("keyup", function (e) {
            typingResetTimeout = setTimeout(function () {
                typing = false;
            }, 100);
        });
        var detectArrowKeys = function(e) {
            if (document.activeElement !== text) return;
            if (typing) return;

            if (cut) {
                return setTimeout(function () {
                    cut = false;
                }, 100);
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            text.setSelectionRange(4, 5);
            if (selectionStart == selectionEnd) {
                switch (selectionStart) {
                    case 0: host.onCommandKey(null, 0, KEYS.up); break;
                    case 1: host.onCommandKey(null, 0, KEYS.home); break;
                    case 2: host.onCommandKey(null, MODS.option, KEYS.left); break;
                    case 4: host.onCommandKey(null, 0, KEYS.left); break;
                    case 5: host.onCommandKey(null, 0, KEYS.right); break;
                    case 7: host.onCommandKey(null, MODS.option, KEYS.right); break;
                    case 8: host.onCommandKey(null, 0, KEYS.end); break;
                    case 9: host.onCommandKey(null, 0, KEYS.down); break;
                }
            } else {
                switch (selectionEnd) {
                    case 6: host.onCommandKey(null, MODS.shift, KEYS.right); break;
                    case 7: host.onCommandKey(null, MODS.shift | MODS.option, KEYS.right); break;
                    case 8: host.onCommandKey(null, MODS.shift, KEYS.end); break;
                    case 9: host.onCommandKey(null, MODS.shift, KEYS.down); break;
                }
                switch (selectionStart) {
                    case 0: host.onCommandKey(null, MODS.shift, KEYS.up); break;
                    case 1: host.onCommandKey(null, MODS.shift, KEYS.home); break;
                    case 2: host.onCommandKey(null, MODS.shift | MODS.option, KEYS.left); break;
                    case 3: host.onCommandKey(null, MODS.shift, KEYS.left); break;
                }
            }
        };
        document.addEventListener("selectionchange", detectArrowKeys);
        host.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
        });
    }
};

exports.TextInput = TextInput;
});

ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/keyboard/textinput_ios"], function(acequire, exports, module) {

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
var dom = acequire("../lib/dom");
var lang = acequire("../lib/lang");
var BROKEN_SETDATA = useragent.isChrome < 18;
var USE_IE_MIME_TYPE =  useragent.isIE;

var TextInputIOS = acequire("./textinput_ios").TextInput;
var TextInput = function(parentNode, host) {
    if (useragent.isIOS)
        return TextInputIOS.call(this, parentNode, host);

    var text = dom.createElement("textarea");
    text.className = "ace_text-input";

    text.setAttribute("wrap", "off");
    text.setAttribute("autocorrect", "off");
    text.setAttribute("autocapitalize", "off");
    text.setAttribute("spellcheck", false);

    text.style.opacity = "0";
    parentNode.insertBefore(text, parentNode.firstChild);

    var PLACEHOLDER = "\u2028\u2028";

    var copied = false;
    var pasted = false;
    var inComposition = false;
    var tempStyle = '';
    var isSelectionEmpty = true;
    try { var isFocused = document.activeElement === text; } catch(e) {}
    
    event.addListener(text, "blur", function(e) {
        host.onBlur(e);
        isFocused = false;
    });
    event.addListener(text, "focus", function(e) {
        isFocused = true;
        host.onFocus(e);
        resetSelection();
    });
    this.focus = function() {
        if (tempStyle) return text.focus();
        var top = text.style.top;
        text.style.position = "fixed";
        text.style.top = "0px";
        text.focus();
        setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
                text.style.top = top;
        }, 0);
    };
    this.blur = function() {
        text.blur();
    };
    this.isFocused = function() {
        return isFocused;
    };
    var syncSelection = lang.delayedCall(function() {
        isFocused && resetSelection(isSelectionEmpty);
    });
    var syncValue = lang.delayedCall(function() {
         if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
         }
    });

    function resetSelection(isEmpty) {
        if (inComposition)
            return;
        inComposition = true;
        
        if (inputHandler) {
            var selectionStart = 0;
            var selectionEnd = isEmpty ? 0 : text.value.length - 1;
        } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
        }
        try {
            text.setSelectionRange(selectionStart, selectionEnd);
        } catch(e){}
        
        inComposition = false;
    }

    function resetValue() {
        if (inComposition)
            return;
        text.value = PLACEHOLDER;
        if (useragent.isWebKit)
            syncValue.schedule();
    }

    useragent.isWebKit || host.addEventListener('changeSelection', function() {
        if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
        }
    });

    resetValue();
    if (isFocused)
        host.onFocus();


    var isAllSelected = function(text) {
        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
    };

    var onSelect = function(e) {
        if (copied) {
            copied = false;
        } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
        } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
        }
    };

    var inputHandler = null;
    this.setInputHandler = function(cb) {inputHandler = cb;};
    this.getInputHandler = function() {return inputHandler;};
    var afterContextMenu = false;
    
    var sendText = function(data) {
        if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
        }
        if (pasted) {
            resetSelection();
            if (data)
                host.onPaste(data);
            pasted = false;
        } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu)
                host.execCommand("del", {source: "ace"});
            else // some versions of android do not fire keydown when pressing backspace
                host.execCommand("backspace", {source: "ace"});
        } else {
            if (data.substring(0, 2) == PLACEHOLDER)
                data = data.substr(2);
            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                data = data.substr(1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                data = data.slice(0, -1);
            
            if (data)
                host.onTextInput(data);
        }
        if (afterContextMenu)
            afterContextMenu = false;
    };
    var onInput = function(e) {
        if (inComposition)
            return;
        var data = text.value;
        sendText(data);
        resetValue();
    };
    
    var handleClipboardData = function(e, data, forceIEMime) {
        var clipboardData = e.clipboardData || window.clipboardData;
        if (!clipboardData || BROKEN_SETDATA)
            return;
        var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
        try {
            if (data) {
                return clipboardData.setData(mime, data) !== false;
            } else {
                return clipboardData.getData(mime);
            }
        } catch(e) {
            if (!forceIEMime)
                return handleClipboardData(e, data, true);
        }
    };

    var doCopy = function(e, isCut) {
        var data = host.getCopyText();
        if (!data)
            return event.preventDefault(e);

        if (handleClipboardData(e, data)) {
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
        } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function(){
                copied = false;
                resetValue();
                resetSelection();
                isCut ? host.onCut() : host.onCopy();
            });
        }
    };
    
    var onCut = function(e) {
        doCopy(e, true);
    };
    
    var onCopy = function(e) {
        doCopy(e, false);
    };
    
    var onPaste = function(e) {
        var data = handleClipboardData(e);
        if (typeof data == "string") {
            if (data)
                host.onPaste(data, e);
            if (useragent.isIE)
                setTimeout(resetSelection);
            event.preventDefault(e);
        }
        else {
            text.value = "";
            pasted = true;
        }
    };

    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

    event.addListener(text, "select", onSelect);

    event.addListener(text, "input", onInput);

    event.addListener(text, "cut", onCut);
    event.addListener(text, "copy", onCopy);
    event.addListener(text, "paste", onPaste);
    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
        event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                return;

            switch (e.keyCode) {
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        });
    }
    var onCompositionStart = function(e) {
        if (inComposition || !host.onCompositionStart || host.$readOnly) 
            return;
        inComposition = {};
        inComposition.canUndo = host.session.$undoManager;
        host.onCompositionStart();
        setTimeout(onCompositionUpdate, 0);
        host.on("mousedown", onCompositionEnd);
        if (inComposition.canUndo && !host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
        }
        host.session.markUndoGroup();
    };

    var onCompositionUpdate = function() {
        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
        var val = text.value.replace(/\u2028/g, "");
        if (inComposition.lastValue === val) return;
        
        host.onCompositionUpdate(val);
        if (inComposition.lastValue)
            host.undo();
        if (inComposition.canUndo)
            inComposition.lastValue = val;
        if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
        }
    };

    var onCompositionEnd = function(e) {
        if (!host.onCompositionEnd || host.$readOnly) return;
        var c = inComposition;
        inComposition = false;
        var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\u2028/g, "");
            if (inComposition)
                return;
            else if (str == c.lastValue)
                resetValue();
            else if (!c.lastValue && str) {
                resetValue();
                sendText(str);
            }
        });
        inputHandler = function compositionInputHandler(str) {
            if (timer)
                clearTimeout(timer);
            str = str.replace(/\u2028/g, "");
            if (str == c.lastValue)
                return "";
            if (c.lastValue && timer)
                host.undo();
            return str;
        };
        host.onCompositionEnd();
        host.removeListener("mousedown", onCompositionEnd);
        if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
        }
        var needsOnInput =
            (!!useragent.isChrome && useragent.isChrome >= 53) ||
            (!!useragent.isWebKit && useragent.isWebKit >= 603);

        if (needsOnInput) {
          onInput();
        }
    };
    
    

    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

    event.addListener(text, "compositionstart", onCompositionStart);
    if (useragent.isGecko) {
        event.addListener(text, "text", function(){syncComposition.schedule();});
    } else {
        event.addListener(text, "keyup", function(){syncComposition.schedule();});
        event.addListener(text, "keydown", function(){syncComposition.schedule();});
    }
    event.addListener(text, "compositionend", onCompositionEnd);

    this.getElement = function() {
        return text;
    };

    this.setReadOnly = function(readOnly) {
       text.readOnly = readOnly;
    };

    this.onContextMenu = function(e) {
        afterContextMenu = true;
        resetSelection(host.selection.isEmpty());
        host._emit("nativecontextmenu", {target: host, domEvent: e});
        this.moveToMouse(e, true);
    };
    
    this.moveToMouse = function(e, bringToFront) {
        if (!tempStyle)
            tempStyle = text.style.cssText;
        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
            + "height:" + text.style.height + ";"
            + (useragent.isIE ? "opacity:0.1;" : "");

        var rect = host.container.getBoundingClientRect();
        var style = dom.computedStyle(host.container);
        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
        var maxTop = rect.bottom - top - text.clientHeight -2;
        var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
        }; 
        move(e);

        if (e.type != "mousedown")
            return;

        if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;

        clearTimeout(closeTimeout);
        if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
    };

    this.onContextMenuClose = onContextMenuClose;
    var closeTimeout;
    function onContextMenuClose() {
        clearTimeout(closeTimeout);
        closeTimeout = setTimeout(function () {
            if (tempStyle) {
                text.style.cssText = tempStyle;
                tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
                host.renderer.$keepTextAreaAtCursor = true;
                host.renderer.$moveTextAreaToCursor();
            }
        }, 0);
    }

    var onContextMenu = function(e) {
        host.textInput.onContextMenu(e);
        onContextMenuClose();
    };
    event.addListener(text, "mouseup", onContextMenu);
    event.addListener(text, "mousedown", function(e) {
        e.preventDefault();
        onContextMenuClose();
    });
    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
    event.addListener(text, "contextmenu", onContextMenu);
};

exports.TextInput = TextInput;
});

ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

var dom = acequire("../lib/dom");
var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");

var DRAG_OFFSET = 0; // pixels
var SCROLL_COOLDOWN_T = 250; // milliseconds

function DefaultHandlers(mouseHandler) {
    mouseHandler.$clickSelection = null;

    var editor = mouseHandler.editor;
    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
    editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));

    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

    exports.forEach(function(x) {
        mouseHandler[x] = this[x];
    }, this);

    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
}

(function() {

    this.onMouseDown = function(ev) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        this.mousedownEvent = ev;
        var editor = this.editor;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            editor.$blockScrolling++;
            if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
            editor.$blockScrolling--;
            if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                    ev.preventDefault();
            }
            return;
        }

        this.mousedownEvent.time = Date.now();
        if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
            }
        }

        this.captureMouse(ev);
        this.startSelect(pos, ev.domEvent._clicks > 1);
        return ev.preventDefault();
    };

    this.startSelect = function(pos, waitForClickSelection) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
        var editor = this.editor;
        editor.$blockScrolling++;
        if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
        else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
        if (!waitForClickSelection)
            this.select();
        if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
        }
        editor.setStyle("ace_selecting");
        this.setState("select");
        editor.$blockScrolling--;
    };

    this.select = function() {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.extendSelectionBy = function(unitName) {
        var anchor, editor = this.editor;
        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
        var range = editor.selection[unitName](cursor.row, cursor.column);
        editor.$blockScrolling++;
        if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);
        editor.$blockScrolling--;
        editor.renderer.scrollCursorIntoView();
    };

    this.selectEnd =
    this.selectAllEnd =
    this.selectByWordsEnd =
    this.selectByLinesEnd = function() {
        this.$clickSelection = null;
        this.editor.unsetStyle("ace_selecting");
        if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
        }
    };

    this.focusWait = function() {
        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
        var time = Date.now();

        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
    };

    this.onDoubleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;
        var session = editor.session;

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            this.setState("select");
        } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
        }
        this.$clickSelection = range;
        this.select();
    };

    this.onTripleClick = function(ev) {
        var pos = ev.getDocumentPosition();
        var editor = this.editor;

        this.setState("selectByLines");
        var range = editor.getSelectionRange();
        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        this.select();
    };

    this.onQuadClick = function(ev) {
        var editor = this.editor;

        editor.selectAll();
        this.$clickSelection = editor.getSelectionRange();
        this.setState("selectAll");
    };

    this.onMouseWheel = function(ev) {
        if (ev.getAccelKey())
            return;
        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }
        
        var editor = this.editor;

        if (!this.$lastScroll)
            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };

        var prevScroll = this.$lastScroll;
        var t = ev.domEvent.timeStamp;
        var dt = t - prevScroll.t;
        var vx = ev.wheelX / dt;
        var vy = ev.wheelY / dt;
        if (dt < SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
        }

        var direction = Math.abs(vx / vy);

        var canScroll = false;
        if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
            canScroll = true;
        if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
            canScroll = true;

        if (canScroll) {
            prevScroll.allowed = t;
        } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) <= 1.1 * Math.abs(prevScroll.vx)
                && Math.abs(vy) <= 1.1 * Math.abs(prevScroll.vy);
            if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
            }
            else {
                prevScroll.allowed = 0;
            }
        }

        prevScroll.t = t;
        prevScroll.vx = vx;
        prevScroll.vy = vy;

        if (canScroll) {
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    };

    this.onTouchMove = function(ev) {
        this.editor._emit("mousewheel", ev);
    };

}).call(DefaultHandlers.prototype);

exports.DefaultHandlers = DefaultHandlers;

function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range, cursor) {
    if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
    else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;

    if (cmp < 0)
        return {cursor: range.start, anchor: range.end};
    else
        return {cursor: range.end, anchor: range.start};
}

});

ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
function Tooltip (parentNode) {
    this.isOpen = false;
    this.$element = null;
    this.$parentNode = parentNode;
}

(function() {
    this.$init = function() {
        this.$element = dom.createElement("div");
        this.$element.className = "ace_tooltip";
        this.$element.style.display = "none";
        this.$parentNode.appendChild(this.$element);
        return this.$element;
    };
    this.getElement = function() {
        return this.$element || this.$init();
    };
    this.setText = function(text) {
        dom.setInnerText(this.getElement(), text);
    };
    this.setHtml = function(html) {
        this.getElement().innerHTML = html;
    };
    this.setPosition = function(x, y) {
        this.getElement().style.left = x + "px";
        this.getElement().style.top = y + "px";
    };
    this.setClassName = function(className) {
        dom.addCssClass(this.getElement(), className);
    };
    this.show = function(text, x, y) {
        if (text != null)
            this.setText(text);
        if (x != null && y != null)
            this.setPosition(x, y);
        if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
        }
    };

    this.hide = function() {
        if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
        }
    };
    this.getHeight = function() {
        return this.getElement().offsetHeight;
    };
    this.getWidth = function() {
        return this.getElement().offsetWidth;
    };

    this.destroy = function() {
        this.isOpen = false;
        if (this.$element && this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
        }
    };

}).call(Tooltip.prototype);

exports.Tooltip = Tooltip;
});

ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(acequire, exports, module) {
var dom = acequire("../lib/dom");
var oop = acequire("../lib/oop");
var event = acequire("../lib/event");
var Tooltip = acequire("../tooltip").Tooltip;

function GutterHandler(mouseHandler) {
    var editor = mouseHandler.editor;
    var gutter = editor.renderer.$gutterLayer;
    var tooltip = new GutterTooltip(editor.container);

    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor.isFocused() || e.getButton() != 0)
            return;
        var gutterRegion = gutter.getRegion(e);

        if (gutterRegion == "foldWidgets")
            return;

        var row = e.getDocumentPosition().row;
        var selection = editor.session.selection;

        if (e.getShiftKey())
            selection.selectTo(row, 0);
        else {
            if (e.domEvent.detail == 2) {
                editor.selectAll();
                return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
    });


    var tooltipTimeout, mouseEvent, tooltipAnnotation;

    function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var annotation = gutter.$annotations[row];
        if (!annotation)
            return hideTooltip();

        var maxRow = editor.session.getLength();
        if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                return hideTooltip();
        }

        if (tooltipAnnotation == annotation)
            return;
        tooltipAnnotation = annotation.text.join("<br/>");

        tooltip.setHtml(tooltipAnnotation);
        tooltip.show();
        editor._signal("showGutterTooltip", tooltip);
        editor.on("mousewheel", hideTooltip);

        if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
        } else {
            var gutterElement = mouseEvent.domEvent.target;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
        }
    }

    function hideTooltip() {
        if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor._signal("hideGutterTooltip", tooltip);
            editor.removeEventListener("mousewheel", hideTooltip);
        }
    }

    function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
    }

    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();

        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);

        mouseEvent = e;
        if (tooltipTimeout)
            return;
        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
                showTooltip();
            else
                hideTooltip();
        }, 50);
    });

    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltipAnnotation || tooltipTimeout)
            return;

        tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
        }, 50);
    });
    
    editor.on("changeSession", hideTooltip);
}

function GutterTooltip(parentNode) {
    Tooltip.call(this, parentNode);
}

oop.inherits(GutterTooltip, Tooltip);

(function(){
    this.setPosition = function(x, y) {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height > windowHeight) {
            y -= 20 + height;
        }
        Tooltip.prototype.setPosition.call(this, x, y);
    };

}).call(GutterTooltip.prototype);



exports.GutterHandler = GutterHandler;

});

ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
    this.domEvent = domEvent;
    this.editor = editor;
    
    this.x = this.clientX = domEvent.clientX;
    this.y = this.clientY = domEvent.clientY;

    this.$pos = null;
    this.$inSelection = null;
    
    this.propagationStopped = false;
    this.defaultPrevented = false;
};

(function() {  
    
    this.stopPropagation = function() {
        event.stopPropagation(this.domEvent);
        this.propagationStopped = true;
    };
    
    this.preventDefault = function() {
        event.preventDefault(this.domEvent);
        this.defaultPrevented = true;
    };
    
    this.stop = function() {
        this.stopPropagation();
        this.preventDefault();
    };
    this.getDocumentPosition = function() {
        if (this.$pos)
            return this.$pos;
        
        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        return this.$pos;
    };
    this.inSelection = function() {
        if (this.$inSelection !== null)
            return this.$inSelection;
            
        var editor = this.editor;
        

        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    };
    this.getButton = function() {
        return event.getButton(this.domEvent);
    };
    this.getShiftKey = function() {
        return this.domEvent.shiftKey;
    };
    
    this.getAccelKey = useragent.isMac
        ? function() { return this.domEvent.metaKey; }
        : function() { return this.domEvent.ctrlKey; };
    
}).call(MouseEvent.prototype);

});

ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

var dom = acequire("../lib/dom");
var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");

var AUTOSCROLL_DELAY = 200;
var SCROLL_CURSOR_DELAY = 200;
var SCROLL_CURSOR_HYSTERESIS = 5;

function DragdropHandler(mouseHandler) {

    var editor = mouseHandler.editor;

    var blankImage = dom.createElement("img");
    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (useragent.isOpera)
        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

     exports.forEach(function(x) {
         mouseHandler[x] = this[x];
    }, this);
    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


    var mouseTarget = editor.container;
    var dragSelectionMarker, x, y;
    var timerId, range;
    var dragCursor, counter = 0;
    var dragOperation;
    var isInternal;
    var autoScrollStartTime;
    var cursorMovedTime;
    var cursorPointOnCaretMoved;

    this.onDragStart = function(e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function(){
                self.startSelect();
                self.captureMouse(e);
            }, 0);
            return e.preventDefault();
        }
        range = editor.getSelectionRange();

        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
        if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage.scrollTop = 0;
        }
        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
        if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
        }
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor.session.getTextRange());

        isInternal = true;
        this.setState("drag");
    };

    this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
                editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
    };

    this.onDragEnter = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
            addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragOver = function(e) {
        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
        }
        if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;

        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
    };

    this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
        }
    };

    this.onDrop = function(e) {
        if (!dragCursor)
            return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
            switch (dragOperation) {
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) {
                        range = {
                            start: dragCursor,
                            end: dragCursor
                        };
                    } else {
                        range = editor.moveText(range, dragCursor);
                    }
                    break;
                case "copy":
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
        } else {
            var dropData = dataTransfer.getData('Text');
            range = {
                start: dragCursor,
                end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
    };

    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

    function scrollCursorIntoView(cursor, prevCursor) {
        var now = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {x: x, y: y};
        } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
                cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                editor.renderer.scrollCursorIntoView();
                cursorMovedTime = null;
            }
        }
    }

    function autoScroll(cursor, prevCursor) {
        var now = Date.now();
        var lineHeight = editor.renderer.layerConfig.lineHeight;
        var characterWidth = editor.renderer.layerConfig.characterWidth;
        var editorRect = editor.renderer.scroller.getBoundingClientRect();
        var offsets = {
           x: {
               left: x - editorRect.left,
               right: editorRect.right - x
           },
           y: {
               top: y - editorRect.top,
               bottom: editorRect.bottom - y
           }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = {row: cursor.row, column: cursor.column};
        if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
        }
        if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
                autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                editor.renderer.scrollCursorIntoView(scrollCursor);
        } else {
            autoScrollStartTime = null;
        }
    }

    function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
    }

    function addDragMarker() {
        range = editor.selection.toOrientedRange();
        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
        editor.clearSelection();
        if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
    }

    function clearDragMarker() {
        clearInterval(timerId);
        editor.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor.$blockScrolling += 1;
        editor.selection.fromOrientedRange(range);
        editor.$blockScrolling -= 1;
        if (editor.isFocused() && !isInternal)
            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
    }
    var onMouseMoveTimer = null;
    function onMouseMove() {
        if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker)
                    clearDragMarker();
            }, 20);
        }
    }

    function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
        });
    }

    function getDropEffect(e) {
        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e) {}
        var dropEffect = "none";

        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";

        return dropEffect;
    }
}

(function() {

    this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
            this.startDrag();
    };

    this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
    };

    this.dragReadyEnd = function(e) {
        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
    };

    this.startDrag = function(){
        this.cancelDrag = false;
        var editor = this.editor;
        var target = editor.container;
        target.draggable = true;
        editor.renderer.$cursorLayer.setBlinking(false);
        editor.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
    };

    this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
                target.dragDrop();
        }
        if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
                target.draggable = false;
                this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
        }
    };

    this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
            return;
        this.mousedownEvent = e;
        var editor = this.editor;

        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
                eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
                if (useragent.isWebKit) {
                    this.cancelDrag = true;
                    var mouseTarget = editor.container;
                    mouseTarget.draggable = true;
                }
                this.setState("dragWait");
            } else {
                this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
        }
    };

}).call(DragdropHandler.prototype);


function calcDistance(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

exports.DragdropHandler = DragdropHandler;

});

ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
var dom = acequire("./dom");

exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            callback(xhr.responseText);
        }
    };
    xhr.send(null);
};

exports.loadScript = function(path, callback) {
    var head = dom.getDocumentHead();
    var s = document.createElement('script');

    s.src = path;
    head.appendChild(s);

    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback();
        }
    };
};
exports.qualifyURL = function(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.href;
};

});

ace.define("ace/lib/event_emitter",["require","exports","module"], function(acequire, exports, module) {

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
"no use strict";

var oop = acequire("./oop");
var EventEmitter = acequire("./event_emitter").EventEmitter;

var optionsProvider = {
    setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
        }, this);
    },
    getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
            optionNames = Object.keys(this.$options);
        } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
        }
        optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
        }, this);
        return result;
    },
    setOption: function(name, value) {
        if (this["$" + name] === value)
            return;
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

        if (!opt.handlesSet)
            this["$" + name] = value;
        if (opt && opt.set)
            opt.set.call(this, value);
    },
    getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
            return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
    }
};

function warn(message) {
    if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
}

function reportError(msg, data) {
    var e = new Error(msg);
    e.data = data;
    if (typeof console == "object" && console.error)
        console.error(e);
    setTimeout(function() { throw e; });
}

var AppConfig = function() {
    this.$defaultOptions = {};
};

(function() {
    oop.implement(this, EventEmitter);
    this.defineOptions = function(obj, path, options) {
        if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};

        Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
                opt = {forwardTo: opt};

            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
        });
        oop.implement(obj, optionsProvider);

        return this;
    };

    this.resetOptions = function(obj) {
        Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
                obj.setOption(key, opt.value);
        });
    };

    this.setDefaultValue = function(path, name, value) {
        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
            else
                opts[name].value = value;
        }
    };

    this.setDefaultValues = function(path, optionHash) {
        Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
        }, this);
    };
    
    this.warn = warn;
    this.reportError = reportError;
    
}).call(AppConfig.prototype);

exports.AppConfig = AppConfig;

});

ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(acequire, exports, module) {
"no use strict";

var lang = acequire("./lib/lang");
var oop = acequire("./lib/oop");
var net = acequire("./lib/net");
var AppConfig = acequire("./lib/app_config").AppConfig;

module.exports = exports = new AppConfig();

var global = (function() {
    return this || typeof window != "undefined" && window;
})();

var options = {
    packaged: false,
    workerPath: null,
    modePath: null,
    themePath: null,
    basePath: "",
    suffix: ".js",
    $moduleUrls: {}
};

exports.get = function(key) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    return options[key];
};

exports.set = function(key, value) {
    if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);

    options[key] = value;
};

exports.all = function() {
    return lang.copyObject(options);
};
exports.moduleUrl = function(name, component) {
    if (options.$moduleUrls[name])
        return options.$moduleUrls[name];

    var parts = name.split("/");
    component = component || parts[parts.length - 2] || "";
    var sep = component == "snippets" ? "/" : "-";
    var base = parts[parts.length - 1];
    if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
    }

    if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
    var path = options[component + "Path"];
    if (path == null) {
        path = options.basePath;
    } else if (sep == "/") {
        component = sep = "";
    }
    if (path && path.slice(-1) != "/")
        path += "/";
    return path + component + sep + base + this.get("suffix");
};

exports.setModuleUrl = function(name, subst) {
    return options.$moduleUrls[name] = subst;
};

exports.$loading = {};
exports.loadModule = function(moduleName, onLoad) {
    var module, moduleType;
    if (Array.isArray(moduleName)) {
        moduleType = moduleName[0];
        moduleName = moduleName[1];
    }

    try {
        module = acequire(moduleName);
    } catch (e) {}
    if (module && !exports.$loading[moduleName])
        return onLoad && onLoad(module);

    if (!exports.$loading[moduleName])
        exports.$loading[moduleName] = [];

    exports.$loading[moduleName].push(onLoad);

    if (exports.$loading[moduleName].length > 1)
        return;

    var afterLoad = function() {
        acequire([moduleName], function(module) {
            exports._emit("load.module", {name: moduleName, module: module});
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
                onLoad && onLoad(module);
            });
        });
    };

    if (!exports.get("packaged"))
        return afterLoad();
    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
};
init(true);function init(packaged) {

    if (!global || !global.document)
        return;
    
    options.packaged = packaged || acequire.packaged || module.packaged || (global.define && undefined.packaged);

    var scriptOptions = {};
    var scriptUrl = "";
    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
    var currentDocument = currentScript && currentScript.ownerDocument || document;
    
    var scripts = currentDocument.getElementsByTagName("script");
    for (var i=0; i<scripts.length; i++) {
        var script = scripts[i];

        var src = script.src || script.getAttribute("src");
        if (!src)
            continue;

        var attributes = script.attributes;
        for (var j=0, l=attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
        }

        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
        if (m)
            scriptUrl = m[1];
    }

    if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
    }

    scriptOptions.basePath = scriptOptions.base;
    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
    delete scriptOptions.base;

    for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
}

exports.init = init;

function deHyphenate(str) {
    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
}

});

ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"], function(acequire, exports, module) {

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
var MouseEvent = acequire("./mouse_event").MouseEvent;
var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
var config = acequire("../config");

var MouseHandler = function(editor) {
    var _self = this;
    this.editor = editor;

    new DefaultHandlers(this);
    new DefaultGutterHandler(this);
    new DragdropHandler(this);

    var focusEditor = function(e) {
        var windowBlurred = !document.hasFocus || !document.hasFocus()
            || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
        if (windowBlurred)
            window.focus();
        editor.focus();
    };

    var mouseTarget = editor.renderer.getMouseEventTarget();
    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
    event.addMultiMouseDownListener([
        mouseTarget,
        editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
        editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
        editor.textInput && editor.textInput.getElement()
    ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
    event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));

    var gutterEl = editor.renderer.$gutter;
    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

    event.addListener(mouseTarget, "mousedown", focusEditor);
    event.addListener(gutterEl, "mousedown", focusEditor);
    if (useragent.isIE && editor.renderer.scrollBarV) {
        event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
        event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
    }

    editor.on("mousemove", function(e){
        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;

        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
        var range = editor.session.selection.getRange();
        var renderer = editor.renderer;

        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
        } else {
            renderer.setCursorStyle("");
        }
    });
};

(function() {
    this.onMouseEvent = function(name, e) {
        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseMove = function(name, e) {
        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
        if (!listeners || !listeners.length)
            return;

        this.editor._emit(name, new MouseEvent(e, this.editor));
    };

    this.onMouseWheel = function(name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;

        this.editor._emit(name, mouseEvent);
    };
    
    this.onTouchMove = function (name, e) {
        var mouseEvent = new MouseEvent(e, this.editor);
        mouseEvent.speed = 1;//this.$scrollSpeed * 2;
        mouseEvent.wheelX = e.wheelX;
        mouseEvent.wheelY = e.wheelY;
        this.editor._emit(name, mouseEvent);
    };

    this.setState = function(state) {
        this.state = state;
    };

    this.captureMouse = function(ev, mouseMoveHandler) {
        this.x = ev.x;
        this.y = ev.y;

        this.isMousePressed = true;
        var renderer = this.editor.renderer;
        if (renderer.$keepTextAreaAtCursor)
            renderer.$keepTextAreaAtCursor = null;

        var self = this;
        var onMouseMove = function(e) {
            if (!e) return;
            if (useragent.isWebKit && !e.which && self.releaseMouse)
                return self.releaseMouse();

            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
        };

        var onCaptureEnd = function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
                renderer.$keepTextAreaAtCursor = true;
                renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
        };

        var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
        };

        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {onCaptureEnd(ev);});
        }

        self.$onCaptureMouseMove = onMouseMove;
        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    };
    this.releaseMouse = null;
    this.cancelContextMenu = function() {
        var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
                event.stopEvent(e.domEvent);
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on("nativecontextmenu", stop);
    };
}).call(MouseHandler.prototype);

config.defineOptions(MouseHandler.prototype, "mouseHandler", {
    scrollSpeed: {initialValue: 2},
    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
    dragEnabled: {initialValue: true},
    focusTimout: {initialValue: 0},
    tooltipFollowsMouse: {initialValue: true}
});


exports.MouseHandler = MouseHandler;
});

ace.define("ace/mouse/fold_handler",["require","exports","module"], function(acequire, exports, module) {

function FoldHandler(editor) {

    editor.on("click", function(e) {
        var position = e.getDocumentPosition();
        var session = editor.session;
        var fold = session.getFoldAt(position.row, position.column, 1);
        if (fold) {
            if (e.getAccelKey())
                session.removeFold(fold);
            else
                session.expandFold(fold);

            e.stop();
        }
    });

    editor.on("gutterclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
                editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
                editor.focus();
            e.stop();
        }
    });

    editor.on("gutterdblclick", function(e) {
        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

        if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;

            if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                if (fold) {
                    session.removeFold(fold);
                } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
                }
            }
            e.stop();
        }
    });
}

exports.FoldHandler = FoldHandler;

});

ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(acequire, exports, module) {

var keyUtil  = acequire("../lib/keys");
var event = acequire("../lib/event");

var KeyBinding = function(editor) {
    this.$editor = editor;
    this.$data = {editor: editor};
    this.$handlers = [];
    this.setDefaultHandler(editor.commands);
};

(function() {
    this.setDefaultHandler = function(kb) {
        this.removeKeyboardHandler(this.$defaultHandler);
        this.$defaultHandler = kb;
        this.addKeyboardHandler(kb, 0);
    };

    this.setKeyboardHandler = function(kb) {
        var h = this.$handlers;
        if (h[h.length - 1] == kb)
            return;

        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);

        this.addKeyboardHandler(kb, 1);
    };

    this.addKeyboardHandler = function(kb, pos) {
        if (!kb)
            return;
        if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
        var i = this.$handlers.indexOf(kb);
        if (i != -1)
            this.$handlers.splice(i, 1);

        if (pos == undefined)
            this.$handlers.push(kb);
        else
            this.$handlers.splice(pos, 0, kb);

        if (i == -1 && kb.attach)
            kb.attach(this.$editor);
    };

    this.removeKeyboardHandler = function(kb) {
        var i = this.$handlers.indexOf(kb);
        if (i == -1)
            return false;
        this.$handlers.splice(i, 1);
        kb.detach && kb.detach(this.$editor);
        return true;
    };

    this.getKeyboardHandler = function() {
        return this.$handlers[this.$handlers.length - 1];
    };
    
    this.getStatusText = function() {
        var data = this.$data;
        var editor = data.editor;
        return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
        }).filter(Boolean).join(" ");
    };

    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
        var toExecute;
        var success = false;
        var commands = this.$editor.commands;

        for (var i = this.$handlers.length; i--;) {
            toExecute = this.$handlers[i].handleKeyboard(
                this.$data, hashId, keyString, keyCode, e
            );
            if (!toExecute || !toExecute.command)
                continue;
            if (toExecute.command == "null") {
                success = true;
            } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 && 
                toExecute.passEvent != true && toExecute.command.passEvent != true
            ) {
                event.stopEvent(e);
            }
            if (success)
                break;
        }
        
        if (!success && hashId == -1) {
            toExecute = {command: "insertstring"};
            success = commands.exec("insertstring", this.$editor, keyString);
        }
        
        if (success && this.$editor._signal)
            this.$editor._signal("keyboardActivity", toExecute);
        
        return success;
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        var keyString = keyUtil.keyCodeToString(keyCode);
        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
    };

    this.onTextInput = function(text) {
        this.$callKeyboardHandlers(-1, text);
    };

}).call(KeyBinding.prototype);

exports.KeyBinding = KeyBinding;
});

ace.define("ace/lib/bidiutil",["require","exports","module"], function(acequire, exports, module) {
var dir = 0, hiLevel = 0;
var lastArabic = false, hasUBAT_B = false,  hasUBAT_S = false;

var impTab_LTR = [	[	0,		3,		0,		1,		0,		0,		0	],	[	0,		3,		0,		1,		2,		2,		0	],	[	0,		3,		0,		0x11,		2,		0,		1	],	[	0,		3,		5,		5,		4,		1,		0	],	[	0,		3,		0x15,		0x15,		4,		0,		1	],	[	0,		3,		5,		5,		4,		2,		0	]
];

var impTab_RTL = [	[	2,		0,		1,		1,		0,		1,		0	],	[	2,		0,		1,		1,		0,		2,		0	],	[	2,		0,		2,		1,		3,		2,		0	],	[	2,		0,		2,		0x21,		3,		1,		1	]
];

var LTR = 0, RTL = 1;

var L = 0;
var R = 1;
var EN = 2;
var AN = 3;
var ON = 4;
var B = 5;
var S = 6;
var AL = 7;
var WS = 8;
var CS = 9;
var ES = 10;
var ET = 11;
var NSM = 12;
var LRE = 13;
var RLE = 14;
var PDF = 15;
var LRO = 16;
var RLO = 17;
var BN = 18;

var UnicodeTBL00 = [
BN,BN,BN,BN,BN,BN,BN,BN,BN,S,B,S,WS,B,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,B,B,B,S,
WS,ON,ON,ET,ET,ET,ON,ON,ON,ON,ON,ES,CS,ES,CS,CS,
EN,EN,EN,EN,EN,EN,EN,EN,EN,EN,CS,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,ON,
ON,L,L,L,L,L,L,L,L,L,L,L,L,L,L,L,
L,L,L,L,L,L,L,L,L,L,L,ON,ON,ON,ON,BN,
BN,BN,BN,BN,BN,B,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,BN,
CS,ON,ET,ET,ET,ET,ON,ON,ON,ON,L,ON,ON,BN,ON,ON,
ET,ET,EN,EN,ON,L,ON,ON,ON,EN,L,ON,ON,ON,ON,ON
];

var UnicodeTBL20 = [
WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,WS,BN,BN,BN,L,R	,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,WS,B,LRE,RLE,PDF,LRO,RLO,CS,
ET,ET,ET,ET,ET,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,CS,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,
ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,ON,WS
];

function _computeLevels(chars, levels, len, charTypes) {
	var impTab = dir ? impTab_RTL : impTab_LTR
		, prevState = null, newClass = null, newLevel = null, newState = 0
		, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];

	if (!charTypes) {
		for (i = 0, charTypes = []; i < len; i++) {
			charTypes[i] = _getCharacterType(chars[i]);
		}
	}
	hiLevel = dir;
	lastArabic = false;
	hasUBAT_B = false;
	hasUBAT_S = false;
	for (ix = 0; ix < len; ix++){
		prevState = newState;
		classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
		newState = impTab[prevState][newClass];
		action = newState & 0xF0;
		newState &= 0x0F;
		levels[ix] = newLevel = impTab[newState][5];
		if (action > 0){
			if (action == 0x10){
				for(i = condPos; i < ix; i++){
					levels[i] = 1;
				}
				condPos = -1;
			} else {
				condPos = -1;
			}
		}
		cond = impTab[newState][6];
		if (cond){
			if(condPos == -1){
				condPos = ix;
			}
		}else {
			if (condPos > -1){
				for(i = condPos; i < ix; i++){
					levels[i] = newLevel;
				}
				condPos = -1;
			}
		}
		if (charTypes[ix] == B){
			levels[ix] = 0;
		}
		hiLevel |= newLevel;
	}
	if (hasUBAT_S){
		for(i = 0; i < len; i++){
			if(charTypes[i] == S){
				levels[i] = dir;
				for(var j = i - 1; j >= 0; j--){
					if(charTypes[j] == WS){
						levels[j] = dir;
					}else {
						break;
					}
				}
			}
		}
	}
}

function _invertLevel(lev, levels, _array) {
	if (hiLevel < lev){
		return;
	}
	if (lev == 1 && dir == RTL && !hasUBAT_B){
		_array.reverse();
		return;
	}
	var len = _array.length, start = 0, end, lo, hi, tmp;
	while(start < len){
		if (levels[start] >= lev){
			end = start + 1;
		while(end < len && levels[end] >= lev){
			end++;
		}
		for(lo = start, hi = end - 1 ; lo < hi; lo++, hi--){
			tmp = _array[lo];
			_array[lo] = _array[hi];
			_array[hi] = tmp;
		}
		start = end;
	}
	start++;
	}
}

function _getCharClass(chars, types, classes, ix) {
	var cType = types[ix], wType, nType, len, i;
	switch(cType){
		case L:
		case R:
			lastArabic = false;
		case ON:
		case AN:
			return cType;
		case EN:
			return lastArabic ? AN : EN;
		case AL:
			lastArabic = true;
			return R;
		case WS:
			return ON;
		case CS:
			if (ix < 1 || (ix + 1) >= types.length ||
				((wType = classes[ix - 1]) != EN && wType != AN) ||
				((nType = types[ix + 1]) != EN && nType != AN)){
				return ON;
			}
			if (lastArabic){nType = AN;}
			return nType == wType ? nType : ON;
		case ES:
			wType = ix > 0 ? classes[ix - 1] : B;
			if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN){
				return EN;
			}
			return ON;
		case ET:
			if (ix > 0 && classes[ix - 1] == EN){
				return EN;
			}
			if (lastArabic){
				return ON;
			}
			i = ix + 1;
			len = types.length;
			while (i < len && types[i] == ET){
				i++;
			}
			if (i < len && types[i] == EN){
				return EN;
			}
			return ON;
		case NSM:
			len = types.length;
			i = ix + 1;
			while (i < len && types[i] == NSM){
				i++;
			}
			if (i < len){
				var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;

				wType = types[i];
				if (rtlCandidate && (wType == R || wType == AL)){
					return R;
				}
			}

			if (ix < 1 || (wType = types[ix - 1]) == B){
				return ON;
			}
			return classes[ix - 1];
		case B:
			lastArabic = false;
			hasUBAT_B = true;
			return dir;
		case S:
			hasUBAT_S = true;
			return ON;
		case LRE:
		case RLE:
		case LRO:
		case RLO:
		case PDF:
			lastArabic = false;
		case BN:
			return ON;
	}
}

function _getCharacterType( ch ) {
	var uc = ch.charCodeAt(0), hi = uc >> 8;

	if (hi == 0) {
		return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
	} else if (hi == 5) {
		return (/[\u0591-\u05f4]/.test(ch) ? R : L);
	} else if (hi == 6) {
		if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
			return NSM;
		else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
			return AN;
		else if (uc == 0x066A)
			return ET;
		else if (/[\u06f0-\u06f9]/.test(ch))
			return EN;
		else
			return AL;
	} else if (hi == 0x20 && uc <= 0x205F) {
		return UnicodeTBL20[uc & 0xFF];
	} else if (hi == 0xFE) {
		return (uc >= 0xFE70 ? AL : ON);
	}
	return ON;
}
exports.L = L;
exports.R = R;
exports.EN = EN;
exports.ON_R = 3;
exports.AN = 4;
exports.R_H = 5;
exports.B = 6;

exports.DOT = "\xB7";
exports.doBidiReorder = function(text, textCharTypes, isRtl) {
	if (text.length < 2)
		return {};

	var chars = text.split(""), logicalFromVisual = new Array(chars.length),
		bidiLevels = new Array(chars.length), levels = [];

	dir = isRtl ? RTL : LTR;

	_computeLevels(chars, levels, chars.length, textCharTypes);

	for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);

	_invertLevel(2, levels, logicalFromVisual);
	_invertLevel(1, levels, logicalFromVisual);

	for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
		if (textCharTypes[i] === AN) {
			levels[i] = exports.AN;
		} else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE)
			|| textCharTypes[i] === ON || textCharTypes[i] === BN)) {
			levels[i] = exports.ON_R;
		} else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
			levels[i - 1] = levels[i] = exports.R_H;
			i++;
		}
	}
	if (chars[chars.length - 1] === exports.DOT)
		levels[chars.length - 1] = exports.B;

	for (var i = 0; i < logicalFromVisual.length; i++) {
		bidiLevels[i] = levels[logicalFromVisual[i]];
	}

	return {'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels};
};
exports.hasBidiCharacters = function(text, textCharTypes){
	var ret = false;
	for (var i = 0; i < text.length; i++){
		textCharTypes[i] = _getCharacterType(text.charAt(i));
		if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL))
			ret = true;
	}
	return ret;
};
exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
	for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
		if (rowMap.logicalFromVisual[i] == logIdx)
			return i;
	}
	return 0;
};

});

ace.define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang","ace/lib/useragent"], function(acequire, exports, module) {

var bidiUtil = acequire("./lib/bidiutil");
var lang = acequire("./lib/lang");
var useragent = acequire("./lib/useragent");
var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
var BidiHandler = function(session) {
    this.session = session;
    this.bidiMap = {};
    this.currentRow = null;
    this.bidiUtil = bidiUtil;
    this.charWidths = [];
    this.EOL = "\xAC";
    this.showInvisibles = true;
    this.isRtlDir = false;
    this.line = "";
    this.wrapIndent = 0;
    this.isLastRow = false;
    this.EOF = "\xB6";
    this.seenBidi = false;
};

(function() {
    this.isBidiRow = function(screenRow, docRow, splitIndex) {
        if (!this.seenBidi)
            return false;
        if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
        }
        return this.bidiMap.bidiLevels;
    };

    this.onChange = function(delta) {
        if (!this.seenBidi) {
            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
            }
        }
        else {
            this.currentRow = null;
        }
    };

    this.getDocumentRow = function() {
        var docRow = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index >= 0)
                docRow = this.session.$docRowCache[index];
        }

        return docRow;
    };

    this.getSplitIndex = function() {
        var splitIndex = 0;
        var rowCache = this.session.$screenRowCache;
        if (rowCache.length) {
            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                    break;

                prevIndex = currentIndex;
                splitIndex++;
            }
        }

        return splitIndex;
    };

    this.updateRowLine = function(docRow, splitIndex) {
        if (docRow === undefined)
            docRow = this.getDocumentRow();

        this.wrapIndent = 0;
        this.isLastRow = (docRow === this.session.getLength() - 1);
        this.line = this.session.getLine(docRow);
        if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
                if (splitIndex === undefined)
                    splitIndex = this.getSplitIndex();

                if(splitIndex > 0 && splits.length) {
                    this.wrapIndent = splits.indent;
                    this.line = (splitIndex < splits.length) ?
                        this.line.substring(splits[splitIndex - 1], splits[splits.length - 1]) :
                            this.line.substring(splits[splits.length - 1]);
                } else {
                    this.line = this.line.substring(0, splits[splitIndex]);
                }
            }
        }
        var session = this.session, shift = 0, size;
        this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i){
            if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
        });
    };

    this.updateBidiMap = function() {
        var textCharTypes = [], endOfLine = this.isLastRow ? this.EOF : this.EOL;
        var line = this.line + (this.showInvisibles ? endOfLine : bidiUtil.DOT);
        if (bidiUtil.hasBidiCharacters(line, textCharTypes)) {
            this.bidiMap = bidiUtil.doBidiReorder(line, textCharTypes, this.isRtlDir);
        } else {
            this.bidiMap = {};
        }
    };
    this.markAsDirty = function() {
        this.currentRow = null;
    };
    this.updateCharacterWidths = function(fontMetrics) {
        if (!this.seenBidi)
            return;
        if (this.characterWidth === fontMetrics.$characterSize.width)
            return;

        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
        var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");

        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
        this.charWidths[bidiUtil.R_H] = useragent.isChrome ? bidiCharWidth : bidiCharWidth * 0.45;
        this.charWidths[bidiUtil.B] = 0;

        this.currentRow = null;
    };

    this.getShowInvisibles = function() {
        return this.showInvisibles;
    };

    this.setShowInvisibles = function(showInvisibles) {
        this.showInvisibles = showInvisibles;
        this.currentRow = null;
    };

    this.setEolChar = function(eolChar) {
        this.EOL = eolChar;
    };

    this.setTextDir = function(isRtlDir) {
        this.isRtlDir = isRtlDir;
    };
    this.getPosLeft = function(col) {
        col -= this.wrapIndent;
        var visualIdx = bidiUtil.getVisualFromLogicalIdx(col > 0 ? col - 1 : 0, this.bidiMap),
            levels = this.bidiMap.bidiLevels, left = 0;

        if (col === 0 && levels[visualIdx] % 2 !== 0)
            visualIdx++;

        for (var i = 0; i < visualIdx; i++) {
            left += this.charWidths[levels[i]];
        }

        if (col !== 0 && levels[visualIdx] % 2 === 0)
            left += this.charWidths[levels[visualIdx]];

        if (this.wrapIndent)
            left += this.wrapIndent * this.charWidths[bidiUtil.L];

        return left;
    };
    this.getSelections = function(startCol, endCol) {
        var map = this.bidiMap, levels = map.bidiLevels, level, offset = this.wrapIndent * this.charWidths[bidiUtil.L], selections = [],
            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,
                isSelected = false, isSelectedPrev = false, selectionStart = 0;

        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
            if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
            } else if (!isSelected && isSelectedPrev) {
                selections.push({left: selectionStart, width: offset - selectionStart});
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
        }

        if (isSelected && (visIdx === levels.length)) {
            selections.push({left: selectionStart, width: offset - selectionStart});
        }

        return selections;
    };
    this.offsetToCol = function(posX) {
        var logicalIdx = 0, posX = Math.max(posX, 0),
            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,
                charWidth = this.charWidths[levels[visualIdx]];

        if (this.wrapIndent) {
            posX -= this.wrapIndent * this.charWidths[bidiUtil.L];
        }

        while(posX > offset + charWidth/2) {
            offset += charWidth;
            if(visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
        }

        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){
            if(posX < offset)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];

        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){
            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);

        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
        } else {
            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
        }

        return (logicalIdx + this.wrapIndent);
    };

}).call(BidiHandler.prototype);

exports.BidiHandler = BidiHandler;
});

ace.define("ace/range",["require","exports","module"], function(acequire, exports, module) {
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var lang = acequire("./lib/lang");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var Range = acequire("./range").Range;
var Selection = function(session) {
    this.session = session;
    this.doc = session.getDocument();

    this.clearSelection();
    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

    var self = this;
    this.lead.on("change", function(e) {
        self._emit("changeCursor");
        if (!self.$isEmpty)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });

    this.selectionAnchor.on("change", function() {
        if (!self.$isEmpty)
            self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);
    this.isEmpty = function() {
        return (this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        ));
    };
    this.isMultiLine = function() {
        if (this.isEmpty()) {
            return false;
        }

        return this.getRange().isMultiLine();
    };
    this.getCursor = function() {
        return this.lead.getPosition();
    };
    this.setSelectionAnchor = function(row, column) {
        this.anchor.setPosition(row, column);

        if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
        }
    };
    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead();
        else
            return this.anchor.getPosition();
    };
    this.getSelectionLead = function() {
        return this.lead.getPosition();
    };
    this.shiftSelection = function(columns) {
        if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return;
        }

        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();

        var isBackwards = this.isBackwards();

        if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);

        if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
                this.moveCursorTo(lead.row, lead.column + columns);
            });
        }
    };
    this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };
    this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.isEmpty())
            return Range.fromPoints(lead, lead);

        if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
        }
        else {
            return Range.fromPoints(anchor, lead);
        }
    };
    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };
    this.selectAll = function() {
        var lastRow = this.doc.getLength() - 1;
        this.setSelectionAnchor(0, 0);
        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
    };
    this.setRange =
    this.setSelectionRange = function(range, reverse) {
        if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
        } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
        }
        if (this.getRange().isEmpty())
            this.$isEmpty = true;
        this.$desiredColumn = null;
    };

    this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };
    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCursorTo(row, column);
        });
    };
    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
        });
    };
    this.moveTo = function(row, column) {
        this.clearSelection();
        this.moveCursorTo(row, column);
    };
    this.moveToPosition = function(pos) {
        this.clearSelection();
        this.moveCursorToPosition(pos);
    };
    this.selectUp = function() {
        this.$moveSelection(this.moveCursorUp);
    };
    this.selectDown = function() {
        this.$moveSelection(this.moveCursorDown);
    };
    this.selectRight = function() {
        this.$moveSelection(this.moveCursorRight);
    };
    this.selectLeft = function() {
        this.$moveSelection(this.moveCursorLeft);
    };
    this.selectLineStart = function() {
        this.$moveSelection(this.moveCursorLineStart);
    };
    this.selectLineEnd = function() {
        this.$moveSelection(this.moveCursorLineEnd);
    };
    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCursorFileEnd);
    };
    this.selectFileStart = function() {
        this.$moveSelection(this.moveCursorFileStart);
    };
    this.selectWordRight = function() {
        this.$moveSelection(this.moveCursorWordRight);
    };
    this.selectWordLeft = function() {
        this.$moveSelection(this.moveCursorWordLeft);
    };
    this.getWordRange = function(row, column) {
        if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
        }
        return this.session.getWordRange(row, column);
    };
    this.selectWord = function() {
        this.setSelectionRange(this.getWordRange());
    };
    this.selectAWord = function() {
        var cursor = this.getCursor();
        var range = this.session.getAWordRange(cursor.row, cursor.column);
        this.setSelectionRange(range);
    };

    this.getLineRange = function(row, excludeLastChar) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        var rowEnd;

        var foldLine = this.session.getFoldLine(rowStart);
        if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
        } else {
            rowEnd = rowStart;
        }
        if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
        else
            return new Range(rowStart, 0, rowEnd + 1, 0);
    };
    this.selectLine = function() {
        this.setSelectionRange(this.getLineRange());
    };
    this.moveCursorUp = function() {
        this.moveCursorBy(-1, 0);
    };
    this.moveCursorDown = function() {
        this.moveCursorBy(1, 0);
    };
    this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
        var start = cursor.column;
        var end = cursor.column + tabSize;

        if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
        }
        return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length-1 == tabSize;
    };
    this.moveCursorLeft = function() {
        var cursor = this.lead.getPosition(),
            fold;

        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
        } else if (cursor.column === 0) {
            if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
            } else {
                this.moveCursorBy(0, -1);
            }
        }
    };
    this.moveCursorRight = function() {
        var cursor = this.lead.getPosition(),
            fold;
        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
        }
        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
            }
        }
        else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
            } else {
                this.moveCursorBy(0, 1);
            }
        }
    };
    this.moveCursorLineStart = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var screenRow = this.session.documentToScreenRow(row, column);
        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
        var beforeCursor = this.session.getDisplayLine(
            row, null, firstColumnPosition.row,
            firstColumnPosition.column
        );

        var leadingSpace = beforeCursor.match(/^\s*/);
        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
        this.moveCursorToPosition(firstColumnPosition);
    };
    this.moveCursorLineEnd = function() {
        var lead = this.lead;
        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
        if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                    lineEnd.column = textEnd;
            }
        }

        this.moveCursorTo(lineEnd.row, lineEnd.column);
    };
    this.moveCursorFileEnd = function() {
        var row = this.doc.getLength() - 1;
        var column = this.doc.getLine(row).length;
        this.moveCursorTo(row, column);
    };
    this.moveCursorFileStart = function() {
        this.moveCursorTo(0, 0);
    };
    this.moveCursorLongWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
        }
        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
        }
        if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
            return;
        }
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };
    this.moveCursorLongWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var fold;
        if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
        }

        var str = this.session.getFoldStringAt(row, column, -1);
        if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
        }

        var leftOfCursor = lang.stringReverse(str);
        var match;
        this.session.nonTokenRe.lastIndex = 0;
        this.session.tokenRe.lastIndex = 0;
        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
        }
        if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
                this.moveCursorWordLeft();
            return;
        }
        if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
        }

        this.moveCursorTo(row, column);
    };

    this.$shortWordEndIndex = function(rightOfCursor) {
        var match, index = 0, ch;
        var whitespaceRe = /\s/;
        var tokenRe = this.session.tokenRe;

        tokenRe.lastIndex = 0;
        if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
        } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index ++;

            if (index < 1) {
                tokenRe.lastIndex = 0;
                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                    tokenRe.lastIndex = 0;
                    index ++;
                    if (whitespaceRe.test(ch)) {
                        if (index > 2) {
                            index--;
                            break;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                index ++;
                            if (index > 2)
                                break;
                        }
                    }
                }
            }
        }
        tokenRe.lastIndex = 0;

        return index;
    };

    this.moveCursorShortWordRight = function() {
        var row = this.lead.row;
        var column = this.lead.column;
        var line = this.doc.getLine(row);
        var rightOfCursor = line.substring(column);

        var fold = this.session.getFoldAt(row, column, 1);
        if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);

        if (column == line.length) {
            var l = this.doc.getLength();
            do {
                row++;
                rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));

            if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
            column = 0;
        }

        var index = this.$shortWordEndIndex(rightOfCursor);

        this.moveCursorTo(row, column + index);
    };

    this.moveCursorShortWordLeft = function() {
        var row = this.lead.row;
        var column = this.lead.column;

        var fold;
        if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);

        var line = this.session.getLine(row).substring(0, column);
        if (column === 0) {
            do {
                row--;
                line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));

            column = line.length;
            if (!/\s+$/.test(line))
                line = "";
        }

        var leftOfCursor = lang.stringReverse(line);
        var index = this.$shortWordEndIndex(leftOfCursor);

        return this.moveCursorTo(row, column - index);
    };

    this.moveCursorWordRight = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
        else
            this.moveCursorShortWordRight();
    };

    this.moveCursorWordLeft = function() {
        if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
        else
            this.moveCursorShortWordLeft();
    };
    this.moveCursorBy = function(rows, chars) {
        var screenPos = this.session.documentToScreenPosition(
            this.lead.row,
            this.lead.column
        );

        var offsetX;

        if (chars === 0) {
            if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                    offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                    screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                    offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
            }

            if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
            else
                this.$desiredColumn = screenPos.column;
        }

        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
        
        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
                if (docPos.row > 0 || rows > 0)
                    docPos.row++;
            }
        }
        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
    };
    this.moveCursorToPosition = function(position) {
        this.moveCursorTo(position.row, position.column);
    };
    this.moveCursorTo = function(row, column, keepDesiredColumn) {
        var fold = this.session.getFoldAt(row, column, 1);
        if (fold) {
            row = fold.start.row;
            column = fold.start.column;
        }

        this.$keepDesiredColumnOnChange = true;
        var line = this.session.getLine(row);
        if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
            else
                column = column + 1;
        }
        this.lead.setPosition(row, column);
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };
    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
    };
    this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
    };

    this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };

    this.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };
    this.getRangeOfMovements = function(func) {
        var start = this.getCursor();
        try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start,end);
        } catch(e) {
            return Range.fromPoints(start,start);
        } finally {
            this.moveCursorToPosition(start);
        }
    };

    this.toJSON = function() {
        if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
        } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
        }
        return data;
    };

    this.fromJSON = function(data) {
        if (data.start == undefined) {
            if (this.rangeList) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                    var r = Range.fromPoints(data[i].start, data[i].end);
                    if (data[i].isBackwards)
                        r.cursor = r.start;
                    this.addRange(r, true);
                }
                return;
            } else
                data = data[0];
        }
        if (this.rangeList)
            this.toSingleRange(data);
        this.setSelectionRange(data, data.isBackwards);
    };

    this.isEqual = function(data) {
        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
        if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);

        for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
                return false;
        }
        return true;
    };

}).call(Selection.prototype);

exports.Selection = Selection;
});

ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(acequire, exports, module) {

var config = acequire("./config");
var MAX_TOKEN_COUNT = 2000;
var Tokenizer = function(rules) {
    this.states = rules;

    this.regExps = {};
    this.matchMappings = {};
    for (var key in this.states) {
        var state = this.states[key];
        var ruleRegExps = [];
        var matchTotal = 0;
        var mapping = this.matchMappings[key] = {defaultToken: "text"};
        var flag = "g";

        var splitterRurles = [];
        for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
                flag = "gi";
            if (rule.regex == null)
                continue;

            if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", { 
                        rule: rule,
                        groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                else
                    rule.onMatch = rule.token;
            }

            if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule); // flag will be known only at the very end
            }

            mapping[matchTotal] = i;
            matchTotal += matchcount;

            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
                rule.onMatch = null;
        }
        
        if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
        }
        
        splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
        }, this);

        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
    }
};

(function() {
    this.$setMaxTokenCount = function(m) {
        MAX_TOKEN_COUNT = m | 0;
    };
    
    this.$applyToken = function(str) {
        var values = this.splitRegex.exec(str).slice(1);
        var types = this.token.apply(this, values);
        if (typeof types === "string")
            return [{type: types, value: str}];

        var tokens = [];
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i]
                };
        }
        return tokens;
    };

    this.$arrayTokens = function(str) {
        if (!str)
            return [];
        var values = this.splitRegex.exec(str);
        if (!values)
            return "text";
        var tokens = [];
        var types = this.tokenArray;
        for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
                tokens[tokens.length] = {
                    type: types[i],
                    value: values[i + 1]
                };
        }
        return tokens;
    };

    this.removeCapturingGroups = function(src) {
        var r = src.replace(
            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
            function(x, y) {return y ? "(?:" : x;}
        );
        return r;
    };

    this.createSplitterRegexp = function(src, flag) {
        if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
                m, esc, parenOpen, parenClose, square, index
            ) {
                if (inChClass) {
                    inChClass = square != "]";
                } else if (square) {
                    inChClass = true;
                } else if (parenClose) {
                    if (stack == lastCapture.stack) {
                        lastCapture.end = index+1;
                        lastCapture.stack = -1;
                    }
                    stack--;
                } else if (parenOpen) {
                    stack++;
                    if (parenOpen.length != 1) {
                        lastCapture.stack = stack;
                        lastCapture.start = index;
                    }
                }
                return m;
            });

            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
        }
        if (src.charAt(0) != "^") src = "^" + src;
        if (src.charAt(src.length - 1) != "$") src += "$";
        
        return new RegExp(src, (flag||"").replace("g", ""));
    };
    this.getLineTokens = function(line, startState) {
        if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
            }
        } else
            var stack = [];

        var currentState = startState || "start";
        var state = this.states[currentState];
        if (!state) {
            currentState = "start";
            state = this.states[currentState];
        }
        var mapping = this.matchMappings[currentState];
        var re = this.regExps[currentState];
        re.lastIndex = 0;

        var match, tokens = [];
        var lastIndex = 0;
        var matchAttempts = 0;

        var token = {type: null, value: ""};

        while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;

            if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                    token.value += skipped;
                } else {
                    if (token.type)
                        tokens.push(token);
                    token = {type: type, value: skipped};
                }
            }

            for (var i = 0; i < match.length-2; i++) {
                if (match[i + 1] === undefined)
                    continue;

                rule = state[mapping[i]];

                if (rule.onMatch)
                    type = rule.onMatch(value, currentState, stack, line);
                else
                    type = rule.token;

                if (rule.next) {
                    if (typeof rule.next == "string") {
                        currentState = rule.next;
                    } else {
                        currentState = rule.next(currentState, stack);
                    }
                    
                    state = this.states[currentState];
                    if (!state) {
                        this.reportError("state doesn't exist", currentState);
                        currentState = "start";
                        state = this.states[currentState];
                    }
                    mapping = this.matchMappings[currentState];
                    lastIndex = index;
                    re = this.regExps[currentState];
                    re.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                    lastIndex = index;
                break;
            }

            if (value) {
                if (typeof type === "string") {
                    if ((!rule || rule.merge !== false) && token.type === type) {
                        token.value += value;
                    } else {
                        if (token.type)
                            tokens.push(token);
                        token = {type: type, value: value};
                    }
                } else if (type) {
                    if (token.type)
                        tokens.push(token);
                    token = {type: null, value: ""};
                    for (var i = 0; i < type.length; i++)
                        tokens.push(type[i]);
                }
            }

            if (lastIndex == line.length)
                break;

            lastIndex = index;

            if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                    this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                }
                while (lastIndex < line.length) {
                    if (token.type)
                        tokens.push(token);
                    token = {
                        value: line.substring(lastIndex, lastIndex += 2000),
                        type: "overflow"
                    };
                }
                currentState = "start";
                stack = [];
                break;
            }
        }

        if (token.type)
            tokens.push(token);
        
        if (stack.length > 1) {
            if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
        }
        return {
            tokens : tokens,
            state : stack.length ? stack : currentState
        };
    };
    
    this.reportError = config.reportError;
    
}).call(Tokenizer.prototype);

exports.Tokenizer = Tokenizer;
});

ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(acequire, exports, module) {

var lang = acequire("../lib/lang");

var TextHighlightRules = function() {

    this.$rules = {
        "start" : [{
            token : "empty_line",
            regex : '^$'
        }, {
            defaultToken : "text"
        }]
    };
};

(function() {

    this.addRules = function(rules, prefix) {
        if (!prefix) {
            for (var key in rules)
                this.$rules[key] = rules[key];
            return;
        }
        for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.next || rule.onMatch) {
                    if (typeof rule.next == "string") {
                        if (rule.next.indexOf(prefix) !== 0)
                            rule.next = prefix + rule.next;
                    }
                    if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                        rule.nextState = prefix + rule.nextState;
                }
            }
            this.$rules[prefix + key] = state;
        }
    };

    this.getRules = function() {
        return this.$rules;
    };

    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function"
            ? new HighlightRules().getRules()
            : HighlightRules;
        if (states) {
            for (var i = 0; i < states.length; i++)
                states[i] = prefix + states[i];
        } else {
            states = [];
            for (var key in embedRules)
                states.push(prefix + key);
        }

        this.addRules(embedRules, prefix);

        if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
        }

        if (!this.$embeds)
            this.$embeds = [];
        this.$embeds.push(prefix);
    };

    this.getEmbeds = function() {
        return this.$embeds;
    };

    var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
        return this.nextState;
    };
    var popState = function(currentState, stack) {
        stack.shift();
        return stack.shift() || "start";
    };

    this.normalizeRules = function() {
        var id = 0;
        var rules = this.$rules;
        function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                var toInsert = null;
                if (Array.isArray(rule)) {
                    toInsert = rule;
                    rule = {};
                }
                if (!rule.regex && rule.start) {
                    rule.regex = rule.start;
                    if (!rule.next)
                        rule.next = [];
                    rule.next.push({
                        defaultToken: rule.token
                    }, {
                        token: rule.token + ".end",
                        regex: rule.end || rule.start,
                        next: "pop"
                    });
                    rule.token = rule.token + ".start";
                    rule.push = true;
                }
                var next = rule.next || rule.push;
                if (next && Array.isArray(next)) {
                    var stateName = rule.stateName;
                    if (!stateName)  {
                        stateName = rule.token;
                        if (typeof stateName != "string")
                            stateName = stateName[0] || "";
                        if (rules[stateName])
                            stateName += id++;
                    }
                    rules[stateName] = next;
                    rule.next = stateName;
                    processState(stateName);
                } else if (next == "pop") {
                    rule.next = popState;
                }

                if (rule.push) {
                    rule.nextState = rule.next || rule.push;
                    rule.next = pushState;
                    delete rule.push;
                }

                if (rule.rules) {
                    for (var r in rule.rules) {
                        if (rules[r]) {
                            if (rules[r].push)
                                rules[r].push.apply(rules[r], rule.rules[r]);
                        } else {
                            rules[r] = rule.rules[r];
                        }
                    }
                }
                var includeName = typeof rule == "string" ? rule : rule.include;
                if (includeName) {
                    if (Array.isArray(includeName))
                        toInsert = includeName.map(function(x) { return rules[x]; });
                    else
                        toInsert = rules[includeName];
                }

                if (toInsert) {
                    var args = [i, 1].concat(toInsert);
                    if (rule.noEscape)
                        args = args.filter(function(x) {return !x.next;});
                    state.splice.apply(state, args);
                    i--;
                }
                
                if (rule.keywordMap) {
                    rule.token = this.createKeywordMapper(
                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
                    );
                    delete rule.defaultToken;
                }
            }
        }
        Object.keys(rules).forEach(processState, this);
    };

    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = Object.create(null);
        Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
                a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
                keywords[list[i]] = className;
        });
        if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
        }
        this.$keywordList = Object.keys(keywords);
        map = null;
        return ignoreCase
            ? function(value) {return keywords[value.toLowerCase()] || defaultToken; }
            : function(value) {return keywords[value] || defaultToken; };
    };

    this.getKeywords = function() {
        return this.$keywords;
    };

}).call(TextHighlightRules.prototype);

exports.TextHighlightRules = TextHighlightRules;
});

ace.define("ace/mode/behaviour",["require","exports","module"], function(acequire, exports, module) {

var Behaviour = function() {
   this.$behaviours = {};
};

(function () {

    this.add = function (name, action, callback) {
        switch (undefined) {
          case this.$behaviours:
              this.$behaviours = {};
          case this.$behaviours[name]:
              this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
    };
    
    this.addBehaviours = function (behaviours) {
        for (var key in behaviours) {
            for (var action in behaviours[key]) {
                this.add(key, action, behaviours[key][action]);
            }
        }
    };
    
    this.remove = function (name) {
        if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
        }
    };
    
    this.inherit = function (mode, filter) {
        if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
        } else {
            var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
    };
    
    this.getBehaviours = function (filter) {
        if (!filter) {
            return this.$behaviours;
        } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
                if (this.$behaviours[filter[i]]) {
                    ret[filter[i]] = this.$behaviours[filter[i]];
                }
            }
            return ret;
        }
    };

}).call(Behaviour.prototype);

exports.Behaviour = Behaviour;
});

ace.define("ace/token_iterator",["require","exports","module","ace/range"], function(acequire, exports, module) {

var Range = acequire("./range").Range;
var TokenIterator = function(session, initialRow, initialColumn) {
    this.$session = session;
    this.$row = initialRow;
    this.$rowTokens = session.getTokens(initialRow);

    var token = session.getTokenAt(initialRow, initialColumn);
    this.$tokenIndex = token ? token.index : -1;
};

(function() { 
    this.stepBackward = function() {
        this.$tokenIndex -= 1;
        
        while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
                this.$row = 0;
                return null;
            }
                
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };   
    this.stepForward = function() {
        this.$tokenIndex += 1;
        var rowCount;
        while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
                rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
            }

            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
        }
            
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentToken = function () {
        return this.$rowTokens[this.$tokenIndex];
    };      
    this.getCurrentTokenRow = function () {
        return this.$row;
    };     
    this.getCurrentTokenColumn = function() {
        var rowTokens = this.$rowTokens;
        var tokenIndex = this.$tokenIndex;
        var column = rowTokens[tokenIndex].start;
        if (column !== undefined)
            return column;
            
        column = 0;
        while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
        }
        
        return column;  
    };
    this.getCurrentTokenPosition = function() {
        return {row: this.$row, column: this.getCurrentTokenColumn()};
    };
    this.getCurrentTokenRange = function() {
        var token = this.$rowTokens[this.$tokenIndex];
        var column = this.getCurrentTokenColumn();
        return new Range(this.$row, column, this.$row, column + token.value.length);
    };

}).call(TokenIterator.prototype);

exports.TokenIterator = TokenIterator;
});

ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(acequire, exports, module) {

var oop = acequire("../../lib/oop");
var Behaviour = acequire("../behaviour").Behaviour;
var TokenIterator = acequire("../../token_iterator").TokenIterator;
var lang = acequire("../../lib/lang");

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var defaultQuotes = {'"' : '"', "'" : "'"};

var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var getWrapped = function(selection, selected, opening, closing) {
    var rowDiff = selection.end.row - selection.start.row;
    return {
        text: opening + selected + closing,
        selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
    };
};

var CstyleBehaviour = function(options) {
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '{', '}');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '(', ')');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, '[', ']');
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
                return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                var rightChar = line.substring(cursor.column, cursor.column + 1);

                var token = session.getTokenAt(cursor.row, cursor.column);
                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                if (leftChar == "\\" && token && /escape/.test(token.type))
                    return null;

                var stringBefore = token && /string|escape/.test(token.type);
                var stringAfter = !rightToken || /string|escape/.test(rightToken.type);

                var pair;
                if (rightChar == quote) {
                    pair = stringBefore !== stringAfter;
                    if (pair && /string\.end/.test(rightToken.type))
                        pair = false;
                } else {
                    if (stringBefore && !stringAfter)
                        return null; // wrap string with different quote
                    if (stringBefore && stringAfter)
                        return null; // do not pair quotes inside strings
                    var wordRe = session.$mode.tokenRe;
                    wordRe.lastIndex = 0;
                    var isWordBefore = wordRe.test(leftChar);
                    wordRe.lastIndex = 0;
                    var isWordAfter = wordRe.test(leftChar);
                    if (isWordBefore || isWordAfter)
                        return null; // before or after alphanumeric
                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                        return null; // there is rightChar and it isn't closing
                    pair = true;
                }
                return {
                    text: pair ? quote + quote : "",
                    selection: [1,1]
                };
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

};


CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};

CstyleBehaviour.$matchTokenType = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour.popAutoInsertedClosing = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour.clearMaybeInsertedClosing = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports.CstyleBehaviour = CstyleBehaviour;
});

ace.define("ace/unicode",["require","exports","module"], function(acequire, exports, module) {
exports.packages = {};

addUnicodePackage({
    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
    Z:  "002000A01680180E2000-200A20282029202F205F3000",
    Zs: "002000A01680180E2000-200A202F205F3000",
    Zl: "2028",
    Zp: "2029",
    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
    Cc: "0000-001F007F-009F",
    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
    Co: "E000-F8FF",
    Cs: "D800-DFFF",
    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
});

function addUnicodePackage (pack) {
    var codePoint = /\w{4}/g;
    for (var name in pack)
        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
}

});

ace.define("ace/mode/text",["require","exports","module","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(acequire, exports, module) {

var Tokenizer = acequire("../tokenizer").Tokenizer;
var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
var unicode = acequire("../unicode");
var lang = acequire("../lib/lang");
var TokenIterator = acequire("../token_iterator").TokenIterator;
var Range = acequire("../range").Range;

var Mode = function() {
    this.HighlightRules = TextHighlightRules;
};

(function() {
    this.$defaultBehaviour = new CstyleBehaviour();

    this.tokenRe = new RegExp("^["
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]+", "g"
    );

    this.nonTokenRe = new RegExp("^(?:[^"
        + unicode.packages.L
        + unicode.packages.Mn + unicode.packages.Mc
        + unicode.packages.Nd
        + unicode.packages.Pc + "\\$_]|\\s])+", "g"
    );

    this.getTokenizer = function() {
        if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
    };

    this.lineCommentStart = "";
    this.blockComment = "";

    this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;

        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;

        if (!this.lineCommentStart) {
            if (!this.blockComment)
                return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

            var comment = function(line, i) {
                if (testRemove(line, i))
                    return;
                if (!ignoreBlankLines || /\S/.test(line)) {
                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };

            var uncomment = function(line, i) {
                var m;
                if (m = line.match(regexpEnd))
                    doc.removeInLine(i, line.length - m[0].length, line.length);
                if (m = line.match(regexpStart))
                    doc.removeInLine(i, m[1].length, m[0].length);
            };

            var testRemove = function(line, row) {
                if (regexpStart.test(line))
                    return true;
                var tokens = session.getTokens(row);
                for (var i = 0; i < tokens.length; i++) {
                    if (tokens[i].type === "comment")
                        return true;
                }
            };
        } else {
            if (Array.isArray(this.lineCommentStart)) {
                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                var lineCommentStart = this.lineCommentStart[0];
            } else {
                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            
            insertAtTabStop = session.getUseSoftTabs();

            var uncomment = function(line, i) {
                var m = line.match(regexpStart);
                if (!m) return;
                var start = m[1].length, end = m[0].length;
                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                    end--;
                doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
                if (!ignoreBlankLines || /\S/.test(line)) {
                    if (shouldInsertSpace(line, minIndent, minIndent))
                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
                    else
                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
                }
            };
            var testRemove = function(line, i) {
                return regexpStart.test(line);
            };
            
            var shouldInsertSpace = function(line, before, after) {
                var spaces = 0;
                while (before-- && line.charAt(before) == " ")
                    spaces++;
                if (spaces % tabSize != 0)
                    return false;
                var spaces = 0;
                while (line.charAt(after++) == " ")
                    spaces++;
                if (tabSize > 2)
                    return spaces % tabSize != tabSize - 1;
                else
                    return spaces % tabSize == 0;
            };
        }

        function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
                fun(doc.getLine(i), i);
        }


        var minEmptyLength = Infinity;
        iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
                if (indent < minIndent)
                    minIndent = indent;
                if (shouldRemove && !testRemove(line, i))
                    shouldRemove = false;
            } else if (minEmptyLength > line.length) {
                minEmptyLength = line.length;
            }
        });

        if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
        }

        if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;

        iter(shouldRemove ? uncomment : comment);
    };

    this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
            return;
        if (!comment.start && comment[0])
            comment = comment[0];

        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;

        if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.start);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    startRange = new Range(row, column, row, column + comment.start.length);
                    break;
                }
                token = iterator.stepBackward();
            }

            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
                var i = token.value.indexOf(comment.end);
                if (i != -1) {
                    var row = iterator.getCurrentTokenRow();
                    var column = iterator.getCurrentTokenColumn() + i;
                    endRange = new Range(row, column, row, column + comment.end.length);
                    break;
                }
                token = iterator.stepForward();
            }
            if (endRange)
                session.remove(endRange);
            if (startRange) {
                session.remove(startRange);
                startRow = startRange.start.row;
                colDiff = -comment.start.length;
            }
        } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
    };

    this.getNextLineIndent = function(state, line, tab) {
        return this.$getIndent(line);
    };

    this.checkOutdent = function(state, line, input) {
        return false;
    };

    this.autoOutdent = function(state, doc, row) {
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

    this.createWorker = function(session) {
        return null;
    };

    this.createModeDelegates = function (mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
            if (mapping[i]) {
                this.$embeds.push(i);
                this.$modes[i] = new mapping[i]();
            }
        }

        var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", 
            "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];

        for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                  return this.$delegator(functionName, arguments, defaultHandler);
              };
            }(this));
        }
    };

    this.$delegator = function(method, args, defaultHandler) {
        var state = args[0];
        if (typeof state != "string")
            state = state[0];
        for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]]) continue;

            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
                args[0] = split[1];
                var mode = this.$modes[this.$embeds[i]];
                return mode[method].apply(mode, args);
            }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : undefined;
    };

    this.transformAction = function(state, action, editor, session, param) {
        if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
                if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) {
                        return ret;
                    }
                }
            }
        }
    };
    
    this.getKeywords = function(append) {
        if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
                var ruleItr = rules[rule];
                for (var r = 0, l = ruleItr.length; r < l; r++) {
                    if (typeof ruleItr[r].token === "string") {
                        if (/keyword|support|storage/.test(ruleItr[r].token))
                            completionKeywords.push(ruleItr[r].regex);
                    }
                    else if (typeof ruleItr[r].token === "object") {
                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
            }
            this.completionKeywords = completionKeywords;
        }
        if (!append)
            return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
    };
    
    this.$createKeywordList = function() {
        if (!this.$highlightRules)
            this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
    };

    this.getCompletions = function(state, session, pos, prefix) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
            return {
                name: word,
                value: word,
                score: 0,
                meta: "keyword"
            };
        });
    };

    this.$id = "ace/mode/text";
}).call(Mode.prototype);

exports.Mode = Mode;
});

ace.define("ace/apply_delta",["require","exports","module"], function(acequire, exports, module) {

exports.applyDelta = function(docLines, delta, doNotValidate) {
    
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
};
});

ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;
            
        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }
            
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var applyDelta = acequire("./apply_delta").applyDelta;
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var Range = acequire("./range").Range;
var Anchor = acequire("./anchor").Anchor;

var Document = function(textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
        this.insert({row: 0, column:0}, textOrLines);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    } else {
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
    }


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function(position, text) {
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    };
    
    this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    };
    
    this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
    };
    
    this.pos = function(row, column) {
        return {row: row, column: column};
    };
    
    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
        } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({row: row, column: column}, lines);
    };    
    this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    };
    this.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    };
    this.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };
    this.replace = function(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000)
            this.$splitAndapplyLargeDelta(delta, 20000);
        applyDelta(this.$lines, delta, doNotValidate);
        this._signal("change", delta);
    };
    
    this.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l = lines.length;
        var row = delta.start.row; 
        var column = delta.start.column;
        var from = 0, to = 0;
        do {
            from = to;
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            if (to > l) {
                delta.lines = chunk;
                delta.start.row = row + from;
                delta.start.column = column;
                break;
            }
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        } while(true);
    };
    this.revertDelta = function(delta) {
        this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: lines[l-1].length};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

var BackgroundTokenizer = function(tokenizer, editor) {
    this.running = false;
    this.lines = [];
    this.states = [];
    this.currentLine = 0;
    this.tokenizer = tokenizer;

    var self = this;

    this.$worker = function() {
        if (!self.running) { return; }

        var workerStart = new Date();
        var currentLine = self.currentLine;
        var endLine = -1;
        var doc = self.doc;

        var startLine = currentLine;
        while (self.lines[currentLine])
            currentLine++;
        
        var len = doc.getLength();
        var processedLines = 0;
        self.running = false;
        while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
                currentLine++;
            } while (self.lines[currentLine]);
            processedLines ++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                
                self.running = setTimeout(self.$worker, 20);
                break;
            }
        }
        self.currentLine = currentLine;
        
        if (endLine == -1)
            endLine = currentLine;

        if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
    };
};

(function(){

    oop.implement(this, EventEmitter);
    this.setTokenizer = function(tokenizer) {
        this.tokenizer = tokenizer;
        this.lines = [];
        this.states = [];

        this.start(0);
    };
    this.setDocument = function(doc) {
        this.doc = doc;
        this.lines = [];
        this.states = [];

        this.stop();
    };
    this.fireUpdateEvent = function(firstRow, lastRow) {
        var data = {
            first: firstRow,
            last: lastRow
        };
        this._signal("update", {data: data});
    };
    this.start = function(startRow) {
        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
        this.lines.splice(this.currentLine, this.lines.length);
        this.states.splice(this.currentLine, this.states.length);

        this.stop();
        this.running = setTimeout(this.$worker, 700);
    };
    
    this.scheduleStart = function() {
        if (!this.running)
            this.running = setTimeout(this.$worker, 700);
    };

    this.$updateOnChange = function(delta) {
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) {
            this.lines[startRow] = null;
        } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
        }

        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

        this.stop();
    };
    this.stop = function() {
        if (this.running)
            clearTimeout(this.running);
        this.running = false;
    };
    this.getTokens = function(row) {
        return this.lines[row] || this.$tokenizeRow(row);
    };
    this.getState = function(row) {
        if (this.currentLine == row)
            this.$tokenizeRow(row);
        return this.states[row] || "start";
    };

    this.$tokenizeRow = function(row) {
        var line = this.doc.getLine(row);
        var state = this.states[row - 1];

        var data = this.tokenizer.getLineTokens(line, state, row);

        if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
                this.currentLine = row + 1;
        } else if (this.currentLine == row) {
            this.currentLine = row + 1;
        }

        return this.lines[row] = data.tokens;
    };

}).call(BackgroundTokenizer.prototype);

exports.BackgroundTokenizer = BackgroundTokenizer;
});

ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {

var lang = acequire("./lib/lang");
var oop = acequire("./lib/oop");
var Range = acequire("./range").Range;

var SearchHighlight = function(regExp, clazz, type) {
    this.setRegexp(regExp);
    this.clazz = clazz;
    this.type = type || "text";
};

(function() {
    this.MAX_RANGES = 500;
    
    this.setRegexp = function(regExp) {
        if (this.regExp+"" == regExp+"")
            return;
        this.regExp = regExp;
        this.cache = [];
    };

    this.update = function(html, markerLayer, session, config) {
        if (!this.regExp)
            return;
        var start = config.firstRow, end = config.lastRow;

        for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match) {
                    return new Range(i, match.offset, i, match.offset + match.length);
                });
                this.cache[i] = ranges.length ? ranges : "";
            }

            for (var j = ranges.length; j --; ) {
                markerLayer.drawSingleLineMarker(
                    html, ranges[j].toScreenRange(session), this.clazz, config);
            }
        }
    };

}).call(SearchHighlight.prototype);

exports.SearchHighlight = SearchHighlight;
});

ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(acequire, exports, module) {

var Range = acequire("../range").Range;
function FoldLine(foldData, folds) {
    this.foldData = foldData;
    if (Array.isArray(folds)) {
        this.folds = folds;
    } else {
        folds = this.folds = [ folds ];
    }

    var last = folds[folds.length - 1];
    this.range = new Range(folds[0].start.row, folds[0].start.column,
                           last.end.row, last.end.column);
    this.start = this.range.start;
    this.end   = this.range.end;

    this.folds.forEach(function(fold) {
        fold.setFoldLine(this);
    }, this);
}

(function() {
    this.shiftRow = function(shift) {
        this.start.row += shift;
        this.end.row += shift;
        this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
        });
    };

    this.addFold = function(fold) {
        if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
                return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column =  fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            }
        } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
        } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
        } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
        }
        fold.foldLine = this;
    };

    this.containsRow = function(row) {
        return row >= this.start.row && row <= this.end.row;
    };

    this.walk = function(callback, endRow, endColumn) {
        var lastEnd = 0,
            folds = this.folds,
            fold,
            cmp, stop, isNewRow = true;

        if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
        }

        for (var i = 0; i < folds.length; i++) {
            fold = folds[i];

            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
            }

            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
                return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
        }
        callback(null, endRow, endColumn, lastEnd, isNewRow);
    };

    this.getNextFoldTo = function(row, column) {
        var fold, cmp;
        for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                return {
                    fold: fold,
                    kind: "after"
                };
            } else if (cmp === 0) {
                return {
                    fold: fold,
                    kind: "inside"
                };
            }
        }
        return null;
    };

    this.addRemoveChars = function(row, column, len) {
        var ret = this.getNextFoldTo(row, column),
            fold, folds;
        if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside"
                && fold.start.column != column
                && fold.start.row != row)
            {
                window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                    this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                    fold = folds[i];
                    fold.start.column += len;
                    if (!fold.sameRow) {
                        return;
                    }
                    fold.end.column += len;
                }
                this.end.column += len;
            }
        }
    };

    this.split = function(row, column) {
        var pos = this.getNextFoldTo(row, column);
        
        if (!pos || pos.kind == "inside")
            return null;
            
        var fold = pos.fold;
        var folds = this.folds;
        var foldData = this.foldData;
        
        var i = folds.indexOf(fold);
        var foldBefore = folds[i - 1];
        this.end.row = foldBefore.end.row;
        this.end.column = foldBefore.end.column;
        folds = folds.splice(i, folds.length - i);

        var newFoldLine = new FoldLine(foldData, folds);
        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
        return newFoldLine;
    };

    this.merge = function(foldLineNext) {
        var folds = foldLineNext.folds;
        for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
        }
        var foldData = this.foldData;
        foldData.splice(foldData.indexOf(foldLineNext), 1);
    };

    this.toString = function() {
        var ret = [this.range.toString() + ": [" ];

        this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
        });
        ret.push("]");
        return ret.join("\n");
    };

    this.idxToPosition = function(idx) {
        var lastFoldEndColumn = 0;

        for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];

            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
                return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
            }

            idx -= fold.placeholder.length;
            if (idx < 0) {
                return fold.start;
            }

            lastFoldEndColumn = fold.end.column;
        }

        return {
            row: this.end.row,
            column: this.end.column + idx
        };
    };
}).call(FoldLine.prototype);

exports.FoldLine = FoldLine;
});

ace.define("ace/range_list",["require","exports","module","ace/range"], function(acequire, exports, module) {
var Range = acequire("./range").Range;
var comparePoints = Range.comparePoints;

var RangeList = function() {
    this.ranges = [];
};

(function() {
    this.comparePoints = comparePoints;

    this.pointIndex = function(pos, excludeEdges, startIndex) {
        var list = this.ranges;

        for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
                continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                return i;

            return -i-1;
        }
        return -i - 1;
    };

    this.add = function(range) {
        var excludeEdges = !range.isEmpty();
        var startIndex = this.pointIndex(range.start, excludeEdges);
        if (startIndex < 0)
            startIndex = -startIndex - 1;

        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

        if (endIndex < 0)
            endIndex = -endIndex - 1;
        else
            endIndex++;
        return this.ranges.splice(startIndex, endIndex - startIndex, range);
    };

    this.addList = function(list) {
        var removed = [];
        for (var i = list.length; i--; ) {
            removed.push.apply(removed, this.add(list[i]));
        }
        return removed;
    };

    this.substractPoint = function(pos) {
        var i = this.pointIndex(pos);

        if (i >= 0)
            return this.ranges.splice(i, 1);
    };
    this.merge = function() {
        var removed = [];
        var list = this.ranges;
        
        list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
        });
        
        var next = list[0], range;
        for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
                continue;

            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;

            if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
            }

            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
        }
        
        this.ranges = list;

        return removed;
    };

    this.contains = function(row, column) {
        return this.pointIndex({row: row, column: column}) >= 0;
    };

    this.containsPoint = function(pos) {
        return this.pointIndex(pos) >= 0;
    };

    this.rangeAtPoint = function(pos) {
        var i = this.pointIndex(pos);
        if (i >= 0)
            return this.ranges[i];
    };


    this.clipRows = function(startRow, endRow) {
        var list = this.ranges;
        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];

        var startIndex = this.pointIndex({row: startRow, column: 0});
        if (startIndex < 0)
            startIndex = -startIndex - 1;
        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
        if (endIndex < 0)
            endIndex = -endIndex - 1;

        var clipped = [];
        for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
        }
        return clipped;
    };

    this.removeAll = function() {
        return this.ranges.splice(0, this.ranges.length);
    };

    this.attach = function(session) {
        if (this.session)
            this.detach();

        this.session = session;
        this.onChange = this.$onChange.bind(this);

        this.session.on('change', this.onChange);
    };

    this.detach = function() {
        if (!this.session)
            return;
        this.session.removeListener('change', this.onChange);
        this.session = null;
    };

    this.$onChange = function(delta) {
        if (delta.action == "insert"){
            var start = delta.start;
            var end = delta.end;
        } else {
            var end = delta.start;
            var start = delta.end;
        }
        var startRow = start.row;
        var endRow = end.row;
        var lineDif = endRow - startRow;

        var colDiff = -start.column + end.column;
        var ranges = this.ranges;

        for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow)
                continue;
            if (r.start.row > startRow)
                break;

            if (r.start.row == startRow && r.start.column >= start.column ) {
                if (r.start.column == start.column && this.$insertRight) ; else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
                if (r.end.column == start.column && this.$insertRight) {
                    continue;
                }
                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
                        r.end.column -= colDiff;
                }
                r.end.column += colDiff;
                r.end.row += lineDif;
            }
        }

        if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        }
    };

}).call(RangeList.prototype);

exports.RangeList = RangeList;
});

ace.define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"], function(acequire, exports, module) {

var Range = acequire("../range").Range;
var RangeList = acequire("../range_list").RangeList;
var oop = acequire("../lib/oop");
var Fold = exports.Fold = function(range, placeholder) {
    this.foldLine = null;
    this.placeholder = placeholder;
    this.range = range;
    this.start = range.start;
    this.end = range.end;

    this.sameRow = range.start.row == range.end.row;
    this.subFolds = this.ranges = [];
};

oop.inherits(Fold, RangeList);

(function() {

    this.toString = function() {
        return '"' + this.placeholder + '" ' + this.range.toString();
    };

    this.setFoldLine = function(foldLine) {
        this.foldLine = foldLine;
        this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
        });
    };

    this.clone = function() {
        var range = this.range.clone();
        var fold = new Fold(range, this.placeholder);
        this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
        });
        fold.collapseChildren = this.collapseChildren;
        return fold;
    };

    this.addSubFold = function(fold) {
        if (this.range.isEqual(fold))
            return;

        if (!this.range.containsRange(fold))
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
        consumeRange(fold, this.start);

        var row = fold.start.row, column = fold.start.column;
        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
                break;
        }
        var afterStart = this.subFolds[i];

        if (cmp == 0)
            return afterStart.addSubFold(fold);
        var row = fold.range.end.row, column = fold.range.end.column;
        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
                break;
        }

        if (cmp == 0)
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

        var consumedFolds = this.subFolds.splice(i, j - i, fold);
        fold.setFoldLine(this.foldLine);

        return fold;
    };
    
    this.restoreRange = function(range) {
        return restoreRange(range, this.start);
    };

}).call(Fold.prototype);

function consumePoint(point, anchor) {
    point.row -= anchor.row;
    if (point.row == 0)
        point.column -= anchor.column;
}
function consumeRange(range, anchor) {
    consumePoint(range.start, anchor);
    consumePoint(range.end, anchor);
}
function restorePoint(point, anchor) {
    if (point.row == 0)
        point.column += anchor.column;
    point.row += anchor.row;
}
function restoreRange(range, anchor) {
    restorePoint(range.start, anchor);
    restorePoint(range.end, anchor);
}

});

ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(acequire, exports, module) {

var Range = acequire("../range").Range;
var FoldLine = acequire("./fold_line").FoldLine;
var Fold = acequire("./fold").Fold;
var TokenIterator = acequire("../token_iterator").TokenIterator;

function Folding() {
    this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
                if (side == 1 && fold.range.isEnd(row, column)) {
                    continue;
                } else if (side == -1 && fold.range.isStart(row, column)) {
                    continue;
                }
                return fold;
            }
        }
    };
    this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                continue;
            }
            else if (cmp == -2) {
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                if (cmp == 42) {
                    break;
                }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    };

    this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        } else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    };
    this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        
        for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    };
    this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this
                    .getLine(fold.start.row)
                    .substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    };

    this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                return foldLine;
            } else if (foldLine.end.row > docRow) {
                return null;
            }
        }
        return null;
    };
    this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
                return foldLine;
            }
        }
        return null;
    };

    this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last-first+1;
        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
                if (start < last) {
                    if (start >= first)
                        rowCount -= last-start;
                    else
                        rowCount = 0; // in one fold
                }
                break;
            } else if (end >= first){
                if (start >= first) // fold inside range
                    rowCount -=  end-start;
                else
                    rowCount -=  end-first+1;
            }
        }
        return rowCount;
    };

    this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    };
    this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        
        if (placeholder instanceof Fold)
            fold = placeholder;
        else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        if (!(startRow < endRow || 
            startRow == endRow && startColumn <= endColumn - 2))
            throw new Error("The range has to be at least 2 characters width");

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);

        if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
        
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
            });
        }

        for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext && foldLineNext.start.row == endRow) {
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow <= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "add" });

        return fold;
    };

    this.addFolds = function(folds) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    };

    this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else
        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
        } else
        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
        } else
        if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
        } else
        {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
        }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "remove" });
    };

    this.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.$modified = true;
    };

    this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
        }
        fold.subFolds = [];
    };

    this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    };

    this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
        } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
        else if ("row" in location)
            range = Range.fromPoints(location, location);
        else
            range = location;
        
        folds = this.getFoldsInRangeList(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            var subFolds = folds;
            while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
            }
        }
        if (folds.length)
            return folds;
    };
    this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
    };

    this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    };

    this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    };

    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = "";

        foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
                return;
            if (row == startRow) {
                if (column < startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += doc.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    };

    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    };

    this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    };

    this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
                if (range.comparePoint(bracketPos) == 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1 ) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = "...";
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
        }

        this.addFold(placeholder, range);
    };

    this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type = token.type;
        if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
                type += "|doc-start";
            var re = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token && re.test(token.type));
                iterator.stepForward();
            }
            
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);
            
            if (dir != -1) {
                var lastRow = -1;
                do {
                    token = iterator.stepForward();
                    if (lastRow == -1) {
                        var state = this.getState(iterator.$row);
                        if (!re.test(state))
                            lastRow = iterator.$row;
                    } else if (iterator.$row > lastRow) {
                        break;
                    }
                } while (token && re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
        }
    };

    this.foldAll = function(startRow, endRow, depth) {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn't hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn't support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
                continue;

            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine()
                && range.end.row <= endRow
                && range.start.row >= startRow
            ) {
                row = range.end.row;
                try {
                    var fold = this.addFold("...", range);
                    if (fold)
                        fold.collapseChildren = depth;
                } catch(e) {}
            }
        }
    };
    this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
    };
    this.$foldStyle = "markbegin";
    this.setFoldStyle = function(style) {
        if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        
        if (this.$foldStyle == style)
            return;

        this.$foldStyle = style;
        
        if (style == "manual")
            this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    };

    this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
            return;
            
        this.$foldMode = foldMode;
        
        this.off('change', this.$updateFoldWidgets);
        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        
        if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
        }
        
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on('change', this.$updateFoldWidgets);
        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
    };

    this.getParentFoldRangeData = function (row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent && fw[row]))
            return {};

        var i = row - 1, firstRange;
        while (i >= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == "start") {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range && range.end.row >= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 && range,
            firstRange: firstRange
        };
    };

    this.onFoldWidgetClick = function(row, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };
        
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
                el.className += " ace_invalid";
        }
    };
    
    this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return fold;
        }

        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
                this.removeFold(fold);
                return fold;
            }
        }
        
        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
        } else if (range) {
            if (options.all) 
                range.collapseChildren = 10000;
            this.addFold("...", range);
        }
        
        return range;
    };
    
    
    
    this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        
        if (range)
            return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        
        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold("...", range);
            }
        }
    };

    this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    };
    this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
    };
}

exports.Folding = Folding;

});

ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(acequire, exports, module) {

var TokenIterator = acequire("../token_iterator").TokenIterator;
var Range = acequire("../range").Range;


function BracketMatch() {

    this.findMatchingBracket = function(position, chr) {
        if (position.column == 0) return null;

        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
        if (charBeforeCursor == "") return null;

        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
            return null;

        if (match[1])
            return this.$findClosingBracket(match[1], position);
        else
            return this.$findOpeningBracket(match[2], position);
    };
    
    this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;

        var chr = line.charAt(pos.column-1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
            chr = line.charAt(pos.column);
            pos = {row: pos.row, column: pos.column + 1};
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
        }
        if (!match)
            return null;

        if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
                range.end.column++;
                range.start.column--;
            }
            range.cursor = range.end;
        } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
                return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
                range.start.column++;
                range.end.column--;
            }
            range.cursor = range.start;
        }
        
        return range;
    };

    this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{"
    };

    this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;
        
         if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("rparen", ".paren")
                    .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        
        while (true) {
        
            while (valueIndex >= 0) {
                var chr = value.charAt(valueIndex);
                if (chr == openBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex -= 1;
            }
            do {
                token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;
                
            value = token.value;
            valueIndex = value.length - 1;
        }
        
        return null;
    };

    this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;

        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
            token = iterator.stepForward();
        if (!token)
            return;

        if (!typeRe){
            typeRe = new RegExp(
                "(\\.?" +
                token.type.replace(".", "\\.").replace("lparen", ".paren")
                    .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                + ")+"
            );
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();

        while (true) {

            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
                var chr = value.charAt(valueIndex);
                if (chr == closingBracket) {
                    depth -= 1;
                    if (depth == 0) {
                        return {row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()};
                    }
                }
                else if (chr == bracket) {
                    depth += 1;
                }
                valueIndex += 1;
            }
            do {
                token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));

            if (token == null)
                break;

            valueIndex = 0;
        }
        
        return null;
    };
}
exports.BracketMatch = BracketMatch;

});

ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var lang = acequire("./lib/lang");
var BidiHandler = acequire("./bidihandler").BidiHandler;
var config = acequire("./config");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var Selection = acequire("./selection").Selection;
var TextMode = acequire("./mode/text").Mode;
var Range = acequire("./range").Range;
var Document = acequire("./document").Document;
var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
var SearchHighlight = acequire("./search_highlight").SearchHighlight;

var EditSession = function(text, mode) {
    this.$breakpoints = [];
    this.$decorations = [];
    this.$frontMarkers = {};
    this.$backMarkers = {};
    this.$markerId = 1;
    this.$undoSelect = true;

    this.$foldData = [];
    this.id = "session" + (++EditSession.$uid);
    this.$foldData.toString = function() {
        return this.join("\n");
    };
    this.on("changeFold", this.onChangeFold.bind(this));
    this.$onChange = this.onChange.bind(this);

    if (typeof text != "object" || !text.getLine)
        text = new Document(text);

    this.$bidiHandler = new BidiHandler(this);
    this.setDocument(text);
    this.selection = new Selection(this);

    config.resetOptions(this);
    this.setMode(mode);
    config._signal("session", this);
};


EditSession.$uid = 0;

(function() {

    oop.implement(this, EventEmitter);
    this.setDocument = function(doc) {
        if (this.doc)
            this.doc.removeListener("change", this.$onChange);

        this.doc = doc;
        doc.on("change", this.$onChange);

        if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());

        this.resetCaches();
    };
    this.getDocument = function() {
        return this.doc;
    };
    this.$resetRowCache = function(docRow) {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    };

    this.$getRowCacheIndex = function(cacheArray, val) {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];

            if (val > c)
                low = mid + 1;
            else if (val < c)
                hi = mid - 1;
            else
                return mid;
        }

        return low -1;
    };

    this.resetCaches = function() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer)
            this.bgTokenizer.start(0);
    };

    this.onChangeFold = function(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    };

    this.onChange = function(delta) {
        this.$modified = true;
        this.$bidiHandler.onChange(delta);
        this.$resetRowCache(delta.start.row);

        var removedFolds = this.$updateInternalDataOnChange(delta);
        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
                this.$deltasFold.push({
                    action: "removeFolds",
                    folds:  removedFolds
                });
            }

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
        this._signal("change", delta);
    };
    this.setValue = function(text) {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    };
    this.getValue =
    this.toString = function() {
        return this.doc.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.getState = function(row) {
        return this.bgTokenizer.getState(row);
    };
    this.getTokens = function(row) {
        return this.bgTokenizer.getTokens(row);
    };
    this.getTokenAt = function(row, column) {
        var tokens = this.bgTokenizer.getTokens(row);
        var token, c = 0;
        if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
        } else {
            for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    };
    this.setUndoManager = function(undoManager) {
        this.$undoManager = undoManager;
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;

            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();

                if (self.$deltasFold.length) {
                    self.$deltas.push({
                        group: "fold",
                        deltas: self.$deltasFold
                    });
                    self.$deltasFold = [];
                }

                if (self.$deltasDoc.length) {
                    self.$deltas.push({
                        group: "doc",
                        deltas: self.$deltasDoc
                    });
                    self.$deltasDoc = [];
                }

                if (self.$deltas.length > 0) {
                    undoManager.execute({
                        action: "aceupdate",
                        args: [self.$deltas, self],
                        merge: self.mergeUndoDeltas
                    });
                }
                self.mergeUndoDeltas = false;
                self.$deltas = [];
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
        }
    };
    this.markUndoGroup = function() {
        if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
    };
    
    this.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        reset: function() {}
    };
    this.getUndoManager = function() {
        return this.$undoManager || this.$defaultUndoManager;
    };
    this.getTabString = function() {
        if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
        } else {
            return "\t";
        }
    };
    this.setUseSoftTabs = function(val) {
        this.setOption("useSoftTabs", val);
    };
    this.getUseSoftTabs = function() {
        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
    };
    this.setTabSize = function(tabSize) {
        this.setOption("tabSize", tabSize);
    };
    this.getTabSize = function() {
        return this.$tabSize;
    };
    this.isTabStop = function(position) {
        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
    };
    this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
        this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
    };
    this.getNavigateWithinSoftTabs = function() {
        return this.$navigateWithinSoftTabs;
    };

    this.$overwrite = false;
    this.setOverwrite = function(overwrite) {
        this.setOption("overwrite", overwrite);
    };
    this.getOverwrite = function() {
        return this.$overwrite;
    };
    this.toggleOverwrite = function() {
        this.setOverwrite(!this.$overwrite);
    };
    this.addGutterDecoration = function(row, className) {
        if (!this.$decorations[row])
            this.$decorations[row] = "";
        this.$decorations[row] += " " + className;
        this._signal("changeBreakpoint", {});
    };
    this.removeGutterDecoration = function(row, className) {
        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
        this._signal("changeBreakpoint", {});
    };
    this.getBreakpoints = function() {
        return this.$breakpoints;
    };
    this.setBreakpoints = function(rows) {
        this.$breakpoints = [];
        for (var i=0; i<rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
        }
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoints = function() {
        this.$breakpoints = [];
        this._signal("changeBreakpoint", {});
    };
    this.setBreakpoint = function(row, className) {
        if (className === undefined)
            className = "ace_breakpoint";
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.clearBreakpoint = function(row) {
        delete this.$breakpoints[row];
        this._signal("changeBreakpoint", {});
    };
    this.addMarker = function(range, clazz, type, inFront) {
        var id = this.$markerId++;

        var marker = {
            range : range,
            type : type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz : clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return id;
    };
    this.addDynamicMarker = function(marker, inFront) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
        } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
        }

        return marker;
    };
    this.removeMarker = function(markerId) {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
            delete (markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        }
    };
    this.getMarkers = function(inFront) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    };

    this.highlight = function(re) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    };
    this.highlightLines = function(startRow, endRow, clazz, inFront) {
        if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
        }
        if (!clazz)
            clazz = "ace_step";

        var range = new Range(startRow, 0, endRow, Infinity);
        range.id = this.addMarker(range, clazz, "fullLine", inFront);
        return range;
    };
    this.setAnnotations = function(annotations) {
        this.$annotations = annotations;
        this._signal("changeAnnotation", {});
    };
    this.getAnnotations = function() {
        return this.$annotations || [];
    };
    this.clearAnnotations = function() {
        this.setAnnotations([]);
    };
    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        } else {
            this.$autoNewLine = "\n";
        }
    };
    this.getWordRange = function(row, column) {
        var line = this.getLine(row);

        var inToken = false;
        if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column-1, column+1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start > 0) {
            do {
                start--;
            }
            while (start >= 0 && line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end < line.length && line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    };
    this.getAWordRange = function(row, column) {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }
        return wordRange;
    };
    this.setNewLineMode = function(newLineMode) {
        this.doc.setNewLineMode(newLineMode);
    };
    this.getNewLineMode = function() {
        return this.doc.getNewLineMode();
    };
    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
    this.getUseWorker = function() { return this.$useWorker; };
    this.onReloadTokenizer = function(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal("tokenizerUpdate", e);
    };

    this.$modes = {};
    this.$mode = null;
    this.$modeId = null;
    this.setMode = function(mode, cb) {
        if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
                return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
        } else {
            path = mode || "ace/mode/text";
        }
        if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();

        if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
        }
        this.$modeId = path;
        config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
                return cb && cb();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
            }
            cb && cb();
        }.bind(this));
        if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
    };

    this.$onChangeMode = function(mode, $isPlaceholder) {
        if (!$isPlaceholder)
            this.$modeId = mode.$id;
        if (this.$mode === mode) 
            return;

        this.$mode = mode;

        this.$stopWorker();

        if (this.$useWorker)
            this.$startWorker();

        var tokenizer = mode.getTokenizer();

        if(tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
                _self._signal("tokenizerUpdate", e);
            });
        } else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;

        
        if (!$isPlaceholder) {
            if (mode.attachToSession)
                mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
        }
    };

    this.$stopWorker = function() {
        if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
        }
    };

    this.$startWorker = function() {
        try {
            this.$worker = this.$mode.createWorker(this);
        } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
        }
    };
    this.getMode = function() {
        return this.$mode;
    };

    this.$scrollTop = 0;
    this.setScrollTop = function(scrollTop) {
        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.$scrollTop = scrollTop;
        this._signal("changeScrollTop", scrollTop);
    };
    this.getScrollTop = function() {
        return this.$scrollTop;
    };

    this.$scrollLeft = 0;
    this.setScrollLeft = function(scrollLeft) {
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal("changeScrollLeft", scrollLeft);
    };
    this.getScrollLeft = function() {
        return this.$scrollLeft;
    };
    this.getScreenWidth = function() {
        this.$computeWidth();
        if (this.lineWidgets) 
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    };
    
    this.getLineWidgetMaxWidth = function() {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    };

    this.$computeWidth = function(force) {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                    i = foldLine.end.row + 1;
                    if (i >= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] > longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    };
    this.getLine = function(row) {
        return this.doc.getLine(row);
    };
    this.getLines = function(firstRow, lastRow) {
        return this.doc.getLines(firstRow, lastRow);
    };
    this.getLength = function() {
        return this.doc.getLength();
    };
    this.getTextRange = function(range) {
        return this.doc.getTextRange(range || this.selection.getRange());
    };
    this.insert = function(position, text) {
        return this.doc.insert(position, text);
    };
    this.remove = function(range) {
        return this.doc.remove(range);
    };
    this.removeFullLines = function(firstRow, lastRow){
        return this.doc.removeFullLines(firstRow, lastRow);
    };
    this.undoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
                delta.deltas.forEach(function(foldDelta) {
                    this.addFolds(foldDelta.folds);
                }, this);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.redoChanges = function(deltas, dontSelect) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange = null;
        for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &&
            this.$undoSelect &&
            !dontSelect &&
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    };
    this.setUndoSelect = function(enable) {
        this.$undoSelect = enable;
    };

    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
        function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
        }

        var delta = deltas[0];
        var range, point;
        if (isInsert(delta)) {
            range = Range.fromPoints(delta.start, delta.end);
        } else {
            range = Range.fromPoints(delta.start, delta.start);
        }

        for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                    range.setEnd(point);
                }
            } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                    range = Range.fromPoints(delta.start, delta.start);
                }
            }
        }
        if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                lastUndoRange.start.column += range.end.column - range.start.column;
                lastUndoRange.end.column += range.end.column - range.start.column;
            }

            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
                range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
                range.setEnd(lastUndoRange.end);
            }
        }

        return range;
    };
    this.replace = function(range, text) {
        return this.doc.replace(range, text);
    };
    this.moveText = function(fromRange, toPosition, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                    toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                    toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                    x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                    x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    };
    this.indentRows = function(startRow, endRow, indentString) {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row=startRow; row<=endRow; row++)
            this.doc.insertInLine({row: row, column: 0}, indentString);
    };
    this.outdentRows = function (range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
                if (line.charAt(j) != ' ')
                    break;
            if (j < size && line.charAt(j) == '\t') {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    };

    this.$moveLines = function(firstRow, lastRow, dir) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0) return 0;
            var diff = row-firstRow;
        } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength()-1) return 0;
            var diff = row-lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x){
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });
        
        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeFullLines(firstRow, lastRow);
        this.doc.insertFullLines(firstRow+diff, lines);
        folds.length && this.addFolds(folds);
        return diff;
    };
    this.moveLinesUp = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, -1);
    };
    this.moveLinesDown = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 1);
    };
    this.duplicateLines = function(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    };


    this.$clipRowToDocument = function(row) {
        return Math.max(0, Math.min(row, this.doc.getLength()-1));
    };

    this.$clipColumnToRow = function(row, column) {
        if (column < 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    };


    this.$clipPositionToDocument = function(row, column) {
        column = Math.max(0, column);

        if (row < 0) {
            row = 0;
            column = 0;
        } else {
            var len = this.doc.getLength();
            if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len-1).length;
            } else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    };

    this.$clipRangeToDocument = function(range) {
        if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
        } else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        } else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    };
    this.$wrapLimit = 80;
    this.$useWrapMode = false;
    this.$wrapLimitRange = {
        min : null,
        max : null
    };
    this.setUseWrapMode = function(useWrapMode) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal("changeWrapMode");
        }
    };
    this.getUseWrapMode = function() {
        return this.$useWrapMode;
    };
    this.setWrapLimitRange = function(min, max) {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min: min, max: max };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();
            if (this.$useWrapMode)
                this._signal("changeWrapMode");
        }
    };
    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
        var limits = this.$wrapLimitRange;
        if (limits.max < 0)
            limits = {min: $printMargin, max: $printMargin};
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
            }
            return true;
        }
        return false;
    };

    this.$constrainWrapLimit = function(wrapLimit, min, max) {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    };
    this.getWrapLimit = function() {
        return this.$wrapLimit;
    };
    this.setWrapLimit = function (limit) {
        this.setWrapLimitRange(limit, limit);
    };
    this.getWrapLimitRange = function() {
        return {
            min : this.$wrapLimitRange.min,
            max : this.$wrapLimitRange.max
        };
    };

    this.$updateInternalDataOnChange = function(delta) {
        var useWrapMode = this.$useWrapMode;
        var action = delta.action;
        var start = delta.start;
        var end = delta.end;
        var firstRow = start.row;
        var lastRow = end.row;
        var len = lastRow - firstRow;
        var removedFolds = null;
        
        this.$updating = true;
        if (len != 0) {
            if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore && foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column);
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        if (foldLine) {
                            foldLine.shiftRow(len);
                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                        }
                    } else
                    if (cmp == -1) {
                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                        foldLine.shiftRow(len);
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx < foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row >= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    };

    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    };

    this.$updateWrapData = function(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row ++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(
                                            placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for (var i = 1; i < walkTokens.length; i++) {
                                walkTokens[i] = PLACEHOLDER_BODY;
                            }
                        } else {
                            walkTokens = this.$getDisplayTokens(
                                lines[row].substring(lastColumn, column),
                                tokens.length);
                        }
                        tokens = tokens.concat(walkTokens);
                    }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    };
    var CHAR = 1,
        CHAR_EXT = 2,
        PLACEHOLDER_START = 3,
        PLACEHOLDER_BODY =  4,
        PUNCTUATION = 9,
        SPACE = 10,
        TAB = 11,
        TAB_SPACE = 12;


    this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
        if (tokens.length == 0) {
            return [];
        }

        var splits = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        var indentedSoftWrap = this.$indentedSoftWrap;
        var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
            || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);

        function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
                return indentation;
            if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if (token == SPACE)
                        indentation += 1;
                    else if (token == TAB)
                        indentation += tabSize;
                    else if (token == TAB_SPACE)
                        continue;
                    else
                        break;
                }
            }
            if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
            return Math.min(indentation, maxIndent);
        }
        function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);
            var len = displayed.length;
            displayed.join("")
                .replace(/12/g, function() {
                    len -= 1;
                })
                .replace(/2/g, function() {
                    len -= 1;
                });

            if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }
        var indent = 0;
        while (displayLength - lastSplit > wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        break;
                    }
                }
                if (split > lastSplit) {
                    addSplit(split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }
                addSplit(split);
                continue;
            }
            var minSplit = Math.max(split - (wrapLimit -(wrapLimit>>2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split --;
            }
            if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                    split --;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                    split --;
                }
            } else {
                while (split > minSplit && tokens[split] < SPACE) {
                    split --;
                }
            }
            if (split > minSplit) {
                addSplit(++split);
                continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
                split--;
            addSplit(split - indent);
        }
        return splits;
    };
    this.$getDisplayTokens = function(str, offset) {
        var arr = [];
        var tabSize;
        offset = offset || 0;

        for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            else if (c == 32) {
                arr.push(SPACE);
            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
                arr.push(PUNCTUATION);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            } else {
                arr.push(CHAR);
            }
        }
        return arr;
    };
    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c, column;
        for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            else if (c >= 0x1100 && isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    };

    this.lineWidgets = null;
    this.getRowLength = function(row) {
        if (this.lineWidgets)
            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };
    this.getRowLineCount = function(row) {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        } else {
            return this.$wrapData[row].length + 1;
        }
    };

    this.getRowWrapIndent = function(screenRow) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
        } else {
            return 0;
        }
    };
    this.getScreenLastRowColumn = function(screenRow) {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    };
    this.getDocumentLastRowColumn = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    };
    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    };
    this.getRowSplitData = function(row) {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    };
    this.getScreenTabSize = function(screenColumn) {
        return this.$tabSize - screenColumn % this.$tabSize;
    };


    this.screenToDocumentRow = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    };


    this.screenToDocumentColumn = function(screenRow, screenColumn) {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    };
    this.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
        if (screenRow < 0)
            return {row: 0, column: 0};

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                    docRow = foldLine.end.row+1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }
        var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                column = splits[splitIndex];
                if(splitIndex > 0 && splits.length) {
                    wrapIndent = splits.indent;
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
            screenColumn = this.$bidiHandler.offsetToCol(offsetX);

        docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
        if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return {row: docRow, column: docColumn};
    };
    this.documentToScreenPosition = function(docRow, docColumn) {
        if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
        else
            pos = this.$clipPositionToDocument(docRow, docColumn);

        docRow = pos.row;
        docColumn = pos.column;

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;


        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ?foldLine.start.row :Infinity;

        while (row < docRow) {
            if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ?foldLine.start.row :Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }
        var textLine = "";
        if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        var wrapIndent = 0;
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                    screenRow ++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(
                    wrapRow[screenRowOffset - 1] || 0, textLine.length
                );
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
        }

        return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
        };
    };
    this.documentToScreenColumn = function(row, docColumn) {
        return this.documentToScreenPosition(row, docColumn).column;
    };
    this.documentToScreenRow = function(docRow, docColumn) {
        return this.documentToScreenPosition(docRow, docColumn).row;
    };
    this.getScreenLength = function() {
        var screenRows = 0;
        var fold = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row :Infinity;

            while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row ++;
                if (row > foldStart) {
                    row = fold.end.row+1;
                    fold = this.$foldData[i++];
                    foldStart = fold ?fold.start.row :Infinity;
                }
            }
        }
        if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();

        return screenRows;
    };
    this.$setFontMetrics = function(fm) {
        if (!this.$enableVarChar) return;
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
                return [0, 0];
            if (!maxScreenColumn)
                maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            
            var c, column;
            for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                if (c === "\t") {
                    screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                    screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                    break;
                }
            }
            
            return [screenColumn, column];
        };
    };
    
    this.destroy = function() {
        if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
        }
        this.$stopWorker();
    };

    this.isFullWidth = isFullWidth;
    function isFullWidth(c) {
        if (c < 0x1100)
            return false;
        return c >= 0x1100 && c <= 0x115F ||
               c >= 0x11A3 && c <= 0x11A7 ||
               c >= 0x11FA && c <= 0x11FF ||
               c >= 0x2329 && c <= 0x232A ||
               c >= 0x2E80 && c <= 0x2E99 ||
               c >= 0x2E9B && c <= 0x2EF3 ||
               c >= 0x2F00 && c <= 0x2FD5 ||
               c >= 0x2FF0 && c <= 0x2FFB ||
               c >= 0x3000 && c <= 0x303E ||
               c >= 0x3041 && c <= 0x3096 ||
               c >= 0x3099 && c <= 0x30FF ||
               c >= 0x3105 && c <= 0x312D ||
               c >= 0x3131 && c <= 0x318E ||
               c >= 0x3190 && c <= 0x31BA ||
               c >= 0x31C0 && c <= 0x31E3 ||
               c >= 0x31F0 && c <= 0x321E ||
               c >= 0x3220 && c <= 0x3247 ||
               c >= 0x3250 && c <= 0x32FE ||
               c >= 0x3300 && c <= 0x4DBF ||
               c >= 0x4E00 && c <= 0xA48C ||
               c >= 0xA490 && c <= 0xA4C6 ||
               c >= 0xA960 && c <= 0xA97C ||
               c >= 0xAC00 && c <= 0xD7A3 ||
               c >= 0xD7B0 && c <= 0xD7C6 ||
               c >= 0xD7CB && c <= 0xD7FB ||
               c >= 0xF900 && c <= 0xFAFF ||
               c >= 0xFE10 && c <= 0xFE19 ||
               c >= 0xFE30 && c <= 0xFE52 ||
               c >= 0xFE54 && c <= 0xFE66 ||
               c >= 0xFE68 && c <= 0xFE6B ||
               c >= 0xFF01 && c <= 0xFF60 ||
               c >= 0xFFE0 && c <= 0xFFE6;
    }

}).call(EditSession.prototype);

acequire("./edit_session/folding").Folding.call(EditSession.prototype);
acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


config.defineOptions(EditSession.prototype, "session", {
    wrap: {
        set: function(value) {
            if (!value || value == "off")
                value = false;
            else if (value == "free")
                value = true;
            else if (value == "printMargin")
                value = -1;
            else if (typeof value == "string")
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            this.$wrap = value;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == "number" ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return "printMargin";
                if (!this.getWrapLimitRange().min)
                    return "free";
                return this.$wrap;
            }
            return "off";
        },
        handlesSet: true
    },    
    wrapMethod: {
        set: function(val) {
            val = val == "auto"
                ? this.$mode.type != "text"
                : val != "text";
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$modified = true;
                    this.$resetRowCache(0);
                    this.$updateWrapData(0, this.getLength() - 1);
                }
            }
        },
        initialValue: "auto"
    },
    indentedSoftWrap: { initialValue: true },
    firstLineNumber: {
        set: function() {this._signal("changeBreakpoint");},
        initialValue: 1
    },
    useWorker: {
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: {initialValue: true},
    tabSize: {
        set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
        },
        initialValue: 4,
        handlesSet: true
    },
    navigateWithinSoftTabs: {initialValue: false},
    overwrite: {
        set: function(val) {this._signal("changeOverwrite");},
        initialValue: false
    },
    newLineMode: {
        set: function(val) {this.doc.setNewLineMode(val);},
        get: function() {return this.doc.getNewLineMode();},
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val); },
        get: function() { return this.$modeId; }
    }
});

exports.EditSession = EditSession;
});

ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {

var lang = acequire("./lib/lang");
var oop = acequire("./lib/oop");
var Range = acequire("./range").Range;

var Search = function() {
    this.$options = {};
};

(function() {
    this.set = function(options) {
        oop.mixin(this.$options, options);
        return this;
    };
    this.getOptions = function() {
        return lang.copyObject(this.$options);
    };
    this.setOptions = function(options) {
        this.$options = options;
    };
    this.find = function(session) {
        var options = this.$options;
        var iterator = this.$matchIterator(session, options);
        if (!iterator)
            return false;

        var firstRange = null;
        iterator.forEach(function(sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec && options.start && options.start.start
                && options.skipCurrent != false && firstRange.isEqual(options.start)
            ) {
                firstRange = null;
                return false;
            }

            return true;
        });

        return firstRange;
    };
    this.findAll = function(session) {
        var options = this.$options;
        if (!options.needle)
            return [];
        this.$assembleRegExp(options);

        var range = options.range;
        var lines = range
            ? session.getLines(range.start.row, range.end.row)
            : session.doc.getAllLines();

        var ranges = [];
        var re = options.re;
        if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                    if (lines[row + j].search(re[j]) == -1)
                        continue outer;
                
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                var endIndex = line.match(re[len - 1])[0].length;
                
                if (prevRange && prevRange.end.row === row &&
                    prevRange.end.column > startIndex
                ) {
                    continue;
                }
                ranges.push(prevRange = new Range(
                    row, startIndex, row + len - 1, endIndex
                ));
                if (len > 2)
                    row = row + len - 2;
            }
        } else {
            for (var i = 0; i < lines.length; i++) {
                var matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                    var match = matches[j];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
            }
        }

        if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                i++;

            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                j--;
            
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
            }
        }

        return ranges;
    };
    this.replace = function(input, replacement) {
        var options = this.$options;

        var re = this.$assembleRegExp(options);
        if (options.$isMultiLine)
            return replacement;

        if (!re)
            return;

        var match = re.exec(input);
        if (!match || match[0].length != input.length)
            return null;
        
        replacement = input.replace(re, replacement);
        if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                    replacement[i] = replacement[i].toUpperCase();
                else
                    replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
        }
        
        return replacement;
    };

    this.$assembleRegExp = function(options, $disableFakeMultiline) {
        if (options.needle instanceof RegExp)
            return options.re = options.needle;

        var needle = options.needle;

        if (!options.needle)
            return options.re = false;

        if (!options.regExp)
            needle = lang.escapeRegExp(needle);

        if (options.wholeWord)
            needle = addWordBoundary(needle, options);

        var modifier = options.caseSensitive ? "gm" : "gmi";

        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
        if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);

        try {
            var re = new RegExp(needle, modifier);
        } catch(e) {
            re = false;
        }
        return options.re = re;
    };

    this.$assembleMultilineRegExp = function(needle, modifier) {
        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
        var re = [];
        for (var i = 0; i < parts.length; i++) try {
            re.push(new RegExp(parts[i], modifier));
        } catch(e) {
            return false;
        }
        return re;
    };

    this.$matchIterator = function(session, options) {
        var re = this.$assembleRegExp(options);
        if (!re)
            return false;
        var backwards = options.backwards == true;
        var skipCurrent = options.skipCurrent != false;

        var range = options.range;
        var start = options.start;
        if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
         
        if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];

        var firstRow = range ? range.start.row : 0;
        var lastRow = range ? range.end.row : session.getLength() - 1;

        if (backwards) {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row--; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                    if (forEachInLine(row, Number.MAX_VALUE, callback))
                        return;
            };
        }
        else {
            var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                    return;
                for (row = row + 1; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
                if (options.wrap == false)
                    return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                    if (forEachInLine(row, 0, callback))
                        return;
            };
        }
        
        if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0) return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re[0]);
                if (!backwards && startIndex < offset || startIndex === -1) return;
                for (var i = 1; i < len; i++) {
                    line = session.getLine(startRow + i);
                    if (line.search(re[i]) == -1)
                        return;
                }
                var endIndex = line.match(re[len - 1])[0].length;
                if (backwards && endIndex > offset) return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                    return true;
            };
        }
        else if (backwards) {
            var forEachInLine = function(row, endIndex, callback) {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (!length) {
                        if (last >= line.length) break;
                        re.lastIndex = last += 1;
                    }
                    if (m.index + length > endIndex)
                        break;
                    matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i >= 0; i -= 2) {
                    var column = matches[i - 1];
                    var length = matches[i];
                    if (callback(row, column, row, column + length))
                        return true;
                }
            };
        }
        else {
            var forEachInLine = function(row, startIndex, callback) {
                var line = session.getLine(row);
                var m;
                var last = startIndex;
                re.lastIndex = startIndex;
                while((m = re.exec(line))) {
                    var length = m[0].length;
                    last = m.index;
                    if (callback(row, last, row,last + length))
                        return true;
                    if (!length) {
                        re.lastIndex = last += 1;
                        if (last >= line.length) return false;
                    }
                }
            };
        }
        return {forEach: forEach};
    };

}).call(Search.prototype);

function addWordBoundary(needle, options) {
    function wordBoundary(c) {
        if (/\w/.test(c) || options.regExp) return "\\b";
        return "";
    }
    return wordBoundary(needle[0]) + needle
        + wordBoundary(needle[needle.length - 1]);
}

exports.Search = Search;
});

ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {

var keyUtil = acequire("../lib/keys");
var useragent = acequire("../lib/useragent");
var KEY_MODS = keyUtil.KEY_MODS;

function HashHandler(config, platform) {
    this.platform = platform || (useragent.isMac ? "mac" : "win");
    this.commands = {};
    this.commandKeyBinding = {};
    this.addCommands(config);
    this.$singleCommand = true;
}

function MultiHashHandler(config, platform) {
    HashHandler.call(this, config, platform);
    this.$singleCommand = false;
}

MultiHashHandler.prototype = HashHandler.prototype;

(function() {
    

    this.addCommand = function(command) {
        if (this.commands[command.name])
            this.removeCommand(command);

        this.commands[command.name] = command;

        if (command.bindKey)
            this._buildKeyHash(command);
    };

    this.removeCommand = function(command, keepCommand) {
        var name = command && (typeof command === 'string' ? command : command.name);
        command = this.commands[name];
        if (!keepCommand)
            delete this.commands[name];
        var ckb = this.commandKeyBinding;
        for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
                delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                    cmdGroup.splice(i, 1);
                    if (cmdGroup.length == 1)
                        ckb[keyId] = cmdGroup[0];
                }
            }
        }
    };

    this.bindKey = function(key, command, position) {
        if (typeof key == "object" && key) {
            if (position == undefined)
                position = key.position;
            key = key[this.platform];
        }
        if (!key)
            return;
        if (typeof command == "function")
            return this.addCommand({exec: command, bindKey: key, name: command.name || key});
        
        key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart) {
                    var binding = this.parseKeys(keyPart);
                    var id = KEY_MODS[binding.hashId] + binding.key;
                    chain += (chain ? " " : "") + id;
                    this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
        }, this);
    };
    
    function getPosition(command) {
        return typeof command == "object" && command.bindKey
            && command.bindKey.position
            || (command.isDefault ? -100 : 0);
    }
    this._addCommandToBinding = function(keyId, command, position) {
        var ckb = this.commandKeyBinding, i;
        if (!command) {
            delete ckb[keyId];
        } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
        } else {
            if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
            }

            if (typeof position != "number") {
                position = getPosition(command);
            }

            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                    break;
            }
            commands.splice(i, 0, command);
        }
    };

    this.addCommands = function(commands) {
        commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
                return;
            
            if (typeof command === "string")
                return this.bindKey(command, name);

            if (typeof command === "function")
                command = { exec: command };

            if (typeof command !== "object")
                return;

            if (!command.name)
                command.name = name;

            this.addCommand(command);
        }, this);
    };

    this.removeCommands = function(commands) {
        Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
        }, this);
    };

    this.bindKeys = function(keyList) {
        Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
        }, this);
    };

    this._buildKeyHash = function(command) {
        this.bindKey(command.bindKey, command);
    };
    this.parseKeys = function(keys) {
        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x;});
        var key = parts.pop();

        var keyCode = keyUtil[key];
        if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
        else if (!parts.length)
            return {key: key, hashId: -1};
        else if (parts.length == 1 && parts[0] == "shift")
            return {key: key.toUpperCase(), hashId: -1};

        var hashId = 0;
        for (var i = parts.length; i--;) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
                if (typeof console != "undefined")
                    console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
            }
            hashId |= modifier;
        }
        return {key: key, hashId: hashId};
    };

    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
        var key = KEY_MODS[hashId] + keyString;
        return this.commandKeyBinding[key];
    };

    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
        if (keyCode < 0) return;
        var key = KEY_MODS[hashId] + keyString;
        var command = this.commandKeyBinding[key];
        if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
        }
        
        if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return {command: "null"};
            }
        }
        
        if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
            else if (hashId == -1 || keyCode > 0)
                data.$keyChain = ""; // reset keyChain
        }
        return {command: command};
    };
    
    this.getStatusText = function(editor, data) {
        return data.$keyChain || "";
    };

}).call(HashHandler.prototype);

exports.HashHandler = HashHandler;
exports.MultiHashHandler = MultiHashHandler;
});

ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("../lib/oop");
var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var CommandManager = function(platform, commands) {
    MultiHashHandler.call(this, commands, platform);
    this.byName = this.commands;
    this.setDefaultHandler("exec", function(e) {
        return e.command.exec(e.editor, e.args || {});
    });
};

oop.inherits(CommandManager, MultiHashHandler);

(function() {

    oop.implement(this, EventEmitter);

    this.exec = function(command, editor, args) {
        if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args)) return true;
            }
            return false;
        }

        if (typeof command === "string")
            command = this.commands[command];

        if (!command)
            return false;

        if (editor && editor.$readOnly && !command.readOnly)
            return false;

        if (command.isAvailable && !command.isAvailable(editor))
            return false;

        var e = {editor: editor, command: command, args: args};
        e.returnValue = this._emit("exec", e);
        this._signal("afterExec", e);

        return e.returnValue === false ? false : true;
    };

    this.toggleRecording = function(editor) {
        if (this.$inReplay)
            return;

        editor && editor._emit("changeStatus");
        if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);

            if (!this.macro.length)
                this.macro = this.oldMacro;

            return this.recording = false;
        }
        if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
            }.bind(this);
        }

        this.oldMacro = this.macro;
        this.macro = [];
        this.on("exec", this.$addCommandToMacro);
        return this.recording = true;
    };

    this.replay = function(editor) {
        if (this.$inReplay || !this.macro)
            return;

        if (this.recording)
            return this.toggleRecording(editor);

        try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
                if (typeof x == "string")
                    this.exec(x, editor);
                else
                    this.exec(x[0], editor, x[1]);
            }, this);
        } finally {
            this.$inReplay = false;
        }
    };

    this.trimMacro = function(m) {
        return m.map(function(x){
            if (typeof x[0] != "string")
                x[0] = x[0].name;
            if (!x[1])
                x = x[0];
            return x;
        });
    };

}).call(CommandManager.prototype);

exports.CommandManager = CommandManager;

});

ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(acequire, exports, module) {

var lang = acequire("../lib/lang");
var config = acequire("../config");
var Range = acequire("../range").Range;

function bindKey(win, mac) {
    return {win: win, mac: mac};
}
exports.commands = [{
    name: "showSettingsMenu",
    bindKey: bindKey("Ctrl-,", "Command-,"),
    exec: function(editor) {
        config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
        });
    },
    readOnly: true
}, {
    name: "goToNextError",
    bindKey: bindKey("Alt-E", "F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "goToPreviousError",
    bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
    exec: function(editor) {
        config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
        });
    },
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selectall",
    bindKey: bindKey("Ctrl-A", "Command-A"),
    exec: function(editor) { editor.selectAll(); },
    readOnly: true
}, {
    name: "centerselection",
    bindKey: bindKey(null, "Ctrl-L"),
    exec: function(editor) { editor.centerSelection(); },
    readOnly: true
}, {
    name: "gotoline",
    bindKey: bindKey("Ctrl-L", "Command-L"),
    exec: function(editor) {
        var line = parseInt(prompt("Enter line number:"), 10);
        if (!isNaN(line)) {
            editor.gotoLine(line);
        }
    },
    readOnly: true
}, {
    name: "fold",
    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
    exec: function(editor) { editor.session.toggleFold(false); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfold",
    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
    exec: function(editor) { editor.session.toggleFold(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleFoldWidget",
    bindKey: bindKey("F2", "F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "toggleParentFoldWidget",
    bindKey: bindKey("Alt-F2", "Alt-F2"),
    exec: function(editor) { editor.session.toggleFoldWidget(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldall",
    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
    exec: function(editor) { editor.session.foldAll(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "foldOther",
    bindKey: bindKey("Alt-0", "Command-Option-0"),
    exec: function(editor) { 
        editor.session.foldAll();
        editor.session.unfold(editor.selection.getAllRanges());
    },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "unfoldall",
    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
    exec: function(editor) { editor.session.unfold(); },
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findnext",
    bindKey: bindKey("Ctrl-K", "Command-G"),
    exec: function(editor) { editor.findNext(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "findprevious",
    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
    exec: function(editor) { editor.findPrevious(); },
    multiSelectAction: "forEach",
    scrollIntoView: "center",
    readOnly: true
}, {
    name: "selectOrFindNext",
    bindKey: bindKey("Alt-K", "Ctrl-G"),
    exec: function(editor) {
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findNext(); 
    },
    readOnly: true
}, {
    name: "selectOrFindPrevious",
    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
    exec: function(editor) { 
        if (editor.selection.isEmpty())
            editor.selection.selectWord();
        else
            editor.findPrevious();
    },
    readOnly: true
}, {
    name: "find",
    bindKey: bindKey("Ctrl-F", "Command-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor);});
    },
    readOnly: true
}, {
    name: "overwrite",
    bindKey: "Insert",
    exec: function(editor) { editor.toggleOverwrite(); },
    readOnly: true
}, {
    name: "selecttostart",
    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
    exec: function(editor) { editor.getSelection().selectFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotostart",
    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
    exec: function(editor) { editor.navigateFileStart(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectup",
    bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
    exec: function(editor) { editor.getSelection().selectUp(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golineup",
    bindKey: bindKey("Up", "Up|Ctrl-P"),
    exec: function(editor, args) { editor.navigateUp(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttoend",
    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
    exec: function(editor) { editor.getSelection().selectFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "gotoend",
    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
    exec: function(editor) { editor.navigateFileEnd(); },
    multiSelectAction: "forEach",
    readOnly: true,
    scrollIntoView: "animate",
    aceCommandGroup: "fileJump"
}, {
    name: "selectdown",
    bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
    exec: function(editor) { editor.getSelection().selectDown(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "golinedown",
    bindKey: bindKey("Down", "Down|Ctrl-N"),
    exec: function(editor, args) { editor.navigateDown(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordleft",
    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
    exec: function(editor) { editor.getSelection().selectWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordleft",
    bindKey: bindKey("Ctrl-Left", "Option-Left"),
    exec: function(editor) { editor.navigateWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolinestart",
    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolinestart",
    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
    exec: function(editor) { editor.navigateLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectleft",
    bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
    exec: function(editor) { editor.getSelection().selectLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoleft",
    bindKey: bindKey("Left", "Left|Ctrl-B"),
    exec: function(editor, args) { editor.navigateLeft(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectwordright",
    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
    exec: function(editor) { editor.getSelection().selectWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotowordright",
    bindKey: bindKey("Ctrl-Right", "Option-Right"),
    exec: function(editor) { editor.navigateWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selecttolineend",
    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotolineend",
    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
    exec: function(editor) { editor.navigateLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectright",
    bindKey: bindKey("Shift-Right", "Shift-Right"),
    exec: function(editor) { editor.getSelection().selectRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "gotoright",
    bindKey: bindKey("Right", "Right|Ctrl-F"),
    exec: function(editor, args) { editor.navigateRight(args.times); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectpagedown",
    bindKey: "Shift-PageDown",
    exec: function(editor) { editor.selectPageDown(); },
    readOnly: true
}, {
    name: "pagedown",
    bindKey: bindKey(null, "Option-PageDown"),
    exec: function(editor) { editor.scrollPageDown(); },
    readOnly: true
}, {
    name: "gotopagedown",
    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
    exec: function(editor) { editor.gotoPageDown(); },
    readOnly: true
}, {
    name: "selectpageup",
    bindKey: "Shift-PageUp",
    exec: function(editor) { editor.selectPageUp(); },
    readOnly: true
}, {
    name: "pageup",
    bindKey: bindKey(null, "Option-PageUp"),
    exec: function(editor) { editor.scrollPageUp(); },
    readOnly: true
}, {
    name: "gotopageup",
    bindKey: "PageUp",
    exec: function(editor) { editor.gotoPageUp(); },
    readOnly: true
}, {
    name: "scrollup",
    bindKey: bindKey("Ctrl-Up", null),
    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "scrolldown",
    bindKey: bindKey("Ctrl-Down", null),
    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
    readOnly: true
}, {
    name: "selectlinestart",
    bindKey: "Shift-Home",
    exec: function(editor) { editor.getSelection().selectLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectlineend",
    bindKey: "Shift-End",
    exec: function(editor) { editor.getSelection().selectLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "togglerecording",
    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
    exec: function(editor) { editor.commands.toggleRecording(editor); },
    readOnly: true
}, {
    name: "replaymacro",
    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
    exec: function(editor) { editor.commands.replay(editor); },
    readOnly: true
}, {
    name: "jumptomatching",
    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
    exec: function(editor) { editor.jumpToMatching(); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "selecttomatching",
    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
    exec: function(editor) { editor.jumpToMatching(true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "expandToMatching",
    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
    exec: function(editor) { editor.jumpToMatching(true, true); },
    multiSelectAction: "forEach",
    scrollIntoView: "animate",
    readOnly: true
}, {
    name: "passKeysToBrowser",
    bindKey: bindKey(null, null),
    exec: function() {},
    passEvent: true,
    readOnly: true
}, {
    name: "copy",
    exec: function(editor) {
    },
    readOnly: true
},
{
    name: "cut",
    exec: function(editor) {
        var range = editor.getSelectionRange();
        editor._emit("cut", range);

        if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
        }
    },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "paste",
    exec: function(editor, args) {
        editor.$handlePaste(args);
    },
    scrollIntoView: "cursor"
}, {
    name: "removeline",
    bindKey: bindKey("Ctrl-D", "Command-D"),
    exec: function(editor) { editor.removeLines(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEachLine"
}, {
    name: "duplicateSelection",
    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
    exec: function(editor) { editor.duplicateSelection(); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "sortlines",
    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
    exec: function(editor) { editor.sortLines(); },
    scrollIntoView: "selection",
    multiSelectAction: "forEachLine"
}, {
    name: "togglecomment",
    bindKey: bindKey("Ctrl-/", "Command-/"),
    exec: function(editor) { editor.toggleCommentLines(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "toggleBlockComment",
    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
    exec: function(editor) { editor.toggleBlockComment(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "modifyNumberUp",
    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
    exec: function(editor) { editor.modifyNumber(1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "modifyNumberDown",
    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
    exec: function(editor) { editor.modifyNumber(-1); },
    scrollIntoView: "cursor",
    multiSelectAction: "forEach"
}, {
    name: "replace",
    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
    exec: function(editor) {
        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true);});
    }
}, {
    name: "undo",
    bindKey: bindKey("Ctrl-Z", "Command-Z"),
    exec: function(editor) { editor.undo(); }
}, {
    name: "redo",
    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
    exec: function(editor) { editor.redo(); }
}, {
    name: "copylinesup",
    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
    exec: function(editor) { editor.copyLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesup",
    bindKey: bindKey("Alt-Up", "Option-Up"),
    exec: function(editor) { editor.moveLinesUp(); },
    scrollIntoView: "cursor"
}, {
    name: "copylinesdown",
    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
    exec: function(editor) { editor.copyLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "movelinesdown",
    bindKey: bindKey("Alt-Down", "Option-Down"),
    exec: function(editor) { editor.moveLinesDown(); },
    scrollIntoView: "cursor"
}, {
    name: "del",
    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
    exec: function(editor) { editor.remove("right"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "backspace",
    bindKey: bindKey(
        "Shift-Backspace|Backspace",
        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
    ),
    exec: function(editor) { editor.remove("left"); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "cut_or_delete",
    bindKey: bindKey("Shift-Delete", null),
    exec: function(editor) { 
        if (editor.selection.isEmpty()) {
            editor.remove("left");
        } else {
            return false;
        }
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestart",
    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
    exec: function(editor) { editor.removeToLineStart(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineend",
    bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
    exec: function(editor) { editor.removeToLineEnd(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolinestarthard",
    bindKey: bindKey("Ctrl-Shift-Backspace", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.start.column = 0;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removetolineendhard",
    bindKey: bindKey("Ctrl-Shift-Delete", null),
    exec: function(editor) {
        var range = editor.selection.getRange();
        range.end.column = Number.MAX_VALUE;
        editor.session.remove(range);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordleft",
    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
    exec: function(editor) { editor.removeWordLeft(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "removewordright",
    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
    exec: function(editor) { editor.removeWordRight(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "outdent",
    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "indent",
    bindKey: bindKey("Tab", "Tab"),
    exec: function(editor) { editor.indent(); },
    multiSelectAction: "forEach",
    scrollIntoView: "selectionPart"
}, {
    name: "blockoutdent",
    bindKey: bindKey("Ctrl-[", "Ctrl-["),
    exec: function(editor) { editor.blockOutdent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "blockindent",
    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
    exec: function(editor) { editor.blockIndent(); },
    multiSelectAction: "forEachLine",
    scrollIntoView: "selectionPart"
}, {
    name: "insertstring",
    exec: function(editor, str) { editor.insert(str); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "inserttext",
    exec: function(editor, args) {
        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "splitline",
    bindKey: bindKey(null, "Ctrl-O"),
    exec: function(editor) { editor.splitLine(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "transposeletters",
    bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
    exec: function(editor) { editor.transposeLetters(); },
    multiSelectAction: function(editor) {editor.transposeSelections(1); },
    scrollIntoView: "cursor"
}, {
    name: "touppercase",
    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
    exec: function(editor) { editor.toUpperCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "tolowercase",
    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
    exec: function(editor) { editor.toLowerCase(); },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor"
}, {
    name: "expandtoline",
    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
    exec: function(editor) {
        var range = editor.selection.getRange();

        range.start.column = range.end.column = 0;
        range.end.row++;
        editor.selection.setRange(range, false);
    },
    multiSelectAction: "forEach",
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "joinlines",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var isBackwards = editor.selection.isBackwards();
        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
        var insertLine = editor.session.doc.getLine(selectionStart.row);

        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
                curLine = " " + curLine;
            }
            insertLine += curLine;
        }

        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            insertLine += editor.session.doc.getNewLineCharacter();
        }

        editor.clearSelection();
        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

        if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
        } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
        }
    },
    multiSelectAction: "forEach",
    readOnly: true
}, {
    name: "invertSelection",
    bindKey: bindKey(null, null),
    exec: function(editor) {
        var endRow = editor.session.doc.getLength() - 1;
        var endCol = editor.session.doc.getLine(endRow).length;
        var ranges = editor.selection.rangeList.ranges;
        var newRanges = [];
        if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
        }

        for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                }
            }

            if (i === 0) {
                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                }
            } else {
                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
        }

        editor.exitMultiSelectMode();
        editor.clearSelection();

        for(var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
        }
    },
    readOnly: true,
    scrollIntoView: "none"
}];

});

ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator"], function(acequire, exports, module) {

acequire("./lib/fixoldbrowsers");

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var lang = acequire("./lib/lang");
var useragent = acequire("./lib/useragent");
var TextInput = acequire("./keyboard/textinput").TextInput;
var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
var EditSession = acequire("./edit_session").EditSession;
var Search = acequire("./search").Search;
var Range = acequire("./range").Range;
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var CommandManager = acequire("./commands/command_manager").CommandManager;
var defaultCommands = acequire("./commands/default_commands").commands;
var config = acequire("./config");
var TokenIterator = acequire("./token_iterator").TokenIterator;
var Editor = function(renderer, session) {
    var container = renderer.getContainerElement();
    this.container = container;
    this.renderer = renderer;
    this.id = "editor" + (++Editor.$uid);

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    if (typeof document == "object") {
        this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
    }

    this.keyBinding = new KeyBinding(this);

    this.$blockScrolling = 0;
    this.$search = new Search().set({
        wrap: true
    });

    this.$historyTracker = this.$historyTracker.bind(this);
    this.commands.on("exec", this.$historyTracker);

    this.$initOperationListeners();
    
    this._$emitInputEvent = lang.delayedCall(function() {
        this._signal("input", {});
        if (this.session && this.session.bgTokenizer)
            this.session.bgTokenizer.scheduleStart();
    }.bind(this));
    
    this.on("change", function(_, _self) {
        _self._$emitInputEvent.schedule(31);
    });

    this.setSession(session || new EditSession(""));
    config.resetOptions(this);
    config._signal("editor", this);
};

Editor.$uid = 0;

(function(){

    oop.implement(this, EventEmitter);

    this.$initOperationListeners = function() {

        this.selections = [];
        this.commands.on("exec", this.startOperation.bind(this), true);
        this.commands.on("afterExec", this.endOperation.bind(this), true);

        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

        this.on("change", function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
        }.bind(this), true);

        this.on("changeSelection", function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    };

    this.curOp = null;
    this.prevOp = {};
    this.startOperation = function(commadEvent) {
        if (this.curOp) {
            if (!commadEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
        }

        this.$opResetTimer.schedule();
        this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
        };
        if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
            this.$blockScrolling++;
    };

    this.endOperation = function(e) {
        if (this.curOp) {
            if (e && e.returnValue === false)
                return this.curOp = null;
            this._signal("beforeEndOperation");
            var command = this.curOp.command;
            if (command.name && this.$blockScrolling > 0)
                this.$blockScrolling--;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
                switch (scrollIntoView) {
                    case "center-animate":
                        scrollIntoView = "animate";
                    case "center":
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case "animate":
                    case "cursor":
                        this.renderer.scrollCursorIntoView();
                        break;
                    case "selectionPart":
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                }
                if (scrollIntoView == "animate")
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            
            this.prevOp = this.curOp;
            this.curOp = null;
        }
    };
    this.$mergeableCommands = ["backspace", "del", "insertstring"];
    this.$historyTracker = function(e) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        var shouldMerge = prev.command && (e.command.name == prev.command.name);
        if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                && this.mergeNextCommand // previous command allows to coalesce with
                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != "always"
            && Date.now() - this.sequenceStartTime > 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    };
    this.setKeyboardHandler = function(keyboardHandler, cb) {
        if (keyboardHandler && typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module && module.handler);
                cb && cb();
            });
        } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
        }
    };
    this.getKeyboardHandler = function() {
        return this.keyBinding.getKeyboardHandler();
    };
    this.setSession = function(session) {
        if (this.session == session)
            return;
        if (this.curOp) this.endOperation();
        this.curOp = {};

        var oldSession = this.session;
        if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);
    
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
    
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
    
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);
    
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);
    
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);
    
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);
    
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
    
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);
    
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
    
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);
    
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);
    
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);
    
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
    
            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);
    
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
    
            this.onChangeMode();
    
            this.$blockScrolling += 1;
            this.onCursorChange();
            this.$blockScrolling -= 1;
    
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        } else {
            this.selection = null;
            this.renderer.setSession(session);
        }

        this._signal("changeSession", {
            session: session,
            oldSession: oldSession
        });
        
        this.curOp = null;
        
        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
        session && session._signal("changeEditor", {editor: this});

        if (session && session.bgTokenizer)
            session.bgTokenizer.scheduleStart();
    };
    this.getSession = function() {
        return this.session;
    };
    this.setValue = function(val, cursorPos) {
        this.session.doc.setValue(val);

        if (!cursorPos)
            this.selectAll();
        else if (cursorPos == 1)
            this.navigateFileEnd();
        else if (cursorPos == -1)
            this.navigateFileStart();

        return val;
    };
    this.getValue = function() {
        return this.session.getValue();
    };
    this.getSelection = function() {
        return this.selection;
    };
    this.resize = function(force) {
        this.renderer.onResize(force);
    };
    this.setTheme = function(theme, cb) {
        this.renderer.setTheme(theme, cb);
    };
    this.getTheme = function() {
        return this.renderer.getTheme();
    };
    this.setStyle = function(style) {
        this.renderer.setStyle(style);
    };
    this.unsetStyle = function(style) {
        this.renderer.unsetStyle(style);
    };
    this.getFontSize = function () {
        return this.getOption("fontSize") ||
           dom.computedStyle(this.container, "fontSize");
    };
    this.setFontSize = function(size) {
        this.setOption("fontSize", size);
    };

    this.$highlightBrackets = function() {
        if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
        }

        if (this.$highlightPending) {
            return;
        }
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            var pos = session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (session.$mode.getMatching) {
                var range = session.$mode.getMatching(self.session);
            }
            if (range)
                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.$highlightTags = function() {
        if (this.$highlightTagPending)
            return;
        var self = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
            self.$highlightTagPending = false;
            
            var session = self.session;
            if (!session || !session.bgTokenizer) return;
            
            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();
            
            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }
            
            if (token.type.indexOf("tag-open") != -1) {
                token = iterator.stepForward();
                if (!token)
                    return;
            }
            
            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();
            
            if (prevToken.value == '<'){
                do {
                    prevToken = token;
                    token = iterator.stepForward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<'){
                            depth++;
                        } else if (prevToken.value === '</'){
                            depth--;
                        }
                    }
                    
                } while (token && depth >= 0);
            } else {
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                        if (prevToken.value === '<') {
                            depth++;
                        } else if (prevToken.value === '</') {
                            depth--;
                        }
                    }
                } while (prevToken && depth <= 0);
                iterator.stepForward();
            }
            
            if (!token) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }
            
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column+token.value.length);
            var sbm = session.$backMarkers[session.$tagHighlight];
            if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
            }
            
            if (range && !session.$tagHighlight)
                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
        }, 50);
    };
    this.focus = function() {
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    };
    this.isFocused = function() {
        return this.textInput.isFocused();
    };
    this.blur = function() {
        this.textInput.blur();
    };
    this.onFocus = function(e) {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit("focus", e);
    };
    this.onBlur = function(e) {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit("blur", e);
    };

    this.$cursorChange = function() {
        this.renderer.updateCursor();
    };
    this.onDocumentChange = function(delta) {
        var wrap = this.session.$useWrapMode;
        var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
        this.renderer.updateLines(delta.start.row, lastRow, wrap);

        this._signal("change", delta);
        this.$cursorChange();
        this.$updateHighlightActiveLine();
    };

    this.onTokenizerUpdate = function(e) {
        var rows = e.data;
        this.renderer.updateLines(rows.first, rows.last);
    };


    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.session.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.session.getScrollLeft());
    };
    this.onCursorChange = function() {
        this.$cursorChange();

        if (!this.$blockScrolling) {
            config.warn("Automatically scrolling cursor into view after selection change",
                "this will be disabled in the next version",
                "set editor.$blockScrolling = Infinity to disable this message"
            );
            this.renderer.scrollCursorIntoView();
        }

        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
        this._signal("changeSelection");
    };

    this.$updateHighlightActiveLine = function() {
        var session = this.getSession();

        var highlight;
        if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
                highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
        }

        if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
        } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
        } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
        }
    };

    this.onSelectionChange = function(e) {
        var session = this.session;

        if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
        }
        session.$selectionMarker = null;

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
        } else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal("changeSelection");
    };

    this.$getSelectionHighLightRegexp = function() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0),
                                    Math.min(endOuter, lineCols));
        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return;

        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        return re;
    };


    this.onChangeFrontMarker = function() {
        this.renderer.updateFrontMarkers();
    };

    this.onChangeBackMarker = function() {
        this.renderer.updateBackMarkers();
    };


    this.onChangeBreakpoint = function() {
        this.renderer.updateBreakpoints();
    };

    this.onChangeAnnotation = function() {
        this.renderer.setAnnotations(this.session.getAnnotations());
    };


    this.onChangeMode = function(e) {
        this.renderer.updateText();
        this._emit("changeMode", e);
    };


    this.onChangeWrapLimit = function() {
        this.renderer.updateFull();
    };

    this.onChangeWrapMode = function() {
        this.renderer.onResize(true);
    };


    this.onChangeFold = function() {
        this.$updateHighlightActiveLine();
        this.renderer.updateFull();
    };
    this.getSelectedText = function() {
        return this.session.getTextRange(this.getSelectionRange());
    };
    this.getCopyText = function() {
        var text = this.getSelectedText();
        this._signal("copy", text);
        return text;
    };
    this.onCopy = function() {
        this.commands.exec("copy", this);
    };
    this.onCut = function() {
        this.commands.exec("cut", this);
    };
    this.onPaste = function(text, event) {
        var e = {text: text, event: event};
        this.commands.exec("paste", this, e);
    };
    
    this.$handlePaste = function(e) {
        if (typeof e == "string") 
            e = {text: e};
        this._signal("paste", e);
        var text = e.text;
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            this.insert(text);
        } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
    
            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
                return this.commands.exec("insertstring", this, text);
    
            for (var i = ranges.length; i--;) {
                var range = ranges[i];
                if (!range.isEmpty())
                    this.session.remove(range);
    
                this.session.insert(range.start, lines[i]);
            }
        }
    };

    this.execCommand = function(command, args) {
        return this.commands.exec(command, this, args);
    };
    this.insert = function(text, pasted) {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    this.session.mergeUndoDeltas = false;
                    this.$mergeNextCommand = false;
                }
                text = transform.text;

            }
        }
        
        if (text == "\t")
            text = this.session.getTabString();
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        var end = session.insert(cursor, text);

        if (transform && transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                              cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                              transform.selection[1],
                              cursor.row + transform.selection[2],
                              transform.selection[3]));
            }
        }

        if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

            session.insert({row: cursor.row+1, column: 0}, lineIndent);
        }
        if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
    };

    this.onTextInput = function(text) {
        this.keyBinding.onTextInput(text);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    };
    this.setOverwrite = function(overwrite) {
        this.session.setOverwrite(overwrite);
    };
    this.getOverwrite = function() {
        return this.session.getOverwrite();
    };
    this.toggleOverwrite = function() {
        this.session.toggleOverwrite();
    };
    this.setScrollSpeed = function(speed) {
        this.setOption("scrollSpeed", speed);
    };
    this.getScrollSpeed = function() {
        return this.getOption("scrollSpeed");
    };
    this.setDragDelay = function(dragDelay) {
        this.setOption("dragDelay", dragDelay);
    };
    this.getDragDelay = function() {
        return this.getOption("dragDelay");
    };
    this.setSelectionStyle = function(val) {
        this.setOption("selectionStyle", val);
    };
    this.getSelectionStyle = function() {
        return this.getOption("selectionStyle");
    };
    this.setHighlightActiveLine = function(shouldHighlight) {
        this.setOption("highlightActiveLine", shouldHighlight);
    };
    this.getHighlightActiveLine = function() {
        return this.getOption("highlightActiveLine");
    };
    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };
    this.setHighlightSelectedWord = function(shouldHighlight) {
        this.setOption("highlightSelectedWord", shouldHighlight);
    };
    this.getHighlightSelectedWord = function() {
        return this.$highlightSelectedWord;
    };

    this.setAnimatedScroll = function(shouldAnimate){
        this.renderer.setAnimatedScroll(shouldAnimate);
    };

    this.getAnimatedScroll = function(){
        return this.renderer.getAnimatedScroll();
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.renderer.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.renderer.getShowInvisibles();
    };

    this.setDisplayIndentGuides = function(display) {
        this.renderer.setDisplayIndentGuides(display);
    };

    this.getDisplayIndentGuides = function() {
        return this.renderer.getDisplayIndentGuides();
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.renderer.getShowPrintMargin();
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.renderer.getPrintMarginColumn();
    };
    this.setReadOnly = function(readOnly) {
        this.setOption("readOnly", readOnly);
    };
    this.getReadOnly = function() {
        return this.getOption("readOnly");
    };
    this.setBehavioursEnabled = function (enabled) {
        this.setOption("behavioursEnabled", enabled);
    };
    this.getBehavioursEnabled = function () {
        return this.getOption("behavioursEnabled");
    };
    this.setWrapBehavioursEnabled = function (enabled) {
        this.setOption("wrapBehavioursEnabled", enabled);
    };
    this.getWrapBehavioursEnabled = function () {
        return this.getOption("wrapBehavioursEnabled");
    };
    this.setShowFoldWidgets = function(show) {
        this.setOption("showFoldWidgets", show);

    };
    this.getShowFoldWidgets = function() {
        return this.getOption("showFoldWidgets");
    };

    this.setFadeFoldWidgets = function(fade) {
        this.setOption("fadeFoldWidgets", fade);
    };

    this.getFadeFoldWidgets = function() {
        return this.getOption("fadeFoldWidgets");
    };
    this.remove = function(dir) {
        if (this.selection.isEmpty()){
            if (dir == "left")
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.removeWordRight = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeWordLeft = function() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineStart = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    };
    this.removeToLineEnd = function() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    };
    this.splitLine = function() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert("\n");
        this.moveCursorToPosition(cursor);
    };
    this.transposeLetters = function() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column-1);
            range = new Range(cursor.row, column-1, cursor.row, column+1);
        }
        else {
            swap = line.charAt(column-1) + line.charAt(column-2);
            range = new Range(cursor.row, column-2, cursor.row, column);
        }
        this.session.replace(range, swap);
        this.session.selection.moveToPosition(range.end);
    };
    this.toLowerCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.toUpperCase = function() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    };
    this.indent = function() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
        } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "\t");
                return;
            }
        }
        
        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
        } else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
        }
        return this.insert(indentString);
    };
    this.blockIndent = function() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, "\t");
    };
    this.blockOutdent = function() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    };
    this.sortLines = function() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (var i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i-rows.first]);
        }
    };
    this.toggleCommentLines = function() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    };

    this.toggleBlockComment = function() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    };
    this.getNumberAt = function(row, column) {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if(m.index <= column && m.index+m[0].length >= column){
                var number = {
                    value: m[0],
                    start: m.index,
                    end: m.index+m[0].length
                };
                return number;
            }
        }
        return null;
    };
    this.modifyNumber = function(amount) {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;
        var charRange = new Range(row, column-1, row, column);

        var c = this.session.getTextRange(charRange);
        if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if(fp !== nr.end && column < fp){
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

            }
        }
    };
    this.removeLines = function() {
        var rows = this.$getSelectedRows();
        this.session.removeFullLines(rows.first, rows.last);
        this.clearSelection();
    };

    this.duplicateSelection = function() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    };
    this.moveLinesDown = function() {
        this.$moveLines(1, false);
    };
    this.moveLinesUp = function() {
        this.$moveLines(-1, false);
    };
    this.moveText = function(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    };
    this.copyLinesUp = function() {
        this.$moveLines(-1, true);
    };
    this.copyLinesDown = function() {
        this.$moveLines(1, true);
    };
    this.$moveLines = function(dir, copy) {
        var rows, moved;
        var selection = this.selection;
        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1) moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
        } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                    var subRows = this.$getSelectedRows(ranges[i]);
                    if (copy && subRows.first != last)
                        break;
                    else if (!copy && subRows.first > last + 1)
                        break;
                    last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1) rangeIndex = i + 1;
                while (rangeIndex <= i) {
                    ranges[rangeIndex].moveBy(diff, 0);
                    rangeIndex++;
                }
                if (!copy) diff = 0;
                totalDiff += diff;
            }
            
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
        }
    };
    this.$getSelectedRows = function(range) {
        range = (range || this.getSelectionRange()).collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    };

    this.onCompositionStart = function(text) {
        this.renderer.showComposition(this.getCursorPosition());
    };

    this.onCompositionUpdate = function(text) {
        this.renderer.setCompositionText(text);
    };

    this.onCompositionEnd = function() {
        this.renderer.hideComposition();
    };
    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };
    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };
    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };
    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };
    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };

    this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = dir * Math.floor(config.height / config.lineHeight);

        this.$blockScrolling++;
        if (select === true) {
            this.selection.$moveSelection(function(){
                this.moveCursorBy(rows, 0);
            });
        } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        this.$blockScrolling--;

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    };
    this.selectPageDown = function() {
        this.$moveByPage(1, true);
    };
    this.selectPageUp = function() {
        this.$moveByPage(-1, true);
    };
    this.gotoPageDown = function() {
       this.$moveByPage(1, false);
    };
    this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
    };
    this.scrollPageDown = function() {
        this.$moveByPage(1);
    };
    this.scrollPageUp = function() {
        this.$moveByPage(-1);
    };
    this.scrollToRow = function(row) {
        this.renderer.scrollToRow(row);
    };
    this.scrollToLine = function(line, center, animate, callback) {
        this.renderer.scrollToLine(line, center, animate, callback);
    };
    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    };
    this.getCursorPosition = function() {
        return this.selection.getCursor();
    };
    this.getCursorPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCursorPosition());
    };
    this.getSelectionRange = function() {
        return this.selection.getRange();
    };
    this.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    };
    this.clearSelection = function() {
        this.selection.clearSelection();
    };
    this.moveCursorTo = function(row, column) {
        this.selection.moveCursorTo(row, column);
    };
    this.moveCursorToPosition = function(pos) {
        this.selection.moveCursorToPosition(pos);
    };
    this.jumpToMatching = function(select, expand) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken || iterator.stepForward();

        if (!token) return;
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
        };
        
        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case '(':
                        case '[':
                        case '{':
                            depth[bracketType]++;
                            break;
                        case ')':
                        case ']':
                        case '}':
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = 'bracket';
                                found = true;
                            }
                        break;
                    }
                }
            }
            else if (token && token.type.indexOf('tag-name') !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }
                
                if (prevToken.value === '<') {
                    depth[token.value]++;
                }
                else if (prevToken.value === '</') {
                    depth[token.value]--;
                }
                
                if (depth[token.value] === -1) {
                    matchType = 'tag';
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token && !found);
        if (!matchType)
            return;

        var range, pos;
        if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1
                );
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    range = this.session.getBracketRange(pos);
            }
        }
        else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1) 
                var tag = token.value;
            else
                return;

            range = new Range(
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2
            );
            if (range.compare(cursor.row, cursor.column) === 0) {
                found = false;
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();
                    
                    if (prevToken) {
                        if (prevToken.type.indexOf('tag-close') !== -1) {
                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                        }

                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                            if (prevToken.value === '<') {
                                depth[tag]++;
                            }
                            else if (prevToken.value === '</') {
                                depth[tag]--;
                            }
                            
                            if (depth[tag] === 0)
                                found = true;
                        }
                    }
                } while (prevToken && !found);
            }
            if (token && token.type.indexOf('tag-name')) {
                pos = range.start;
                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                    pos = range.end;
            }
        }

        pos = range && range.cursor || pos;
        if (pos) {
            if (select) {
                if (range && expand) {
                    this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                    this.clearSelection();
                } else {
                    this.selection.selectTo(pos.row, pos.column);
                }
            } else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    };
    this.gotoLine = function(lineNumber, column, animate) {
        this.selection.clearSelection();
        this.session.unfold({row: lineNumber - 1, column: column || 0});

        this.$blockScrolling += 1;
        this.exitMultiSelectMode && this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        this.$blockScrolling -= 1;

        if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
    };
    this.navigateTo = function(row, column) {
        this.selection.moveTo(row, column);
    };
    this.navigateUp = function(times) {
        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    };
    this.navigateDown = function(times) {
        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    };
    this.navigateLeft = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    };
    this.navigateRight = function(times) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    };
    this.navigateLineStart = function() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    };
    this.navigateLineEnd = function() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    };
    this.navigateFileEnd = function() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    };
    this.navigateFileStart = function() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    };
    this.navigateWordRight = function() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    };
    this.navigateWordLeft = function() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    };
    this.replace = function(replacement, options) {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
        }

        return replaced;
    };
    this.replaceAll = function(replacement, options) {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        this.$blockScrolling += 1;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i >= 0; --i) {
            if(this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;

        return replaced;
    };

    this.$tryReplace = function(range, replacement) {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    };
    this.getLastSearchOptions = function() {
        return this.$search.getOptions();
    };
    this.find = function(needle, options, animate) {
        if (!options)
            options = {};

        if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == "object")
            oop.mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range)
                || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({start: range});

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    };
    this.findNext = function(options, animate) {
        this.find({skipCurrent: true, backwards: false}, options, animate);
    };
    this.findPrevious = function(options, animate) {
        this.find(options, {skipCurrent: true, backwards: true}, animate);
    };

    this.revealRange = function(range, animate) {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    };
    this.undo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.redo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    };
    this.destroy = function() {
        this.renderer.destroy();
        this._signal("destroy", this);
        if (this.session) {
            this.session.destroy();
        }
    };
    this.setAutoScrollEditorIntoView = function(enable) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused()
                || self.searchBox && self.searchBox.isFocused())
            ) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.lineHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
        };
    };


    this.$resetCursorStyle = function() {
        var style = this.$cursorStyle || "ace";
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer)
            return;
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
    };

}).call(Editor.prototype);



config.defineOptions(Editor.prototype, "editor", {
    selectionStyle: {
        set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
        },
        initialValue: "line"
    },
    highlightActiveLine: {
        set: function() {this.$updateHighlightActiveLine();},
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {this.$onSelectionChange();},
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            this.$resetCursorStyle(); 
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) { this.$resetCursorStyle(); },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
    },
    mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
    },
    behavioursEnabled: {initialValue: true},
    wrapBehavioursEnabled: {initialValue: true},
    autoScrollEditorIntoView: {
        set: function(val) {this.setAutoScrollEditorIntoView(val);}
    },
    keyboardHandler: {
        set: function(val) { this.setKeyboardHandler(val); },
        get: function() { return this.keybindingId; },
        handlesSet: true
    },

    hScrollBarAlwaysVisible: "renderer",
    vScrollBarAlwaysVisible: "renderer",
    highlightGutterLine: "renderer",
    animatedScroll: "renderer",
    showInvisibles: "renderer",
    showPrintMargin: "renderer",
    printMarginColumn: "renderer",
    printMargin: "renderer",
    fadeFoldWidgets: "renderer",
    showFoldWidgets: "renderer",
    showLineNumbers: "renderer",
    showGutter: "renderer",
    displayIndentGuides: "renderer",
    fontSize: "renderer",
    fontFamily: "renderer",
    maxLines: "renderer",
    minLines: "renderer",
    scrollPastEnd: "renderer",
    fixedWidthGutter: "renderer",
    theme: "renderer",

    scrollSpeed: "$mouseHandler",
    dragDelay: "$mouseHandler",
    dragEnabled: "$mouseHandler",
    focusTimout: "$mouseHandler",
    tooltipFollowsMouse: "$mouseHandler",

    firstLineNumber: "session",
    overwrite: "session",
    newLineMode: "session",
    useWorker: "session",
    useSoftTabs: "session",
    tabSize: "session",
    wrap: "session",
    indentedSoftWrap: "session",
    foldStyle: "session",
    mode: "session"
});

exports.Editor = Editor;
});

ace.define("ace/undomanager",["require","exports","module"], function(acequire, exports, module) {
var UndoManager = function() {
    this.reset();
};

(function() {
    this.execute = function(options) {
        var deltaSets = options.args[0];
        this.$doc  = options.args[1];
        if (options.merge && this.hasUndo()){
            this.dirtyCounter--;
            deltaSets = this.$undoStack.pop().concat(deltaSets);
        }
        this.$undoStack.push(deltaSets);
        this.$redoStack = [];
        if (this.dirtyCounter < 0) {
            this.dirtyCounter = NaN;
        }
        this.dirtyCounter++;
    };
    this.undo = function(dontSelect) {
        var deltaSets = this.$undoStack.pop();
        var undoSelectionRange = null;
        if (deltaSets) {
            undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
            this.$redoStack.push(deltaSets);
            this.dirtyCounter--;
        }

        return undoSelectionRange;
    };
    this.redo = function(dontSelect) {
        var deltaSets = this.$redoStack.pop();
        var redoSelectionRange = null;
        if (deltaSets) {
            redoSelectionRange =
                this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
            this.$undoStack.push(deltaSets);
            this.dirtyCounter++;
        }
        return redoSelectionRange;
    };
    this.reset = function() {
        this.$undoStack = [];
        this.$redoStack = [];
        this.dirtyCounter = 0;
    };
    this.hasUndo = function() {
        return this.$undoStack.length > 0;
    };
    this.hasRedo = function() {
        return this.$redoStack.length > 0;
    };
    this.markClean = function() {
        this.dirtyCounter = 0;
    };
    this.isClean = function() {
        return this.dirtyCounter === 0;
    };
    this.$serializeDeltas = function(deltaSets) {
        return cloneDeltaSetsObj(deltaSets, $serializeDelta);
    };
    this.$deserializeDeltas = function(deltaSets) {
        return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
    };
    
    function $serializeDelta(delta){
        return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines.length == 1 ? null : delta.lines,
            text: delta.lines.length == 1 ? delta.lines[0] : null
        };
    }
        
    function $deserializeDelta(delta) {
        return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines || [delta.text]
        };
    }
    
    function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
        var deltaSets_new = new Array(deltaSets_old.length);
        for (var i = 0; i < deltaSets_old.length; i++) {
            var deltaSet_old = deltaSets_old[i];
            var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length)};
            
            for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                var delta_old = deltaSet_old.deltas[j];
                deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
            }
            
            deltaSets_new[i] = deltaSet_new;
        }
        return deltaSets_new;
    }
    
}).call(UndoManager.prototype);

exports.UndoManager = UndoManager;
});

ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter"], function(acequire, exports, module) {

var dom = acequire("../lib/dom");
var oop = acequire("../lib/oop");
var lang = acequire("../lib/lang");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var Gutter = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_gutter-layer";
    parentEl.appendChild(this.element);
    this.setShowFoldWidgets(this.$showFoldWidgets);
    
    this.gutterWidth = 0;

    this.$annotations = [];
    this.$updateAnnotations = this.$updateAnnotations.bind(this);

    this.$cells = [];
};

(function() {

    oop.implement(this, EventEmitter);

    this.setSession = function(session) {
        if (this.session)
            this.session.removeEventListener("change", this.$updateAnnotations);
        this.session = session;
        if (session)
            session.on("change", this.$updateAnnotations);
    };

    this.addGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
        this.session.addGutterDecoration(row, className);
    };

    this.removeGutterDecoration = function(row, className){
        if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
        this.session.removeGutterDecoration(row, className);
    };

    this.setAnnotations = function(annotations) {
        this.$annotations = [];
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
                rowInfo = this.$annotations[row] = {text: []};
           
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

            if (rowInfo.text.indexOf(annoText) === -1)
                rowInfo.text.push(annoText);

            var type = annotation.type;
            if (type == "error")
                rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
                rowInfo.className = " ace_info";
        }
    };

    this.$updateAnnotations = function (delta) {
        if (!this.$annotations.length)
            return;
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) ; else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
        } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
        }
    };

    this.update = function(config) {
        var session = this.session;
        var firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineNumber = 0;
        
        var gutterRenderer = session.gutterRenderer || this.$renderer;

        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (this.$cells.length > index + 1) {
                    cell = this.$cells.pop();
                    this.element.removeChild(cell.element);
                }
                break;
            }

            cell = this.$cells[++index];
            if (!cell) {
                cell = {element: null, textNode: null, foldWidget: null};
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode('');
                cell.element.appendChild(cell.textNode);
                this.element.appendChild(cell.element);
                this.$cells[index] = cell;
            }

            var className = "ace_gutter-cell ";
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (this.$annotations[row])
                className += this.$annotations[row].className;
            if (cell.element.className != className)
                cell.element.className = className;

            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
                cell.element.style.height = height;

            if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                if (!cell.foldWidget) {
                    cell.foldWidget = dom.createElement("span");
                    cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (cell.foldWidget.className != className)
                    cell.foldWidget.className = className;

                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                    cell.foldWidget.style.height = height;
            } else {
                if (cell.foldWidget) {
                    cell.element.removeChild(cell.foldWidget);
                    cell.foldWidget = null;
                }
            }
            
            var text = lastLineNumber = gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber;
            if (text !== cell.textNode.data)
                cell.textNode.data = text;

            row++;
        }

        this.element.style.height = config.minHeight + "px";

        if (this.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineNumber, config)
            : lastLineNumber.toString().length * config.characterWidth;
        
        var padding = this.$padding || this.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
        }
    };

    this.$fixedWidth = false;
    
    this.$showLineNumbers = true;
    this.$renderer = "";
    this.setShowLineNumbers = function(show) {
        this.$renderer = !show && {
            getWidth: function() {return "";},
            getText: function() {return "";}
        };
    };
    
    this.getShowLineNumbers = function() {
        return this.$showLineNumbers;
    };
    
    this.$showFoldWidgets = true;
    this.setShowFoldWidgets = function(show) {
        if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
        else
            dom.removeCssClass(this.element, "ace_folding-enabled");

        this.$showFoldWidgets = show;
        this.$padding = null;
    };
    
    this.getShowFoldWidgets = function() {
        return this.$showFoldWidgets;
    };

    this.$computePadding = function() {
        if (!this.element.firstChild)
            return {left: 0, right: 0};
        var style = dom.computedStyle(this.element.firstChild);
        this.$padding = {};
        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
        this.$padding.right = parseInt(style.paddingRight) || 0;
        return this.$padding;
    };

    this.getRegion = function(point) {
        var padding = this.$padding || this.$computePadding();
        var rect = this.element.getBoundingClientRect();
        if (point.x < padding.left + rect.left)
            return "markers";
        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
    };

}).call(Gutter.prototype);

exports.Gutter = Gutter;

});

ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(acequire, exports, module) {

var Range = acequire("../range").Range;
var dom = acequire("../lib/dom");

var Marker = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_marker-layer";
    parentEl.appendChild(this.element);
};

(function() {

    this.$padding = 0;

    this.setPadding = function(padding) {
        this.$padding = padding;
    };
    this.setSession = function(session) {
        this.session = session;
    };
    
    this.setMarkers = function(markers) {
        this.markers = markers;
    };

    this.update = function(config) {
        if (!config) return;

        this.config = config;


        var html = [];
        for (var key in this.markers) {
            var marker = this.markers[key];

            if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
            }

            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty()) continue;

            range = range.toScreenRange(this.session);
            if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + (this.session.$bidiHandler.isBidiRow(range.start.row)
                    ? this.session.$bidiHandler.getPosLeft(range.start.column)
                    : range.start.column * config.characterWidth);
                marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
                if (marker.type == "text")
                    this.drawTextMarker(html, range, marker.clazz, config);
                else
                    this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
                if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
                    this.drawBidiSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                } else {
                    this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                }
            }
        }
        this.element.innerHTML = html.join("");
    };

    this.$getTop = function(row, layerConfig) {
        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
    };

    function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
        var session = this.session;
        var start = range.start.row;
        var end = range.end.row;
        var row = start;
        var prev = 0; 
        var curr = 0;
        var next = session.getScreenLastRowColumn(row);
        var clazzModified = null;
        var lineRange = new Range(row, range.start.column, row, curr);
        for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            clazzModified = clazz + (row == start  ? " ace_start" : "") + " ace_br"
                + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end);

            if (this.session.$bidiHandler.isBidiRow(row)) {
                this.drawBidiSingleLineMarker(stringBuilder, lineRange, clazzModified,
                    layerConfig, row == end ? 0 : 1, extraStyle);
            } else {
                this.drawSingleLineMarker(stringBuilder, lineRange, clazzModified,
                    layerConfig, row == end ? 0 : 1, extraStyle);
            }
        }
    };
    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var padding = this.$padding;
        var height, top, left;
        extraStyle = extraStyle || "";
       if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
           var range1 = range.clone();
           range1.end.row = range1.start.row;
           range1.end.column = this.session.getLine(range1.start.row).length;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
        } else {
           height = config.lineHeight;
           top = this.$getTop(range.start.row, config);
           left = padding + range.start.column * config.characterWidth;
           stringBuilder.push(
               "<div class='", clazz, " ace_br1 ace_start' style='",
               "height:", height, "px;",
               "right:0;",
               "top:", top, "px;",
               "left:", left, "px;", extraStyle, "'></div>"
           );
        }
        if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
           var range1 = range.clone();
           range1.start.row = range1.end.row;
           range1.start.column = 0;
           this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
        } else {
           var width = range.end.column * config.characterWidth;
           height = config.lineHeight;
           top = this.$getTop(range.end.row, config);
           stringBuilder.push(
               "<div class='", clazz, " ace_br12' style='",
               "height:", height, "px;",
               "width:", width, "px;",
               "top:", top, "px;",
               "left:", padding, "px;", extraStyle, "'></div>"
           );
        }
        height = (range.end.row - range.start.row - 1) * config.lineHeight;
        if (height <= 0)
            return;
        top = this.$getTop(range.start.row + 1, config);
        
        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);

        stringBuilder.push(
            "<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='",
            "height:", height, "px;",
            "right:0;",
            "top:", top, "px;",
            "left:", padding, "px;", extraStyle, "'></div>"
        );
    };
    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight;
        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

        var top = this.$getTop(range.start.row, config);
        var left = this.$padding + range.start.column * config.characterWidth;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "width:", width, "px;",
            "top:", top, "px;",
            "left:", left, "px;", extraStyle || "", "'></div>"
        );
    };
    this.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
        var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
        var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);

        selections.forEach(function(selection) {
            stringBuilder.push(
                "<div class='", clazz, "' style='",
                "height:", height, "px;",
                "width:", selection.width + (extraLength || 0), "px;",
                "top:", top, "px;",
                "left:", padding + selection.left, "px;", extraStyle || "", "'></div>"
            );
        });
    };

    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;
        if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };
    
    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
        var top = this.$getTop(range.start.row, config);
        var height = config.lineHeight;

        stringBuilder.push(
            "<div class='", clazz, "' style='",
            "height:", height, "px;",
            "top:", top, "px;",
            "left:0;right:0;", extraStyle || "", "'></div>"
        );
    };

}).call(Marker.prototype);

exports.Marker = Marker;

});

ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("../lib/oop");
var dom = acequire("../lib/dom");
var lang = acequire("../lib/lang");
var useragent = acequire("../lib/useragent");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var Text = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_text-layer";
    parentEl.appendChild(this.element);
    this.$updateEolChar = this.$updateEolChar.bind(this);
};

(function() {

    oop.implement(this, EventEmitter);

    this.EOF_CHAR = "\xB6";
    this.EOL_CHAR_LF = "\xAC";
    this.EOL_CHAR_CRLF = "\xa4";
    this.EOL_CHAR = this.EOL_CHAR_LF;
    this.TAB_CHAR = "\u2014"; //"\u21E5";
    this.SPACE_CHAR = "\xB7";
    this.$padding = 0;

    this.$updateEolChar = function() {
        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
           ? this.EOL_CHAR_LF
           : this.EOL_CHAR_CRLF;
        if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
        }
    };

    this.setPadding = function(padding) {
        this.$padding = padding;
        this.element.style.padding = "0 " + padding + "px";
    };

    this.getLineHeight = function() {
        return this.$fontMetrics.$characterSize.height || 0;
    };

    this.getCharacterWidth = function() {
        return this.$fontMetrics.$characterSize.width || 0;
    };
    
    this.$setFontMetrics = function(measure) {
        this.$fontMetrics = measure;
        this.$fontMetrics.on("changeCharacterSize", function(e) {
            this._signal("changeCharacterSize", e);
        }.bind(this));
        this.$pollSizeChanges();
    };

    this.checkForSizeChanges = function() {
        this.$fontMetrics.checkForSizeChanges();
    };
    this.$pollSizeChanges = function() {
        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
    };
    this.setSession = function(session) {
        this.session = session;
        if (session)
            this.$computeTabString();
    };

    this.showInvisibles = false;
    this.setShowInvisibles = function(showInvisibles) {
        if (this.showInvisibles == showInvisibles)
            return false;

        this.showInvisibles = showInvisibles;
        this.$computeTabString();
        return true;
    };

    this.displayIndentGuides = true;
    this.setDisplayIndentGuides = function(display) {
        if (this.displayIndentGuides == display)
            return false;

        this.displayIndentGuides = display;
        this.$computeTabString();
        return true;
    };

    this.$tabStrings = [];
    this.onChangeTabSize =
    this.$computeTabString = function() {
        var tabSize = this.session.getTabSize();
        this.tabSize = tabSize;
        var tabStr = this.$tabStrings = [0];
        for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
                    + lang.stringRepeat(this.TAB_CHAR, i)
                    + "</span>");
            } else {
                tabStr.push(lang.stringRepeat(" ", i));
            }
        }
        if (this.displayIndentGuides) {
            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = "";
            var tabClass = "";
            if (this.showInvisibles) {
                className += " ace_invisible";
                spaceClass = " ace_invisible_space";
                tabClass = " ace_invisible_tab";
                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
            } else {
                var spaceContent = lang.stringRepeat(" ", this.tabSize);
                var tabContent = spaceContent;
            }

            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
        }
    };

    this.updateLines = function(config, firstRow, lastRow) {
        if (this.config.lastRow != config.lastRow ||
            this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
        }
        this.config = config;

        var first = Math.max(firstRow, config.firstRow);
        var last = Math.min(lastRow, config.lastRow);

        var lineElements = this.element.childNodes;
        var lineElementsIdx = 0;

        for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
                if (foldLine.containsRow(first)) {
                    first = foldLine.start.row;
                    break;
                } else {
                    row = foldLine.end.row;
                }
            }
            lineElementsIdx ++;
        }

        var row = first;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > last)
                break;

            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
                var html = [];
                this.$renderLine(
                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
                );
                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                lineElement.innerHTML = html.join("");
            }
            row++;
        }
    };

    this.scrollLines = function(config) {
        var oldConfig = this.config;
        this.config = config;

        if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);

        if (config.lastRow < oldConfig.firstRow)
            return this.update(config);

        var el = this.element;
        if (oldConfig.firstRow < config.firstRow)
            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
                el.removeChild(el.firstChild);

        if (oldConfig.lastRow > config.lastRow)
            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
                el.removeChild(el.lastChild);

        if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
                el.insertBefore(fragment, el.firstChild);
            else
                el.appendChild(fragment);
        }

        if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
        }
    };

    this.$renderLinesFragment = function(config, firstRow, lastRow) {
        var fragment = this.element.ownerDocument.createDocumentFragment();
        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
                break;

            var container = dom.createElement("div");

            var html = [];
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
                container.className = 'ace_line_group';
                fragment.appendChild(container);
                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

            } else {
                while(container.firstChild)
                    fragment.appendChild(container.firstChild);
            }

            row++;
        }
        return fragment;
    };

    this.update = function(config) {
        this.config = config;

        var html = [];
        var firstRow = config.firstRow, lastRow = config.lastRow;

        var row = firstRow;
        var foldLine = this.session.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (true) {
            if (row > foldStart) {
                row = foldLine.end.row+1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row :Infinity;
            }
            if (row > lastRow)
                break;

            if (this.$useLineGroups())
                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>");

            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

            if (this.$useLineGroups())
                html.push("</div>"); // end the line group

            row++;
        }
        this.element.innerHTML = html.join("");
    };

    this.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
    };

    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
        var self = this;
        var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (a) {
                return self.showInvisibles
                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
                    : c;
            } else if (c == "&") {
                return "&#38;";
            } else if (c == "<") {
                return "&#60;";
            } else if (c == ">") {
                return "&#62;";
            } else if (c == "\t") {
                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                screenColumn += tabSize - 1;
                return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                var space = self.showInvisibles ? self.SPACE_CHAR : "";
                screenColumn += 1;
                return "<span class='" + classToUse + "' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + space + "</span>";
            } else if (b) {
                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
                screenColumn += 1;
                return "<span class='ace_cjk' style='width:" +
                    (self.config.characterWidth * 2) +
                    "px'>" + c + "</span>";
            }
        };

        var output = value.replace(replaceReg, replaceFunc);

        if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
        }
        else {
            stringBuilder.push(output);
        }
        return screenColumn + value.length;
    };

    this.renderIndentGuide = function(stringBuilder, value, max) {
        var cols = value.search(this.$indentGuideRe);
        if (cols <= 0 || cols >= max)
            return value;
        if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
            return value.substr(cols);
        } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
        }
        return value;
    };

    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
        var chars = 0;
        var split = 0;
        var splitChars = splits[0];
        var screenColumn = 0;

        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(stringBuilder, value, splitChars);
                if (!value)
                    continue;
                chars -= value.length;
            }

            if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                chars += value.length;
            } else {
                while (chars + value.length >= splitChars) {
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn,
                        token, value.substring(0, splitChars - chars)
                    );
                    value = value.substring(splitChars - chars);
                    chars = splitChars;

                    if (!onlyContents) {
                        stringBuilder.push("</div>",
                            "<div class='ace_line' style='height:",
                            this.config.lineHeight, "px'>"
                        );
                    }

                    stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));

                    split ++;
                    screenColumn = 0;
                    splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                    chars += value.length;
                    screenColumn = this.$renderToken(
                        stringBuilder, screenColumn, token, value
                    );
                }
            }
        }
    };

    this.$renderSimpleLine = function(stringBuilder, tokens) {
        var screenColumn = 0;
        var token = tokens[0];
        var value = token.value;
        if (this.displayIndentGuides)
            value = this.renderIndentGuide(stringBuilder, value);
        if (value)
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
        }
    };
    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
        if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);

        if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
        else
            var tokens = this.session.getTokens(row);


        if (!onlyContents) {
            stringBuilder.push(
                "<div class='ace_line' style='height:", 
                    this.config.lineHeight * (
                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
                    ), "px'>"
            );
        }

        if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length)
                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
            else
                this.$renderSimpleLine(stringBuilder, tokens);
        }

        if (this.showInvisibles) {
            if (foldLine)
                row = foldLine.end.row;

            stringBuilder.push(
                "<span class='ace_invisible ace_invisible_eol'>",
                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
                "</span>"
            );
        }
        if (!onlyContents)
            stringBuilder.push("</div>");
    };

    this.$getFoldLineTokens = function(row, foldLine) {
        var session = this.session;
        var renderTokens = [];

        function addTokens(tokens, from, to) {
            var idx = 0, col = 0;
            while ((col + tokens[idx].value.length) < from) {
                col += tokens[idx].value.length;
                idx++;

                if (idx == tokens.length)
                    return;
            }
            if (col != from) {
                var value = tokens[idx].value.substring(from - col);
                if (value.length > (to - from))
                    value = value.substring(0, to - from);

                renderTokens.push({
                    type: tokens[idx].type,
                    value: value
                });

                col = from + value.length;
                idx += 1;
            }

            while (col < to && idx < tokens.length) {
                var value = tokens[idx].value;
                if (value.length + col > to) {
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                } else
                    renderTokens.push(tokens[idx]);
                col += value.length;
                idx += 1;
            }
        }

        var tokens = session.getTokens(row);
        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
                renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
            } else {
                if (isNewRow)
                    tokens = session.getTokens(row);

                if (tokens.length)
                    addTokens(tokens, lastColumn, column);
            }
        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

        return renderTokens;
    };

    this.$useLineGroups = function() {
        return this.session.getUseWrapMode();
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
        delete this.$measureNode;
    };

}).call(Text.prototype);

exports.Text = Text;

});

ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {

var dom = acequire("../lib/dom");
var isIE8;

var Cursor = function(parentEl) {
    this.element = dom.createElement("div");
    this.element.className = "ace_layer ace_cursor-layer";
    parentEl.appendChild(this.element);
    
    if (isIE8 === undefined)
        isIE8 = !("opacity" in this.element.style);

    this.isVisible = false;
    this.isBlinking = true;
    this.blinkInterval = 1000;
    this.smoothBlinking = false;

    this.cursors = [];
    this.cursor = this.addCursor();
    dom.addCssClass(this.element, "ace_hidden-cursors");
    this.$updateCursors = (isIE8
        ? this.$updateVisibility
        : this.$updateOpacity).bind(this);
};

(function() {
    
    this.$updateVisibility = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.visibility = val ? "" : "hidden";
    };
    this.$updateOpacity = function(val) {
        var cursors = this.cursors;
        for (var i = cursors.length; i--; )
            cursors[i].style.opacity = val ? "" : "0";
    };
    

    this.$padding = 0;
    this.setPadding = function(padding) {
        this.$padding = padding;
    };

    this.setSession = function(session) {
        this.session = session;
    };

    this.setBlinking = function(blinking) {
        if (blinking != this.isBlinking){
            this.isBlinking = blinking;
            this.restartTimer();
        }
    };

    this.setBlinkInterval = function(blinkInterval) {
        if (blinkInterval != this.blinkInterval){
            this.blinkInterval = blinkInterval;
            this.restartTimer();
        }
    };

    this.setSmoothBlinking = function(smoothBlinking) {
        if (smoothBlinking != this.smoothBlinking && !isIE8) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.$updateCursors = (this.$updateOpacity).bind(this);
            this.restartTimer();
        }
    };

    this.addCursor = function() {
        var el = dom.createElement("div");
        el.className = "ace_cursor";
        this.element.appendChild(el);
        this.cursors.push(el);
        return el;
    };

    this.removeCursor = function() {
        if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
        }
    };

    this.hideCursor = function() {
        this.isVisible = false;
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.showCursor = function() {
        this.isVisible = true;
        dom.removeCssClass(this.element, "ace_hidden-cursors");
        this.restartTimer();
    };

    this.restartTimer = function() {
        var update = this.$updateCursors;
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
        if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
        }
        
        update(true);

        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
            return;

        if (this.smoothBlinking) {
            setTimeout(function(){
                dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
        }
        
        var blink = function(){
            this.timeoutId = setTimeout(function() {
                update(false);
            }, 0.6 * this.blinkInterval);
        }.bind(this);

        this.intervalId = setInterval(function() {
            update(true);
            blink();
        }, this.blinkInterval);

        blink();
    };

    this.getPixelPosition = function(position, onScreen) {
        if (!this.config || !this.session)
            return {left : 0, top : 0};

        if (!position)
            position = this.session.selection.getCursor();
        var pos = this.session.documentToScreenPosition(position);
        var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
            ? this.session.$bidiHandler.getPosLeft(pos.column)
            : pos.column * this.config.characterWidth);

        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
            this.config.lineHeight;

        return {left : cursorLeft, top : cursorTop};
    };

    this.update = function(config) {
        this.config = config;

        var selections = this.session.$selectionMarkers;
        var i = 0, cursorIndex = 0;

        if (selections === undefined || selections.length === 0){
            selections = [{cursor: null}];
        }

        for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset ||
                 pixelPos.top < 0) && i > 1) {
                continue;
            }

            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
            
            if (!this.drawCursor) {
                style.left = pixelPos.left + "px";
                style.top = pixelPos.top + "px";
                style.width = config.characterWidth + "px";
                style.height = config.lineHeight + "px";
            } else {
                this.drawCursor(style, pixelPos, config, selections[i], this.session);
            }
        }
        while (this.cursors.length > cursorIndex)
            this.removeCursor();

        var overwrite = this.session.getOverwrite();
        this.$setOverwrite(overwrite);
        this.$pixelPos = pixelPos;
        this.restartTimer();
    };
    
    this.drawCursor = null;

    this.$setOverwrite = function(overwrite) {
        if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
        }
    };

    this.destroy = function() {
        clearInterval(this.intervalId);
        clearTimeout(this.timeoutId);
    };

}).call(Cursor.prototype);

exports.Cursor = Cursor;

});

ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var event = acequire("./lib/event");
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var MAX_SCROLL_H = 0x8000;
var ScrollBar = function(parent) {
    this.element = dom.createElement("div");
    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

    this.inner = dom.createElement("div");
    this.inner.className = "ace_scrollbar-inner";
    this.element.appendChild(this.inner);

    parent.appendChild(this.element);

    this.setVisible(false);
    this.skipEvent = false;

    event.addListener(this.element, "scroll", this.onScroll.bind(this));
    event.addListener(this.element, "mousedown", event.preventDefault);
};

(function() {
    oop.implement(this, EventEmitter);

    this.setVisible = function(isVisible) {
        this.element.style.display = isVisible ? "" : "none";
        this.isVisible = isVisible;
        this.coeff = 1;
    };
}).call(ScrollBar.prototype);
var VScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollTop = 0;
    this.scrollHeight = 0;
    renderer.$scrollbarWidth = 
    this.width = dom.scrollbarWidth(parent.ownerDocument);
    this.inner.style.width =
    this.element.style.width = (this.width || 15) + 5 + "px";
    this.$minWidth = 0;
};

oop.inherits(VScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-v';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", {data: this.scrollTop});
        }
        this.skipEvent = false;
    };
    this.getWidth = function() {
        return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
    };
    this.setHeight = function(height) {
        this.element.style.height = height + "px";
    };
    this.setInnerHeight =
    this.setScrollHeight = function(height) {
        this.scrollHeight = height;
        if (height > MAX_SCROLL_H) {
            this.coeff = MAX_SCROLL_H / height;
            height = MAX_SCROLL_H;
        } else if (this.coeff != 1) {
            this.coeff = 1;
        }
        this.inner.style.height = height + "px";
    };
    this.setScrollTop = function(scrollTop) {
        if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
        }
    };

}).call(VScrollBar.prototype);
var HScrollBar = function(parent, renderer) {
    ScrollBar.call(this, parent);
    this.scrollLeft = 0;
    this.height = renderer.$scrollbarWidth;
    this.inner.style.height =
    this.element.style.height = (this.height || 15) + 5 + "px";
};

oop.inherits(HScrollBar, ScrollBar);

(function() {

    this.classSuffix = '-h';
    this.onScroll = function() {
        if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
        }
        this.skipEvent = false;
    };
    this.getHeight = function() {
        return this.isVisible ? this.height : 0;
    };
    this.setWidth = function(width) {
        this.element.style.width = width + "px";
    };
    this.setInnerWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollWidth = function(width) {
        this.inner.style.width = width + "px";
    };
    this.setScrollLeft = function(scrollLeft) {
        if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
        }
    };

}).call(HScrollBar.prototype);


exports.ScrollBar = VScrollBar; // backward compatibility
exports.ScrollBarV = VScrollBar; // backward compatibility
exports.ScrollBarH = HScrollBar; // backward compatibility

exports.VScrollBar = VScrollBar;
exports.HScrollBar = HScrollBar;
});

ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(acequire, exports, module) {

var event = acequire("./lib/event");


var RenderLoop = function(onRender, win) {
    this.onRender = onRender;
    this.pending = false;
    this.changes = 0;
    this.window = win || window;
};

(function() {


    this.schedule = function(change) {
        this.changes = this.changes | change;
        if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function() {
                _self.pending = false;
                var changes;
                while (changes = _self.changes) {
                    _self.changes = 0;
                    _self.onRender(changes);
                }
            }, this.window);
        }
    };

}).call(RenderLoop.prototype);

exports.RenderLoop = RenderLoop;
});

ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("../lib/oop");
var dom = acequire("../lib/dom");
var lang = acequire("../lib/lang");
var useragent = acequire("../lib/useragent");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

var CHAR_COUNT = 0;

var FontMetrics = exports.FontMetrics = function(parentEl) {
    this.el = dom.createElement("div");
    this.$setMeasureNodeStyles(this.el.style, true);
    
    this.$main = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$main.style);
    
    this.$measureNode = dom.createElement("div");
    this.$setMeasureNodeStyles(this.$measureNode.style);
    
    
    this.el.appendChild(this.$main);
    this.el.appendChild(this.$measureNode);
    parentEl.appendChild(this.el);
    
    if (!CHAR_COUNT)
        this.$testFractionalRect();
    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
    
    this.$characterSize = {width: 0, height: 0};
    this.checkForSizeChanges();
};

(function() {

    oop.implement(this, EventEmitter);
        
    this.$characterSize = {width: 0, height: 0};
    
    this.$testFractionalRect = function() {
        var el = dom.createElement("div");
        this.$setMeasureNodeStyles(el.style);
        el.style.width = "0.2px";
        document.documentElement.appendChild(el);
        var w = el.getBoundingClientRect().width;
        if (w > 0 && w < 1)
            CHAR_COUNT = 50;
        else
            CHAR_COUNT = 100;
        el.parentNode.removeChild(el);
    };
    
    this.$setMeasureNodeStyles = function(style, isRoot) {
        style.width = style.height = "auto";
        style.left = style.top = "0px";
        style.visibility = "hidden";
        style.position = "absolute";
        style.whiteSpace = "pre";

        if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
        } else {
            style.font = "inherit";
        }
        style.overflow = isRoot ? "hidden" : "visible";
    };

    this.checkForSizeChanges = function() {
        var size = this.$measureSizes();
        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
        }
    };

    this.$pollSizeChanges = function() {
        if (this.$pollSizeChangesTimer)
            return this.$pollSizeChangesTimer;
        var self = this;
        return this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
        }, 500);
    };
    
    this.setPolling = function(val) {
        if (val) {
            this.$pollSizeChanges();
        } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
        }
    };

    this.$measureSizes = function() {
        if (CHAR_COUNT === 50) {
            var rect = null;
            try { 
               rect = this.$measureNode.getBoundingClientRect();
            } catch(e) {
               rect = {width: 0, height:0 };
            }
            var size = {
                height: rect.height,
                width: rect.width / CHAR_COUNT
            };
        } else {
            var size = {
                height: this.$measureNode.clientHeight,
                width: this.$measureNode.clientWidth / CHAR_COUNT
            };
        }
        if (size.width === 0 || size.height === 0)
            return null;
        return size;
    };

    this.$measureCharWidth = function(ch) {
        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
        var rect = this.$main.getBoundingClientRect();
        return rect.width / CHAR_COUNT;
    };
    
    this.getCharacterWidth = function(ch) {
        var w = this.charSizes[ch];
        if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
        }
        return w;
    };

    this.destroy = function() {
        clearInterval(this.$pollSizeChangesTimer);
        if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
    };

}).call(FontMetrics.prototype);

});

ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/lib/useragent","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var config = acequire("./config");
var useragent = acequire("./lib/useragent");
var GutterLayer = acequire("./layer/gutter").Gutter;
var MarkerLayer = acequire("./layer/marker").Marker;
var TextLayer = acequire("./layer/text").Text;
var CursorLayer = acequire("./layer/cursor").Cursor;
var HScrollBar = acequire("./scrollbar").HScrollBar;
var VScrollBar = acequire("./scrollbar").VScrollBar;
var RenderLoop = acequire("./renderloop").RenderLoop;
var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
.ace_text-input-ios {\
position: absolute !important;\
top: -100000px !important;\
left: -100000px !important;\
}\
";

dom.importCssString(editorCss, "ace_editor.css");

var VirtualRenderer = function(container, theme) {
    var _self = this;

    this.container = container || dom.createElement("div");
    this.$keepTextAreaAtCursor = !useragent.isOldIE;

    dom.addCssClass(this.container, "ace_editor");

    this.setTheme(theme);

    this.$gutter = dom.createElement("div");
    this.$gutter.className = "ace_gutter";
    this.container.appendChild(this.$gutter);
    this.$gutter.setAttribute("aria-hidden", true);

    this.scroller = dom.createElement("div");
    this.scroller.className = "ace_scroller";
    this.container.appendChild(this.scroller);

    this.content = dom.createElement("div");
    this.content.className = "ace_content";
    this.scroller.appendChild(this.content);

    this.$gutterLayer = new GutterLayer(this.$gutter);
    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

    this.$markerBack = new MarkerLayer(this.content);

    var textLayer = this.$textLayer = new TextLayer(this.content);
    this.canvas = textLayer.element;

    this.$markerFront = new MarkerLayer(this.content);

    this.$cursorLayer = new CursorLayer(this.content);
    this.$horizScroll = false;
    this.$vScroll = false;

    this.scrollBar = 
    this.scrollBarV = new VScrollBar(this.container, this);
    this.scrollBarH = new HScrollBar(this.container, this);
    this.scrollBarV.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
    });
    this.scrollBarH.addEventListener("scroll", function(e) {
        if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
    });

    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.cursorPos = {
        row : 0,
        column : 0
    };

    this.$fontMetrics = new FontMetrics(this.container);
    this.$textLayer.$setFontMetrics(this.$fontMetrics);
    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
        _self.updateCharacterSize();
        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
        _self._signal("changeCharacterSize", e);
    });

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0,
        $dirty: true
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 0,
        characterWidth : 0,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1,
        gutterOffset: 1
    };
    
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);

    this.updateCharacterSize();
    this.setPadding(4);
    config.resetOptions(this);
    config._emit("renderer", this);
};

(function() {

    this.CHANGE_CURSOR = 1;
    this.CHANGE_MARKER = 2;
    this.CHANGE_GUTTER = 4;
    this.CHANGE_SCROLL = 8;
    this.CHANGE_LINES = 16;
    this.CHANGE_TEXT = 32;
    this.CHANGE_SIZE = 64;
    this.CHANGE_MARKER_BACK = 128;
    this.CHANGE_MARKER_FRONT = 256;
    this.CHANGE_FULL = 512;
    this.CHANGE_H_SCROLL = 1024;

    oop.implement(this, EventEmitter);

    this.updateCharacterSize = function() {
        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
        }

        this.layerConfig.characterWidth =
        this.characterWidth = this.$textLayer.getCharacterWidth();
        this.layerConfig.lineHeight =
        this.lineHeight = this.$textLayer.getLineHeight();
        this.$updatePrintMargin();
    };
    this.setSession = function(session) {
        if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            
        this.session = session;
        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);

        this.$cursorLayer.setSession(session);
        this.$markerBack.setSession(session);
        this.$markerFront.setSession(session);
        this.$gutterLayer.setSession(session);
        this.$textLayer.setSession(session);
        if (!session)
            return;
        
        this.$loop.schedule(this.CHANGE_FULL);
        this.session.$setFontMetrics(this.$fontMetrics);
        this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
        
        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
        this.onChangeNewLineMode();
        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
    };
    this.updateLines = function(firstRow, lastRow, force) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }
        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
                return;
        }
        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
        this.$loop.schedule(this.CHANGE_LINES);
    };

    this.onChangeNewLineMode = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
        this.$textLayer.$updateEolChar();
        this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
    };
    
    this.onChangeTabSize = function() {
        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
        this.$textLayer.onChangeTabSize();
    };
    this.updateText = function() {
        this.$loop.schedule(this.CHANGE_TEXT);
    };
    this.updateFull = function(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    this.updateFontSize = function() {
        this.$textLayer.checkForSizeChanges();
    };

    this.$changes = 0;
    this.$updateSizeAsync = function() {
        if (this.$loop.pending)
            this.$size.$dirty = true;
        else
            this.onResize();
    };
    this.onResize = function(force, gutterWidth, width, height) {
        if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

        
        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$gutterLayer.$padding = null;

        if (force)
            this.$renderChanges(changes | this.$changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
    };
    
    this.$updateCachedSize = function(force, gutterWidth, width, height) {
        height -= (this.$extraHeight || 0);
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;

            size.scrollerHeight = size.height;
            if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

            changes = changes | this.CHANGE_SCROLL;
        }

        if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            
            if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            
            this.gutterWidth = gutterWidth;
            
            this.scrollBarH.element.style.left = 
            this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
            
            this.scrollBarH.element.style.right = 
            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                changes |= this.CHANGE_FULL;
        }
        
        size.$dirty = !width || !height;

        if (changes)
            this._signal("resize", oldSize);

        return changes;
    };

    this.onGutterResize = function() {
        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
        if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
        } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
        }
    };
    this.adjustWrapLimit = function() {
        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
        var limit = Math.floor(availableWidth / this.characterWidth);
        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
    };
    this.setAnimatedScroll = function(shouldAnimate){
        this.setOption("animatedScroll", shouldAnimate);
    };
    this.getAnimatedScroll = function() {
        return this.$animatedScroll;
    };
    this.setShowInvisibles = function(showInvisibles) {
        this.setOption("showInvisibles", showInvisibles);
        this.session.$bidiHandler.setShowInvisibles(showInvisibles);
    };
    this.getShowInvisibles = function() {
        return this.getOption("showInvisibles");
    };
    this.getDisplayIndentGuides = function() {
        return this.getOption("displayIndentGuides");
    };

    this.setDisplayIndentGuides = function(display) {
        this.setOption("displayIndentGuides", display);
    };
    this.setShowPrintMargin = function(showPrintMargin) {
        this.setOption("showPrintMargin", showPrintMargin);
    };
    this.getShowPrintMargin = function() {
        return this.getOption("showPrintMargin");
    };
    this.setPrintMarginColumn = function(showPrintMargin) {
        this.setOption("printMarginColumn", showPrintMargin);
    };
    this.getPrintMarginColumn = function() {
        return this.getOption("printMarginColumn");
    };
    this.getShowGutter = function(){
        return this.getOption("showGutter");
    };
    this.setShowGutter = function(show){
        return this.setOption("showGutter", show);
    };

    this.getFadeFoldWidgets = function(){
        return this.getOption("fadeFoldWidgets");
    };

    this.setFadeFoldWidgets = function(show) {
        this.setOption("fadeFoldWidgets", show);
    };

    this.setHighlightGutterLine = function(shouldHighlight) {
        this.setOption("highlightGutterLine", shouldHighlight);
    };

    this.getHighlightGutterLine = function() {
        return this.getOption("highlightGutterLine");
    };

    this.$updateGutterLineHighlight = function() {
        var pos = this.$cursorLayer.$pixelPos;
        var height = this.layerConfig.lineHeight;
        if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
        }
        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
        this.$gutterLineHighlight.style.height = height + "px";
    };

    this.$updatePrintMargin = function() {
        if (!this.$showPrintMargin && !this.$printMarginEl)
            return;

        if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
        }

        var style = this.$printMarginEl.style;
        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
        
        if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
    };
    this.getContainerElement = function() {
        return this.container;
    };
    this.getMouseEventTarget = function() {
        return this.scroller;
    };
    this.getTextAreaContainer = function() {
        return this.container;
    };
    this.$moveTextAreaToCursor = function() {
        if (!this.$keepTextAreaAtCursor)
            return;
        var config = this.layerConfig;
        var posTop = this.$cursorLayer.$pixelPos.top;
        var posLeft = this.$cursorLayer.$pixelPos.left;
        posTop -= config.offset;

        var style = this.textarea.style;
        var h = this.lineHeight;
        if (posTop < 0 || posTop > config.height - h) {
            style.top = style.left = "0";
            return;
        }

        var w = this.characterWidth;
        if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= (this.session.$getStringScreenWidth(val)[0]+2);
            h += 2;
        }
        posLeft -= this.scrollLeft;
        if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;

        posLeft += this.gutterWidth;
        style.height = h + "px";
        style.width = w + "px";
        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
        style.top = Math.min(posTop, this.$size.height - h) + "px";
    };
    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };
    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };
    this.getLastFullyVisibleRow = function() {
        var config = this.layerConfig;
        var lastRow = config.lastRow;
        var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
        if (top - this.session.getScrollTop() > config.height - config.lineHeight)
            return lastRow - 1;
        return lastRow;
    };
    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };

    this.$padding = null;
    this.setPadding = function(padding) {
        this.$padding = padding;
        this.$textLayer.setPadding(padding);
        this.$cursorLayer.setPadding(padding);
        this.$markerFront.setPadding(padding);
        this.$markerBack.setPadding(padding);
        this.$loop.schedule(this.CHANGE_FULL);
        this.$updatePrintMargin();
    };
    
    this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
        this.updateFull();
    };
    this.getHScrollBarAlwaysVisible = function() {
        return this.$hScrollBarAlwaysVisible;
    };
    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
    };
    this.getVScrollBarAlwaysVisible = function() {
        return this.$vScrollBarAlwaysVisible;
    };
    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
    };

    this.$updateScrollBarV = function() {
        var scrollHeight = this.layerConfig.maxHeight;
        var scrollerHeight = this.$size.scrollerHeight;
        if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
            }
        }
        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };
    
    this.$frozen = false;
    this.freeze = function() {
        this.$frozen = true;
    };
    
    this.unfreeze = function() {
        this.$frozen = false;
    };

    this.$renderChanges = function(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return; 
        } 
        if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
        }
        if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
        }
        
        this._signal("beforeRender");

        if (this.session && this.session.$bidiHandler)
            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);

        var config = this.layerConfig;
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_TEXT ||
            changes & this.CHANGE_LINES ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL
        ) {
            changes |= this.$computeLayerConfig();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                if (st > 0) {
                    this.scrollTop = st;
                    changes = changes | this.CHANGE_SCROLL;
                    changes |= this.$computeLayerConfig();
                }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
            this.content.style.marginTop = (-config.offset) + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
        }
        if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
        }
        if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return;
        }
        if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config);
            else
                this.$textLayer.scrollLines(config);

            if (this.$showGutter)
                this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return;
        }

        if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                this.$gutterLayer.update(config);
        }
        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
                this.$gutterLayer.update(config);
        }

        if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
        }

        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
        }

        this._signal("afterRender");
    };

    
    this.$autosize = function() {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.min(maxHeight,
            Math.max((this.$minLines || 1) * this.lineHeight, height)
        ) + this.scrollMargin.v + (this.$extraHeight || 0);
        if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
        if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;
        var vScroll = height > maxHeight;
        
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            
            this._signal("autosize");
        }
    };
    
    this.$computeLayerConfig = function() {
        var session = this.session;
        var size = this.$size;
        
        var hideScrollbars = size.height <= 2 * this.lineHeight;
        var screenLines = this.session.getScreenLength();
        var maxHeight = screenLines * this.lineHeight;

        var longestLine = this.$getLongestLine();
        
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var offset = this.scrollTop % this.lineHeight;
        var minHeight = size.scrollerHeight + this.lineHeight;
        
        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
            : 0;
        maxHeight += scrollPastEnd;
        
        var sm = this.scrollMargin;
        this.session.setScrollTop(Math.max(-sm.top,
            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));

        this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, 
            longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
        
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
        var vScrollChanged = vScrollBefore !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }

        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
        var lastRow = firstRow + lineCount;
        var firstRowScreen, firstRowHeight;
        var lineHeight = this.lineHeight;
        firstRow = session.screenToDocumentRow(firstRow, 0);
        var foldLine = session.getFoldLine(firstRow);
        if (foldLine) {
            firstRow = foldLine.start.row;
        }

        firstRowScreen = session.documentToScreenRow(firstRow, 0);
        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                                                firstRowHeight;

        offset = this.scrollTop - firstRowScreen * lineHeight;

        var changes = 0;
        if (this.layerConfig.width != longestLine) 
            changes = this.CHANGE_H_SCROLL;
        if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
                longestLine = this.$getLongestLine();
        }
        
        this.layerConfig = {
            width : longestLine,
            padding : this.$padding,
            firstRow : firstRow,
            firstRowScreen: firstRowScreen,
            lastRow : lastRow,
            lineHeight : lineHeight,
            characterWidth : this.characterWidth,
            minHeight : minHeight,
            maxHeight : maxHeight,
            offset : offset,
            gutterOffset : lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height : this.$size.scrollerHeight
        };

        return changes;
    };

    this.$updateLines = function() {
        if (!this.$changedLines) return;
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }
        if (lastRow === Infinity) {
            if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
        }
        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
        return true;
    };

    this.$getLongestLine = function() {
        var charCount = this.session.getScreenWidth();
        if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;

        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
    };
    this.updateFrontMarkers = function() {
        this.$markerFront.setMarkers(this.session.getMarkers(true));
        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
    };
    this.updateBackMarkers = function() {
        this.$markerBack.setMarkers(this.session.getMarkers());
        this.$loop.schedule(this.CHANGE_MARKER_BACK);
    };
    this.addGutterDecoration = function(row, className){
        this.$gutterLayer.addGutterDecoration(row, className);
    };
    this.removeGutterDecoration = function(row, className){
        this.$gutterLayer.removeGutterDecoration(row, className);
    };
    this.updateBreakpoints = function(rows) {
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.setAnnotations = function(annotations) {
        this.$gutterLayer.setAnnotations(annotations);
        this.$loop.schedule(this.CHANGE_GUTTER);
    };
    this.updateCursor = function() {
        this.$loop.schedule(this.CHANGE_CURSOR);
    };
    this.hideCursor = function() {
        this.$cursorLayer.hideCursor();
    };
    this.showCursor = function() {
        this.$cursorLayer.showCursor();
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
        this.scrollCursorIntoView(anchor, offset);
        this.scrollCursorIntoView(lead, offset);
    };
    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
        if (this.$size.scrollerHeight === 0)
            return;

        var pos = this.$cursorLayer.getPixelPosition(cursor);

        var left = pos.left;
        var top = pos.top;
        
        var topMargin = $viewMargin && $viewMargin.top || 0;
        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
        
        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
        
        if (scrollTop + topMargin > top) {
            if (offset && scrollTop + topMargin > top + this.lineHeight)
                top -= offset * this.$size.scrollerHeight;
            if (top === 0)
                top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top -  this.lineHeight)
                top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
        }
    };
    this.getScrollTop = function() {
        return this.session.getScrollTop();
    };
    this.getScrollLeft = function() {
        return this.session.getScrollLeft();
    };
    this.getScrollTopRow = function() {
        return this.scrollTop / this.lineHeight;
    };
    this.getScrollBottomRow = function() {
        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };
    this.scrollToRow = function(row) {
        this.session.setScrollTop(row * this.lineHeight);
    };

    this.alignCursor = function(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var pos = this.$cursorLayer.getPixelPosition(cursor);
        var h = this.$size.scrollerHeight - this.lineHeight;
        var offset = pos.top - h * (alignment || 0);

        this.session.setScrollTop(offset);
        return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    };
    this.scrollToLine = function(line, center, animate, callback) {
        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
        var offset = pos.top;
        if (center)
            offset -= this.$size.scrollerHeight / 2;

        var initialScroll = this.scrollTop;
        this.session.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (!this.$animatedScroll)
            return;
        var _self = this;
        
        if (fromValue == toValue)
            return;
        
        if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                    return;
            }
        }
        
        var steps = _self.$calcSteps(fromValue, toValue);
        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

        clearInterval(this.$timer);

        _self.session.setScrollTop(steps.shift());
        _self.session.$scrollTop = toValue;
        this.$timer = setInterval(function() {
            if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
            } else {
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                callback && callback();
            }
        }, 10);
    };
    this.scrollToY = function(scrollTop) {
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };
    this.scrollToX = function(scrollLeft) {
        if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
        this.$loop.schedule(this.CHANGE_H_SCROLL);
    };
    this.scrollTo = function(x, y) {
        this.session.setScrollTop(y);
        this.session.setScrollLeft(y);
    };
    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
    };
    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
           return true;
        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
           return true;
        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
            - this.layerConfig.width < -1 + this.scrollMargin.right)
           return true;
    };

    this.pixelToScreenCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
        var offset = offsetX / this.characterWidth;
        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
        var col = Math.round(offset);

        return {row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX:  offsetX};
    };

    this.screenToTextCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;

        var col = Math.round(offsetX / this.characterWidth);

        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

        return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
    };
    this.textToScreenCoordinates = function(row, column) {
        var canvasPos = this.scroller.getBoundingClientRect();
        var pos = this.session.documentToScreenPosition(row, column);

        var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
             ? this.session.$bidiHandler.getPosLeft(pos.column)
             : Math.round(pos.column * this.characterWidth));

        var y = pos.row * this.lineHeight;

        return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
        };
    };
    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "ace_focus");
    };
    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "ace_focus");
    };
    this.showComposition = function(position) {
        if (!this.$composition)
            this.$composition = {
                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                cssText: this.textarea.style.cssText
            };

        this.$keepTextAreaAtCursor = true;
        dom.addCssClass(this.textarea, "ace_composition");
        this.textarea.style.cssText = "";
        this.$moveTextAreaToCursor();
    };
    this.setCompositionText = function(text) {
        this.$moveTextAreaToCursor();
    };
    this.hideComposition = function() {
        if (!this.$composition)
            return;

        dom.removeCssClass(this.textarea, "ace_composition");
        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
        this.textarea.style.cssText = this.$composition.cssText;
        this.$composition = null;
    };
    this.setTheme = function(theme, cb) {
        var _self = this;
        this.$themeId = theme;
        _self._dispatchEvent('themeChange',{theme:theme});

        if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
        } else {
            afterLoad(theme);
        }

        function afterLoad(module) {
            if (_self.$themeId != theme)
                return cb && cb();
            if (!module || !module.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
            dom.importCssString(
                module.cssText,
                module.cssClass,
                _self.container.ownerDocument
            );

            if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);

            var padding = "padding" in module ? module.padding 
                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
            _self.$theme = module.cssClass;

            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
            }

            _self._dispatchEvent('themeLoaded', {theme:module});
            cb && cb();
        }
    };
    this.getTheme = function() {
        return this.$themeId;
    };
    this.setStyle = function(style, include) {
        dom.setCssClass(this.container, style, include !== false);
    };
    this.unsetStyle = function(style) {
        dom.removeCssClass(this.container, style);
    };
    
    this.setCursorStyle = function(style) {
        if (this.scroller.style.cursor != style)
            this.scroller.style.cursor = style;
    };
    this.setMouseCursor = function(cursorStyle) {
        this.scroller.style.cursor = cursorStyle;
    };
    this.destroy = function() {
        this.$textLayer.destroy();
        this.$cursorLayer.destroy();
    };

}).call(VirtualRenderer.prototype);


config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn; 
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show);},
        initialValue: true
    },
    showLineNumbers: {
        set: function(show) {
            this.$gutterLayer.setShowLineNumbers(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
                this.$gutterLineHighlight = dom.createElement("div");
                this.$gutterLineHighlight.className = "ace_gutter-active-line";
                this.$gutter.appendChild(this.$gutterLineHighlight);
                return;
            }

            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            if (this.$cursorLayer.$pixelPos)
                this.$updateGutterLineHighlight();
        },
        initialValue: false,
        value: true
    },
    hScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    vScrollBarAlwaysVisible: {
        set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize:  {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    },
    maxLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    minLines: {
        set: function(val) {
            this.updateFull();
        }
    },
    maxPixelHeight: {
        set: function(val) {
            this.updateFull();
        },
        initialValue: 0
    },
    scrollPastEnd: {
        set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
                return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
    },
    fixedWidthGutter: {
        set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
        }
    },
    theme: {
        set: function(val) { this.setTheme(val); },
        get: function() { return this.$themeId || this.theme; },
        initialValue: "./theme/textmate",
        handlesSet: true
    }
});

exports.VirtualRenderer = VirtualRenderer;
});

ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(acequire, exports, module) {

var oop = acequire("../lib/oop");
var net = acequire("../lib/net");
var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
var config = acequire("../config");

function $workerBlob(workerUrl, mod) {
    var script = mod.src;"importScripts('" + net.qualifyURL(workerUrl) + "');";
    try {
        return new Blob([script], {"type": "application/javascript"});
    } catch (e) { // Backwards-compatibility
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob("application/javascript");
    }
}

function createWorker(workerUrl, mod) {
    var blob = $workerBlob(workerUrl, mod);
    var URL = window.URL || window.webkitURL;
    var blobURL = URL.createObjectURL(blob);
    return new Worker(blobURL);
}

var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.onMessage = this.onMessage.bind(this);
    if (acequire.nameToUrl && !acequire.toUrl)
        acequire.toUrl = acequire.nameToUrl;
    
    if (config.get("packaged") || !acequire.toUrl) {
        workerUrl = workerUrl || config.moduleUrl(mod.id, "worker");
    } else {
        var normalizePath = this.$normalizePath;
        workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));

        var tlns = {};
        topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
        });
    }

    this.$worker = createWorker(workerUrl, mod);
    if (importScripts) {
        this.send("importScripts", importScripts);
    }
    this.$worker.postMessage({
        init : true,
        tlns : tlns,
        module : mod.id,
        classname : classname
    });

    this.callbackId = 1;
    this.callbacks = {};

    this.$worker.onmessage = this.onMessage;
};

(function(){

    oop.implement(this, EventEmitter);

    this.onMessage = function(e) {
        var msg = e.data;
        switch (msg.type) {
            case "event":
                this._signal(msg.name, {data: msg.data});
                break;
            case "call":
                var callback = this.callbacks[msg.id];
                if (callback) {
                    callback(msg.data);
                    delete this.callbacks[msg.id];
                }
                break;
            case "error":
                this.reportError(msg.data);
                break;
            case "log":
                window.console && console.log && console.log.apply(console, msg.data);
                break;
        }
    };
    
    this.reportError = function(err) {
        window.console && console.error && console.error(err);
    };

    this.$normalizePath = function(path) {
        return net.qualifyURL(path);
    };

    this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker = null;
        if (this.$doc)
            this.$doc.off("change", this.changeListener);
        this.$doc = null;
    };

    this.send = function(cmd, args) {
        this.$worker.postMessage({command: cmd, args: args});
    };

    this.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };

    this.emit = function(event, data) {
        try {
            this.$worker.postMessage({event: event, data: {data: data.data}});
        }
        catch(ex) {
            console.error(ex.stack);
        }
    };

    this.attachToDocument = function(doc) {
        if (this.$doc)
            this.terminate();

        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener);
    };

    this.changeListener = function(delta) {
        if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
        else
            this.deltaQueue.push(delta.start, delta.end);
    };

    this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
        } else
            this.emit("change", {data: q});
    };

}).call(WorkerClient.prototype);


var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
    this.changeListener = this.changeListener.bind(this);
    this.callbackId = 1;
    this.callbacks = {};
    this.messageBuffer = [];

    var main = null;
    var emitSync = false;
    var sender = Object.create(EventEmitter);
    var _self = this;

    this.$worker = {};
    this.$worker.terminate = function() {};
    this.$worker.postMessage = function(e) {
        _self.messageBuffer.push(e);
        if (main) {
            if (emitSync)
                setTimeout(processNext);
            else
                processNext();
        }
    };
    this.setEmitSync = function(val) { emitSync = val; };

    var processNext = function() {
        var msg = _self.messageBuffer.shift();
        if (msg.command)
            main[msg.command].apply(main, msg.args);
        else if (msg.event)
            sender._signal(msg.event, msg.data);
    };

    sender.postMessage = function(msg) {
        _self.onMessage({data: msg});
    };
    sender.callback = function(data, callbackId) {
        this.postMessage({type: "call", id: callbackId, data: data});
    };
    sender.emit = function(name, data) {
        this.postMessage({type: "event", name: name, data: data});
    };

    config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (_self.messageBuffer.length)
            processNext();
    });
};

UIWorkerClient.prototype = WorkerClient.prototype;

exports.UIWorkerClient = UIWorkerClient;
exports.WorkerClient = WorkerClient;
exports.createWorker = createWorker;


});

ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(acequire, exports, module) {

var Range = acequire("./range").Range;
var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
var oop = acequire("./lib/oop");

var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
    var _self = this;
    this.length = length;
    this.session = session;
    this.doc = session.getDocument();
    this.mainClass = mainClass;
    this.othersClass = othersClass;
    this.$onUpdate = this.onUpdate.bind(this);
    this.doc.on("change", this.$onUpdate);
    this.$others = others;
    
    this.$onCursorChange = function() {
        setTimeout(function() {
            _self.onCursorChange();
        });
    };
    
    this.$pos = pos;
    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
    this.$undoStackDepth = undoStack.length;
    this.setup();

    session.selection.on("changeCursor", this.$onCursorChange);
};

(function() {

    oop.implement(this, EventEmitter);
    this.setup = function() {
        var _self = this;
        var doc = this.doc;
        var session = this.session;
        
        this.selectionBefore = session.selection.toJSON();
        if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();

        this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
        var pos = this.pos;
        pos.$insertRight = true;
        pos.detach();
        pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
        this.others = [];
        this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
        });
        session.setUndoSelect(false);
    };
    this.showOtherMarkers = function() {
        if (this.othersActive) return;
        var session = this.session;
        var _self = this;
        this.othersActive = true;
        this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
        });
    };
    this.hideOtherMarkers = function() {
        if (!this.othersActive) return;
        this.othersActive = false;
        for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
        }
    };
    this.onUpdate = function(delta) {
        if (this.$updating)
            return this.updateAnchors(delta);
            
        var range = delta;
        if (range.start.row !== range.end.row) return;
        if (range.start.row !== this.pos.row) return;
        this.$updating = true;
        var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
        var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
        var distanceFromStart = range.start.column - this.pos.column;
        
        this.updateAnchors(delta);
        
        if (inMainRange)
            this.length += lengthDiff;

        if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
            } else if (delta.action === 'remove') {
                for (var i = this.others.length - 1; i >= 0; i--) {
                    var otherPos = this.others[i];
                    var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
        }
        
        this.$updating = false;
        this.updateMarkers();
    };
    
    this.updateAnchors = function(delta) {
        this.pos.onChange(delta);
        for (var i = this.others.length; i--;)
            this.others[i].onChange(delta);
        this.updateMarkers();
    };
    
    this.updateMarkers = function() {
        if (this.$updating)
            return;
        var _self = this;
        var session = this.session;
        var updateMarker = function(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column+_self.length), className, null, false);
        };
        updateMarker(this.pos, this.mainClass);
        for (var i = this.others.length; i--;)
            updateMarker(this.others[i], this.othersClass);
    };

    this.onCursorChange = function(event) {
        if (this.$updating || !this.session) return;
        var pos = this.session.selection.getCursor();
        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
        } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
        }
    };    
    this.detach = function() {
        this.session.removeMarker(this.pos && this.pos.markerId);
        this.hideOtherMarkers();
        this.doc.removeEventListener("change", this.$onUpdate);
        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
        this.session.setUndoSelect(true);
        this.session = null;
    };
    this.cancel = function() {
        if (this.$undoStackDepth === -1)
            return;
        var undoManager = this.session.getUndoManager();
        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
        for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
        }
        if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
    };
}).call(PlaceHolder.prototype);


exports.PlaceHolder = PlaceHolder;
});

ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

var event = acequire("../lib/event");
var useragent = acequire("../lib/useragent");
function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}

function onMouseDown(e) {
    var ev = e.domEvent;
    var alt = ev.altKey;
    var shift = ev.shiftKey;
    var ctrl = ev.ctrlKey;
    var accel = e.getAccelKey();
    var button = e.getButton();
    
    if (ctrl && useragent.isMac)
        button = ev.button;

    if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
    }
    
    if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
        return;
    }
    
    if (button !== 0)
        return;

    var editor = e.editor;
    var selection = editor.selection;
    var isMultiSelect = editor.inMultiSelectMode;
    var pos = e.getDocumentPosition();
    var cursor = selection.getCursor();
    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

    var mouseX = e.x, mouseY = e.y;
    var onMouseSelection = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
    };
    
    var session = editor.session;
    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
    var screenCursor = screenAnchor;
    
    var selectionMode;
    if (editor.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
        else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
    } else {
        if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
                return;
        } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
        }
    }
    
    if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor.$mouseHandler.cancelContextMenu();
    }

    if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
            return; // dragging

        if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
        }

        var oldRange = selection.rangeList.rangeAtPoint(pos);
        
        
        editor.$blockScrolling++;
        editor.inVirtualSelectionMode = true;
        
        if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
        }
        editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();

            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                selection.substractPoint(tmpSel.cursor);
            else {
                if (shift) {
                    selection.substractPoint(range.cursor);
                } else if (range) {
                    editor.removeSelectionMarker(range);
                    selection.addRange(range);
                }
                selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
            editor.inVirtualSelectionMode = false;
        });

    } else if (selectionMode == "block") {
        e.stop();
        editor.inVirtualSelectionMode = true;        
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);

            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                return;
            screenCursor = newCursor;
            
            editor.$blockScrolling++;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();

            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
            editor.$blockScrolling--;
        };
        editor.$blockScrolling++;
        if (isMultiSelect && !accel) {
            selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
        }
        
        if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);            
        else
            selection.moveToPosition(pos);
        editor.$blockScrolling--;
        
        screenCursor = {row: -1, column: -1};

        var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
                rectSel = [selection.toOrientedRange()];
            editor.$blockScrolling++;
            if (initialRange) {
                editor.removeSelectionMarker(initialRange);
                selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
                selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
            editor.$blockScrolling--;
        };

        var onSelectionInterval = blockSelect;

        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {onSelectionInterval();}, 20);

        return e.preventDefault();
    }
}


exports.onMouseDown = onMouseDown;

});

ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(acequire, exports, module) {
exports.defaultCommands = [{
    name: "addCursorAbove",
    exec: function(editor) { editor.selectMoreLines(-1); },
    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelow",
    exec: function(editor) { editor.selectMoreLines(1); },
    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorAboveSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "addCursorBelowSkipCurrent",
    exec: function(editor) { editor.selectMoreLines(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreBefore",
    exec: function(editor) { editor.selectMore(-1); },
    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectMoreAfter",
    exec: function(editor) { editor.selectMore(1); },
    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextBefore",
    exec: function(editor) { editor.selectMore(-1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "selectNextAfter",
    exec: function(editor) { editor.selectMore(1, true); },
    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
    scrollIntoView: "cursor",
    readOnly: true
}, {
    name: "splitIntoLines",
    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
    readOnly: true
}, {
    name: "alignCursors",
    exec: function(editor) { editor.alignCursors(); },
    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
    scrollIntoView: "cursor"
}, {
    name: "findAll",
    exec: function(editor) { editor.findAll(); },
    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
    scrollIntoView: "cursor",
    readOnly: true
}];
exports.multiSelectCommands = [{
    name: "singleSelection",
    bindKey: "esc",
    exec: function(editor) { editor.exitMultiSelectMode(); },
    scrollIntoView: "cursor",
    readOnly: true,
    isAvailable: function(editor) {return editor && editor.inMultiSelectMode;}
}];

var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

});

ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(acequire, exports, module) {

var RangeList = acequire("./range_list").RangeList;
var Range = acequire("./range").Range;
var Selection = acequire("./selection").Selection;
var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
var event = acequire("./lib/event");
var lang = acequire("./lib/lang");
var commands = acequire("./commands/multi_select_commands");
exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
var Search = acequire("./search").Search;
var search = new Search();

function find(session, needle, dir) {
    search.$options.wrap = true;
    search.$options.needle = needle;
    search.$options.backwards = dir == -1;
    return search.find(session);
}
var EditSession = acequire("./edit_session").EditSession;
(function() {
    this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
    };
}).call(EditSession.prototype);
(function() {
    this.ranges = null;
    this.rangeList = null;
    this.addRange = function(range, $blockChangeEvents) {
        if (!range)
            return;

        if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
                this.rangeList.removeAll();
                return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
        }

        if (!range.cursor)
            range.cursor = range.end;

        var removed = this.rangeList.add(range);

        this.$onAddRange(range);

        if (removed.length)
            this.$onRemoveRange(removed);

        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
        }

        return $blockChangeEvents || this.fromOrientedRange(range);
    };

    this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
            this.$onRemoveRange(removed);

        range && this.fromOrientedRange(range);
    };
    this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
        }
    };
    this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
            this.$onRemoveRange(removed);
        else if(this.ranges[0])
            this.fromOrientedRange(this.ranges[0]);
    };

    this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", {range: range});
    };

    this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
        }

        for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
        }

        this._signal("removeRange", {ranges: removed});

        if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
        }

        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
    };
    this.$initRangeList = function() {
        if (this.rangeList)
            return;

        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
    };
    this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
    };

    this.splitIntoLines = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
                if (isBackwards)
                    var start = range.end, end = range.start;
                else
                    var start = range.start, end = range.end;
                
                this.addRange(Range.fromPoints(end, end));
                this.addRange(Range.fromPoints(start, start));
                return;
            }

            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);

            for (var i = startRow + 1; i < endRow; i++)
                rectSel.push(this.getLineRange(i, true));

            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);

            rectSel.forEach(this.addRange, this);
        }
    };
    this.toggleBlockSelection = function () {
        if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);

            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
        }
    };
    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];

        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
        } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
        }

        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
        } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
        }

        if (startColumn < 0)
            startColumn = 0;
        if (startRow < 0)
            startRow = 0;

        if (startRow == endRow)
            includeEmptyLines = true;

        for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(
                this.session.screenToDocumentPosition(row, startColumn, startOffsetX),
                this.session.screenToDocumentPosition(row, endColumn, endOffsetX)
            );
            if (range.isEmpty()) {
                if (docEnd && isSamePoint(range.end, docEnd))
                    break;
                var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
        }

        if (yBackwards)
            rectSel.reverse();

        if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
                end--;
            if (end > 0) {
                var start = 0;
                while (rectSel[start].isEmpty())
                    start++;
            }
            for (var i = end; i >= start; i--) {
                if (rectSel[i].isEmpty())
                    rectSel.splice(i, 1);
            }
        }

        return rectSel;
    };
}).call(Selection.prototype);
var Editor = acequire("./editor").Editor;
(function() {
    this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };
    this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;

        var style = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
    };
    this.removeSelectionMarker = function(range) {
        if (!range.marker)
            return;
        this.session.removeMarker(range.marker);
        var index = this.session.$selectionMarkers.indexOf(range);
        if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
    };

    this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
                continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
                markerList.splice(index, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
    };

    this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
            return;
        this.inMultiSelectMode = true;

        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
    };

    this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
            return;
        this.inMultiSelectMode = false;

        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
    };

    this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor = e.editor;
        if (!editor.multiSelect)
            return;
        if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
        } else {
            result = command.multiSelectAction(editor, e.args || {});
        }
        return result;
    }; 
    this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
            return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        
        if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};

        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--;) {
            if ($byLines) {
                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                    i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
                result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();

        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
        
        return result;
    };
    this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
        this.multiSelect.toSingleRange();
    };

    this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
                buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
                text = "";
        } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
    };
    
    this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                return;
            var pos = anchor == this.multiSelect.anchor
                ? range.cursor == range.start ? range.end : range.start
                : range.cursor;
            if (pos.row != anchor.row 
                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
        }
    };
    this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == undefined) {
            var range = this.selection.isEmpty()
                ? this.selection.getWordRange()
                : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
        }    
        this.$search.set(options);
        
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
            return 0;

        this.$blockScrolling += 1;
        var selection = this.multiSelect;

        if (!additive)
            selection.toSingleRange(ranges[0]);

        for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
        
        this.$blockScrolling -= 1;

        return ranges.length;
    };
    this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;

        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;

        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

        if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
            var anchor = lead;
        }

        if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
        } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
        }

        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
        } else {
            if (skip)
                var toRemove = range.cursor;
        }

        this.selection.addRange(newRange);
        if (toRemove)
            this.selection.substractPoint(toRemove);
    };
    this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;

        for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
                var tmp = session.getWordRange(range.start.row, range.start.column);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
                range.end.row = tmp.end.row;
                range.end.column = tmp.end.column;
            }
        }
        sel.mergeOverlappingRanges();

        var words = [];
        for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
        }

        if (dir < 0)
            words.unshift(words.pop());
        else
            words.push(words.shift());

        for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
        }
    };
    this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;

        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
                return;
        }
        var needle = session.getTextRange(range);

        var newRange = find(session, needle, dir);
        if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
            this.multiSelect.substractPoint(range.cursor);
    };
    this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
                return true;
            row = r.cursor.row;
        });
        
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
                var max = this.session.getLength();
                var line;
                do {
                    line = this.session.getLine(lr);
                } while (/[=:]/.test(line) && ++lr < max);
                do {
                    line = this.session.getLine(fr);
                } while (/[=:]/.test(line) && --fr > 0);
                
                if (fr < 0) fr = 0;
                if (lr >= max) lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({row: fr, column: 0}, lines.join("\n") + "\n");
            if (!guessRange) {
                range.start.column = 0;
                range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
        } else {
            sameRowRanges.forEach(function(r) {
                sel.substractPoint(r.cursor);
            });

            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
                var p = r.cursor;
                var line = session.getLine(p.row);
                var spaceOffset = line.substr(p.column).search(/\S/g);
                if (spaceOffset == -1)
                    spaceOffset = 0;

                if (p.column > maxCol)
                    maxCol = p.column;
                if (spaceOffset < minSpace)
                    minSpace = spaceOffset;
                return spaceOffset;
            });
            ranges.forEach(function(r, i) {
                var p = r.cursor;
                var l = maxCol - p.column;
                var d = spaceOffsets[i] - minSpace;
                if (l > d)
                    session.insert(p, lang.stringRepeat(" ", l - d));
                else
                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

                r.start.column = r.end.column = maxCol;
                r.start.row = r.end.row = p.row;
                r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        }
    };

    this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;

        return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
                return [line];

            if (startW == null) {
                startW = m[1].length;
                textW = m[2].length;
                endW = m[3].length;
                return m;
            }

            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                isRightAligned = false;
            if (startW != m[1].length)
                isLeftAligned = false;

            if (startW > m[1].length)
                startW = m[1].length;
            if (textW < m[2].length)
                textW = m[2].length;
            if (endW > m[3].length)
                endW = m[3].length;

            return m;
        }).map(forceLeft ? alignLeft :
            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

        function spaces(n) {
            return lang.stringRepeat(" ", n);
        }

        function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(textW - m[2].length + endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2]
                + spaces(endW)
                + m[4].replace(/^([=:])\s+/, "$1 ");
        }
    };
}).call(Editor.prototype);


function isSamePoint(p1, p2) {
    return p1.row == p2.row && p1.column == p2.column;
}
exports.onSessionChange = function(e) {
    var session = e.session;
    if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
    }
    this.multiSelect = session && session.multiSelect;

    var oldSession = e.oldSession;
    if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
    }

    if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
    }

    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
        else
            this.$onSingleSelect();
    }
};
function MultiSelect(editor) {
    if (editor.$multiselectOnSessionChange)
        return;
    editor.$onAddRange = editor.$onAddRange.bind(editor);
    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

    editor.$multiselectOnSessionChange(editor);
    editor.on("changeSession", editor.$multiselectOnSessionChange);

    editor.on("mousedown", onMouseDown);
    editor.commands.addCommands(commands.defaultCommands);

    addAltCursorListeners(editor);
}

function addAltCursorListeners(editor){
    var el = editor.textInput.getElement();
    var altCursor = false;
    event.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
                editor.renderer.setMouseCursor("crosshair");
                altCursor = true;
            }
        } else if (altCursor) {
            reset();
        }
    });

    event.addListener(el, "keyup", reset);
    event.addListener(el, "blur", reset);
    function reset(e) {
        if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
        }
    }
}

exports.MultiSelect = MultiSelect;


acequire("./config").defineOptions(Editor.prototype, "editor", {
    enableMultiselect: {
        set: function(val) {
            MultiSelect(this);
            if (val) {
                this.on("changeSession", this.$multiselectOnSessionChange);
                this.on("mousedown", onMouseDown);
            } else {
                this.off("changeSession", this.$multiselectOnSessionChange);
                this.off("mousedown", onMouseDown);
            }
        },
        value: true
    },
    enableBlockSelect: {
        set: function(val) {
            this.$blockSelectEnabled = val;
        },
        value: true
    }
});



});

ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(acequire, exports, module) {

var Range = acequire("../../range").Range;

var FoldMode = exports.FoldMode = function() {};

(function() {

    this.foldingStartMarker = null;
    this.foldingStopMarker = null;
    this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
            return "start";
        if (foldStyle == "markbeginend"
                && this.foldingStopMarker
                && this.foldingStopMarker.test(line))
            return "end";
        return "";
    };

    this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
    };

    this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
            return;

        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;

        while (++row < maxRow) {
            var level = session.getLine(row).search(re);

            if (level == -1)
                continue;

            if (level <= startLevel)
                break;

            endRow = row;
        }

        if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
        }
    };

    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = {row: row, column: column + 1};
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
            return;

        var fw = session.foldWidgets[end.row];
        if (fw == null)
            fw = session.getFoldWidget(end.row);

        if (fw == "start" && end.row > start.row) {
            end.row --;
            end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
    };

    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = {row: row, column: column};
        var start = session.$findOpeningBracket(bracket, end);

        if (!start)
            return;

        start.column++;
        end.column--;

        return  Range.fromPoints(start, end);
    };
}).call(FoldMode.prototype);

});

ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {

exports.isDark = false;
exports.cssClass = "ace-tm";
exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";

var dom = acequire("../lib/dom");
dom.importCssString(exports.cssText, exports.cssClass);
});

ace.define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"], function(acequire, exports, module) {

var oop = acequire("./lib/oop");
var dom = acequire("./lib/dom");
var Range = acequire("./range").Range;


function LineWidgets(session) {
    this.session = session;
    this.session.widgetManager = this;
    this.session.getRowLength = this.getRowLength;
    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
    this.updateOnChange = this.updateOnChange.bind(this);
    this.renderWidgets = this.renderWidgets.bind(this);
    this.measureWidgets = this.measureWidgets.bind(this);
    this.session._changedWidgets = [];
    this.$onChangeEditor = this.$onChangeEditor.bind(this);
    
    this.session.on("change", this.updateOnChange);
    this.session.on("changeFold", this.updateOnFold);
    this.session.on("changeEditor", this.$onChangeEditor);
}

(function() {
    this.getRowLength = function(row) {
        var h;
        if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
        else 
            h = 0;
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    };

    this.$getWidgetScreenLength = function() {
        var screenRows = 0;
        this.lineWidgets.forEach(function(w){
            if (w && w.rowCount && !w.hidden)
                screenRows += w.rowCount;
        });
        return screenRows;
    };    
    
    this.$onChangeEditor = function(e) {
        this.attach(e.editor);
    };
    
    this.attach = function(editor) {
        if (editor  && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();

        if (this.editor == editor)
            return;

        this.detach();
        this.editor = editor;
        
        if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
        }
    };
    this.detach = function(e) {
        var editor = this.editor;
        if (!editor)
            return;
        
        this.editor = null;
        editor.widgetManager = null;
        
        editor.renderer.off("beforeRender", this.measureWidgets);
        editor.renderer.off("afterRender", this.renderWidgets);
        var lineWidgets = this.session.lineWidgets;
        lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
                w._inDocument = false;
                w.el.parentNode.removeChild(w.el);
            }
        });
    };

    this.updateOnFold = function(e, session) {
        var lineWidgets = session.lineWidgets;
        if (!lineWidgets || !e.action)
            return;
        var fold = e.data;
        var start = fold.start.row;
        var end = fold.end.row;
        var hide = e.action == "add";
        for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
        }
        if (lineWidgets[end]) {
            if (hide) {
                if (!lineWidgets[start])
                    lineWidgets[start] = lineWidgets[end];
                else
                    lineWidgets[end].hidden = hide;
            } else {
                if (lineWidgets[start] == lineWidgets[end])
                    lineWidgets[start] = undefined;
                lineWidgets[end].hidden = hide;
            }
        }
    };
    
    this.updateOnChange = function(delta) {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        
        var startRow = delta.start.row;
        var len = delta.end.row - startRow;

        if (len === 0) ; else if (delta.action == 'remove') {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function(w) {
                w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
        } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
        }
    };
    
    this.$updateRows = function() {
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets) return;
        var noWidgets = true;
        lineWidgets.forEach(function(w, i) {
            if (w) {
                noWidgets = false;
                w.row = i;
                while (w.$oldWidget) {
                    w.$oldWidget.row = i;
                    w = w.$oldWidget;
                }
            }
        });
        if (noWidgets)
            this.session.lineWidgets = null;
    };

    this.addLineWidget = function(w) {
        if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
        
        var old = this.session.lineWidgets[w.row];
        if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
            }
        }
            
        this.session.lineWidgets[w.row] = w;
        
        w.session = this.session;
        
        var renderer = this.editor.renderer;
        if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
        }
        if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
        }
        
        if (!w.coverGutter) {
            w.el.style.zIndex = 3;
        }
        if (w.pixelHeight == null) {
            w.pixelHeight = w.el.offsetHeight;
        }
        if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
        }
        
        var fold = this.session.getFoldAt(w.row, 0);
        w.$fold = fold;
        if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w;
            else
                w.hidden = true;
        }
            
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        
        this.$updateRows();
        this.renderWidgets(null, renderer);
        this.onWidgetChanged(w);
        return w;
    };
    
    this.removeLineWidget = function(w) {
        w._inDocument = false;
        w.session = null;
        if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
        if (w.editor && w.editor.destroy) try {
            w.editor.destroy();
        } catch(e){}
        if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
                this.session.lineWidgets[w.row] = w.$oldWidget;
                if (w.$oldWidget)
                    this.onWidgetChanged(w.$oldWidget);
            } else {
                while (w1) {
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
        }
        this.session._emit("changeFold", {data:{start:{row: w.row}}});
        this.$updateRows();
    };
    
    this.getWidgetsAtRow = function(row) {
        var lineWidgets = this.session.lineWidgets;
        var w = lineWidgets && lineWidgets[row];
        var list = [];
        while (w) {
            list.push(w);
            w = w.$oldWidget;
        }
        return list;
    };
    
    this.onWidgetChanged = function(w) {
        this.session._changedWidgets.push(w);
        this.editor && this.editor.renderer.updateFull();
    };
    
    this.measureWidgets = function(e, renderer) {
        var changedWidgets = this.session._changedWidgets;
        var config = renderer.layerConfig;
        
        if (!changedWidgets || !changedWidgets.length) return;
        var min = Infinity;
        for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el) continue;
            if (w.session != this.session) continue;
            if (!w._inDocument) {
                if (this.session.lineWidgets[w.row] != w)
                    continue;
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            
            w.h = w.el.offsetHeight;
            
            if (!w.fixedWidth) {
                w.w = w.el.offsetWidth;
                w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
                rowCount -= this.session.getRowLineCount(w.row);
                if (rowCount < 0)
                    rowCount = 0;
            }
            if (w.rowCount != rowCount) {
                w.rowCount = rowCount;
                if (w.row < min)
                    min = w.row;
            }
        }
        if (min != Infinity) {
            this.session._emit("changeFold", {data:{start:{row: min}}});
            this.session.lineWidgetWidth = null;
        }
        this.session._changedWidgets = [];
    };
    
    this.renderWidgets = function(e, renderer) {
        var config = renderer.layerConfig;
        var lineWidgets = this.session.lineWidgets;
        if (!lineWidgets)
            return;
        var first = Math.min(this.firstRow, config.firstRow);
        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
        
        while (first > 0 && !lineWidgets[first])
            first--;
        
        this.firstRow = config.firstRow;
        this.lastRow = config.lastRow;

        renderer.$cursorLayer.config = config;
        for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el) continue;
            if (w.hidden) {
                w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                continue;
            }
            if (!w._inDocument) {
                w._inDocument = true;
                renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
            if (!w.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
                left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            
            if (w.fullWidth && w.screenWidth) {
                w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }
            
            if (w.fixedWidth) {
                w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
                w.el.style.right = "";
            }
        }
    };
    
}).call(LineWidgets.prototype);


exports.LineWidgets = LineWidgets;

});

ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(acequire, exports, module) {
var LineWidgets = acequire("../line_widgets").LineWidgets;
var dom = acequire("../lib/dom");
var Range = acequire("../range").Range;

function binarySearch(array, needle, comparator) {
    var first = 0;
    var last = array.length - 1;

    while (first <= last) {
        var mid = (first + last) >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
            first = mid + 1;
        else if (c < 0)
            last = mid - 1;
        else
            return mid;
    }
    return -(first + 1);
}

function findAnnotations(session, row, dir) {
    var annotations = session.getAnnotations().sort(Range.comparePoints);
    if (!annotations.length)
        return;
    
    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
    if (i < 0)
        i = -i - 1;
    
    if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
    else if (i === 0 && dir < 0)
        i = annotations.length - 1;
    
    var annotation = annotations[i];
    if (!annotation || !dir)
        return;

    if (annotation.row === row) {
        do {
            annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
            return annotations.slice();
    }
    
    
    var matched = [];
    row = annotation.row;
    do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
    } while (annotation && annotation.row == row);
    return matched.length && matched;
}

exports.showErrorMarker = function(editor, dir) {
    var session = editor.session;
    if (!session.widgetManager) {
        session.widgetManager = new LineWidgets(session);
        session.widgetManager.attach(editor);
    }
    
    var pos = editor.getCursorPosition();
    var row = pos.row;
    var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
        return w.type == "errorMarker";
    })[0];
    if (oldWidget) {
        oldWidget.destroy();
    } else {
        row -= dir;
    }
    var annotations = findAnnotations(session, row, dir);
    var gutterAnno;
    if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number"
            ? annotation.pos.sc
            : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
    } else if (oldWidget) {
        return;
    } else {
        gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
        };
    }
    editor.session.unfold(pos.row);
    editor.selection.moveToPosition(pos);
    
    var w = {
        row: pos.row, 
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
    };
    var el = w.el.appendChild(dom.createElement("div"));
    var arrow = w.el.appendChild(dom.createElement("div"));
    arrow.className = "error_widget_arrow " + gutterAnno.className;
    
    var left = editor.renderer.$cursorLayer
        .getPixelPosition(pos).left;
    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
    
    w.el.className = "error_widget_wrapper";
    el.className = "error_widget " + gutterAnno.className;
    el.innerHTML = gutterAnno.text.join("<br>");
    
    el.appendChild(dom.createElement("div"));
    
    var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
        }
    };
    
    w.destroy = function() {
        if (editor.$mouseHandler.isMousePressed)
            return;
        editor.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor.off("changeSelection", w.destroy);
        editor.off("changeSession", w.destroy);
        editor.off("mouseup", w.destroy);
        editor.off("change", w.destroy);
    };
    
    editor.keyBinding.addKeyboardHandler(kb);
    editor.on("changeSelection", w.destroy);
    editor.on("changeSession", w.destroy);
    editor.on("mouseup", w.destroy);
    editor.on("change", w.destroy);
    
    editor.session.widgetManager.addLineWidget(w);
    
    w.el.onmousedown = editor.focus.bind(editor);
    
    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
};


dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");

});

ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(acequire, exports, module) {

acequire("./lib/fixoldbrowsers");

var dom = acequire("./lib/dom");
var event = acequire("./lib/event");

var Editor = acequire("./editor").Editor;
var EditSession = acequire("./edit_session").EditSession;
var UndoManager = acequire("./undomanager").UndoManager;
var Renderer = acequire("./virtual_renderer").VirtualRenderer;
acequire("./worker/worker_client");
acequire("./keyboard/hash_handler");
acequire("./placeholder");
acequire("./multi_select");
acequire("./mode/folding/fold_mode");
acequire("./theme/textmate");
acequire("./ext/error_marker");

exports.config = acequire("./config");
exports.acequire = acequire;
exports.edit = function(el) {
    if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
            throw new Error("ace.edit can't find div #" + _id);
    }

    if (el && el.env && el.env.editor instanceof Editor)
        return el.env.editor;

    var value = "";
    if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
    } else if (el) {
        value = dom.getInnerText(el);
        el.innerHTML = "";
    }

    var doc = exports.createEditSession(value);

    var editor = new Editor(new Renderer(el));
    editor.setSession(doc);

    var env = {
        document: doc,
        editor: editor,
        onResize: editor.resize.bind(editor, null)
    };
    if (oldNode) env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie
    });
    editor.container.env = editor.env = env;
    return editor;
};
exports.createEditSession = function(text, mode) {
    var doc = new EditSession(text, mode);
    doc.setUndoManager(new UndoManager());
    return doc;
};
exports.EditSession = EditSession;
exports.UndoManager = UndoManager;
exports.version = "1.2.9";
});
            (function() {
                ace.acequire(["ace/ace"], function(a) {
                    if (a) {
                        a.config.init(true);
                        a.define = ace.define;
                    }
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                });
            })();
        
var brace = window.ace.acequire("ace/ace");

const zeaParamWidgetCodeCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-code{color:var(--color-foreground-1)}.editor-container{min-width:150px;min-height:100px}";

const ZeaParamWidgetCode = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    this.onInput = this.onInput.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Listen CTRL + s for save
   * @param {any} event the keydown event
   */
  keydownHandler(event) {
    if (event.ctrlKey && event.key == 's') {
      this.onInput();
      event.preventDefault();
    }
    else if (event.key == 'Enter' || event.keyCode == 46) {
      // on Enter or Backspace
      this.resetEditorHeight();
    }
    event.stopPropagation();
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    this.handleComponentUpdate();
    this.updateComponent();
  }
  /**
   * Set up ACE code input
   */
  async handleComponentUpdate() {
    this.editor = ace.edit(this.editorContainer);
    await import('./chrome.js');
    this.editor.setTheme('ace/theme/chrome');
    await import('./javascript.js').then(function (n) { return n.j; });
    this.editor.session.setMode('ace/mode/javascript');
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Input handler
   */
  onInput() {
    if (!globalThis.zeaEngine) {
      console.log('`zeaEngine` missing from `globalThis` object.');
      return;
    }
    const value = this.editor.getValue();
    this.handleUXChange(value);
    this.resetEditorHeight();
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    const change = new ParameterValueChange(this.parameter, value);
    undoRedoManager.addChange(change);
  }
  /**
   * Reset editor to content's height
   */
  resetEditorHeight() {
    /* this.editorHeight =
      this.editor.getSession().getScreenLength() *
        this.editor.renderer.lineHeight +
      this.editor.renderer.scroller.getWidth() +
      30 */
  }
  /**
   * Called after component render
   */
  componentDidRender() {
    if (this.editor)
      this.editor.resize();
  }
  /**
   * Value change handler
   */
  updateComponent() {
    if (!this.parameterChange) {
      this.editor.session.setValue(this.parameter.getValue());
    }
    this.resetEditorHeight();
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-param-widget-code" }, h$4("div", { style: { height: `${this.editorHeight}px` }, class: "editor-container", ref: (el) => (this.editorContainer = el) })));
  }
  static get style() { return zeaParamWidgetCodeCss; }
};
uxFactory.registerWidget('zea-param-widget-code', (p) => p.getDataType() === 'Box3' && 'getLanguage' in p);

/*!
 * iro.js v5.2.3
 * 2016-2020 James Daniel
 * Licensed under MPL 2.0
 * github.com/jaames/iro.js
 */

var n,u,t,i$1,r,o,f={},e=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;function s(n,l){for(var u in l){ n[u]=l[u]; }return n}function a(n){var l=n.parentNode;l&&l.removeChild(n);}function h(n,l,u){var t,i,r,o,f=arguments;if(l=s({},l),arguments.length>3){ for(u=[u],t=3;t<arguments.length;t++){ u.push(f[t]); } }if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps){ for(i in n.defaultProps){ void 0===l[i]&&(l[i]=n.defaultProps[i]); } }return o=l.key,null!=(r=l.ref)&&delete l.ref,null!=o&&delete l.key,v(n,l,o,r)}function v(l,u,t,i){var r={type:l,props:u,key:t,ref:i,__k:null,__p:null,__b:0,__e:null,l:null,__c:null,constructor:void 0};return n.vnode&&n.vnode(r),r}function d(n){return n.children}function y(n){if(null==n||"boolean"==typeof n){ return null; }if("string"==typeof n||"number"==typeof n){ return v(null,n,null,null); }if(null!=n.__e||null!=n.__c){var l=v(n.type,n.props,n.key,null);return l.__e=n.__e,l}return n}function m(n,l){this.props=n,this.context=l;}function w(n,l){if(null==l){ return n.__p?w(n.__p,n.__p.__k.indexOf(n)+1):null; }for(var u;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){ return u.__e; } }return "function"==typeof n.type?w(n):null}function g(n){var l,u;if(null!=(n=n.__p)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break} }return g(n)}}function k(l){(!l.__d&&(l.__d=!0)&&1===u.push(l)||i$1!==n.debounceRendering)&&(i$1=n.debounceRendering,(n.debounceRendering||t)(_));}function _(){var n,l,t,i,r,o,f,e;for(u.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u.pop();){ n.__d&&(t=void 0,i=void 0,o=(r=(l=n).__v).__e,f=l.__P,e=l.u,l.u=!1,f&&(t=[],i=$(f,r,s({},r),l.__n,void 0!==f.ownerSVGElement,null,t,e,null==o?w(r):o),j$1(t,r),i!=o&&g(r))); }}function b$1(n,l,u,t,i,r,o,c,s){var h,v,p,d,y,m,g,k=u&&u.__k||e,_=k.length;if(c==f&&(c=null!=r?r[0]:_?w(u,0):null),h=0,l.__k=x(l.__k,function(u){if(null!=u){if(u.__p=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type){ k[h]=void 0; }else { for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null;} }if(d=$(n,u,p=p||f,t,i,r,o,null,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[])).push(v,u.__c||d,u),null!=d){if(null==m&&(m=d),null!=u.l){ d=u.l,u.l=null; }else if(r==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n){ n.appendChild(d); }else {for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2){ if(y==d){ break n; } }n.insertBefore(d,c);}"option"==l.type&&(n.value="");}c=d.nextSibling,"function"==typeof l.type&&(l.l=d);}}return h++,u}),l.__e=m,null!=r&&"function"!=typeof l.type){ for(h=r.length;h--;){ null!=r[h]&&a(r[h]); } }for(h=_;h--;){ null!=k[h]&&D(k[h],k[h]); }if(g){ for(h=0;h<g.length;h++){ A(g[h],g[++h],g[++h]); } }}function x(n,l,u){if(null==u&&(u=[]),null==n||"boolean"==typeof n){ l&&u.push(l(null)); }else if(Array.isArray(n)){ for(var t=0;t<n.length;t++){ x(n[t],l,u); } }else { u.push(l?l(y(n)):n); }return u}function C(n,l,u,t,i){var r;for(r in u){ r in l||N(n,r,null,u[r],t); }for(r in l){ i&&"function"!=typeof l[r]||"value"===r||"checked"===r||u[r]===l[r]||N(n,r,l[r],u[r],t); }}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]="number"==typeof u&&!1===c$1.test(l)?u+"px":null==u?"":u;}function N(n,l,u,t,i){var r,o,f,e,c;if("key"===(l=i?"className"===l?"class":l:"class"===l?"className":l)||"children"===l);else if("style"===l){ if(r=n.style,"string"==typeof u){ r.cssText=u; }else {if("string"==typeof t&&(r.cssText="",t=null),t){ for(o in t){ u&&o in u||P(r,o,""); } }if(u){ for(f in u){ t&&u[f]===t[f]||P(r,f,u[f]); } }} }else { "o"===l[0]&&"n"===l[1]?(e=l!==(l=l.replace(/Capture$/,"")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(t||n.addEventListener(l,T,e),(n.t||(n.t={}))[l]=u):n.removeEventListener(l,T,e)):"list"!==l&&"tagName"!==l&&"form"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/^xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u)); }}function T(l){return this.t[l.type](n.event?n.event(l):l)}function $(l,u,t,i,r,o,f,e,c,a){var h,v,p,y,w,g,k,_,C,P,N=u.type;if(void 0!==u.constructor){ return null; }(h=n.__b)&&h(u);try{n:if("function"==typeof N){if(_=u.props,C=(h=N.contextType)&&i[h.__c],P=h?C?C.props.value:h.__p:i,t.__c?k=(v=u.__c=t.__c).__p=v.__E:("prototype"in N&&N.prototype.render?u.__c=v=new N(_,P):(u.__c=v=new m(_,P),v.constructor=N,v.render=H),C&&C.sub(v),v.props=_,v.state||(v.state={}),v.context=P,v.__n=i,p=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=N.getDerivedStateFromProps&&s(v.__s==v.state?v.__s=s({},v.__s):v.__s,N.getDerivedStateFromProps(_,v.__s)),p){ null==N.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&f.push(v); }else {if(null==N.getDerivedStateFromProps&&null==e&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(_,P),!e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(_,v.__s,P)){for(v.props=_,v.state=v.__s,v.__d=!1,v.__v=u,u.__e=null!=c?c!==t.__e?c:t.__e:null,u.__k=t.__k,h=0;h<u.__k.length;h++){ u.__k[h]&&(u.__k[h].__p=u); }break n}null!=v.componentWillUpdate&&v.componentWillUpdate(_,v.__s,P);}for(y=v.props,w=v.state,v.context=P,v.props=_,v.state=v.__s,(h=n.__r)&&h(u),v.__d=!1,v.__v=u,v.__P=l,h=v.render(v.props,v.state,v.context),u.__k=x(null!=h&&h.type==d&&null==h.key?h.props.children:h),null!=v.getChildContext&&(i=s(s({},i),v.getChildContext())),p||null==v.getSnapshotBeforeUpdate||(g=v.getSnapshotBeforeUpdate(y,w)),b$1(l,u,t,i,r,o,f,c,a),v.base=u.__e;h=v.__h.pop();){ v.__s&&(v.state=v.__s),h.call(v); }p||null==y||null==v.componentDidUpdate||v.componentDidUpdate(y,w,g),k&&(v.__E=v.__p=null);}else { u.__e=z(t.__e,u,t,i,r,o,f,a); }(h=n.diffed)&&h(u);}catch(l){n.__e(l,u,t);}return u.__e}function j$1(l,u){for(var t;t=l.pop();){ try{t.componentDidMount();}catch(l){n.__e(l,t.__v);} }n.__c&&n.__c(u);}function z(n,l,u,t,i,r,o,c){var s,a,h,v,p=u.props,d=l.props;if(i="svg"===l.type||i,null==n&&null!=r){ for(s=0;s<r.length;s++){ if(null!=(a=r[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,r[s]=null;break} } }if(null==n){if(null===l.type){ return document.createTextNode(d); }n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type),r=null;}return null===l.type?p!==d&&(null!=r&&(r[r.indexOf(n)]=null),n.data=d):l!==u&&(null!=r&&(r=e.slice.call(n.childNodes)),h=(p=u.props||f).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,c||(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||"")),C(n,d,p,i,c),l.__k=l.props.children,v||b$1(n,l,u,t,"foreignObject"!==l.type&&i,r,o,f,c),c||("value"in d&&void 0!==d.value&&d.value!==n.value&&(n.value=null==d.value?"":d.value),"checked"in d&&void 0!==d.checked&&d.checked!==n.checked&&(n.checked=d.checked))),n}function A(l,u,t){try{"function"==typeof l?l(u):l.current=u;}catch(l){n.__e(l,t);}}function D(l,u,t){var i,r,o;if(n.unmount&&n.unmount(l),(i=l.ref)&&A(i,null,u),t||"function"==typeof l.type||(t=null!=(r=l.__e)),l.__e=l.l=null,null!=(i=l.__c)){if(i.componentWillUnmount){ try{i.componentWillUnmount();}catch(l){n.__e(l,u);} }i.base=i.__P=null;}if(i=l.__k){ for(o=0;o<i.length;o++){ i[o]&&D(i[o],u,t); } }null!=r&&a(r);}function H(n,l,u){return this.constructor(n,u)}function I(l,u,t){var i,o,c;n.__p&&n.__p(l,u),o=(i=t===r)?null:t&&t.__k||u.__k,l=h(d,null,[l]),c=[],$(u,i?u.__k=l:(t||u).__k=l,o||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:o?null:e.slice.call(u.childNodes),c,!1,t||f,i),j$1(c,l);}n={},m.prototype.setState=function(n,l){var u=this.__s!==this.state&&this.__s||(this.__s=s({},this.state));("function"!=typeof n||(n=n(u,this.props)))&&s(u,n),null!=n&&this.__v&&(this.u=!1,l&&this.__h.push(l),k(this));},m.prototype.forceUpdate=function(n){this.__v&&(n&&this.__h.push(n),this.u=!0,k(this));},m.prototype.render=d,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,i$1=n.debounceRendering,n.__e=function(n,l,u){for(var t;l=l.__p;){ if((t=l.__c)&&!t.__p){ try{if(t.constructor&&null!=t.constructor.getDerivedStateFromError){ t.setState(t.constructor.getDerivedStateFromError(n)); }else {if(null==t.componentDidCatch){ continue; }t.componentDidCatch(n);}return k(t.__E=t)}catch(l){n=l;} } }throw n},r=f,o=0;

// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor
// https://github.com/bgrins/TinyColor
// Kelvin temperature math borrowed from Neil Barlett's implementation
// from https://github.com/neilbartlett/color-temperature
// https://www.w3.org/TR/css3-values/#integers
var CSS_INTEGER = '[-\\+]?\\d+%?'; // http://www.w3.org/TR/css3-values/#number-value

var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?'; // Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome

var CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')'; // Parse function params
// Parens and commas are optional, and this also allows for whitespace between numbers

var PERMISSIVE_MATCH_3 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
var PERMISSIVE_MATCH_4 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?'; // Regex patterns for functional color strings

var REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);
var REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);
var REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);
var REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4); // Color string parsing regex

var HEX_START = '^(?:#?|0x?)';
var HEX_INT_SINGLE = '([0-9a-fA-F]{1})';
var HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';
var REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');
var REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');
var REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');
var REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$'); // Kelvin temperature bounds

var KELVIN_MIN = 1000;
var KELVIN_MAX = 40000; // Math shorthands

var log = Math.log;
var round = Math.round;
var floor = Math.floor;
/**
 * @desc Clamp a number between a min and max value
 * @param num - input value
 * @param min - min allowed value
 * @param max - max allowed value
 */

function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
/**
 * @desc Parse a css unit string - either regular int or a percentage number
 * @param str - css unit string
 * @param max - max unit value, used for calculating percentages
 */


function parseUnit(str, max) {
  var isPercentage = str.indexOf('%') > -1;
  var num = parseFloat(str);
  return isPercentage ? max / 100 * num : num;
}
/**
 * @desc Parse hex str to an int
 * @param str - hex string to parse
 */


function parseHexInt(str) {
  return parseInt(str, 16);
}
/**
 * @desc Convert nunber into to 2-digit hex
 * @param int - number to convert
 */


function intToHex(int) {
  return int.toString(16).padStart(2, '0');
}

var IroColor = function IroColor(value, onChange) {
  // The default Color value
  this.$ = {
    h: 0,
    s: 0,
    v: 0,
    a: 1
  };
  if (value) { this.set(value); } // The watch callback function for this Color will be stored here

  this.onChange = onChange;
  this.initialValue = Object.assign({}, this.$); // copy initial value
};

var prototypeAccessors = { hsv: { configurable: true },hsva: { configurable: true },hue: { configurable: true },saturation: { configurable: true },value: { configurable: true },alpha: { configurable: true },kelvin: { configurable: true },red: { configurable: true },green: { configurable: true },blue: { configurable: true },rgb: { configurable: true },rgba: { configurable: true },hsl: { configurable: true },hsla: { configurable: true },rgbString: { configurable: true },rgbaString: { configurable: true },hexString: { configurable: true },hex8String: { configurable: true },hslString: { configurable: true },hslaString: { configurable: true } };
/**
  * @desc Set the Color from any valid value
  * @param value - new color value
*/


IroColor.prototype.set = function set (value) {
  if (typeof value === 'string') {
    if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value)) {
      this.hexString = value;
    } else if (/^rgba?/.test(value)) {
      this.rgbString = value;
    } else if (/^hsla?/.test(value)) {
      this.hslString = value;
    }
  } else if (typeof value === 'object') {
    if (value instanceof IroColor) {
      this.hsv = value.hsv;
    } else if (typeof value === 'object' && 'r' in value && 'g' in value && 'b' in value) {
      this.rgb = value;
    } else if (typeof value === 'object' && 'h' in value && 's' in value && 'v' in value) {
      this.hsv = value;
    } else if (typeof value === 'object' && 'h' in value && 's' in value && 'l' in value) {
      this.hsl = value;
    }
  } else {
    throw new Error('Invalid color value');
  }
};
/**
  * @desc Shortcut to set a specific channel value
  * @param format - hsv | hsl | rgb
  * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l
  * @param value - new value for the channel
*/


IroColor.prototype.setChannel = function setChannel (format, channel, value) {
    var obj;

  this[format] = Object.assign({}, this[format],
    ( obj = {}, obj[channel] = value, obj ));
};
/**
 * @desc Reset color back to its initial value
 */


IroColor.prototype.reset = function reset () {
  this.hsva = this.initialValue;
};
/**
  * @desc make new Color instance with the same value as this one
*/


IroColor.prototype.clone = function clone () {
  return new IroColor(this);
};
/**
 * @desc remove color onChange
 */


IroColor.prototype.unbind = function unbind () {
  this.onChange = undefined;
};
/**
  * @desc Convert hsv object to rgb
  * @param hsv - hsv color object
*/


IroColor.hsvToRgb = function hsvToRgb (hsv) {
  var h = hsv.h / 60;
  var s = hsv.s / 100;
  var v = hsv.v / 100;
  var i = floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q, p, p, t, v][mod];
  var g = [t, v, v, q, p, p][mod];
  var b = [p, p, t, v, v, q][mod];
  return {
    r: clamp(r * 255, 0, 255),
    g: clamp(g * 255, 0, 255),
    b: clamp(b * 255, 0, 255)
  };
};
/**
  * @desc Convert rgb object to hsv
  * @param rgb - rgb object
*/


IroColor.rgbToHsv = function rgbToHsv (rgb) {
  var r = rgb.r / 255;
  var g = rgb.g / 255;
  var b = rgb.b / 255;
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var delta = max - min;
  var hue = 0;
  var value = max;
  var saturation = max === 0 ? 0 : delta / max;

  switch (max) {
    case min:
      hue = 0; // achromatic

      break;

    case r:
      hue = (g - b) / delta + (g < b ? 6 : 0);
      break;

    case g:
      hue = (b - r) / delta + 2;
      break;

    case b:
      hue = (r - g) / delta + 4;
      break;
  }

  return {
    h: hue * 60 % 360,
    s: clamp(saturation * 100, 0, 100),
    v: clamp(value * 100, 0, 100)
  };
};
/**
  * @desc Convert hsv object to hsl
  * @param hsv - hsv object
*/


IroColor.hsvToHsl = function hsvToHsl (hsv) {
  var s = hsv.s / 100;
  var v = hsv.v / 100;
  var l = (2 - s) * v;
  var divisor = l <= 1 ? l : 2 - l; // Avoid division by zero when lightness is close to zero

  var saturation = divisor < 1e-9 ? 0 : s * v / divisor;
  return {
    h: hsv.h,
    s: clamp(saturation * 100, 0, 100),
    l: clamp(l * 50, 0, 100)
  };
};
/**
  * @desc Convert hsl object to hsv
  * @param hsl - hsl object
*/


IroColor.hslToHsv = function hslToHsv (hsl) {
  var l = hsl.l * 2;
  var s = hsl.s * (l <= 100 ? l : 200 - l) / 100; // Avoid division by zero when l + s is near 0

  var saturation = l + s < 1e-9 ? 0 : 2 * s / (l + s);
  return {
    h: hsl.h,
    s: clamp(saturation * 100, 0, 100),
    v: clamp((l + s) / 2, 0, 100)
  };
};
/**
  * @desc Convert a kelvin temperature to an approx, RGB value
  * @param kelvin - kelvin temperature
*/


IroColor.kelvinToRgb = function kelvinToRgb (kelvin) {
  var temp = kelvin / 100;
  var r, g, b;

  if (temp < 66) {
    r = 255;
    g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);
    b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);
  } else {
    r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);
    g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);
    b = 255;
  }

  return {
    r: clamp(floor(r), 0, 255),
    g: clamp(floor(g), 0, 255),
    b: clamp(floor(b), 0, 255)
  };
};
/**
 * @desc Convert an RGB color to an approximate kelvin temperature
 * @param kelvin - kelvin temperature
*/


IroColor.rgbToKelvin = function rgbToKelvin (rgb) {
  var r = rgb.r;
    var b = rgb.b;
  var eps = 0.4;
  var minTemp = KELVIN_MIN;
  var maxTemp = KELVIN_MAX;
  var temp;

  while (maxTemp - minTemp > eps) {
    temp = (maxTemp + minTemp) * 0.5;
    var rgb$1 = IroColor.kelvinToRgb(temp);

    if (rgb$1.b / rgb$1.r >= b / r) {
      maxTemp = temp;
    } else {
      minTemp = temp;
    }
  }

  return temp;
};

prototypeAccessors.hsv.get = function () {
  // value is cloned to allow changes to be made to the values before passing them back
  var value = this.$;
  return {
    h: value.h,
    s: value.s,
    v: value.v
  };
};

prototypeAccessors.hsv.set = function (newValue) {
  var oldValue = this.$;
  newValue = Object.assign({}, oldValue,
    newValue); // If this Color is being watched for changes we need to compare the new and old values to check the difference
  // Otherwise we can just be lazy

  if (this.onChange) {
    // Compute changed values
    var changes = {
      h: false,
      v: false,
      s: false,
      a: false
    };

    for (var key in oldValue) {
      changes[key] = newValue[key] != oldValue[key];
    }

    this.$ = newValue; // If the value has changed, call hook callback

    if (changes.h || changes.s || changes.v || changes.a) { this.onChange(this, changes); }
  } else {
    this.$ = newValue;
  }
};

prototypeAccessors.hsva.get = function () {
  return Object.assign({}, this.$);
};

prototypeAccessors.hsva.set = function (value) {
  this.hsv = value;
};

prototypeAccessors.hue.get = function () {
  return this.$.h;
};

prototypeAccessors.hue.set = function (value) {
  this.hsv = {
    h: value
  };
};

prototypeAccessors.saturation.get = function () {
  return this.$.s;
};

prototypeAccessors.saturation.set = function (value) {
  this.hsv = {
    s: value
  };
};

prototypeAccessors.value.get = function () {
  return this.$.v;
};

prototypeAccessors.value.set = function (value) {
  this.hsv = {
    v: value
  };
};

prototypeAccessors.alpha.get = function () {
  return this.$.a;
};

prototypeAccessors.alpha.set = function (value) {
  this.hsv = Object.assign({}, this.hsv,
    {a: value});
};

prototypeAccessors.kelvin.get = function () {
  return IroColor.rgbToKelvin(this.rgb);
};

prototypeAccessors.kelvin.set = function (value) {
  this.rgb = IroColor.kelvinToRgb(value);
};

prototypeAccessors.red.get = function () {
  var rgb = this.rgb;
  return rgb.r;
};

prototypeAccessors.red.set = function (value) {
  this.rgb = Object.assign({}, this.rgb,
    {r: value});
};

prototypeAccessors.green.get = function () {
  var rgb = this.rgb;
  return rgb.g;
};

prototypeAccessors.green.set = function (value) {
  this.rgb = Object.assign({}, this.rgb,
    {g: value});
};

prototypeAccessors.blue.get = function () {
  var rgb = this.rgb;
  return rgb.b;
};

prototypeAccessors.blue.set = function (value) {
  this.rgb = Object.assign({}, this.rgb,
    {b: value});
};

prototypeAccessors.rgb.get = function () {
  var ref = IroColor.hsvToRgb(this.$);
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
  return {
    r: round(r),
    g: round(g),
    b: round(b)
  };
};

prototypeAccessors.rgb.set = function (value) {
  this.hsv = Object.assign({}, IroColor.rgbToHsv(value),
    {a: value.a === undefined ? 1 : value.a});
};

prototypeAccessors.rgba.get = function () {
  return Object.assign({}, this.rgb,
    {a: this.alpha});
};

prototypeAccessors.rgba.set = function (value) {
  this.rgb = value;
};

prototypeAccessors.hsl.get = function () {
  var ref = IroColor.hsvToHsl(this.$);
    var h = ref.h;
    var s = ref.s;
    var l = ref.l;
  return {
    h: round(h),
    s: round(s),
    l: round(l)
  };
};

prototypeAccessors.hsl.set = function (value) {
  this.hsv = Object.assign({}, IroColor.hslToHsv(value),
    {a: value.a === undefined ? 1 : value.a});
};

prototypeAccessors.hsla.get = function () {
  return Object.assign({}, this.hsl,
    {a: this.alpha});
};

prototypeAccessors.hsla.set = function (value) {
  this.hsl = value;
};

prototypeAccessors.rgbString.get = function () {
  var rgb = this.rgb;
  return ("rgb(" + (rgb.r) + ", " + (rgb.g) + ", " + (rgb.b) + ")");
};

prototypeAccessors.rgbString.set = function (value) {
  var match;
  var r,
      g,
      b,
      a = 1;

  if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {
    r = parseUnit(match[1], 255);
    g = parseUnit(match[2], 255);
    b = parseUnit(match[3], 255);
  } else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {
    r = parseUnit(match[1], 255);
    g = parseUnit(match[2], 255);
    b = parseUnit(match[3], 255);
    a = parseUnit(match[4], 1);
  }

  if (match) {
    this.rgb = {
      r: r,
      g: g,
      b: b,
      a: a
    };
  } else {
    throw new Error('Invalid rgb string');
  }
};

prototypeAccessors.rgbaString.get = function () {
  var rgba = this.rgba;
  return ("rgba(" + (rgba.r) + ", " + (rgba.g) + ", " + (rgba.b) + ", " + (rgba.a) + ")");
};

prototypeAccessors.rgbaString.set = function (value) {
  this.rgbString = value;
};

prototypeAccessors.hexString.get = function () {
  var rgb = this.rgb;
  return ("#" + (intToHex(rgb.r)) + (intToHex(rgb.g)) + (intToHex(rgb.b)));
};

prototypeAccessors.hexString.set = function (value) {
  var match;
  var r,
      g,
      b,
      a = 255;

  if (match = REGEX_HEX_3.exec(value)) {
    r = parseHexInt(match[1]) * 17;
    g = parseHexInt(match[2]) * 17;
    b = parseHexInt(match[3]) * 17;
  } else if (match = REGEX_HEX_4.exec(value)) {
    r = parseHexInt(match[1]) * 17;
    g = parseHexInt(match[2]) * 17;
    b = parseHexInt(match[3]) * 17;
    a = parseHexInt(match[4]) * 17;
  } else if (match = REGEX_HEX_6.exec(value)) {
    r = parseHexInt(match[1]);
    g = parseHexInt(match[2]);
    b = parseHexInt(match[3]);
  } else if (match = REGEX_HEX_8.exec(value)) {
    r = parseHexInt(match[1]);
    g = parseHexInt(match[2]);
    b = parseHexInt(match[3]);
    a = parseHexInt(match[4]);
  }

  if (match) {
    this.rgb = {
      r: r,
      g: g,
      b: b,
      a: a / 255
    };
  } else {
    throw new Error('Invalid hex string');
  }
};

prototypeAccessors.hex8String.get = function () {
  var rgba = this.rgba;
  return ("#" + (intToHex(rgba.r)) + (intToHex(rgba.g)) + (intToHex(rgba.b)) + (intToHex(floor(rgba.a * 255))));
};

prototypeAccessors.hex8String.set = function (value) {
  this.hexString = value;
};

prototypeAccessors.hslString.get = function () {
  var hsl = this.hsl;
  return ("hsl(" + (hsl.h) + ", " + (hsl.s) + "%, " + (hsl.l) + "%)");
};

prototypeAccessors.hslString.set = function (value) {
  var match;
  var h,
      s,
      l,
      a = 1;

  if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {
    h = parseUnit(match[1], 360);
    s = parseUnit(match[2], 100);
    l = parseUnit(match[3], 100);
  } else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {
    h = parseUnit(match[1], 360);
    s = parseUnit(match[2], 100);
    l = parseUnit(match[3], 100);
    a = parseUnit(match[4], 1);
  }

  if (match) {
    this.hsl = {
      h: h,
      s: s,
      l: l,
      a: a
    };
  } else {
    throw new Error('Invalid hsl string');
  }
};

prototypeAccessors.hslaString.get = function () {
  var hsla = this.hsla;
  return ("hsl(" + (hsla.h) + ", " + (hsla.s) + "%, " + (hsla.l) + "%, " + (hsla.a) + ")");
};

prototypeAccessors.hslaString.set = function (value) {
  this.hslString = value;
};

Object.defineProperties( IroColor.prototype, prototypeAccessors );

var sliderDefaultOptions = {
  sliderShape: 'bar',
  sliderType: 'value',
  minTemperature: 2200,
  maxTemperature: 11000
};
/**
 * @desc Get the bounding dimensions of the slider
 * @param props - slider props
 */

function getSliderDimensions(props) {
  var width = props.width;
  var sliderSize = props.sliderSize;
  var borderWidth = props.borderWidth;
  var handleRadius = props.handleRadius;
  var padding = props.padding;
  var sliderShape = props.sliderShape;
  var ishorizontal = props.layoutDirection === 'horizontal'; // automatically calculate sliderSize if its not defined

  sliderSize = sliderSize ? sliderSize : padding * 2 + handleRadius * 2 + borderWidth * 2;

  if (sliderShape === 'circle') {
    return {
      handleStart: props.padding + props.handleRadius,
      handleRange: width - padding * 2 - handleRadius * 2 - borderWidth * 2,
      width: width,
      height: width,
      cx: width / 2,
      cy: width / 2,
      radius: width / 2 - borderWidth / 2
    };
  } else {
    return {
      handleStart: sliderSize / 2,
      handleRange: width - sliderSize,
      radius: sliderSize / 2,
      x: 0,
      y: 0,
      width: ishorizontal ? sliderSize : width,
      height: ishorizontal ? width : sliderSize
    };
  }
}
/**
 * @desc Get the current slider value for a given color, as a percentage
 * @param props - slider props
 * @param color
 */

function getCurrentSliderValue(props, color) {
  var hsva = color.hsva;
  var rgb = color.rgb;

  switch (props.sliderType) {
    case 'red':
      return rgb.r / 2.55;

    case 'green':
      return rgb.g / 2.55;

    case 'blue':
      return rgb.b / 2.55;

    case 'alpha':
      return hsva.a * 100;

    case 'kelvin':
      var minTemperature = props.minTemperature;
  var maxTemperature = props.maxTemperature;
      var temperatureRange = maxTemperature - minTemperature;
      var percent = (color.kelvin - minTemperature) / temperatureRange * 100; // clmap percentage

      return Math.max(0, Math.min(percent, 100));

    case 'hue':
      return hsva.h /= 3.6;

    case 'saturation':
      return hsva.s;

    case 'value':
    default:
      return hsva.v;
  }
}
/**
 * @desc Get the current slider value from user input
 * @param props - slider props
 * @param x - global input x position
 * @param y - global input y position
 */

function getSliderValueFromInput(props, x, y) {
  var ref = getSliderDimensions(props);
  var handleRange = ref.handleRange;
  var handleStart = ref.handleStart;
  var handlePos;

  if (props.layoutDirection === 'horizontal') {
    handlePos = -1 * y + handleRange + handleStart;
  } else {
    handlePos = x - handleStart;
  } // clamp handle position


  handlePos = Math.max(Math.min(handlePos, handleRange), 0);
  var percent = Math.round(100 / handleRange * handlePos);

  switch (props.sliderType) {
    case 'kelvin':
      var minTemperature = props.minTemperature;
  var maxTemperature = props.maxTemperature;
      var temperatureRange = maxTemperature - minTemperature;
      return minTemperature + temperatureRange * (percent / 100);

    case 'alpha':
      return percent / 100;

    case 'hue':
      return percent * 3.6;

    case 'red':
    case 'blue':
    case 'green':
      return percent * 2.55;

    default:
      return percent;
  }
}
/**
 * @desc Get the current handle position for a given color
 * @param props - slider props
 * @param color
 */

function getSliderHandlePosition(props, color) {
  var ref = getSliderDimensions(props);
  var width = ref.width;
  var height = ref.height;
  var handleRange = ref.handleRange;
  var handleStart = ref.handleStart;
  var ishorizontal = props.layoutDirection === 'horizontal';
  var sliderValue = getCurrentSliderValue(props, color);
  var midPoint = ishorizontal ? width / 2 : height / 2;
  var handlePos = handleStart + sliderValue / 100 * handleRange;

  if (ishorizontal) {
    handlePos = -1 * handlePos + handleRange + handleStart * 2;
  }

  return {
    x: ishorizontal ? midPoint : handlePos,
    y: ishorizontal ? handlePos : midPoint
  };
}
/**
 * @desc Get the gradient stops for a slider
 * @param props - slider props
 * @param color
 */

function getSliderGradient(props, color) {
  var hsv = color.hsv;
  var rgb = color.rgb;

  switch (props.sliderType) {
    case 'red':
      return [[0, ("rgb(" + (0) + "," + (rgb.g) + "," + (rgb.b) + ")")], [100, ("rgb(" + (255) + "," + (rgb.g) + "," + (rgb.b) + ")")]];

    case 'green':
      return [[0, ("rgb(" + (rgb.r) + "," + (0) + "," + (rgb.b) + ")")], [100, ("rgb(" + (rgb.r) + "," + (255) + "," + (rgb.b) + ")")]];

    case 'blue':
      return [[0, ("rgb(" + (rgb.r) + "," + (rgb.g) + "," + (0) + ")")], [100, ("rgb(" + (rgb.r) + "," + (rgb.g) + "," + (255) + ")")]];

    case 'alpha':
      return [[0, ("rgba(" + (rgb.r) + "," + (rgb.g) + "," + (rgb.b) + ",0)")], [100, ("rgb(" + (rgb.r) + "," + (rgb.g) + "," + (rgb.b) + ")")]];

    case 'kelvin':
      var stops = [];
      var min = props.minTemperature;
      var max = props.maxTemperature;
      var numStops = 8;
      var range = max - min;

      for (var kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {
        var ref = IroColor.kelvinToRgb(kelvin);
        var r = ref.r;
        var g = ref.g;
        var b = ref.b;
        stops.push([100 / numStops * stop, ("rgb(" + r + "," + g + "," + b + ")")]);
      }

      return stops;

    case 'hue':
      return [[0, '#f00'], [16.666, '#ff0'], [33.333, '#0f0'], [50, '#0ff'], [66.666, '#00f'], [83.333, '#f0f'], [100, '#f00']];

    case 'saturation':
      var noSat = IroColor.hsvToHsl({
        h: hsv.h,
        s: 0,
        v: hsv.v
      });
      var fullSat = IroColor.hsvToHsl({
        h: hsv.h,
        s: 100,
        v: hsv.v
      });
      return [[0, ("hsl(" + (noSat.h) + "," + (noSat.s) + "%," + (noSat.l) + "%)")], [100, ("hsl(" + (fullSat.h) + "," + (fullSat.s) + "%," + (fullSat.l) + "%)")]];

    case 'value':
    default:
      var hsl = IroColor.hsvToHsl({
        h: hsv.h,
        s: hsv.s,
        v: 100
      });
      return [[0, '#000'], [100, ("hsl(" + (hsl.h) + "," + (hsl.s) + "%," + (hsl.l) + "%)")]];
  }
}
/**
 * @desc Get the gradient coords for a slider
 * @param props - slider props
 */

function getSliderGradientCoords(props) {
  var ishorizontal = props.layoutDirection === 'horizontal';
  return {
    x1: '0%',
    y1: ishorizontal ? '100%' : '0%',
    x2: ishorizontal ? '0%' : '100%',
    y2: '0%'
  };
}

/**
 * @desc Get the point as the center of the wheel
 * @param props - wheel props
 */
function getWheelDimensions(props) {
  var rad = props.width / 2;
  return {
    width: props.width,
    radius: rad - props.borderWidth,
    cx: rad,
    cy: rad
  };
}
/**
 * @desc Translate an angle according to wheelAngle and wheelDirection
 * @param props - wheel props
 * @param angle - input angle
 */

function translateWheelAngle(props, angle, invert) {
  var wheelAngle = props.wheelAngle;
  var wheelDirection = props.wheelDirection;

  if (!invert && wheelDirection === 'clockwise' || invert && wheelDirection === 'anticlockwise') {
    angle = (invert ? 180 : 360) - (wheelAngle - angle);
  } else {
    angle = wheelAngle + angle;
  } // javascript's modulo operator doesn't produce positive numbers with negative input
  // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e


  return (angle % 360 + 360) % 360;
}
/**
 * @desc Get the current handle position for a given color
 * @param props - wheel props
 * @param color
 */

function getWheelHandlePosition(props, color) {
  var hsv = color.hsv;
  var ref = getWheelDimensions(props);
  var cx = ref.cx;
  var cy = ref.cy;
  var handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;
  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (Math.PI / 180);
  var handleDist = hsv.s / 100 * handleRange;
  var direction = props.wheelDirection === 'clockwise' ? -1 : 1;
  return {
    x: cx + handleDist * Math.cos(handleAngle) * direction,
    y: cy + handleDist * Math.sin(handleAngle) * direction
  };
}
/**
 * @desc Get the current wheel value from user input
 * @param props - wheel props
 * @param x - global input x position
 * @param y - global input y position
 */

function getWheelValueFromInput(props, x, y) {
  var ref = getWheelDimensions(props);
  var cx = ref.cx;
  var cy = ref.cy;
  var handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;
  x = cx - x;
  y = cy - y; // Calculate the hue by converting the angle to radians

  var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (180 / Math.PI)); // Find the point's distance from the center of the wheel
  // This is used to show the saturation level

  var handleDist = Math.min(Math.sqrt(x * x + y * y), handleRange);
  return {
    h: Math.round(hue),
    s: Math.round(100 / handleRange * handleDist)
  };
}
/**
 * @desc Get the bounding dimensions of the box
 * @param props - box props
 */

function getBoxDimensions(props) {
  var width = props.width;
  var padding = props.padding;
  var handleRadius = props.handleRadius;
  return {
    width: width,
    height: width,
    radius: padding + handleRadius
  };
}
/**
 * @desc Get the current box value from user input
 * @param props - box props
 * @param x - global input x position
 * @param y - global input y position
 */

function getBoxValueFromInput(props, x, y) {
  var ref = getBoxDimensions(props);
  var width = ref.width;
  var height = ref.height;
  var radius = ref.radius;
  var handleStart = radius;
  var handleRangeX = width - radius * 2;
  var handleRangeY = height - radius * 2;
  var percentX = (x - handleStart) / handleRangeX * 100;
  var percentY = (y - handleStart) / handleRangeY * 100;
  return {
    s: Math.max(0, Math.min(percentX, 100)),
    v: Math.max(0, Math.min(100 - percentY, 100))
  };
}
/**
 * @desc Get the current box handle position for a given color
 * @param props - box props
 * @param color
 */

function getBoxHandlePosition(props, color) {
  var ref = getBoxDimensions(props);
  var width = ref.width;
  var height = ref.height;
  var radius = ref.radius;
  var hsv = color.hsv;
  var handleStart = radius;
  var handleRangeX = width - radius * 2;
  var handleRangeY = height - radius * 2;
  return {
    x: handleStart + hsv.s / 100 * handleRangeX,
    y: handleStart + (handleRangeY - hsv.v / 100 * handleRangeY)
  };
}
/**
 * @desc Get the gradient stops for a box
 * @param props - box props
 * @param color
 */

function getBoxGradients(props, color) {
  var hue = color.hue;
  return [// saturation gradient
  [[0, '#fff'], [100, ("hsl(" + hue + ",100%,50%)")]], // lightness gradient
  [[0, 'rgba(0,0,0,0)'], [100, '#000']]];
}

// Keep track of html <base> elements for resolveSvgUrl
// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree
// So it only needs to be called once
var BASE_ELEMENTS;
/**
 * @desc Resolve an SVG reference URL
 * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions
 * If a page is using a client-side routing library which makes use of the HTML <base> tag,
 * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)
 * More info on the problem:
 * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427
 * https://github.com/jaames/iro.js/issues/18
 * https://github.com/jaames/iro.js/issues/45
 * https://github.com/jaames/iro.js/pull/89
 * @props url - SVG reference URL
 */

function resolveSvgUrl(url) {
  if (!BASE_ELEMENTS) { BASE_ELEMENTS = document.getElementsByTagName('base'); } // Sniff useragent string to check if the user is running Safari

  var ua = window.navigator.userAgent;
  var isSafari = /^((?!chrome|android).)*safari/i.test(ua);
  var isIos = /iPhone|iPod|iPad/i.test(ua);
  var location = window.location;
  return (isSafari || isIos) && BASE_ELEMENTS.length > 0 ? ((location.protocol) + "//" + (location.host) + (location.pathname) + (location.search) + url) : url;
}
/**
 * @desc Get the path commands to draw an svg arc
 * @props cx - arc center point x
 * @props cy - arc center point y
 * @props radius - arc radius
 * @props startAngle - arc start angle
 * @props endAngle - arc end angle
 */

function getSvgArcPath(cx, cy, radius, startAngle, endAngle) {
  var largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;
  startAngle *= Math.PI / 180;
  endAngle *= Math.PI / 180;
  var x1 = cx + radius * Math.cos(endAngle);
  var y1 = cy + radius * Math.sin(endAngle);
  var x2 = cx + radius * Math.cos(startAngle);
  var y2 = cy + radius * Math.sin(startAngle);
  return ("M " + x1 + " " + y1 + " A " + radius + " " + radius + " 0 " + largeArcFlag + " 0 " + x2 + " " + y2);
}
/**
 * @desc Given a specifc (x, y) position, test if there's a handle there and return its index, else return null.
 *       This is used for components like the box and wheel which support multiple handles when multicolor is active
 * @props x - point x position
 * @props y - point y position
 * @props handlePositions - array of {x, y} coords for each handle
 */

function getHandleAtPoint(props, x, y, handlePositions) {
  for (var i = 0; i < handlePositions.length; i++) {
    var dX = handlePositions[i].x - x;
    var dY = handlePositions[i].y - y;
    var dist = Math.sqrt(dX * dX + dY * dY);

    if (dist < props.handleRadius) {
      return i;
    }
  }

  return null;
}

var iroColorPickerOptionDefaults = {
  width: 300,
  height: 300,
  handleRadius: 8,
  handleSvg: null,
  handleProps: {
    x: 0,
    y: 0
  },
  color: '#fff',
  colors: [],
  borderColor: '#fff',
  borderWidth: 0,
  wheelLightness: true,
  wheelAngle: 0,
  wheelDirection: 'anticlockwise',
  layoutDirection: 'vertical',
  sliderSize: null,
  sliderMargin: 12,
  padding: 6
};

var SECONDARY_EVENTS = ["mousemove" /* MouseMove */, "touchmove" /* TouchMove */, "mouseup" /* MouseUp */, "touchend" /* TouchEnd */];
// Base component class for iro UI components
// This extends the Preact component class to allow them to react to mouse/touch input events by themselves
var IroComponentBase = /*@__PURE__*/(function (Component) {
    function IroComponentBase(props) {
        Component.call(this, props);
        // Generate unique ID for the component
        // This can be used to generate unique IDs for gradients, etc
        this.uid = (Math.random() + 1).toString(36).substring(5);
    }

    if ( Component ) IroComponentBase.__proto__ = Component;
    IroComponentBase.prototype = Object.create( Component && Component.prototype );
    IroComponentBase.prototype.constructor = IroComponentBase;
    IroComponentBase.prototype.render = function render (props) {
        var eventHandler = this.handleEvent.bind(this);
        var rootProps = {
            onMouseDown: eventHandler,
            // https://github.com/jaames/iro.js/issues/126
            // https://github.com/preactjs/preact/issues/2113#issuecomment-553408767
            ontouchstart: eventHandler,
        };
        var isHorizontal = props.layoutDirection === 'horizontal';
        var margin = props.margin === null ? props.sliderMargin : props.margin;
        var rootStyles = {
            overflow: 'visible',
            display: isHorizontal ? 'inline-block' : 'block'
        };
        // first component shouldn't have any margin
        if (props.index > 0) {
            rootStyles[isHorizontal ? 'marginLeft' : 'marginTop'] = margin;
        }
        return (h(d, null, props.children(this.uid, rootProps, rootStyles)));
    };
    // More info on handleEvent:
    // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38
    // TL;DR this lets us have a single point of entry for multiple events, and we can avoid callback/binding hell
    IroComponentBase.prototype.handleEvent = function handleEvent (e) {
        var this$1 = this;

        var inputHandler = this.props.onInput;
        // Get the screen position of the component
        var bounds = this.base.getBoundingClientRect();
        // Prefect default browser action
        e.preventDefault();
        // Detect if the event is a touch event by checking if it has the `touches` property
        // If it is a touch event, use the first touch input
        var point = e.touches ? e.changedTouches[0] : e;
        var x = point.clientX - bounds.left;
        var y = point.clientY - bounds.top;
        switch (e.type) {
            case "mousedown" /* MouseDown */:
            case "touchstart" /* TouchStart */:
                SECONDARY_EVENTS.forEach(function (event) {
                    document.addEventListener(event, this$1, { passive: false });
                });
                inputHandler(x, y, 0 /* Start */);
                break;
            case "mousemove" /* MouseMove */:
            case "touchmove" /* TouchMove */:
                inputHandler(x, y, 1 /* Move */);
                break;
            case "mouseup" /* MouseUp */:
            case "touchend" /* TouchEnd */:
                inputHandler(x, y, 2 /* End */);
                SECONDARY_EVENTS.forEach(function (event) {
                    document.removeEventListener(event, this$1);
                });
                break;
        }
    };

    return IroComponentBase;
}(m));

function IroHandle(props) {
    var radius = props.r;
    var url = props.url;
    return (h("svg", { className: ("IroHandle IroHandle--" + (props.index) + " " + (props.isActive ? 'IroHandle--isActive' : '')), x: props.x, y: props.y, style: {
            overflow: 'visible'
        } },
        url && (h("use", Object.assign({ xlinkHref: resolveSvgUrl(url) }, props.props))),
        !url && (h("circle", { r: radius, fill: "none", "stroke-width": 2, stroke: "#000" })),
        !url && (h("circle", { r: radius - 2, fill: props.fill, "stroke-width": 2, stroke: "#fff" }))));
}
IroHandle.defaultProps = {
    fill: 'none',
    x: 0,
    y: 0,
    r: 8,
    url: null,
    props: { x: 0, y: 0 }
};

function IroSlider(props) {
    var activeIndex = props.activeIndex;
    var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;
    var ref = getSliderDimensions(props);
    var width = ref.width;
    var height = ref.height;
    var radius = ref.radius;
    var handlePos = getSliderHandlePosition(props, activeColor);
    var gradient = getSliderGradient(props, activeColor);
    var isAlpha = props.sliderType === 'alpha';
    function handleInput(x, y, type) {
        var value = getSliderValueFromInput(props, x, y);
        props.parent.inputActive = true;
        activeColor[props.sliderType] = value;
        props.onInput(type);
    }
    return (h(IroComponentBase, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h("svg", Object.assign({}, rootProps, { className: "IroSlider", width: width, height: height, style: rootStyles }),
        h("defs", null,
            h("linearGradient", Object.assign({ id: 'g' + uid }, getSliderGradientCoords(props)), gradient.map(function (ref) {
                var offset = ref[0];
                var color = ref[1];

                return (h("stop", { offset: (offset + "%"), "stop-color": color }));
        })),
            isAlpha && (h("pattern", { id: 'b' + uid, width: "8", height: "8", patternUnits: "userSpaceOnUse" },
                h("rect", { x: "0", y: "0", width: "8", height: "8", fill: "#fff" }),
                h("rect", { x: "0", y: "0", width: "4", height: "4", fill: "#ccc" }),
                h("rect", { x: "4", y: "4", width: "4", height: "4", fill: "#ccc" }))),
            isAlpha && (h("pattern", { id: 'f' + uid, width: "100%", height: "100%" },
                h("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: ("url(" + (resolveSvgUrl('#b' + uid)) + ")") }),
                h("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: ("url(" + (resolveSvgUrl('#g' + uid)) + ")") })))),
        h("rect", { className: "IroSliderBg", rx: radius, ry: radius, x: props.borderWidth / 2, y: props.borderWidth / 2, width: width - props.borderWidth, height: height - props.borderWidth, "stroke-width": props.borderWidth, stroke: props.borderColor, fill: ("url(" + (resolveSvgUrl((isAlpha ? '#f' : '#g') + uid)) + ")") }),
        h(IroHandle, { isActive: true, index: activeColor.index, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePos.x, y: handlePos.y }))); }));
}
IroSlider.defaultProps = Object.assign({}, sliderDefaultOptions);

function IroBox(props) {
    var ref = getBoxDimensions(props);
    var width = ref.width;
    var height = ref.height;
    var radius = ref.radius;
    var colors = props.colors;
    var colorPicker = props.parent;
    var activeIndex = props.activeIndex;
    var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;
    var gradients = getBoxGradients(props, activeColor);
    var handlePositions = colors.map(function (color) { return getBoxHandlePosition(props, color); });
    function handleInput(x, y, inputType) {
        if (inputType === 0 /* Start */) {
            // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise
            var activeHandle = getHandleAtPoint(props, x, y, handlePositions);
            // If the input hit a handle, set it as the active handle, but don't update the color
            if (activeHandle !== null) {
                colorPicker.setActiveColor(activeHandle);
            }
            // If the input didn't hit a handle, set the currently active handle to that position
            else {
                colorPicker.inputActive = true;
                activeColor.hsv = getBoxValueFromInput(props, x, y);
                props.onInput(inputType);
            }
        }
        // move is fired when the user has started dragging
        else if (inputType === 1 /* Move */) {
            colorPicker.inputActive = true;
            activeColor.hsv = getBoxValueFromInput(props, x, y);
        }
        // let the color picker fire input:start, input:move or input:end events
        props.onInput(inputType);
    }
    return (h(IroComponentBase, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h("svg", Object.assign({}, rootProps, { className: "IroBox", width: width, height: height, style: rootStyles }),
        h("defs", null,
            h("linearGradient", { id: 's' + uid, x1: "0%", y1: "0%", x2: "100%", y2: "0%" }, gradients[0].map(function (ref) {
                var offset = ref[0];
                var color = ref[1];

                return (h("stop", { offset: (offset + "%"), "stop-color": color }));
        })),
            h("linearGradient", { id: 'l' + uid, x1: "0%", y1: "0%", x2: "0%", y2: "100%" }, gradients[1].map(function (ref) {
                var offset = ref[0];
                var color = ref[1];

                return (h("stop", { offset: (offset + "%"), "stop-color": color }));
        })),
            h("pattern", { id: 'f' + uid, width: "100%", height: "100%" },
                h("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: ("url(" + (resolveSvgUrl('#s' + uid)) + ")") }),
                h("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: ("url(" + (resolveSvgUrl('#l' + uid)) + ")") }))),
        h("rect", { rx: radius, ry: radius, x: props.borderWidth / 2, y: props.borderWidth / 2, width: width - props.borderWidth, height: height - props.borderWidth, "stroke-width": props.borderWidth, stroke: props.borderColor, fill: ("url(" + (resolveSvgUrl('#f' + uid)) + ")") }),
        colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),
        h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));
}

var HUE_STEPS = Array.apply(null, { length: 360 }).map(function (_, index) { return index; });
function IroWheel(props) {
    var ref = getWheelDimensions(props);
    var width = ref.width;
    var radius = ref.radius;
    var cx = ref.cx;
    var cy = ref.cy;
    var colors = props.colors;
    var borderWidth = props.borderWidth;
    var colorPicker = props.parent;
    var activeColor = props.color;
    var hsv = activeColor.hsv;
    var handlePositions = colors.map(function (color) { return getWheelHandlePosition(props, color); });
    function handleInput(x, y, inputType) {
        if (inputType === 0 /* Start */) {
            // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise
            var activeHandle = getHandleAtPoint(props, x, y, handlePositions);
            // If the input hit a handle, set it as the active handle, but don't update the color
            if (activeHandle !== null) {
                colorPicker.setActiveColor(activeHandle);
            }
            // If the input didn't hit a handle, set the currently active handle to that position
            else {
                colorPicker.inputActive = true;
                activeColor.hsv = getWheelValueFromInput(props, x, y);
                props.onInput(inputType);
            }
        }
        // move is fired when the user has started dragging
        else if (inputType === 1 /* Move */) {
            colorPicker.inputActive = true;
            activeColor.hsv = getWheelValueFromInput(props, x, y);
        }
        // let the color picker fire input:start, input:move or input:end events
        props.onInput(inputType);
    }
    return (h(IroComponentBase, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h("svg", Object.assign({}, rootProps, { className: "IroWheel", width: width, height: width, style: rootStyles }),
        h("defs", null,
            h("radialGradient", { id: uid },
                h("stop", { offset: "0%", "stop-color": "#fff" }),
                h("stop", { offset: "100%", "stop-color": "#fff", "stop-opacity": "0" }))),
        h("g", { className: "IroWheelHue", "stroke-width": radius, fill: "none" }, HUE_STEPS.map(function (angle) { return (h("path", { key: angle, d: getSvgArcPath(cx, cy, radius / 2, angle, angle + 1.5), stroke: ("hsl(" + (translateWheelAngle(props, angle)) + ", 100%, 50%)") })); })),
        h("circle", { className: "IroWheelSaturation", cx: cx, cy: cy, r: radius, fill: ("url(" + (resolveSvgUrl('#' + uid)) + ")") }),
        props.wheelLightness && (h("circle", { className: "IroWheelLightness", cx: cx, cy: cy, r: radius, fill: "#000", opacity: 1 - hsv.v / 100 })),
        h("circle", { className: "IroWheelBorder", cx: cx, cy: cy, r: radius, fill: "none", stroke: props.borderColor, "stroke-width": borderWidth }),
        colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),
        h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));
}

// Turn a component into a widget
// This returns a factory function that can be used to create an instance of the widget component
// The first function param is a DOM element or CSS selector for the element to mount to,
// The second param is for config options which are passed to the component as props
// This factory function can also delay mounting the element into the DOM until the page is ready
function createWidget(WidgetComponent) {
    var widgetFactory = function (parent, props) {
        var widget; // will become an instance of the widget component class
        var widgetRoot = document.createElement('div');
        // Render widget into a temp DOM node
        I(h(WidgetComponent, Object.assign({}, {ref: function (ref) { return widget = ref; }},
            props)), widgetRoot);
        function mountWidget() {
            var container = parent instanceof Element ? parent : document.querySelector(parent);
            container.appendChild(widget.base);
            widget.onMount(container);
        }
        // Mount it into the DOM when the page document is ready
        if (document.readyState !== 'loading') {
            mountWidget();
        }
        else {
            document.addEventListener('DOMContentLoaded', mountWidget);
        }
        return widget;
    };
    // Allow the widget factory to inherit component prototype + static class methods
    // This makes it easier for plugin authors to extend the base widget component
    widgetFactory.prototype = WidgetComponent.prototype;
    Object.assign(widgetFactory, WidgetComponent);
    // Add reference to base component too
    widgetFactory.__component = WidgetComponent;
    return widgetFactory;
}

var IroColorPicker = /*@__PURE__*/(function (Component) {
    function IroColorPicker(props) {
        var this$1 = this;

        Component.call(this, props);
        this.colors = [];
        this.inputActive = false;
        this.events = {};
        this.activeEvents = {};
        this.deferredEvents = {};
        this.id = props.id;
        var colors = props.colors.length > 0 ? props.colors : [props.color];
        colors.forEach(function (colorValue) { return this$1.addColor(colorValue); });
        this.setActiveColor(0);
        // Pass all the props into the component's state,
        // Except we want to add the color object and make sure that refs aren't passed down to children
        this.state = Object.assign({}, props,
            {color: this.color,
            colors: this.colors,
            layout: props.layout});
    }

    if ( Component ) IroColorPicker.__proto__ = Component;
    IroColorPicker.prototype = Object.create( Component && Component.prototype );
    IroColorPicker.prototype.constructor = IroColorPicker;
    // Plubic multicolor API
    /**
    * @desc Add a color to the color picker
    * @param color new color to add
    * @param index optional color index
    */
    IroColorPicker.prototype.addColor = function addColor (color, index) {
        if ( index === void 0 ) index = this.colors.length;

        // Create a new iro.Color
        // Also bind it to onColorChange, so whenever the color changes it updates the color picker
        var newColor = new IroColor(color, this.onColorChange.bind(this));
        // Insert color @ the given index
        this.colors.splice(index, 0, newColor);
        // Reindex colors
        this.colors.forEach(function (color, index) { return color.index = index; });
        // Update picker state if necessary
        if (this.state) {
            this.setState({ colors: this.colors });
        }
        // Fire color init event
        this.deferredEmit('color:init', newColor);
    };
    /**
     * @desc Remove a color from the color picker
     * @param index color index
     */
    IroColorPicker.prototype.removeColor = function removeColor (index) {
        var color = this.colors.splice(index, 1)[0];
        // Destroy the color object -- this unbinds it from the color picker
        color.unbind();
        // Reindex colors
        this.colors.forEach(function (color, index) { return color.index = index; });
        // Update picker state if necessary
        if (this.state) {
            this.setState({ colors: this.colors });
        }
        // If the active color was removed, default active color to 0
        if (color.index === this.color.index) {
            this.setActiveColor(0);
        }
        // Fire color remove event
        this.emit('color:remove', color);
    };
    /**
     * @desc Set the currently active color
     * @param index color index
     */
    IroColorPicker.prototype.setActiveColor = function setActiveColor (index) {
        this.color = this.colors[index];
        if (this.state) {
            this.setState({ color: this.color });
        }
        // Fire color switch event
        this.emit('color:setActive', this.color);
    };
    /**
     * @desc Replace all of the current colorPicker colors
     * @param newColorValues list of new colors to add
     */
    IroColorPicker.prototype.setColors = function setColors (newColorValues) {
        var this$1 = this;

        // Unbind color events
        this.colors.forEach(function (color) { return color.unbind(); });
        // Destroy old colors
        this.colors = [];
        // Add new colors
        newColorValues.forEach(function (colorValue) { return this$1.addColor(colorValue); });
        // Reset active color
        this.setActiveColor(0);
        this.emit('color:setAll', this.colors);
    };
    // Public ColorPicker events API
    /**
     * @desc Set a callback function for an event
     * @param eventList event(s) to listen to
     * @param callback - Function called when the event is fired
     */
    IroColorPicker.prototype.on = function on (eventList, callback) {
        var this$1 = this;

        var events = this.events;
        // eventList can be an eventType string or an array of eventType strings
        (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {
            // Add event callback
            (events[eventType] || (events[eventType] = [])).push(callback);
            // Call deferred events
            // These are events that can be stored until a listener for them is added
            if (this$1.deferredEvents[eventType]) {
                // Deffered events store an array of arguments from when the event was called
                this$1.deferredEvents[eventType].forEach(function (args) {
                    callback.apply(null, args);
                });
                // Clear deferred events
                this$1.deferredEvents[eventType] = [];
            }
        });
    };
    /**
     * @desc Remove a callback function for an event added with on()
     * @param eventList - event(s) to listen to
     * @param callback - original callback function to remove
     */
    IroColorPicker.prototype.off = function off (eventList, callback) {
        var this$1 = this;

        (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {
            var callbackList = this$1.events[eventType];
            // this.emitHook('event:off', eventType, callback);
            if (callbackList)
                { callbackList.splice(callbackList.indexOf(callback), 1); }
        });
    };
    /**
     * @desc Emit an event
     * @param eventType event to emit
     */
    IroColorPicker.prototype.emit = function emit (eventType) {
        var this$1 = this;
        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

        var activeEvents = this.activeEvents;
        var isEventActive = activeEvents.hasOwnProperty(eventType) ? activeEvents[eventType] : false;
        // Prevent event callbacks from firing if the event is already active
        // This stops infinite loops if something in an event callback causes the same event to be fired again
        // (e.g. setting the color inside a color:change callback)
        if (!isEventActive) {
            activeEvents[eventType] = true;
            var callbackList = this.events[eventType] || [];
            callbackList.forEach(function (fn) { return fn.apply(this$1, args); });
            activeEvents[eventType] = false;
        }
    };
    /**
     * @desc Emit an event now, or save it for when the relevent event listener is added
     * @param eventType - The name of the event to emit
     */
    IroColorPicker.prototype.deferredEmit = function deferredEmit (eventType) {
        var ref;

        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
        var deferredEvents = this.deferredEvents;
        (ref = this).emit.apply(ref, [ eventType ].concat( args ));
        (deferredEvents[eventType] || (deferredEvents[eventType] = [])).push(args);
    };
    // Public utility methods
    IroColorPicker.prototype.setOptions = function setOptions (newOptions) {
        this.setState(Object.assign({}, this.state, newOptions));
    };
    /**
     * @desc Resize the color picker
     * @param width - new width
     */
    IroColorPicker.prototype.resize = function resize (width) {
        this.setOptions({ width: width });
    };
    /**
     * @desc Reset the color picker to the initial color provided in the color picker options
     */
    IroColorPicker.prototype.reset = function reset () {
        this.colors.forEach(function (color) { return color.reset(); });
        this.setState({ colors: this.colors });
    };
    /**
     * @desc Called by the createWidget wrapper when the element is mounted into the page
     * @param container - the container element for this ColorPicker instance
     */
    IroColorPicker.prototype.onMount = function onMount (container) {
        this.el = container;
        this.deferredEmit('mount', this);
    };
    // Internal methods
    /**
     * @desc React to a color update
     * @param color - current color
     * @param changes - shows which h,s,v,a color channels changed
     */
    IroColorPicker.prototype.onColorChange = function onColorChange (color, changes) {
        this.setState({ color: this.color });
        if (this.inputActive) {
            this.inputActive = false;
            this.emit('input:change', color, changes);
        }
        this.emit('color:change', color, changes);
    };
    /**
     * @desc Handle input from a UI control element
     * @param type - event type
     */
    IroColorPicker.prototype.emitInputEvent = function emitInputEvent (type) {
        if (type === 0 /* Start */) {
            this.emit('input:start', this.color);
        }
        else if (type === 1 /* Move */) {
            this.emit('input:move', this.color);
        }
        else if (type === 2 /* End */) {
            this.emit('input:end', this.color);
        }
    };
    IroColorPicker.prototype.render = function render (props, state) {
        var this$1 = this;

        var layout = state.layout;
        // use layout shorthands
        if (!Array.isArray(layout)) {
            switch (layout) {
                // TODO: implement some?
                default:
                    layout = [
                        { component: IroWheel },
                        { component: IroSlider } ];
            }
            // add transparency slider to the layout
            if (state.transparency) {
                layout.push({
                    component: IroSlider,
                    options: {
                        sliderType: 'alpha'
                    }
                });
            }
        }
        return (h("div", { class: "IroColorPicker", id: state.id, style: {
                display: state.display
            } }, layout.map(function (ref, componentIndex) {
                var UiComponent = ref.component;
                var options = ref.options;

                return (h(UiComponent, Object.assign({}, state, options, { ref: undefined, onInput: this$1.emitInputEvent.bind(this$1), parent: this$1, index: componentIndex })));
        })));
    };

    return IroColorPicker;
}(m));
IroColorPicker.defaultProps = Object.assign({}, iroColorPickerOptionDefaults,
    {colors: [],
    display: 'block',
    id: null,
    layout: 'default',
    margin: null});
var IroColorPickerWidget = createWidget(IroColorPicker);

var iro$1;
(function (iro) {
    iro.version = "5.2.3"; // replaced by @rollup/plugin-replace; see rollup.config.js
    iro.Color = IroColor;
    iro.ColorPicker = IroColorPickerWidget;
    var ui;
    (function (ui) {
        ui.h = h;
        ui.ComponentBase = IroComponentBase;
        ui.Handle = IroHandle;
        ui.Slider = IroSlider;
        ui.Wheel = IroWheel;
        ui.Box = IroBox;
    })(ui = iro.ui || (iro.ui = {}));
})(iro$1 || (iro$1 = {}));
var iro$1$1 = iro$1;

const zeaParamWidgetColorCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-color{color:var(--color-foreground-1)}.color-sample{height:30px;line-height:30px;border:1px solid var(--color-foreground-1);margin-bottom:0.5em;text-align:center;font-size:0.8em}";

const ZeaParamWidgetColor = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.colorPickerHeight = 200;
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Listen to window resize event
   */
  handleWindowResize() {
    clearTimeout(this.resizeTimeout);
    this.resizeTimeout = setTimeout(() => this.resizeColorPicker(), 500);
  }
  /**
   * Resizes color picker
   */
  resizeColorPicker() {
    this.colorPicker.resize(this.container.offsetWidth, this.colorPickerHeight);
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    this.setUpColorPicker();
    if (this.parameter) {
      this.parameter.on('valueChanged', () => {
        this.updateComponent();
      });
      this.updateComponent();
    }
    setTimeout(() => window.dispatchEvent(new Event('resize')), 1000);
  }
  /**
   * Called when the parameter value changes externally
   */
  updateComponent() {
    if (!this.parameterChange) {
      this.undoing = true;
      this.colorPicker.color.rgb = this.parameter.getValue().getAsRGBDict();
      this.undoing = false;
      this.sampleColor = this.colorPicker.color.hslString;
      this.setSampleTextColor();
    }
  }
  /**
   * Set the color of the text in the sample box
   */
  setSampleTextColor() {
    const l = 100 - this.colorPicker.color.hsl.l;
    this.sampleTextColor = `hsl(1, 0%, ${l}%)`;
  }
  /**
   * Setup the color picker and it's events
   */
  setUpColorPicker() {
    this.colorPicker = iro$1$1.ColorPicker(this.colorPickerContainer, {
      // Color picker options:
      // https://iro.js.org/guide.html
      width: this.container.offsetWidth,
      height: this.colorPickerHeight,
      anticlockwise: true,
      borderWidth: 0,
      borderColor: '#fff',
      sliderHeight: '10px',
      padding: 1,
      sliderMargin: 4,
      handleRadius: 4,
      layout: [
        {
          // hue slider
          component: iro$1$1.ui.Slider,
          options: {
            sliderType: 'hue',
          },
        },
        {
          // saturation slider
          component: iro$1$1.ui.Slider,
          options: {
            sliderType: 'saturation',
          },
        },
        {
          // regular value slider
          component: iro$1$1.ui.Slider,
          options: {},
        },
      ],
    });
    this.colorPicker.on('input:start', () => {
      this.handleUXChange(this.parameter.getValue());
    });
    this.colorPicker.on('input:end', () => {
      this.parameterChange = undefined;
    });
    this.colorPicker.on('color:change', () => {
      if (this.undoing)
        return;
      if (!globalThis.zeaEngine) {
        console.log('`zeaEngine` missing from `globalThis` object.');
        return;
      }
      const { Color } = globalThis.zeaEngine;
      const value = new Color();
      value.setFromRGBDict(this.colorPicker.color.rgb);
      this.sampleColor = this.colorPicker.color.hslString;
      this.setSampleTextColor();
      this.handleUXChange(value);
    });
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Main ender method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { ref: (el) => (this.container = el), class: "zea-param-widget-color" }, h$4("div", { style: {
        color: this.sampleTextColor,
        backgroundColor: this.sampleColor,
      }, class: "color-sample" }, this.sampleColor), h$4("div", { ref: (el) => (this.colorPickerContainer = el), class: "color-picker" })));
  }
  static get style() { return zeaParamWidgetColorCss; }
};
uxFactory.registerWidget('zea-param-widget-color', (p) => p.getDataType() === 'Color');

const zeaParamWidgetMaterialColorCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-material-color{color:var(--color-foreground-1)}.color-sample{height:30px;line-height:30px;border:1px solid var(--color-foreground-1);margin-bottom:0.5em;text-align:center;font-size:0.8em}";

const ZeaParamWidgetMaterialColor = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.colorPickerHeight = 200;
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Listen to window resize event
   */
  handleWindowResize() {
    clearTimeout(this.resizeTimeout);
    this.resizeTimeout = setTimeout(() => this.resizeColorPicker(), 500);
  }
  /**
   * Resizes the  Color Picker
   */
  resizeColorPicker() {
    this.colorPicker.resize(this.container.offsetWidth, this.colorPickerHeight);
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    this.setUpColorPicker();
    if (this.parameter) {
      this.parameter.on('valueChanged', () => {
        this.updateComponent();
      });
      this.updateComponent();
    }
  }
  /**
   * Called when the parameter value changes externally
   */
  updateComponent() {
    if (!this.parameterChange) {
      this.undoing = true;
      this.colorPicker.color.rgb = this.parameter.getValue().getAsRGBDict();
      this.undoing = false;
      this.sampleColor = this.colorPicker.color.hslString;
      this.setSampleTextColor();
    }
  }
  /**
   * Set the color of the text in the sample box
   */
  setSampleTextColor() {
    const l = 100 - this.colorPicker.color.hsl.l;
    this.sampleTextColor = `hsl(1, 0%, ${l}%)`;
  }
  /**
   * Setup the color picker and it's events
   */
  setUpColorPicker() {
    this.colorPicker = iro$1$1.ColorPicker(this.colorPickerContainer, {
      // Color picker options:
      // https://iro.js.org/guide.html
      width: this.container.offsetWidth,
      height: this.colorPickerHeight,
      anticlockwise: true,
      borderWidth: 0,
      borderColor: '#fff',
      sliderHeight: '10px',
      padding: 1,
      sliderMargin: 4,
      handleRadius: 4,
      layout: [
        {
          // hue slider
          component: iro$1$1.ui.Slider,
          options: {
            sliderType: 'hue',
          },
        },
        {
          // saturation slider
          component: iro$1$1.ui.Slider,
          options: {
            sliderType: 'saturation',
          },
        },
        {
          // regular value slider
          component: iro$1$1.ui.Slider,
          options: {},
        },
      ],
    });
    this.colorPicker.on('input:start', () => {
      this.handleUXChange(this.parameter.getValue());
    });
    this.colorPicker.on('input:end', () => {
      this.parameterChange = undefined;
    });
    this.colorPicker.on('color:change', () => {
      if (this.undoing)
        return;
      if (!globalThis.zeaEngine) {
        console.log('`zeaEngine` missing from `globalThis` object.');
        return;
      }
      const { Color } = globalThis.zeaEngine;
      const value = new Color();
      value.setFromRGBDict(this.colorPicker.color.rgb);
      this.sampleColor = this.colorPicker.color.hslString;
      this.setSampleTextColor();
      this.handleUXChange(value);
    });
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Main render method.
   * @return {JSX} The generated html
   */
  render() {
    clearTimeout(this.resizeTimeout);
    this.resizeTimeout = setTimeout(() => this.resizeColorPicker(), 500);
    return (h$4("div", { ref: (el) => (this.container = el), class: "zea-param-widget-material-color" }, h$4("div", { style: {
        color: this.sampleTextColor,
        backgroundColor: this.sampleColor,
      }, class: "color-sample" }, this.sampleColor), h$4("div", { ref: (el) => (this.colorPickerContainer = el), class: "color-picker" })));
  }
  static get style() { return zeaParamWidgetMaterialColorCss; }
};
uxFactory.registerWidget('zea-param-widget-material-color', (p) => p.getDataType() === 'Color' && 'getImage' in p);

const zeaParamWidgetNumberCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-number{color:var(--color-foreground-1);background-color:var(--color-background-2);max-width:400px}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}.zea-param-widget-number input{width:100%;box-sizing:border-box;color:var(--color-foreground-1);background-color:var(--color-background-3)}input[type='number']{padding:0.3em;font-size:0.9em;border:1px solid var(--color-grey-3);text-align:right}";

const ZeaParamWidgetNumber = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.onChange = this.onChange.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Re-init input when parameter changes
   */
  parameterChangeHandler() {
    this.setUpInput();
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    if (this.parameter) {
      this.setUpInput();
    }
  }
  /**
   * Set up the input
   */
  setUpInput() {
    this.range = this.parameter.getRange();
    this.step = this.parameter.getStep();
    this.updateComponent();
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Sets the value of the input
   */
  updateComponent() {
    if (this.range) {
      this.value =
        ((this.parameter.getValue() - this.range[0]) /
          (this.range[1] - this.range[0])) *
          200;
    }
    else {
      this.value = this.parameter.getValue();
    }
  }
  /**
   * Run when input changes
   */
  onChange() {
    let value = this.round(this.inputField.valueAsNumber);
    if (this.range) {
      // Renmap from the 0..200 integer to the floating point
      // range specified in the parameter.
      value = this.range[0] + (value / 200) * (this.range[1] - this.range[0]);
      value = this.clamp(value, this.range[0], this.range[1]);
    }
    this.handleUXChange(value);
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      this.parameter.setValue(value);
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    const change = new ParameterValueChange(this.parameter, value);
    undoRedoManager.addChange(change);
  }
  /**
   * Round number
   * @param {number} value Number to be rounded
   * @param {number} decimals Number of decimal places
   * @return {number} Rounded number
   */
  round(value, decimals = 6) {
    return Number(Math.round(Number(value + 'e' + decimals)) + 'e-' + decimals);
  }
  /**
   * Clamp number
   * @param {number} num Number to be rounded
   * @param {number} a Number of decimal places
   * @param {number} b Number of decimal places
   * @return {number} clamped number
   */
  clamp(num, a, b) {
    return Math.max(Math.min(num, Math.max(a, b)), Math.min(a, b));
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    if (this.range) {
      return (h$4("div", { class: "zea-param-widget-number" }, h$4("input", { onChange: this.onChange, ref: (el) => (this.inputField = el), class: "mdl-slider mdl-js-slider", type: "range", min: "0", max: "200", step: this.step ? this.step : 1, id: this.parameter.getName(), value: this.value, tabindex: "0" })));
    }
    return (h$4("div", { class: "zea-param-widget-number" }, h$4("input", { onChange: this.onChange, ref: (el) => (this.inputField = el), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", id: this.parameter.getName(), value: this.value, tabindex: "0" })));
  }
  static get watchers() { return {
    "parameter": ["parameterChangeHandler"]
  }; }
  static get style() { return zeaParamWidgetNumberCss; }
};
uxFactory.registerWidget('zea-param-widget-number', (p) => p.getDataType() === 'Number');

const zeaParamWidgetStringCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-string{color:var(--color-foreground-1);background-color:var(--color-background-2)}input{width:100%;box-sizing:border-box;padding:0.3em;font-size:0.9em;border:1px solid var(--color-grey-3);color:var(--color-foreground-1);background-color:var(--color-background-3)}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}";

const ZeaParamWidgetString = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.onInput = this.onInput.bind(this);
    this.onChange = this.onChange.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    if (this.parameter) {
      this.setUpInputs();
      this.updateComponent();
    }
  }
  /**
   * Set the inputs up
   */
  setUpInputs() {
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Value change handler
   */
  updateComponent() {
    if (!this.parameterChange) {
      this.txtField.value = this.parameter.getValue();
    }
  }
  /**
   * Input handler
   */
  onInput() {
    const value = this.txtField.value;
    this.handleUXChange(value);
  }
  /**
   * Change handler
   */
  onChange() {
    this.onInput();
    this.parameterChange = undefined;
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-param-widget-string" }, h$4("input", { onInput: this.onInput, onChange: this.onChange, onKeyUp: (e) => {
        e.stopPropagation();
      }, onKeyDown: (e) => {
        e.stopPropagation();
      }, ref: (el) => (this.txtField = el), id: this.parameter.getName(), type: "text", tabindex: "0" })));
  }
  static get style() { return zeaParamWidgetStringCss; }
};
uxFactory.registerWidget('zea-param-widget-string', (p) => p.getDataType() === 'String');

const zeaParamWidgetVec2Css = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-vec2{color:var(--color-foreground-1);background-color:var(--color-background-2);max-width:400px}.zea-param-widget-vec2 input{width:100%;box-sizing:border-box;color:var(--color-foreground-1);background-color:var(--color-background-3)}.zea-param-widget-vec2 input:first-child{margin-bottom:0.5em}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}.vector-input-wrap{display:flex;align-items:center;margin-bottom:0.5em}.vector-input-wrap label{font-size:0.7em;padding:0.3em 1em 0.3em 0.3em;opacity:0.5}input[type='number']{padding:0.3em;font-size:0.9em;border:1px solid var(--color-grey-3);text-align:right}";

const ZeaParamWidgetVec2 = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.onInput = this.onInput.bind(this);
    this.onBlur = this.onBlur.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Reinit input when paramater changes
   */
  parameterChangeHandler() {
    this.setUpInputs();
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    if (this.parameter) {
      this.setUpInputs();
      this.updateComponent();
    }
  }
  /**
   * Set the inputs up
   */
  setUpInputs() {
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Value change handler
   */
  updateComponent() {
    if (!this.parameterChange) {
      const vec2 = this.parameter.getValue();
      this.xField.value = `${this.round(vec2.x)}`;
      this.yField.value = `${this.round(vec2.y)}`;
    }
  }
  /**
   * Input handler
   */
  onInput() {
    if (!globalThis.zeaEngine) {
      console.log('`zeaEngine` missing from `globalThis` object.');
      return;
    }
    const { Vec2 } = globalThis.zeaEngine;
    const value = new Vec2(this.xField.valueAsNumber, this.yField.valueAsNumber);
    this.handleUXChange(value);
  }
  /**
   * Change handler
   */
  onBlur() {
    this.parameterChange = undefined;
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Round number
   * @param {number} value Number to be rounded
   * @param {number} decimals Number of decimal places
   * @return {number} Rounded number
   */
  round(value, decimals = 6) {
    return Number(Math.round(Number(value + 'e' + decimals)) + 'e-' + decimals);
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-param-widget-vec2" }, h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.xField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.xValue })), h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.yField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.yValue }))));
  }
  static get watchers() { return {
    "parameter": ["parameterChangeHandler"]
  }; }
  static get style() { return zeaParamWidgetVec2Css; }
};
uxFactory.registerWidget('zea-param-widget-vec2', (p) => p.getDataType() === 'Vec2');

const zeaParamWidgetVec3Css = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-vec3{color:var(--color-foreground-1);background-color:var(--color-background-2);max-width:400px}.zea-param-widget-vec3 input{width:100%;box-sizing:border-box;margin-bottom:0.5em;color:var(--color-foreground-1);background-color:var(--color-background-3)}.zea-param-widget-vec3 input:last-child{margin-bottom:0}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}.vector-input-wrap{display:flex;align-items:center;margin-bottom:0.5em}.vector-input-wrap label{font-size:0.7em;padding:0.3em 1em 0.3em 0.3em;opacity:0.5}input[type='number']{padding:0.3em;font-size:0.9em;border:1px solid var(--color-grey-3);text-align:right}";

const ZeaParamWidgetVec3 = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.onInput = this.onInput.bind(this);
    this.onBlur = this.onBlur.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Re-init input when parameter changes
   */
  parameterChangeHandler() {
    this.setUpInputs();
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    if (this.parameter) {
      this.setUpInputs();
      this.updateComponent();
    }
  }
  /**
   * Set the inputs up
   */
  setUpInputs() {
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Value change handler
   */
  updateComponent() {
    if (!this.parameterChange) {
      const vec3 = this.parameter.getValue();
      this.xField.value = `${this.round(vec3.x)}`;
      this.yField.value = `${this.round(vec3.y)}`;
      this.zField.value = `${this.round(vec3.z)}`;
    }
  }
  /**
   * Input handler
   */
  onInput() {
    if (!globalThis.zeaEngine) {
      console.log('`zeaEngine` missing from `globalThis` object.');
      return;
    }
    const { Vec3 } = globalThis.zeaEngine;
    const value = new Vec3(this.xField.valueAsNumber, this.yField.valueAsNumber, this.zField.valueAsNumber);
    this.handleUXChange(value);
  }
  /**
   * Change handler
   */
  onBlur() {
    this.parameterChange = undefined;
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Round number
   * @param {number} value Number to be rounded
   * @param {number} decimals Number of decimal places
   * @return {number} Rounded number
   */
  round(value, decimals = 6) {
    return Number(Math.round(Number(value + 'e' + decimals)) + 'e-' + decimals);
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-param-widget-vec3" }, h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.xField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.xValue })), h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.yField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.yValue })), h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "Z"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.zField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.zValue }))));
  }
  static get watchers() { return {
    "parameter": ["parameterChangeHandler"]
  }; }
  static get style() { return zeaParamWidgetVec3Css; }
};
uxFactory.registerWidget('zea-param-widget-vec3', (p) => p.getDataType() === 'Vec3');

const zeaParamWidgetVec4Css = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-vec4{color:var(--color-foreground-1);background-color:var(--color-background-2);max-width:400px}.zea-param-widget-vec4 input{width:100%;box-sizing:border-box;margin-bottom:0.5em;color:var(--color-foreground-1);background-color:var(--color-background-3)}.zea-param-widget-vec4 input:last-child{margin-bottom:0}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}.vector-input-wrap{display:flex;align-items:center;margin-bottom:0.5em}.vector-input-wrap label{font-size:0.7em;padding:0.3em 1em 0.3em 0.3em;opacity:0.5}input[type='number']{padding:0.3em;font-size:0.9em;border:1px solid var(--color-grey-3);text-align:right}";

const ZeaParamWidgetVec4 = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.onInput = this.onInput.bind(this);
    this.onBlur = this.onBlur.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Re-init input when parameter changes
   */
  parameterChangeHandler() {
    this.setUpInputs();
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    if (this.parameter) {
      this.setUpInputs();
      this.updateComponent();
    }
  }
  /**
   * Set the inputs up
   */
  setUpInputs() {
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Value change handler
   */
  updateComponent() {
    if (!this.parameterChange) {
      const vec4 = this.parameter.getValue();
      this.xField.value = `${this.round(vec4.x)}`;
      this.yField.value = `${this.round(vec4.y)}`;
      this.zField.value = `${this.round(vec4.z)}`;
      this.tField.value = `${this.round(vec4.t)}`;
    }
  }
  /**
   * Input handler
   */
  onInput() {
    if (!globalThis.zeaEngine) {
      console.log('`zeaEngine` missing from `globalThis` object.');
      return;
    }
    const { Vec4 } = globalThis.zeaEngine;
    const value = new Vec4(this.xField.valueAsNumber, this.yField.valueAsNumber, this.zField.valueAsNumber, this.tField.valueAsNumber);
    this.handleUXChange(value);
  }
  /**
   * Change handler
   */
  onBlur() {
    this.parameterChange = undefined;
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Round number
   * @param {number} value Number to be rounded
   * @param {number} decimals Number of decimal places
   * @return {number} Rounded number
   */
  round(value, decimals = 6) {
    return Number(Math.round(Number(value + 'e' + decimals)) + 'e-' + decimals);
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-param-widget-vec4" }, h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.xField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.xValue })), h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.yField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.yValue })), h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "Z"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.zField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.zValue })), h$4("div", { class: "vector-input-wrap" }, h$4("label", null, "T"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.tField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0", value: this.tValue }))));
  }
  static get watchers() { return {
    "parameter": ["parameterChangeHandler"]
  }; }
  static get style() { return zeaParamWidgetVec4Css; }
};
uxFactory.registerWidget('zea-param-widget-vec4', (p) => p.getDataType() === 'Vec4');

const zeaParamWidgetXfoCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-param-widget-xfo{color:var(--color-foreground-1);background-color:var(--color-background-2);max-width:400px}.zea-param-widget-xfo input{width:100%;box-sizing:border-box;color:var(--color-foreground-1);background-color:var(--color-background-3)}.user-edited{box-shadow:0 0 8px var(--color-success-1);margin:0px}.input-wrap{display:flex;align-items:center;margin-bottom:0.5em}.input-wrap label{font-size:0.7em;padding:0.3em 1em 0.3em 0.3em;opacity:0.5;width:1.5em;text-align:center}input[type='number']{padding:0.3em;font-size:0.9em;border:1px solid var(--color-grey-3);text-align:right}fieldset{border:1px solid var(--color-grey-3)}legend{color:var(--color-foreground-2);font-size:0.8em}";

const ZeaParamWidgetXfo = class extends HTMLElement {
  /**
   * Class constructor
   */
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.settingValue = false;
    this.onInput = this.onInput.bind(this);
    this.onBlur = this.onBlur.bind(this);
    if (!globalThis.zeaEngine) {
      console.warn('`zeaEngine` missing from the `globalThis` object and this component requires it');
    }
  }
  /**
   * Run when component loads
   */
  componentDidLoad() {
    if (this.parameter) {
      this.setUpInputs();
      this.updateComponent();
    }
  }
  /**
   * Value change handler
   */
  updateComponent() {
    if (!this.settingValue) {
      const xfo = this.parameter.getValue();
      this.trxField.value = `${this.round(xfo.tr.x)}`;
      this.tryField.value = `${this.round(xfo.tr.y)}`;
      this.trzField.value = `${this.round(xfo.tr.z)}`;
      this.orxField.value = `${this.round(xfo.ori.x)}`;
      this.oryField.value = `${this.round(xfo.ori.y)}`;
      this.orzField.value = `${this.round(xfo.ori.z)}`;
      this.orwField.value = `${this.round(xfo.ori.w)}`;
      this.scxField.value = `${this.round(xfo.sc.x)}`;
      this.scyField.value = `${this.round(xfo.sc.y)}`;
      this.sczField.value = `${this.round(xfo.sc.z)}`;
    }
  }
  /**
   * Set the inputs up
   */
  setUpInputs() {
    this.parameter.on('valueChanged', () => {
      this.updateComponent();
    });
  }
  /**
   * Input handler
   */
  onInput() {
    this.settingValue = true;
    if (!globalThis.zeaEngine) {
      console.log('`zeaEngine` missing from `globalThis` object.');
      return;
    }
    const { Xfo } = globalThis.zeaEngine;
    const value = new Xfo();
    value.tr.set(this.trxField.valueAsNumber, this.tryField.valueAsNumber, this.trzField.valueAsNumber);
    value.ori.set(this.orxField.valueAsNumber, this.oryField.valueAsNumber, this.orzField.valueAsNumber, this.orwField.valueAsNumber); /* value order is xyzw*/
    value.ori.normalizeInPlace();
    value.sc.set(this.scxField.valueAsNumber, this.scyField.valueAsNumber, this.sczField.valueAsNumber);
    this.handleUXChange(value);
  }
  /**
   * Change handler
   */
  onBlur() {
    this.settingValue = false;
    this.parameterChange = undefined;
  }
  /**
   * Handles the creation of the UX Change object and the UndoRedoManager
   *
   * @param {Parameter} value - Parameter object
   */
  handleUXChange(value) {
    if (!globalThis.zeaUx) {
      console.log('To add Undo/Redo functionalities just add `zeaUx` library to your `globalThis` object, because right now it is missing.');
      return;
    }
    const { UndoRedoManager, ParameterValueChange } = globalThis.zeaUx;
    const undoRedoManager = UndoRedoManager.getInstance();
    if (!this.parameterChange) {
      this.parameterChange = new ParameterValueChange(this.parameter, value);
      undoRedoManager.addChange(this.parameterChange);
    }
    else {
      this.parameterChange.update({ value });
    }
  }
  /**
   * Round number
   * @param {number} value the value to be rounded
   * @param {number} decimals decimal places to keep
   * @return {number} the rouunded value
   */
  round(value, decimals = 6) {
    if (Math.abs(value) < Number('1e-6'))
      return 0;
    return Number(Math.round(Number(value + 'e' + decimals)) + 'e-' + decimals);
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-param-widget-xfo" }, h$4("fieldset", null, h$4("legend", null, "Translation"), h$4("div", { class: "input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.trxField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.tryField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Z"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.trzField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" }))), h$4("fieldset", null, h$4("legend", null, "Rotation"), h$4("div", { class: "input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.orxField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.oryField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Z"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.orzField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "W"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.orwField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" }))), h$4("fieldset", null, h$4("legend", null, "Scale"), h$4("div", { class: "input-wrap" }, h$4("label", null, "X"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.scxField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Y"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.scyField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })), h$4("div", { class: "input-wrap" }, h$4("label", null, "Z"), h$4("input", { onInput: this.onInput, onBlur: this.onBlur, ref: (el) => (this.sczField = el), id: this.parameter.getName(), type: "number", pattern: "-?[0-9]*(.[0-9]+)?", tabindex: "0" })))));
  }
  static get style() { return zeaParamWidgetXfoCss; }
};
uxFactory.registerWidget('zea-param-widget-xfo', (p) => p.getDataType() === 'Xfo');

const zeaParameterContainerCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-parameter-container{color:var(--color-foreground-1);background-color:var(--color-background-2);padding:0.5em}.zea-param-widget-wrap{margin-bottom:1.2em}.zea-param-widget-boolean-wrap{display:flex;flex-direction:row-reverse;justify-content:flex-end;align-items:center}label{font-size:0.8em;padding-bottom:0.4em;padding:0.5em 0 0.5em;display:block}";

const ZeaParameterContainer = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    return (h$4("div", { class: "zea-parameter-container" }, this.parameterOwner.getParameters().map((parameter, index) => {
      const parameterName = parameter.getName();
      const reg = uxFactory.findWidgetReg(parameter);
      if (!reg) {
        return (h$4("div", null, "Unable to display parameter '", parameterName, "', value:", parameter.getValue(), ", index: ", index));
      }
      return (h$4("div", { class: `zea-param-widget-wrap ${reg.widget}-wrap` }, h$4("label", { htmlFor: parameterName }, parameterName), h$4("div", { class: "zea-parameter-input-wrap" }, h$4(reg.widget, { id: parameterName, key: index, appData: this.appData, parameter: parameter }))));
    })));
  }
  static get style() { return zeaParameterContainerCss; }
};

const zeaPopupMenuCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-popup-menu{color:var(--color-foreground-1);display:none;position:absolute;z-index:10000;background-color:var(--color-background-2);box-shadow:0px 5px 10px var(--color-shadow);padding:0.5em 0}.zea-popup-menu.shown{display:block}";

const ZeaPopupMenu = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Whether the menu should be shown
     */
    this.shown = false;
    /**
     * Add twinkle effect on item click
     * @param {any} elmnt the item element
     */
    this.twinkleElement = (elmnt) => {
      elmnt.classList.toggle('twinkled');
      const interval = setInterval(() => {
        elmnt.classList.toggle('twinkled');
      }, 70);
      setTimeout(() => {
        clearTimeout(interval);
        elmnt.classList.remove('twinkled');
      }, 100);
    };
  }
  /**
   * Main render function
   * @param {any} ev the event
   */
  handleClick(ev) {
    if (ev.target == this.anchorElement) {
      this.bbox = ev.target.getBoundingClientRect();
      this.leftOffset = `${this.bbox.left}px`;
      this.topOffset = `${this.bbox.top}px`;
      this.shown = !this.shown;
      return;
    }
    // check if the clicked element is part of the menu
    if (this.hostElement.contains(ev.target)) {
      const item = ev.target.shadowRoot.querySelector('.zea-popup-menu-item');
      this.twinkleElement(item);
      setTimeout(() => {
        this.shown = false;
      }, 300);
    }
    else {
      if (this.anchorElement)
        this.shown = false;
    }
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("div", { ref: (node) => (this.node = node), class: `zea-popup-menu ${this.shown ? 'shown' : 'hidden'}`, style: {
        top: this.topOffset,
        left: this.leftOffset,
      } }, h$4("slot", null)));
  }
  get hostElement() { return this; }
  static get style() { return zeaPopupMenuCss; }
};

const zeaPopupMenuItemCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-popup-menu-item{color:var(--color-foreground-1);font-family:sans-serif;padding:0.3em 0.6em;cursor:pointer;display:flex;align-items:center;justify-content:left}.zea-popup-menu-item:hover{background-color:var(--color-grey-3)}.zea-popup-menu-item.twinkled{background-color:var(--color-secondary-3)}.start-icon{margin-right:0.5em;display:flex;align-items:center;justify-content:center}.end-icon{margin-left:0.5em;display:flex;align-items:center;justify-content:center}";

const ZeaPopupMenuItem = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Handle item click
     * @param {Event} e The event
     */
    this.handleItemClick = (e) => {
      if (this.clickHandler)
        this.clickHandler(e);
    };
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    let startIcon;
    let endIcon;
    if (this.startIcon) {
      startIcon = (h$4("span", { class: "start-icon" }, h$4("zea-icon", { name: this.startIcon })));
    }
    if (this.endIcon) {
      endIcon = (h$4("span", { class: "end-icon" }, h$4("zea-icon", { name: this.endIcon })));
    }
    return (h$4("div", { onClick: (e) => this.handleItemClick(e), class: "zea-popup-menu-item" }, startIcon, h$4("span", null, h$4("slot", null)), endIcon));
  }
  static get style() { return zeaPopupMenuItemCss; }
};

const zeaProgressBarCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-progress-bar{position:absolute;bottom:0;left:0;width:100%;box-sizing:border-box;overflow:hidden}.progress{overflow:hidden;max-width:100%;transition:width 0.4s}.indeterminate .progress{position:absolute;animation-name:indeterminate_progress_continuous;animation-duration:1.4s;animation-iteration-count:infinite;animation-timing-function:linear}.indeterminate.pulsating .progress{position:absolute;width:20% !important;animation-name:indeterminate_progress_pulsating;animation-duration:1.4s;animation-iteration-count:infinite;animation-timing-function:linear}@keyframes indeterminate_progress_continuous{0%{width:0;left:0}50%{width:100%;left:0}100%{width:0%;left:100%}}@keyframes indeterminate_progress_pulsating{0%{width:0;left:0}25%{width:30%;left:0}50%{width:50%;left:25%}75%{width:30%;left:75%}100%{width:0%;left:100%}}";

const ZeaProgressBar = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * The bar type (determinate | indeterminate)
     */
    this.type = 'determinate';
    /**
     * The progress (width) percentage for the bar
     */
    this.percent = 50;
    /**
     * The size (height) of the progress bar
     */
    this.size = 3;
    /**
     * The color for the bar
     */
    this.color = 'var(--color-primary-1)';
    /**
     * The color for the background track
     */
    this.backgroundColor = 'var(--color-primary-3)';
    /**
     * The animation type for the indeterminate bar ( continuous | pulsating)
     */
    this.indeterminateAnimation = 'continuous';
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4("div", { class: `zea-progress-bar ${this.type} ${this.indeterminateAnimation}`, style: {
        backgroundColor: this.backgroundColor,
        height: this.size + 'px',
      } }, h$4("div", { class: "progress", style: {
        width: this.percent + '%',
        height: this.size + 'px',
        backgroundColor: this.color,
      } })));
  }
  static get style() { return zeaProgressBarCss; }
};

// can-promise has a crash in some versions of react native that dont have
// standard global objects
// https://github.com/soldair/node-qrcode/issues/157

var canPromise = function () {
  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
};

var toString = {}.toString;

var isarray = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

function typedArraySupport () {
  // Can typed array instances be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }};
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Buffer$1.TYPED_ARRAY_SUPPORT = typedArraySupport();

var K_MAX_LENGTH = Buffer$1.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff;

function Buffer$1 (arg, offset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, offset, length)
  }

  if (typeof arg === 'number') {
    return allocUnsafe(this, arg)
  }

  return from(this, arg, offset, length)
}

if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;

  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer$1[Symbol.species] === Buffer$1) {
    Object.defineProperty(Buffer$1, Symbol.species, {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    });
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

function createBuffer (that, length) {
  var buf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    buf = new Uint8Array(length);
    buf.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    buf = that;
    if (buf === null) {
      buf = new Buffer$1(length);
    }
    buf.length = length;
  }

  return buf
}

function allocUnsafe (that, size) {
  var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      buf[i] = 0;
    }
  }

  return buf
}

function fromString (that, string) {
  var length = byteLength(string) | 0;
  var buf = createBuffer(that, length);

  var actual = buf.write(string);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf
}

function fromArrayBuffer (that, array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    buf.__proto__ = Buffer$1.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    buf = fromArrayLike(that, buf);
  }

  return buf
}

function fromObject (that, obj) {
  if (Buffer$1.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(that, len);

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len);
    return buf
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function byteLength (string) {
  if (Buffer$1.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  return utf8ToBytes(string).length
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function from (that, value, offset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, offset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value)
  }

  return fromObject(that, value)
}

Buffer$1.prototype.write = function write (string, offset, length) {
  // Buffer#write(string)
  if (offset === undefined) {
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
    } else {
      length = undefined;
    }
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  return utf8Write(this, string, offset, length)
};

Buffer$1.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

Buffer$1.prototype.fill = function fill (val, start, end) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer$1.isBuffer(val)
      ? val
      : new Buffer$1(val);
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

Buffer$1.concat = function concat (list, length) {
  if (!isarray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return createBuffer(null, 0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = allocUnsafe(null, length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer$1.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

Buffer$1.byteLength = byteLength;

Buffer$1.prototype._isBuffer = true;
Buffer$1.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
};

var alloc = function (size) {
  var buffer = new Buffer$1(size);
  buffer.fill(0);
  return buffer
};

var from_1 = function (data) {
  return new Buffer$1(data)
};

var typedarrayBuffer = {
	alloc: alloc,
	from: from_1
};

var toSJISFunction;
var CODEWORDS_COUNT = [
  0, // Not used
  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
];

/**
 * Returns the QR Code size for the specified version
 *
 * @param  {Number} version QR Code version
 * @return {Number}         size of QR code
 */
var getSymbolSize = function getSymbolSize (version) {
  if (!version) throw new Error('"version" cannot be null or undefined')
  if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
  return version * 4 + 17
};

/**
 * Returns the total number of codewords used to store data and EC information.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Data length in bits
 */
var getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
  return CODEWORDS_COUNT[version]
};

/**
 * Encode data with Bose-Chaudhuri-Hocquenghem
 *
 * @param  {Number} data Value to encode
 * @return {Number}      Encoded value
 */
var getBCHDigit = function (data) {
  var digit = 0;

  while (data !== 0) {
    digit++;
    data >>>= 1;
  }

  return digit
};

var setToSJISFunction = function setToSJISFunction (f) {
  if (typeof f !== 'function') {
    throw new Error('"toSJISFunc" is not a valid function.')
  }

  toSJISFunction = f;
};

var isKanjiModeEnabled = function () {
  return typeof toSJISFunction !== 'undefined'
};

var toSJIS = function toSJIS (kanji) {
  return toSJISFunction(kanji)
};

var utils = {
	getSymbolSize: getSymbolSize,
	getSymbolTotalCodewords: getSymbolTotalCodewords,
	getBCHDigit: getBCHDigit,
	setToSJISFunction: setToSJISFunction,
	isKanjiModeEnabled: isKanjiModeEnabled,
	toSJIS: toSJIS
};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
    return commonjsRequire();
  }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var errorCorrectionLevel = createCommonjsModule(function (module, exports) {
exports.L = { bit: 1 };
exports.M = { bit: 0 };
exports.Q = { bit: 3 };
exports.H = { bit: 2 };

function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  var lcStr = string.toLowerCase();

  switch (lcStr) {
    case 'l':
    case 'low':
      return exports.L

    case 'm':
    case 'medium':
      return exports.M

    case 'q':
    case 'quartile':
      return exports.Q

    case 'h':
    case 'high':
      return exports.H

    default:
      throw new Error('Unknown EC Level: ' + string)
  }
}

exports.isValid = function isValid (level) {
  return level && typeof level.bit !== 'undefined' &&
    level.bit >= 0 && level.bit < 4
};

exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
};
});

function BitBuffer () {
  this.buffer = [];
  this.length = 0;
}

BitBuffer.prototype = {

  get: function (index) {
    var bufIndex = Math.floor(index / 8);
    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
  },

  put: function (num, length) {
    for (var i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1);
    }
  },

  getLengthInBits: function () {
    return this.length
  },

  putBit: function (bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }

    if (bit) {
      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
    }

    this.length++;
  }
};

var bitBuffer = BitBuffer;

/**
 * Helper class to handle QR Code symbol modules
 *
 * @param {Number} size Symbol size
 */
function BitMatrix (size) {
  if (!size || size < 1) {
    throw new Error('BitMatrix size must be defined and greater than 0')
  }

  this.size = size;
  this.data = typedarrayBuffer.alloc(size * size);
  this.reservedBit = typedarrayBuffer.alloc(size * size);
}

/**
 * Set bit value at specified location
 * If reserved flag is set, this bit will be ignored during masking process
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 * @param {Boolean} reserved
 */
BitMatrix.prototype.set = function (row, col, value, reserved) {
  var index = row * this.size + col;
  this.data[index] = value;
  if (reserved) this.reservedBit[index] = true;
};

/**
 * Returns bit value at specified location
 *
 * @param  {Number}  row
 * @param  {Number}  col
 * @return {Boolean}
 */
BitMatrix.prototype.get = function (row, col) {
  return this.data[row * this.size + col]
};

/**
 * Applies xor operator at specified location
 * (used during masking process)
 *
 * @param {Number}  row
 * @param {Number}  col
 * @param {Boolean} value
 */
BitMatrix.prototype.xor = function (row, col, value) {
  this.data[row * this.size + col] ^= value;
};

/**
 * Check if bit at specified location is reserved
 *
 * @param {Number}   row
 * @param {Number}   col
 * @return {Boolean}
 */
BitMatrix.prototype.isReserved = function (row, col) {
  return this.reservedBit[row * this.size + col]
};

var bitMatrix = BitMatrix;

var alignmentPattern = createCommonjsModule(function (module, exports) {
/**
 * Alignment pattern are fixed reference pattern in defined positions
 * in a matrix symbology, which enables the decode software to re-synchronise
 * the coordinate mapping of the image modules in the event of moderate amounts
 * of distortion of the image.
 *
 * Alignment patterns are present only in QR Code symbols of version 2 or larger
 * and their number depends on the symbol version.
 */

var getSymbolSize = utils.getSymbolSize;

/**
 * Calculate the row/column coordinates of the center module of each alignment pattern
 * for the specified QR Code version.
 *
 * The alignment patterns are positioned symmetrically on either side of the diagonal
 * running from the top left corner of the symbol to the bottom right corner.
 *
 * Since positions are simmetrical only half of the coordinates are returned.
 * Each item of the array will represent in turn the x and y coordinate.
 * @see {@link getPositions}
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinate
 */
exports.getRowColCoords = function getRowColCoords (version) {
  if (version === 1) return []

  var posCount = Math.floor(version / 7) + 2;
  var size = getSymbolSize(version);
  var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
  var positions = [size - 7]; // Last coord is always (size - 7)

  for (var i = 1; i < posCount - 1; i++) {
    positions[i] = positions[i - 1] - intervals;
  }

  positions.push(6); // First coord is always 6

  return positions.reverse()
};

/**
 * Returns an array containing the positions of each alignment pattern.
 * Each array's element represent the center point of the pattern as (x, y) coordinates
 *
 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
 * and filtering out the items that overlaps with finder pattern
 *
 * @example
 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
 * The alignment patterns, therefore, are to be centered on (row, column)
 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
 * and are not therefore used for alignment patterns.
 *
 * var pos = getPositions(7)
 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
exports.getPositions = function getPositions (version) {
  var coords = [];
  var pos = exports.getRowColCoords(version);
  var posLength = pos.length;

  for (var i = 0; i < posLength; i++) {
    for (var j = 0; j < posLength; j++) {
      // Skip if position is occupied by finder patterns
      if ((i === 0 && j === 0) ||             // top-left
          (i === 0 && j === posLength - 1) || // bottom-left
          (i === posLength - 1 && j === 0)) { // top-right
        continue
      }

      coords.push([pos[i], pos[j]]);
    }
  }

  return coords
};
});

var getSymbolSize$1 = utils.getSymbolSize;
var FINDER_PATTERN_SIZE = 7;

/**
 * Returns an array containing the positions of each finder pattern.
 * Each array's element represent the top-left point of the pattern as (x, y) coordinates
 *
 * @param  {Number} version QR Code version
 * @return {Array}          Array of coordinates
 */
var getPositions = function getPositions (version) {
  var size = getSymbolSize$1(version);

  return [
    // top-left
    [0, 0],
    // top-right
    [size - FINDER_PATTERN_SIZE, 0],
    // bottom-left
    [0, size - FINDER_PATTERN_SIZE]
  ]
};

var finderPattern = {
	getPositions: getPositions
};

var maskPattern = createCommonjsModule(function (module, exports) {
/**
 * Data mask pattern reference
 * @type {Object}
 */
exports.Patterns = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
};

/**
 * Weighted penalty scores for the undesirable features
 * @type {Object}
 */
var PenaltyScores = {
  N1: 3,
  N2: 3,
  N3: 40,
  N4: 10
};

/**
 * Check if mask pattern value is valid
 *
 * @param  {Number}  mask    Mask pattern
 * @return {Boolean}         true if valid, false otherwise
 */
exports.isValid = function isValid (mask) {
  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
};

/**
 * Returns mask pattern from a value.
 * If value is not valid, returns undefined
 *
 * @param  {Number|String} value        Mask pattern value
 * @return {Number}                     Valid mask pattern or undefined
 */
exports.from = function from (value) {
  return exports.isValid(value) ? parseInt(value, 10) : undefined
};

/**
* Find adjacent modules in row/column with the same color
* and assign a penalty value.
*
* Points: N1 + i
* i is the amount by which the number of adjacent modules of the same color exceeds 5
*/
exports.getPenaltyN1 = function getPenaltyN1 (data) {
  var size = data.size;
  var points = 0;
  var sameCountCol = 0;
  var sameCountRow = 0;
  var lastCol = null;
  var lastRow = null;

  for (var row = 0; row < size; row++) {
    sameCountCol = sameCountRow = 0;
    lastCol = lastRow = null;

    for (var col = 0; col < size; col++) {
      var module = data.get(row, col);
      if (module === lastCol) {
        sameCountCol++;
      } else {
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        lastCol = module;
        sameCountCol = 1;
      }

      module = data.get(col, row);
      if (module === lastRow) {
        sameCountRow++;
      } else {
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
        lastRow = module;
        sameCountRow = 1;
      }
    }

    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
  }

  return points
};

/**
 * Find 2x2 blocks with the same color and assign a penalty value
 *
 * Points: N2 * (m - 1) * (n - 1)
 */
exports.getPenaltyN2 = function getPenaltyN2 (data) {
  var size = data.size;
  var points = 0;

  for (var row = 0; row < size - 1; row++) {
    for (var col = 0; col < size - 1; col++) {
      var last = data.get(row, col) +
        data.get(row, col + 1) +
        data.get(row + 1, col) +
        data.get(row + 1, col + 1);

      if (last === 4 || last === 0) points++;
    }
  }

  return points * PenaltyScores.N2
};

/**
 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
 * preceded or followed by light area 4 modules wide
 *
 * Points: N3 * number of pattern found
 */
exports.getPenaltyN3 = function getPenaltyN3 (data) {
  var size = data.size;
  var points = 0;
  var bitsCol = 0;
  var bitsRow = 0;

  for (var row = 0; row < size; row++) {
    bitsCol = bitsRow = 0;
    for (var col = 0; col < size; col++) {
      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);
      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;

      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);
      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
    }
  }

  return points * PenaltyScores.N3
};

/**
 * Calculate proportion of dark modules in entire symbol
 *
 * Points: N4 * k
 *
 * k is the rating of the deviation of the proportion of dark modules
 * in the symbol from 50% in steps of 5%
 */
exports.getPenaltyN4 = function getPenaltyN4 (data) {
  var darkCount = 0;
  var modulesCount = data.data.length;

  for (var i = 0; i < modulesCount; i++) darkCount += data.data[i];

  var k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);

  return k * PenaltyScores.N4
};

/**
 * Return mask value at given position
 *
 * @param  {Number} maskPattern Pattern reference value
 * @param  {Number} i           Row
 * @param  {Number} j           Column
 * @return {Boolean}            Mask value
 */
function getMaskAt (maskPattern, i, j) {
  switch (maskPattern) {
    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
    case exports.Patterns.PATTERN001: return i % 2 === 0
    case exports.Patterns.PATTERN010: return j % 3 === 0
    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

    default: throw new Error('bad maskPattern:' + maskPattern)
  }
}

/**
 * Apply a mask pattern to a BitMatrix
 *
 * @param  {Number}    pattern Pattern reference number
 * @param  {BitMatrix} data    BitMatrix data
 */
exports.applyMask = function applyMask (pattern, data) {
  var size = data.size;

  for (var col = 0; col < size; col++) {
    for (var row = 0; row < size; row++) {
      if (data.isReserved(row, col)) continue
      data.xor(row, col, getMaskAt(pattern, row, col));
    }
  }
};

/**
 * Returns the best mask pattern for data
 *
 * @param  {BitMatrix} data
 * @return {Number} Mask pattern reference number
 */
exports.getBestMask = function getBestMask (data, setupFormatFunc) {
  var numPatterns = Object.keys(exports.Patterns).length;
  var bestPattern = 0;
  var lowerPenalty = Infinity;

  for (var p = 0; p < numPatterns; p++) {
    setupFormatFunc(p);
    exports.applyMask(p, data);

    // Calculate penalty
    var penalty =
      exports.getPenaltyN1(data) +
      exports.getPenaltyN2(data) +
      exports.getPenaltyN3(data) +
      exports.getPenaltyN4(data);

    // Undo previously applied mask
    exports.applyMask(p, data);

    if (penalty < lowerPenalty) {
      lowerPenalty = penalty;
      bestPattern = p;
    }
  }

  return bestPattern
};
});

var EC_BLOCKS_TABLE = [
// L  M  Q  H
  1, 1, 1, 1,
  1, 1, 1, 1,
  1, 1, 2, 2,
  1, 2, 2, 4,
  1, 2, 4, 4,
  2, 4, 4, 4,
  2, 4, 6, 5,
  2, 4, 6, 6,
  2, 5, 8, 8,
  4, 5, 8, 8,
  4, 5, 8, 11,
  4, 8, 10, 11,
  4, 9, 12, 16,
  4, 9, 16, 16,
  6, 10, 12, 18,
  6, 10, 17, 16,
  6, 11, 16, 19,
  6, 13, 18, 21,
  7, 14, 21, 25,
  8, 16, 20, 25,
  8, 17, 23, 25,
  9, 17, 23, 34,
  9, 18, 25, 30,
  10, 20, 27, 32,
  12, 21, 29, 35,
  12, 23, 34, 37,
  12, 25, 34, 40,
  13, 26, 35, 42,
  14, 28, 38, 45,
  15, 29, 40, 48,
  16, 31, 43, 51,
  17, 33, 45, 54,
  18, 35, 48, 57,
  19, 37, 51, 60,
  19, 38, 53, 63,
  20, 40, 56, 66,
  21, 43, 59, 70,
  22, 45, 62, 74,
  24, 47, 65, 77,
  25, 49, 68, 81
];

var EC_CODEWORDS_TABLE = [
// L  M  Q  H
  7, 10, 13, 17,
  10, 16, 22, 28,
  15, 26, 36, 44,
  20, 36, 52, 64,
  26, 48, 72, 88,
  36, 64, 96, 112,
  40, 72, 108, 130,
  48, 88, 132, 156,
  60, 110, 160, 192,
  72, 130, 192, 224,
  80, 150, 224, 264,
  96, 176, 260, 308,
  104, 198, 288, 352,
  120, 216, 320, 384,
  132, 240, 360, 432,
  144, 280, 408, 480,
  168, 308, 448, 532,
  180, 338, 504, 588,
  196, 364, 546, 650,
  224, 416, 600, 700,
  224, 442, 644, 750,
  252, 476, 690, 816,
  270, 504, 750, 900,
  300, 560, 810, 960,
  312, 588, 870, 1050,
  336, 644, 952, 1110,
  360, 700, 1020, 1200,
  390, 728, 1050, 1260,
  420, 784, 1140, 1350,
  450, 812, 1200, 1440,
  480, 868, 1290, 1530,
  510, 924, 1350, 1620,
  540, 980, 1440, 1710,
  570, 1036, 1530, 1800,
  570, 1064, 1590, 1890,
  600, 1120, 1680, 1980,
  630, 1204, 1770, 2100,
  660, 1260, 1860, 2220,
  720, 1316, 1950, 2310,
  750, 1372, 2040, 2430
];

/**
 * Returns the number of error correction block that the QR Code should contain
 * for the specified version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction blocks
 */
var getBlocksCount = function getBlocksCount (version, errorCorrectionLevel$1) {
  switch (errorCorrectionLevel$1) {
    case errorCorrectionLevel.L:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
    case errorCorrectionLevel.M:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
    case errorCorrectionLevel.Q:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
    case errorCorrectionLevel.H:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
};

/**
 * Returns the number of error correction codewords to use for the specified
 * version and error correction level.
 *
 * @param  {Number} version              QR Code version
 * @param  {Number} errorCorrectionLevel Error correction level
 * @return {Number}                      Number of error correction codewords
 */
var getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel$1) {
  switch (errorCorrectionLevel$1) {
    case errorCorrectionLevel.L:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
    case errorCorrectionLevel.M:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
    case errorCorrectionLevel.Q:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
    case errorCorrectionLevel.H:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
    default:
      return undefined
  }
};

var errorCorrectionCode = {
	getBlocksCount: getBlocksCount,
	getTotalCodewordsCount: getTotalCodewordsCount
};

var EXP_TABLE = typedarrayBuffer.alloc(512);
var LOG_TABLE = typedarrayBuffer.alloc(256)
/**
 * Precompute the log and anti-log tables for faster computation later
 *
 * For each possible value in the galois field 2^8, we will pre-compute
 * the logarithm and anti-logarithm (exponential) of this value
 *
 * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
 */
;(function initTables () {
  var x = 1;
  for (var i = 0; i < 255; i++) {
    EXP_TABLE[i] = x;
    LOG_TABLE[x] = i;

    x <<= 1; // multiply by 2

    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
    // This means that when a number is 256 or larger, it should be XORed with 0x11D.
    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
      x ^= 0x11D;
    }
  }

  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
  // stay inside the bounds (because we will mainly use this table for the multiplication of
  // two GF numbers, no more).
  // @see {@link mul}
  for (i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255];
  }
}());

/**
 * Returns log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
var log$1 = function log (n) {
  if (n < 1) throw new Error('log(' + n + ')')
  return LOG_TABLE[n]
};

/**
 * Returns anti-log value of n inside Galois Field
 *
 * @param  {Number} n
 * @return {Number}
 */
var exp = function exp (n) {
  return EXP_TABLE[n]
};

/**
 * Multiplies two number inside Galois Field
 *
 * @param  {Number} x
 * @param  {Number} y
 * @return {Number}
 */
var mul = function mul (x, y) {
  if (x === 0 || y === 0) return 0

  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
  // @see {@link initTables}
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
};

var galoisField = {
	log: log$1,
	exp: exp,
	mul: mul
};

var polynomial = createCommonjsModule(function (module, exports) {
/**
 * Multiplies two polynomials inside Galois Field
 *
 * @param  {Buffer} p1 Polynomial
 * @param  {Buffer} p2 Polynomial
 * @return {Buffer}    Product of p1 and p2
 */
exports.mul = function mul (p1, p2) {
  var coeff = typedarrayBuffer.alloc(p1.length + p2.length - 1);

  for (var i = 0; i < p1.length; i++) {
    for (var j = 0; j < p2.length; j++) {
      coeff[i + j] ^= galoisField.mul(p1[i], p2[j]);
    }
  }

  return coeff
};

/**
 * Calculate the remainder of polynomials division
 *
 * @param  {Buffer} divident Polynomial
 * @param  {Buffer} divisor  Polynomial
 * @return {Buffer}          Remainder
 */
exports.mod = function mod (divident, divisor) {
  var result = typedarrayBuffer.from(divident);

  while ((result.length - divisor.length) >= 0) {
    var coeff = result[0];

    for (var i = 0; i < divisor.length; i++) {
      result[i] ^= galoisField.mul(divisor[i], coeff);
    }

    // remove all zeros from buffer head
    var offset = 0;
    while (offset < result.length && result[offset] === 0) offset++;
    result = result.slice(offset);
  }

  return result
};

/**
 * Generate an irreducible generator polynomial of specified degree
 * (used by Reed-Solomon encoder)
 *
 * @param  {Number} degree Degree of the generator polynomial
 * @return {Buffer}        Buffer containing polynomial coefficients
 */
exports.generateECPolynomial = function generateECPolynomial (degree) {
  var poly = typedarrayBuffer.from([1]);
  for (var i = 0; i < degree; i++) {
    poly = exports.mul(poly, [1, galoisField.exp(i)]);
  }

  return poly
};
});

const global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString$1 = {}.toString;

var isArray = Array.isArray || function (arr) {
  return toString$1.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
var _kMaxLength = kMaxLength();

function kMaxLength () {
  return Buffer$2.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer$1 (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$2.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$2(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$2 (arg, encodingOrOffset, length) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe$1(this, arg)
  }
  return from$1(this, arg, encodingOrOffset, length)
}

Buffer$2.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$2._augment = function (arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr
};

function from$1 (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer$1(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString$1(that, value, encodingOrOffset)
  }

  return fromObject$1(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$2.from = function (value, encodingOrOffset, length) {
  return from$1(null, value, encodingOrOffset, length)
};

if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc$1 (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer$1(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer$1(that, size).fill(fill, encoding)
      : createBuffer$1(that, size).fill(fill)
  }
  return createBuffer$1(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$2.alloc = function (size, fill, encoding) {
  return alloc$1(null, size, fill, encoding)
};

function allocUnsafe$1 (that, size) {
  assertSize(size);
  that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$2.allocUnsafe = function (size) {
  return allocUnsafe$1(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$2.allocUnsafeSlow = function (size) {
  return allocUnsafe$1(null, size)
};

function fromString$1 (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength$1(string, encoding) | 0;
  that = createBuffer$1(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike$1 (that, array) {
  var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
  that = createBuffer$1(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer$1 (that, array, byteOffset, length) {

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$2.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike$1(that, array);
  }
  return that
}

function fromObject$1 (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked$1(obj.length) | 0;
    that = createBuffer$1(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan$1(obj.length)) {
        return createBuffer$1(that, 0)
      }
      return fromArrayLike$1(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike$1(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked$1 (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer$2.alloc(+length)
}
Buffer$2.isBuffer = isBuffer;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer$2.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer$2.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer$2.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer$2.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer$2.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength$1 (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes$1(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes$1(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength$1;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$2.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer$2.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer$2.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer$2.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer$2.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer$2.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer$2.compare(this, b) === 0
};

Buffer$2.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer$2.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$2.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$2.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer$2.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer$2.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer$2.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write$1 (buf, string, offset, length) {
  return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer$1(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer$1(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer$1(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer$2.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write$1(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer$2.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer$2.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$2(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer$2.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer$2.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer$2.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer$2.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer$2.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer$2.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer$2.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer$2.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$2.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer$2.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer$2.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$2.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer$2.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer$2.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer$2.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer$2.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer$2.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer$2.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer$2.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$2.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer$2.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer$2.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$2.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer$2.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$2.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer$2.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$2.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer$2.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer$2.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer$2.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer$2.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer$2.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer$2.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer$2.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer$2.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer$2.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$2.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$2.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes$1(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes$1 (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer$1 (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan$1 (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

const bufferEs6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Buffer: Buffer$2,
    INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
    SlowBuffer: SlowBuffer,
    isBuffer: isBuffer,
    kMaxLength: _kMaxLength
});

var Buffer$3 = bufferEs6.Buffer;

function ReedSolomonEncoder (degree) {
  this.genPoly = undefined;
  this.degree = degree;

  if (this.degree) this.initialize(this.degree);
}

/**
 * Initialize the encoder.
 * The input param should correspond to the number of error correction codewords.
 *
 * @param  {Number} degree
 */
ReedSolomonEncoder.prototype.initialize = function initialize (degree) {
  // create an irreducible generator polynomial
  this.degree = degree;
  this.genPoly = polynomial.generateECPolynomial(this.degree);
};

/**
 * Encodes a chunk of data
 *
 * @param  {Buffer} data Buffer containing input data
 * @return {Buffer}      Buffer containing encoded data
 */
ReedSolomonEncoder.prototype.encode = function encode (data) {
  if (!this.genPoly) {
    throw new Error('Encoder not initialized')
  }

  // Calculate EC for this data block
  // extends data size to data+genPoly size
  var pad = typedarrayBuffer.alloc(this.degree);
  var paddedData = Buffer$3.concat([data, pad], data.length + this.degree);

  // The error correction codewords are the remainder after dividing the data codewords
  // by a generator polynomial
  var remainder = polynomial.mod(paddedData, this.genPoly);

  // return EC data blocks (last n byte, where n is the degree of genPoly)
  // If coefficients number in remainder are less than genPoly degree,
  // pad with 0s to the left to reach the needed number of coefficients
  var start = this.degree - remainder.length;
  if (start > 0) {
    var buff = typedarrayBuffer.alloc(this.degree);
    remainder.copy(buff, start);

    return buff
  }

  return remainder
};

var reedSolomonEncoder = ReedSolomonEncoder;

/**
 * Check if QR Code version is valid
 *
 * @param  {Number}  version QR Code version
 * @return {Boolean}         true if valid version, false otherwise
 */
var isValid$1 = function isValid (version) {
  return !isNaN(version) && version >= 1 && version <= 40
};

var versionCheck = {
	isValid: isValid$1
};

var numeric = '[0-9]+';
var alphanumeric = '[A-Z $%*+\\-./:]+';
var kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
kanji = kanji.replace(/u/g, '\\u');

var byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';

var KANJI = new RegExp(kanji, 'g');
var BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
var BYTE = new RegExp(byte, 'g');
var NUMERIC = new RegExp(numeric, 'g');
var ALPHANUMERIC = new RegExp(alphanumeric, 'g');

var TEST_KANJI = new RegExp('^' + kanji + '$');
var TEST_NUMERIC = new RegExp('^' + numeric + '$');
var TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

var testKanji = function testKanji (str) {
  return TEST_KANJI.test(str)
};

var testNumeric = function testNumeric (str) {
  return TEST_NUMERIC.test(str)
};

var testAlphanumeric = function testAlphanumeric (str) {
  return TEST_ALPHANUMERIC.test(str)
};

var regex = {
	KANJI: KANJI,
	BYTE_KANJI: BYTE_KANJI,
	BYTE: BYTE,
	NUMERIC: NUMERIC,
	ALPHANUMERIC: ALPHANUMERIC,
	testKanji: testKanji,
	testNumeric: testNumeric,
	testAlphanumeric: testAlphanumeric
};

var mode$1 = createCommonjsModule(function (module, exports) {
/**
 * Numeric mode encodes data from the decimal digit set (0 - 9)
 * (byte values 30HEX to 39HEX).
 * Normally, 3 data characters are represented by 10 bits.
 *
 * @type {Object}
 */
exports.NUMERIC = {
  id: 'Numeric',
  bit: 1 << 0,
  ccBits: [10, 12, 14]
};

/**
 * Alphanumeric mode encodes data from a set of 45 characters,
 * i.e. 10 numeric digits (0 - 9),
 *      26 alphabetic characters (A - Z),
 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
 * Normally, two input characters are represented by 11 bits.
 *
 * @type {Object}
 */
exports.ALPHANUMERIC = {
  id: 'Alphanumeric',
  bit: 1 << 1,
  ccBits: [9, 11, 13]
};

/**
 * In byte mode, data is encoded at 8 bits per character.
 *
 * @type {Object}
 */
exports.BYTE = {
  id: 'Byte',
  bit: 1 << 2,
  ccBits: [8, 16, 16]
};

/**
 * The Kanji mode efficiently encodes Kanji characters in accordance with
 * the Shift JIS system based on JIS X 0208.
 * The Shift JIS values are shifted from the JIS X 0208 values.
 * JIS X 0208 gives details of the shift coded representation.
 * Each two-byte character value is compacted to a 13-bit binary codeword.
 *
 * @type {Object}
 */
exports.KANJI = {
  id: 'Kanji',
  bit: 1 << 3,
  ccBits: [8, 10, 12]
};

/**
 * Mixed mode will contain a sequences of data in a combination of any of
 * the modes described above
 *
 * @type {Object}
 */
exports.MIXED = {
  bit: -1
};

/**
 * Returns the number of bits needed to store the data length
 * according to QR Code specifications.
 *
 * @param  {Mode}   mode    Data mode
 * @param  {Number} version QR Code version
 * @return {Number}         Number of bits
 */
exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

  if (!versionCheck.isValid(version)) {
    throw new Error('Invalid version: ' + version)
  }

  if (version >= 1 && version < 10) return mode.ccBits[0]
  else if (version < 27) return mode.ccBits[1]
  return mode.ccBits[2]
};

/**
 * Returns the most efficient mode to store the specified data
 *
 * @param  {String} dataStr Input data string
 * @return {Mode}           Best mode
 */
exports.getBestModeForData = function getBestModeForData (dataStr) {
  if (regex.testNumeric(dataStr)) return exports.NUMERIC
  else if (regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
  else if (regex.testKanji(dataStr)) return exports.KANJI
  else return exports.BYTE
};

/**
 * Return mode name as string
 *
 * @param {Mode} mode Mode object
 * @returns {String}  Mode name
 */
exports.toString = function toString (mode) {
  if (mode && mode.id) return mode.id
  throw new Error('Invalid mode')
};

/**
 * Check if input param is a valid mode object
 *
 * @param   {Mode}    mode Mode object
 * @returns {Boolean} True if valid mode, false otherwise
 */
exports.isValid = function isValid (mode) {
  return mode && mode.bit && mode.ccBits
};

/**
 * Get mode object from its name
 *
 * @param   {String} string Mode name
 * @returns {Mode}          Mode object
 */
function fromString (string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string')
  }

  var lcStr = string.toLowerCase();

  switch (lcStr) {
    case 'numeric':
      return exports.NUMERIC
    case 'alphanumeric':
      return exports.ALPHANUMERIC
    case 'kanji':
      return exports.KANJI
    case 'byte':
      return exports.BYTE
    default:
      throw new Error('Unknown mode: ' + string)
  }
}

/**
 * Returns mode from a value.
 * If value is not a valid mode, returns defaultValue
 *
 * @param  {Mode|String} value        Encoding mode
 * @param  {Mode}        defaultValue Fallback value
 * @return {Mode}                     Encoding mode
 */
exports.from = function from (value, defaultValue) {
  if (exports.isValid(value)) {
    return value
  }

  try {
    return fromString(value)
  } catch (e) {
    return defaultValue
  }
};
});

var version = createCommonjsModule(function (module, exports) {
// Generator polynomial used to encode version information
var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
var G18_BCH = utils.getBCHDigit(G18);

function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
  for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
      return currentVersion
    }
  }

  return undefined
}

function getReservedBitsCount (mode, version) {
  // Character count indicator + mode indicator bits
  return mode$1.getCharCountIndicator(mode, version) + 4
}

function getTotalBitsFromDataArray (segments, version) {
  var totalBits = 0;

  segments.forEach(function (data) {
    var reservedBits = getReservedBitsCount(data.mode, version);
    totalBits += reservedBits + data.getBitsLength();
  });

  return totalBits
}

function getBestVersionForMixedData (segments, errorCorrectionLevel) {
  for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
    var length = getTotalBitsFromDataArray(segments, currentVersion);
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode$1.MIXED)) {
      return currentVersion
    }
  }

  return undefined
}

/**
 * Returns version number from a value.
 * If value is not a valid version, returns defaultValue
 *
 * @param  {Number|String} value        QR Code version
 * @param  {Number}        defaultValue Fallback value
 * @return {Number}                     QR Code version number
 */
exports.from = function from (value, defaultValue) {
  if (versionCheck.isValid(value)) {
    return parseInt(value, 10)
  }

  return defaultValue
};

/**
 * Returns how much data can be stored with the specified QR code version
 * and error correction level
 *
 * @param  {Number} version              QR Code version (1-40)
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Mode}   mode                 Data mode
 * @return {Number}                      Quantity of storable data
 */
exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {
  if (!versionCheck.isValid(version)) {
    throw new Error('Invalid QR Code version')
  }

  // Use Byte mode as default
  if (typeof mode === 'undefined') mode = mode$1.BYTE;

  // Total codewords for this QR code version (Data + Error correction)
  var totalCodewords = utils.getSymbolTotalCodewords(version);

  // Total number of error correction codewords
  var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);

  // Total number of data codewords
  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

  if (mode === mode$1.MIXED) return dataTotalCodewordsBits

  var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);

  // Return max number of storable codewords
  switch (mode) {
    case mode$1.NUMERIC:
      return Math.floor((usableBits / 10) * 3)

    case mode$1.ALPHANUMERIC:
      return Math.floor((usableBits / 11) * 2)

    case mode$1.KANJI:
      return Math.floor(usableBits / 13)

    case mode$1.BYTE:
    default:
      return Math.floor(usableBits / 8)
  }
};

/**
 * Returns the minimum version needed to contain the amount of data
 *
 * @param  {Segment} data                    Segment of data
 * @param  {Number} [errorCorrectionLevel=H] Error correction level
 * @param  {Mode} mode                       Data mode
 * @return {Number}                          QR Code version
 */
exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel$1) {
  var seg;

  var ecl = errorCorrectionLevel.from(errorCorrectionLevel$1, errorCorrectionLevel.M);

  if (isarray(data)) {
    if (data.length > 1) {
      return getBestVersionForMixedData(data, ecl)
    }

    if (data.length === 0) {
      return 1
    }

    seg = data[0];
  } else {
    seg = data;
  }

  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
};

/**
 * Returns version information with relative error correction bits
 *
 * The version information is included in QR Code symbols of version 7 or larger.
 * It consists of an 18-bit sequence containing 6 data bits,
 * with 12 error correction bits calculated using the (18, 6) Golay code.
 *
 * @param  {Number} version QR Code version
 * @return {Number}         Encoded version info bits
 */
exports.getEncodedBits = function getEncodedBits (version) {
  if (!versionCheck.isValid(version) || version < 7) {
    throw new Error('Invalid QR Code version')
  }

  var d = version << 12;

  while (utils.getBCHDigit(d) - G18_BCH >= 0) {
    d ^= (G18 << (utils.getBCHDigit(d) - G18_BCH));
  }

  return (version << 12) | d
};
});

var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
var G15_BCH = utils.getBCHDigit(G15);

/**
 * Returns format information with relative error correction bits
 *
 * The format information is a 15-bit sequence containing 5 data bits,
 * with 10 error correction bits calculated using the (15, 5) BCH code.
 *
 * @param  {Number} errorCorrectionLevel Error correction level
 * @param  {Number} mask                 Mask pattern
 * @return {Number}                      Encoded format information bits
 */
var getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
  var data = ((errorCorrectionLevel.bit << 3) | mask);
  var d = data << 10;

  while (utils.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= (G15 << (utils.getBCHDigit(d) - G15_BCH));
  }

  // xor final data with mask pattern in order to ensure that
  // no combination of Error Correction Level and data mask pattern
  // will result in an all-zero data string
  return ((data << 10) | d) ^ G15_MASK
};

var formatInfo = {
	getEncodedBits: getEncodedBits
};

function NumericData (data) {
  this.mode = mode$1.NUMERIC;
  this.data = data.toString();
}

NumericData.getBitsLength = function getBitsLength (length) {
  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
};

NumericData.prototype.getLength = function getLength () {
  return this.data.length
};

NumericData.prototype.getBitsLength = function getBitsLength () {
  return NumericData.getBitsLength(this.data.length)
};

NumericData.prototype.write = function write (bitBuffer) {
  var i, group, value;

  // The input data string is divided into groups of three digits,
  // and each group is converted to its 10-bit binary equivalent.
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);

    bitBuffer.put(value, 10);
  }

  // If the number of input digits is not an exact multiple of three,
  // the final one or two digits are converted to 4 or 7 bits respectively.
  var remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);

    bitBuffer.put(value, remainingNum * 3 + 1);
  }
};

var numericData = NumericData;

/**
 * Array of characters available in alphanumeric mode
 *
 * As per QR Code specification, to each character
 * is assigned a value from 0 to 44 which in this case coincides
 * with the array index
 *
 * @type {Array}
 */
var ALPHA_NUM_CHARS = [
  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  ' ', '$', '%', '*', '+', '-', '.', '/', ':'
];

function AlphanumericData (data) {
  this.mode = mode$1.ALPHANUMERIC;
  this.data = data;
}

AlphanumericData.getBitsLength = function getBitsLength (length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2)
};

AlphanumericData.prototype.getLength = function getLength () {
  return this.data.length
};

AlphanumericData.prototype.getBitsLength = function getBitsLength () {
  return AlphanumericData.getBitsLength(this.data.length)
};

AlphanumericData.prototype.write = function write (bitBuffer) {
  var i;

  // Input data characters are divided into groups of two characters
  // and encoded as 11-bit binary codes.
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    // The character value of the first character is multiplied by 45
    var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;

    // The character value of the second digit is added to the product
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);

    // The sum is then stored as 11-bit binary number
    bitBuffer.put(value, 11);
  }

  // If the number of input data characters is not a multiple of two,
  // the character value of the final character is encoded as a 6-bit binary number.
  if (this.data.length % 2) {
    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
  }
};

var alphanumericData = AlphanumericData;

function ByteData (data) {
  this.mode = mode$1.BYTE;
  this.data = typedarrayBuffer.from(data);
}

ByteData.getBitsLength = function getBitsLength (length) {
  return length * 8
};

ByteData.prototype.getLength = function getLength () {
  return this.data.length
};

ByteData.prototype.getBitsLength = function getBitsLength () {
  return ByteData.getBitsLength(this.data.length)
};

ByteData.prototype.write = function (bitBuffer) {
  for (var i = 0, l = this.data.length; i < l; i++) {
    bitBuffer.put(this.data[i], 8);
  }
};

var byteData = ByteData;

function KanjiData (data) {
  this.mode = mode$1.KANJI;
  this.data = data;
}

KanjiData.getBitsLength = function getBitsLength (length) {
  return length * 13
};

KanjiData.prototype.getLength = function getLength () {
  return this.data.length
};

KanjiData.prototype.getBitsLength = function getBitsLength () {
  return KanjiData.getBitsLength(this.data.length)
};

KanjiData.prototype.write = function (bitBuffer) {
  var i;

  // In the Shift JIS system, Kanji characters are represented by a two byte combination.
  // These byte values are shifted from the JIS X 0208 values.
  // JIS X 0208 gives details of the shift coded representation.
  for (i = 0; i < this.data.length; i++) {
    var value = utils.toSJIS(this.data[i]);

    // For characters with Shift JIS values from 0x8140 to 0x9FFC:
    if (value >= 0x8140 && value <= 0x9FFC) {
      // Subtract 0x8140 from Shift JIS value
      value -= 0x8140;

    // For characters with Shift JIS values from 0xE040 to 0xEBBF
    } else if (value >= 0xE040 && value <= 0xEBBF) {
      // Subtract 0xC140 from Shift JIS value
      value -= 0xC140;
    } else {
      throw new Error(
        'Invalid SJIS character: ' + this.data[i] + '\n' +
        'Make sure your charset is UTF-8')
    }

    // Multiply most significant byte of result by 0xC0
    // and add least significant byte to product
    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);

    // Convert result to a 13-bit binary string
    bitBuffer.put(value, 13);
  }
};

var kanjiData = KanjiData;

var dijkstra_1 = createCommonjsModule(function (module) {

/******************************************************************************
 * Created 2008-08-19.
 *
 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
 *
 * Copyright (C) 2008
 *   Wyatt Baldwin <self@wyattbaldwin.com>
 *   All rights reserved
 *
 * Licensed under the MIT license.
 *
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *****************************************************************************/
var dijkstra = {
  single_source_shortest_paths: function(graph, s, d) {
    // Predecessor map for each node that has been encountered.
    // node ID => predecessor node ID
    var predecessors = {};

    // Costs of shortest paths from s to all nodes encountered.
    // node ID => cost
    var costs = {};
    costs[s] = 0;

    // Costs of shortest paths from s to all nodes encountered; differs from
    // `costs` in that it provides easy access to the node that currently has
    // the known shortest path from s.
    // XXX: Do we actually need both `costs` and `open`?
    var open = dijkstra.PriorityQueue.make();
    open.push(s, 0);

    var closest,
        u, v,
        cost_of_s_to_u,
        adjacent_nodes,
        cost_of_e,
        cost_of_s_to_u_plus_cost_of_e,
        cost_of_s_to_v,
        first_visit;
    while (!open.empty()) {
      // In the nodes remaining in graph that have a known cost from s,
      // find the node, u, that currently has the shortest path from s.
      closest = open.pop();
      u = closest.value;
      cost_of_s_to_u = closest.cost;

      // Get nodes adjacent to u...
      adjacent_nodes = graph[u] || {};

      // ...and explore the edges that connect u to those nodes, updating
      // the cost of the shortest paths to any or all of those nodes as
      // necessary. v is the node across the current edge from u.
      for (v in adjacent_nodes) {
        if (adjacent_nodes.hasOwnProperty(v)) {
          // Get the cost of the edge running from u to v.
          cost_of_e = adjacent_nodes[v];

          // Cost of s to u plus the cost of u to v across e--this is *a*
          // cost from s to v that may or may not be less than the current
          // known cost to v.
          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

          // If we haven't visited v yet OR if the current known cost from s to
          // v is greater than the new cost we just found (cost of s to u plus
          // cost of u to v across e), update v's cost in the cost list and
          // update v's predecessor in the predecessor list (it's now u).
          cost_of_s_to_v = costs[v];
          first_visit = (typeof costs[v] === 'undefined');
          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
            costs[v] = cost_of_s_to_u_plus_cost_of_e;
            open.push(v, cost_of_s_to_u_plus_cost_of_e);
            predecessors[v] = u;
          }
        }
      }
    }

    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
      throw new Error(msg);
    }

    return predecessors;
  },

  extract_shortest_path_from_predecessor_list: function(predecessors, d) {
    var nodes = [];
    var u = d;
    while (u) {
      nodes.push(u);
      u = predecessors[u];
    }
    nodes.reverse();
    return nodes;
  },

  find_path: function(graph, s, d) {
    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
    return dijkstra.extract_shortest_path_from_predecessor_list(
      predecessors, d);
  },

  /**
   * A very naive priority queue implementation.
   */
  PriorityQueue: {
    make: function (opts) {
      var T = dijkstra.PriorityQueue,
          t = {},
          key;
      opts = opts || {};
      for (key in T) {
        if (T.hasOwnProperty(key)) {
          t[key] = T[key];
        }
      }
      t.queue = [];
      t.sorter = opts.sorter || T.default_sorter;
      return t;
    },

    default_sorter: function (a, b) {
      return a.cost - b.cost;
    },

    /**
     * Add a new item to the queue and ensure the highest priority element
     * is at the front of the queue.
     */
    push: function (value, cost) {
      var item = {value: value, cost: cost};
      this.queue.push(item);
      this.queue.sort(this.sorter);
    },

    /**
     * Return the highest priority element in the queue.
     */
    pop: function () {
      return this.queue.shift();
    },

    empty: function () {
      return this.queue.length === 0;
    }
  }
};


// node.js module exports
{
  module.exports = dijkstra;
}
});

var segments = createCommonjsModule(function (module, exports) {
/**
 * Returns UTF8 byte length
 *
 * @param  {String} str Input string
 * @return {Number}     Number of byte
 */
function getStringByteLength (str) {
  return unescape(encodeURIComponent(str)).length
}

/**
 * Get a list of segments of the specified mode
 * from a string
 *
 * @param  {Mode}   mode Segment mode
 * @param  {String} str  String to process
 * @return {Array}       Array of object with segments data
 */
function getSegments (regex, mode, str) {
  var segments = [];
  var result;

  while ((result = regex.exec(str)) !== null) {
    segments.push({
      data: result[0],
      index: result.index,
      mode: mode,
      length: result[0].length
    });
  }

  return segments
}

/**
 * Extracts a series of segments with the appropriate
 * modes from a string
 *
 * @param  {String} dataStr Input string
 * @return {Array}          Array of object with segments data
 */
function getSegmentsFromString (dataStr) {
  var numSegs = getSegments(regex.NUMERIC, mode$1.NUMERIC, dataStr);
  var alphaNumSegs = getSegments(regex.ALPHANUMERIC, mode$1.ALPHANUMERIC, dataStr);
  var byteSegs;
  var kanjiSegs;

  if (utils.isKanjiModeEnabled()) {
    byteSegs = getSegments(regex.BYTE, mode$1.BYTE, dataStr);
    kanjiSegs = getSegments(regex.KANJI, mode$1.KANJI, dataStr);
  } else {
    byteSegs = getSegments(regex.BYTE_KANJI, mode$1.BYTE, dataStr);
    kanjiSegs = [];
  }

  var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);

  return segs
    .sort(function (s1, s2) {
      return s1.index - s2.index
    })
    .map(function (obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      }
    })
}

/**
 * Returns how many bits are needed to encode a string of
 * specified length with the specified mode
 *
 * @param  {Number} length String length
 * @param  {Mode} mode     Segment mode
 * @return {Number}        Bit length
 */
function getSegmentBitsLength (length, mode) {
  switch (mode) {
    case mode$1.NUMERIC:
      return numericData.getBitsLength(length)
    case mode$1.ALPHANUMERIC:
      return alphanumericData.getBitsLength(length)
    case mode$1.KANJI:
      return kanjiData.getBitsLength(length)
    case mode$1.BYTE:
      return byteData.getBitsLength(length)
  }
}

/**
 * Merges adjacent segments which have the same mode
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function mergeSegments (segs) {
  return segs.reduce(function (acc, curr) {
    var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
    if (prevSeg && prevSeg.mode === curr.mode) {
      acc[acc.length - 1].data += curr.data;
      return acc
    }

    acc.push(curr);
    return acc
  }, [])
}

/**
 * Generates a list of all possible nodes combination which
 * will be used to build a segments graph.
 *
 * Nodes are divided by groups. Each group will contain a list of all the modes
 * in which is possible to encode the given text.
 *
 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
 * The group for '12345' will contain then 3 objects, one for each
 * possible encoding mode.
 *
 * Each node represents a possible segment.
 *
 * @param  {Array} segs Array of object with segments data
 * @return {Array}      Array of object with segments data
 */
function buildNodes (segs) {
  var nodes = [];
  for (var i = 0; i < segs.length; i++) {
    var seg = segs[i];

    switch (seg.mode) {
      case mode$1.NUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: mode$1.ALPHANUMERIC, length: seg.length },
          { data: seg.data, mode: mode$1.BYTE, length: seg.length }
        ]);
        break
      case mode$1.ALPHANUMERIC:
        nodes.push([seg,
          { data: seg.data, mode: mode$1.BYTE, length: seg.length }
        ]);
        break
      case mode$1.KANJI:
        nodes.push([seg,
          { data: seg.data, mode: mode$1.BYTE, length: getStringByteLength(seg.data) }
        ]);
        break
      case mode$1.BYTE:
        nodes.push([
          { data: seg.data, mode: mode$1.BYTE, length: getStringByteLength(seg.data) }
        ]);
    }
  }

  return nodes
}

/**
 * Builds a graph from a list of nodes.
 * All segments in each node group will be connected with all the segments of
 * the next group and so on.
 *
 * At each connection will be assigned a weight depending on the
 * segment's byte length.
 *
 * @param  {Array} nodes    Array of object with segments data
 * @param  {Number} version QR Code version
 * @return {Object}         Graph of all possible segments
 */
function buildGraph (nodes, version) {
  var table = {};
  var graph = {'start': {}};
  var prevNodeIds = ['start'];

  for (var i = 0; i < nodes.length; i++) {
    var nodeGroup = nodes[i];
    var currentNodeIds = [];

    for (var j = 0; j < nodeGroup.length; j++) {
      var node = nodeGroup[j];
      var key = '' + i + j;

      currentNodeIds.push(key);
      table[key] = { node: node, lastCount: 0 };
      graph[key] = {};

      for (var n = 0; n < prevNodeIds.length; n++) {
        var prevNodeId = prevNodeIds[n];

        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
          graph[prevNodeId][key] =
            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);

          table[prevNodeId].lastCount += node.length;
        } else {
          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;

          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
            4 + mode$1.getCharCountIndicator(node.mode, version); // switch cost
        }
      }
    }

    prevNodeIds = currentNodeIds;
  }

  for (n = 0; n < prevNodeIds.length; n++) {
    graph[prevNodeIds[n]]['end'] = 0;
  }

  return { map: graph, table: table }
}

/**
 * Builds a segment from a specified data and mode.
 * If a mode is not specified, the more suitable will be used.
 *
 * @param  {String} data             Input data
 * @param  {Mode | String} modesHint Data mode
 * @return {Segment}                 Segment
 */
function buildSingleSegment (data, modesHint) {
  var mode;
  var bestMode = mode$1.getBestModeForData(data);

  mode = mode$1.from(modesHint, bestMode);

  // Make sure data can be encoded
  if (mode !== mode$1.BYTE && mode.bit < bestMode.bit) {
    throw new Error('"' + data + '"' +
      ' cannot be encoded with mode ' + mode$1.toString(mode) +
      '.\n Suggested mode is: ' + mode$1.toString(bestMode))
  }

  // Use Mode.BYTE if Kanji support is disabled
  if (mode === mode$1.KANJI && !utils.isKanjiModeEnabled()) {
    mode = mode$1.BYTE;
  }

  switch (mode) {
    case mode$1.NUMERIC:
      return new numericData(data)

    case mode$1.ALPHANUMERIC:
      return new alphanumericData(data)

    case mode$1.KANJI:
      return new kanjiData(data)

    case mode$1.BYTE:
      return new byteData(data)
  }
}

/**
 * Builds a list of segments from an array.
 * Array can contain Strings or Objects with segment's info.
 *
 * For each item which is a string, will be generated a segment with the given
 * string and the more appropriate encoding mode.
 *
 * For each item which is an object, will be generated a segment with the given
 * data and mode.
 * Objects must contain at least the property "data".
 * If property "mode" is not present, the more suitable mode will be used.
 *
 * @param  {Array} array Array of objects with segments data
 * @return {Array}       Array of Segments
 */
exports.fromArray = function fromArray (array) {
  return array.reduce(function (acc, seg) {
    if (typeof seg === 'string') {
      acc.push(buildSingleSegment(seg, null));
    } else if (seg.data) {
      acc.push(buildSingleSegment(seg.data, seg.mode));
    }

    return acc
  }, [])
};

/**
 * Builds an optimized sequence of segments from a string,
 * which will produce the shortest possible bitstream.
 *
 * @param  {String} data    Input string
 * @param  {Number} version QR Code version
 * @return {Array}          Array of segments
 */
exports.fromString = function fromString (data, version) {
  var segs = getSegmentsFromString(data, utils.isKanjiModeEnabled());

  var nodes = buildNodes(segs);
  var graph = buildGraph(nodes, version);
  var path = dijkstra_1.find_path(graph.map, 'start', 'end');

  var optimizedSegs = [];
  for (var i = 1; i < path.length - 1; i++) {
    optimizedSegs.push(graph.table[path[i]].node);
  }

  return exports.fromArray(mergeSegments(optimizedSegs))
};

/**
 * Splits a string in various segments with the modes which
 * best represent their content.
 * The produced segments are far from being optimized.
 * The output of this function is only used to estimate a QR Code version
 * which may contain the data.
 *
 * @param  {string} data Input string
 * @return {Array}       Array of segments
 */
exports.rawSplit = function rawSplit (data) {
  return exports.fromArray(
    getSegmentsFromString(data, utils.isKanjiModeEnabled())
  )
};
});

/**
 * QRCode for JavaScript
 *
 * modified by Ryan Day for nodejs support
 * Copyright (c) 2011 Ryan Day
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
*/

/**
 * Add finder patterns bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupFinderPattern (matrix, version) {
  var size = matrix.size;
  var pos = finderPattern.getPositions(version);

  for (var i = 0; i < pos.length; i++) {
    var row = pos[i][0];
    var col = pos[i][1];

    for (var r = -1; r <= 7; r++) {
      if (row + r <= -1 || size <= row + r) continue

      for (var c = -1; c <= 7; c++) {
        if (col + c <= -1 || size <= col + c) continue

        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}

/**
 * Add timing pattern bits to matrix
 *
 * Note: this function must be called before {@link setupAlignmentPattern}
 *
 * @param  {BitMatrix} matrix Modules matrix
 */
function setupTimingPattern (matrix) {
  var size = matrix.size;

  for (var r = 8; r < size - 8; r++) {
    var value = r % 2 === 0;
    matrix.set(r, 6, value, true);
    matrix.set(6, r, value, true);
  }
}

/**
 * Add alignment patterns bits to matrix
 *
 * Note: this function must be called after {@link setupTimingPattern}
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupAlignmentPattern (matrix, version) {
  var pos = alignmentPattern.getPositions(version);

  for (var i = 0; i < pos.length; i++) {
    var row = pos[i][0];
    var col = pos[i][1];

    for (var r = -2; r <= 2; r++) {
      for (var c = -2; c <= 2; c++) {
        if (r === -2 || r === 2 || c === -2 || c === 2 ||
          (r === 0 && c === 0)) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}

/**
 * Add version info bits to matrix
 *
 * @param  {BitMatrix} matrix  Modules matrix
 * @param  {Number}    version QR Code version
 */
function setupVersionInfo (matrix, version$1) {
  var size = matrix.size;
  var bits = version.getEncodedBits(version$1);
  var row, col, mod;

  for (var i = 0; i < 18; i++) {
    row = Math.floor(i / 3);
    col = i % 3 + size - 8 - 3;
    mod = ((bits >> i) & 1) === 1;

    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}

/**
 * Add format info bits to matrix
 *
 * @param  {BitMatrix} matrix               Modules matrix
 * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
 * @param  {Number}    maskPattern          Mask pattern reference value
 */
function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
  var size = matrix.size;
  var bits = formatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
  var i, mod;

  for (i = 0; i < 15; i++) {
    mod = ((bits >> i) & 1) === 1;

    // vertical
    if (i < 6) {
      matrix.set(i, 8, mod, true);
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true);
    } else {
      matrix.set(size - 15 + i, 8, mod, true);
    }

    // horizontal
    if (i < 8) {
      matrix.set(8, size - i - 1, mod, true);
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i - 1, mod, true);
    }
  }

  // fixed module
  matrix.set(size - 8, 8, 1, true);
}

/**
 * Add encoded data bits to matrix
 *
 * @param  {BitMatrix} matrix Modules matrix
 * @param  {Buffer}    data   Data codewords
 */
function setupData (matrix, data) {
  var size = matrix.size;
  var inc = -1;
  var row = size - 1;
  var bitIndex = 7;
  var byteIndex = 0;

  for (var col = size - 1; col > 0; col -= 2) {
    if (col === 6) col--;

    while (true) {
      for (var c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          var dark = false;

          if (byteIndex < data.length) {
            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
          }

          matrix.set(row, col - c, dark);
          bitIndex--;

          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }

      row += inc;

      if (row < 0 || size <= row) {
        row -= inc;
        inc = -inc;
        break
      }
    }
  }
}

/**
 * Create encoded codewords from data input
 *
 * @param  {Number}   version              QR Code version
 * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
 * @param  {ByteData} data                 Data input
 * @return {Buffer}                        Buffer containing encoded codewords
 */
function createData (version, errorCorrectionLevel, segments) {
  // Prepare data buffer
  var buffer = new bitBuffer();

  segments.forEach(function (data) {
    // prefix data with mode indicator (4 bits)
    buffer.put(data.mode.bit, 4);

    // Prefix data with character count indicator.
    // The character count indicator is a string of bits that represents the
    // number of characters that are being encoded.
    // The character count indicator must be placed after the mode indicator
    // and must be a certain number of bits long, depending on the QR version
    // and data mode
    // @see {@link Mode.getCharCountIndicator}.
    buffer.put(data.getLength(), mode$1.getCharCountIndicator(data.mode, version));

    // add binary data sequence to buffer
    data.write(buffer);
  });

  // Calculate required number of bits
  var totalCodewords = utils.getSymbolTotalCodewords(version);
  var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);
  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

  // Add a terminator.
  // If the bit string is shorter than the total number of required bits,
  // a terminator of up to four 0s must be added to the right side of the string.
  // If the bit string is more than four bits shorter than the required number of bits,
  // add four 0s to the end.
  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer.put(0, 4);
  }

  // If the bit string is fewer than four bits shorter, add only the number of 0s that
  // are needed to reach the required number of bits.

  // After adding the terminator, if the number of bits in the string is not a multiple of 8,
  // pad the string on the right with 0s to make the string's length a multiple of 8.
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(0);
  }

  // Add pad bytes if the string is still shorter than the total number of required bits.
  // Extend the buffer to fill the data capacity of the symbol corresponding to
  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
  // and 00010001 (0x11) alternately.
  var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
  for (var i = 0; i < remainingByte; i++) {
    buffer.put(i % 2 ? 0x11 : 0xEC, 8);
  }

  return createCodewords(buffer, version, errorCorrectionLevel)
}

/**
 * Encode input data with Reed-Solomon and return codewords with
 * relative error correction bits
 *
 * @param  {BitBuffer} bitBuffer            Data to encode
 * @param  {Number}    version              QR Code version
 * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
 * @return {Buffer}                         Buffer containing encoded codewords
 */
function createCodewords (bitBuffer, version, errorCorrectionLevel) {
  // Total codewords for this QR code version (Data + Error correction)
  var totalCodewords = utils.getSymbolTotalCodewords(version);

  // Total number of error correction codewords
  var ecTotalCodewords = errorCorrectionCode.getTotalCodewordsCount(version, errorCorrectionLevel);

  // Total number of data codewords
  var dataTotalCodewords = totalCodewords - ecTotalCodewords;

  // Total number of blocks
  var ecTotalBlocks = errorCorrectionCode.getBlocksCount(version, errorCorrectionLevel);

  // Calculate how many blocks each group should contain
  var blocksInGroup2 = totalCodewords % ecTotalBlocks;
  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;

  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);

  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;

  // Number of EC codewords is the same for both groups
  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;

  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
  var rs = new reedSolomonEncoder(ecCount);

  var offset = 0;
  var dcData = new Array(ecTotalBlocks);
  var ecData = new Array(ecTotalBlocks);
  var maxDataSize = 0;
  var buffer = typedarrayBuffer.from(bitBuffer.buffer);

  // Divide the buffer into the required number of blocks
  for (var b = 0; b < ecTotalBlocks; b++) {
    var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;

    // extract a block of data from buffer
    dcData[b] = buffer.slice(offset, offset + dataSize);

    // Calculate EC codewords for this data block
    ecData[b] = rs.encode(dcData[b]);

    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }

  // Create final data
  // Interleave the data and error correction codewords from each block
  var data = typedarrayBuffer.alloc(totalCodewords);
  var index = 0;
  var i, r;

  // Add data codewords
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index++] = dcData[r][i];
      }
    }
  }

  // Apped EC codewords
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index++] = ecData[r][i];
    }
  }

  return data
}

/**
 * Build QR Code symbol
 *
 * @param  {String} data                 Input string
 * @param  {Number} version              QR Code version
 * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
 * @param  {MaskPattern} maskPattern     Mask pattern
 * @return {Object}                      Object containing symbol data
 */
function createSymbol (data, version$1, errorCorrectionLevel, maskPattern$1) {
  var segments$1;

  if (isarray(data)) {
    segments$1 = segments.fromArray(data);
  } else if (typeof data === 'string') {
    var estimatedVersion = version$1;

    if (!estimatedVersion) {
      var rawSegments = segments.rawSplit(data);

      // Estimate best version that can contain raw splitted segments
      estimatedVersion = version.getBestVersionForData(rawSegments,
        errorCorrectionLevel);
    }

    // Build optimized segments
    // If estimated version is undefined, try with the highest version
    segments$1 = segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error('Invalid data')
  }

  // Get the min version that can contain data
  var bestVersion = version.getBestVersionForData(segments$1,
      errorCorrectionLevel);

  // If no version is found, data cannot be stored
  if (!bestVersion) {
    throw new Error('The amount of data is too big to be stored in a QR Code')
  }

  // If not specified, use min version as default
  if (!version$1) {
    version$1 = bestVersion;

  // Check if the specified version can contain the data
  } else if (version$1 < bestVersion) {
    throw new Error('\n' +
      'The chosen QR Code version cannot contain this amount of data.\n' +
      'Minimum version required to store current data is: ' + bestVersion + '.\n'
    )
  }

  var dataBits = createData(version$1, errorCorrectionLevel, segments$1);

  // Allocate matrix buffer
  var moduleCount = utils.getSymbolSize(version$1);
  var modules = new bitMatrix(moduleCount);

  // Add function modules
  setupFinderPattern(modules, version$1);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version$1);

  // Add temporary dummy bits for format info just to set them as reserved.
  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
  // since the masking operation must be performed only on the encoding region.
  // These blocks will be replaced with correct values later in code.
  setupFormatInfo(modules, errorCorrectionLevel, 0);

  if (version$1 >= 7) {
    setupVersionInfo(modules, version$1);
  }

  // Add data codewords
  setupData(modules, dataBits);

  if (isNaN(maskPattern$1)) {
    // Find best mask pattern
    maskPattern$1 = maskPattern.getBestMask(modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel));
  }

  // Apply mask pattern
  maskPattern.applyMask(maskPattern$1, modules);

  // Replace format info bits with correct values
  setupFormatInfo(modules, errorCorrectionLevel, maskPattern$1);

  return {
    modules: modules,
    version: version$1,
    errorCorrectionLevel: errorCorrectionLevel,
    maskPattern: maskPattern$1,
    segments: segments$1
  }
}

/**
 * QR Code
 *
 * @param {String | Array} data                 Input data
 * @param {Object} options                      Optional configurations
 * @param {Number} options.version              QR Code version
 * @param {String} options.errorCorrectionLevel Error correction level
 * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
 */
var create = function create (data, options) {
  if (typeof data === 'undefined' || data === '') {
    throw new Error('No input text')
  }

  var errorCorrectionLevel$1 = errorCorrectionLevel.M;
  var version$1;
  var mask;

  if (typeof options !== 'undefined') {
    // Use higher error correction level as default
    errorCorrectionLevel$1 = errorCorrectionLevel.from(options.errorCorrectionLevel, errorCorrectionLevel.M);
    version$1 = version.from(options.version);
    mask = maskPattern.from(options.maskPattern);

    if (options.toSJISFunc) {
      utils.setToSJISFunction(options.toSJISFunc);
    }
  }

  return createSymbol(data, version$1, errorCorrectionLevel$1, mask)
};

var qrcode = {
	create: create
};

var utils$1 = createCommonjsModule(function (module, exports) {
function hex2rgba (hex) {
  if (typeof hex === 'number') {
    hex = hex.toString();
  }

  if (typeof hex !== 'string') {
    throw new Error('Color should be defined as hex string')
  }

  var hexCode = hex.slice().replace('#', '').split('');
  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
    throw new Error('Invalid hex color: ' + hex)
  }

  // Convert from short to long form (fff -> ffffff)
  if (hexCode.length === 3 || hexCode.length === 4) {
    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
      return [c, c]
    }));
  }

  // Add default alpha value
  if (hexCode.length === 6) hexCode.push('F', 'F');

  var hexValue = parseInt(hexCode.join(''), 16);

  return {
    r: (hexValue >> 24) & 255,
    g: (hexValue >> 16) & 255,
    b: (hexValue >> 8) & 255,
    a: hexValue & 255,
    hex: '#' + hexCode.slice(0, 6).join('')
  }
}

exports.getOptions = function getOptions (options) {
  if (!options) options = {};
  if (!options.color) options.color = {};

  var margin = typeof options.margin === 'undefined' ||
    options.margin === null ||
    options.margin < 0 ? 4 : options.margin;

  var width = options.width && options.width >= 21 ? options.width : undefined;
  var scale = options.scale || 4;

  return {
    width: width,
    scale: width ? 4 : scale,
    margin: margin,
    color: {
      dark: hex2rgba(options.color.dark || '#000000ff'),
      light: hex2rgba(options.color.light || '#ffffffff')
    },
    type: options.type,
    rendererOpts: options.rendererOpts || {}
  }
};

exports.getScale = function getScale (qrSize, opts) {
  return opts.width && opts.width >= qrSize + opts.margin * 2
    ? opts.width / (qrSize + opts.margin * 2)
    : opts.scale
};

exports.getImageWidth = function getImageWidth (qrSize, opts) {
  var scale = exports.getScale(qrSize, opts);
  return Math.floor((qrSize + opts.margin * 2) * scale)
};

exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
  var size = qr.modules.size;
  var data = qr.modules.data;
  var scale = exports.getScale(size, opts);
  var symbolSize = Math.floor((size + opts.margin * 2) * scale);
  var scaledMargin = opts.margin * scale;
  var palette = [opts.color.light, opts.color.dark];

  for (var i = 0; i < symbolSize; i++) {
    for (var j = 0; j < symbolSize; j++) {
      var posDst = (i * symbolSize + j) * 4;
      var pxColor = opts.color.light;

      if (i >= scaledMargin && j >= scaledMargin &&
        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
        var iSrc = Math.floor((i - scaledMargin) / scale);
        var jSrc = Math.floor((j - scaledMargin) / scale);
        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
      }

      imgData[posDst++] = pxColor.r;
      imgData[posDst++] = pxColor.g;
      imgData[posDst++] = pxColor.b;
      imgData[posDst] = pxColor.a;
    }
  }
};
});

var canvas = createCommonjsModule(function (module, exports) {
function clearCanvas (ctx, canvas, size) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!canvas.style) canvas.style = {};
  canvas.height = size;
  canvas.width = size;
  canvas.style.height = size + 'px';
  canvas.style.width = size + 'px';
}

function getCanvasElement () {
  try {
    return document.createElement('canvas')
  } catch (e) {
    throw new Error('You need to specify a canvas element')
  }
}

exports.render = function render (qrData, canvas, options) {
  var opts = options;
  var canvasEl = canvas;

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas;
    canvas = undefined;
  }

  if (!canvas) {
    canvasEl = getCanvasElement();
  }

  opts = utils$1.getOptions(opts);
  var size = utils$1.getImageWidth(qrData.modules.size, opts);

  var ctx = canvasEl.getContext('2d');
  var image = ctx.createImageData(size, size);
  utils$1.qrToImageData(image.data, qrData, opts);

  clearCanvas(ctx, canvasEl, size);
  ctx.putImageData(image, 0, 0);

  return canvasEl
};

exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
  var opts = options;

  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas;
    canvas = undefined;
  }

  if (!opts) opts = {};

  var canvasEl = exports.render(qrData, canvas, opts);

  var type = opts.type || 'image/png';
  var rendererOpts = opts.rendererOpts || {};

  return canvasEl.toDataURL(type, rendererOpts.quality)
};
});

function getColorAttrib (color, attrib) {
  var alpha = color.a / 255;
  var str = attrib + '="' + color.hex + '"';

  return alpha < 1
    ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
    : str
}

function svgCmd (cmd, x, y) {
  var str = cmd + x;
  if (typeof y !== 'undefined') str += ' ' + y;

  return str
}

function qrToPath (data, size, margin) {
  var path = '';
  var moveBy = 0;
  var newRow = false;
  var lineLength = 0;

  for (var i = 0; i < data.length; i++) {
    var col = Math.floor(i % size);
    var row = Math.floor(i / size);

    if (!col && !newRow) newRow = true;

    if (data[i]) {
      lineLength++;

      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow
          ? svgCmd('M', col + margin, 0.5 + row + margin)
          : svgCmd('m', moveBy, 0);

        moveBy = 0;
        newRow = false;
      }

      if (!(col + 1 < size && data[i + 1])) {
        path += svgCmd('h', lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }

  return path
}

var render = function render (qrData, options, cb) {
  var opts = utils$1.getOptions(options);
  var size = qrData.modules.size;
  var data = qrData.modules.data;
  var qrcodesize = size + opts.margin * 2;

  var bg = !opts.color.light.a
    ? ''
    : '<path ' + getColorAttrib(opts.color.light, 'fill') +
      ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';

  var path =
    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
    ' d="' + qrToPath(data, size, opts.margin) + '"/>';

  var viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';

  var width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';

  var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

  if (typeof cb === 'function') {
    cb(null, svgTag);
  }

  return svgTag
};

var svgTag = {
	render: render
};

function renderCanvas (renderFunc, canvas, text, opts, cb) {
  var args = [].slice.call(arguments, 1);
  var argsNum = args.length;
  var isLastArgCb = typeof args[argsNum - 1] === 'function';

  if (!isLastArgCb && !canPromise()) {
    throw new Error('Callback required as last argument')
  }

  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 2) {
      cb = text;
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 3) {
      if (canvas.getContext && typeof cb === 'undefined') {
        cb = opts;
        opts = undefined;
      } else {
        cb = opts;
        opts = text;
        text = canvas;
        canvas = undefined;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error('Too few arguments provided')
    }

    if (argsNum === 1) {
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 2 && !canvas.getContext) {
      opts = text;
      text = canvas;
      canvas = undefined;
    }

    return new Promise(function (resolve, reject) {
      try {
        var data = qrcode.create(text, opts);
        resolve(renderFunc(data, canvas, opts));
      } catch (e) {
        reject(e);
      }
    })
  }

  try {
    var data = qrcode.create(text, opts);
    cb(null, renderFunc(data, canvas, opts));
  } catch (e) {
    cb(e);
  }
}

var create$1 = qrcode.create;
var toCanvas = renderCanvas.bind(null, canvas.render);
var toDataURL = renderCanvas.bind(null, canvas.renderToDataURL);

// only svg for now.
var toString_1 = renderCanvas.bind(null, function (data, _, opts) {
  return svgTag.render(data, opts)
});

var browser = {
	create: create$1,
	toCanvas: toCanvas,
	toDataURL: toDataURL,
	toString: toString_1
};

const zeaQrCodeCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-qr-code{--zea-qr-code-color:var(--theme-color);color:var(--zea-qr-code-color);display:flex;align-items:center;justify-content:center;width:100%;height:100%}.zea-qr-code canvas{width:auto !important;height:auto !important;max-width:100%;padding:1em 0;box-sizing:border-box}";

const ZeaQrCode = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * The content to code into the QR
     */
    this.content = window.location.href;
    /**
     * The content to code into the QR
     */
    this.scale = 4;
  }
  /**
  /**
   * Listen for changes on the content prop
   */
  onContentChanged() {
    this.makeQR();
  }
  /**
   * Runs when component finishes loading
   */
  componentDidLoad() {
    this.makeQR();
  }
  /**
   * Make the QR image as a canvas
   */
  makeQR() {
    if (this.canvas)
      this.canvas.remove();
    browser.toCanvas(this.content, { scale: this.scale }).then((canvas) => {
      this.canvas = canvas;
      this.container.appendChild(this.canvas);
    });
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4("div", { class: "zea-qr-code", ref: (el) => (this.container = el) }));
  }
  static get watchers() { return {
    "content": ["onContentChanged"]
  }; }
  static get style() { return zeaQrCodeCss; }
};

var resizeObservers = [];

var hasActiveObservations = function () {
    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });
};

var hasSkippedObservations = function () {
    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });
};

var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
    var event;
    if (typeof ErrorEvent === 'function') {
        event = new ErrorEvent('error', {
            message: msg
        });
    }
    else {
        event = document.createEvent('Event');
        event.initEvent('error', false, false);
        event.message = msg;
    }
    window.dispatchEvent(event);
};

var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

var DOMRectReadOnly = (function () {
    function DOMRectReadOnly(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return Object.freeze(this);
    }
    DOMRectReadOnly.prototype.toJSON = function () {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };
    };
    DOMRectReadOnly.fromRect = function (rectangle) {
        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly;
}());

var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };
var isHidden = function (target) {
    if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
    }
    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function (obj) {
    var _a, _b;
    var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
    return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target) {
    switch (target.tagName) {
        case 'INPUT':
            if (target.type !== 'image') {
                break;
            }
        case 'VIDEO':
        case 'AUDIO':
        case 'EMBED':
        case 'OBJECT':
        case 'CANVAS':
        case 'IFRAME':
        case 'IMG':
            return true;
    }
    return false;
};

var global$2 = typeof window !== 'undefined' ? window : {};

var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = (/msie|trident/i).test(global$2.navigator && global$2.navigator.userAgent);
var parseDimension = function (pixel) { return parseFloat(pixel || '0'); };
var size = function (inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) { inlineSize = 0; }
    if (blockSize === void 0) { blockSize = 0; }
    if (switchSizes === void 0) { switchSizes = false; }
    return Object.freeze({
        inlineSize: (switchSizes ? blockSize : inlineSize) || 0,
        blockSize: (switchSizes ? inlineSize : blockSize) || 0
    });
};
var zeroBoxes = Object.freeze({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
    if (forceRecalculation === void 0) { forceRecalculation = false; }
    if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
    }
    if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
    }
    var cs = getComputedStyle(target);
    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === 'border-box';
    var switchSizes = verticalRegexp.test(cs.writingMode || '');
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = Object.freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
    switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
            return borderBoxSize;
        default:
            return contentBoxSize;
    }
};

var ResizeObserverEntry = (function () {
    function ResizeObserverEntry(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = [boxes.borderBoxSize];
        this.contentBoxSize = [boxes.contentBoxSize];
        this.devicePixelContentBoxSize = [boxes.devicePixelContentBoxSize];
    }
    return ResizeObserverEntry;
}());

var calculateDepthForNode = function (node) {
    if (isHidden(node)) {
        return Infinity;
    }
    var depth = 0;
    var parent = node.parentNode;
    while (parent) {
        depth += 1;
        parent = parent.parentNode;
    }
    return depth;
};

var broadcastActiveObservations = function () {
    var shallowestDepth = Infinity;
    var callbacks = [];
    resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
            return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new ResizeObserverEntry(ot.target);
            var targetDepth = calculateDepthForNode(ot.target);
            entries.push(entry);
            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
                shallowestDepth = targetDepth;
            }
        });
        callbacks.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
    });
    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
    }
    return shallowestDepth;
};

var gatherActiveObservationsAtDepth = function (depth) {
    resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
                if (calculateDepthForNode(ot.target) > depth) {
                    ro.activeTargets.push(ot);
                }
                else {
                    ro.skippedTargets.push(ot);
                }
            }
        });
    });
};

var process$1 = function () {
    var depth = 0;
    gatherActiveObservationsAtDepth(depth);
    while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
    }
    if (hasSkippedObservations()) {
        deliverResizeLoopError();
    }
    return depth > 0;
};

var trigger;
var callbacks = [];
var notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };
var queueMicroTask = function (callback) {
    if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode('');
        var config = { characterData: true };
        new MutationObserver(function () { return notify(); }).observe(el_1, config);
        trigger = function () { el_1.textContent = "" + (toggle_1 ? toggle_1-- : toggle_1++); };
    }
    callbacks.push(callback);
    trigger();
};

var queueResizeObserver = function (cb) {
    queueMicroTask(function ResizeObserver() {
        requestAnimationFrame(cb);
    });
};

var watching = 0;
var isWatching = function () { return !!watching; };
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
    'resize',
    'load',
    'transitionend',
    'animationend',
    'animationstart',
    'animationiteration',
    'keyup',
    'keydown',
    'mouseup',
    'mousedown',
    'mouseover',
    'mouseout',
    'blur',
    'focus'
];
var time = function (timeout) {
    if (timeout === void 0) { timeout = 0; }
    return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = (function () {
    function Scheduler() {
        var _this = this;
        this.stopped = true;
        this.listener = function () { return _this.schedule(); };
    }
    Scheduler.prototype.run = function (timeout) {
        var _this = this;
        if (timeout === void 0) { timeout = CATCH_PERIOD; }
        if (scheduled) {
            return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function () {
            var elementsHaveResized = false;
            try {
                elementsHaveResized = process$1();
            }
            finally {
                scheduled = false;
                timeout = until - time();
                if (!isWatching()) {
                    return;
                }
                if (elementsHaveResized) {
                    _this.run(1000);
                }
                else if (timeout > 0) {
                    _this.run(timeout);
                }
                else {
                    _this.start();
                }
            }
        });
    };
    Scheduler.prototype.schedule = function () {
        this.stop();
        this.run();
    };
    Scheduler.prototype.observe = function () {
        var _this = this;
        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };
        document.body ? cb() : global$2.addEventListener('DOMContentLoaded', cb);
    };
    Scheduler.prototype.start = function () {
        var _this = this;
        if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            events.forEach(function (name) { return global$2.addEventListener(name, _this.listener, true); });
        }
    };
    Scheduler.prototype.stop = function () {
        var _this = this;
        if (!this.stopped) {
            this.observer && this.observer.disconnect();
            events.forEach(function (name) { return global$2.removeEventListener(name, _this.listener, true); });
            this.stopped = true;
        }
    };
    return Scheduler;
}());
var scheduler = new Scheduler();
var updateCount = function (n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
};

var skipNotifyOnElement = function (target) {
    return !isSVG(target)
        && !isReplacedElement(target)
        && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = (function () {
    function ResizeObservation(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
        };
    }
    ResizeObservation.prototype.isActive = function () {
        var size = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size;
        }
        if (this.lastReportedSize.inlineSize !== size.inlineSize
            || this.lastReportedSize.blockSize !== size.blockSize) {
            return true;
        }
        return false;
    };
    return ResizeObservation;
}());

var ResizeObserverDetail = (function () {
    function ResizeObserverDetail(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
    }
    return ResizeObserverDetail;
}());

var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
    for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
            return i;
        }
    }
    return -1;
};
var ResizeObserverController = (function () {
    function ResizeObserverController() {
    }
    ResizeObserverController.connect = function (resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController.observe = function (resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && resizeObservers.push(detail);
            detail.observationTargets.push(new ResizeObservation(target, options && options.box));
            updateCount(1);
            scheduler.schedule();
        }
    };
    ResizeObserverController.unobserve = function (resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            updateCount(-1);
        }
    };
    ResizeObserverController.disconnect = function (resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });
        detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController;
}());

var ResizeObserver = (function () {
    function ResizeObserver(callback) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== 'function') {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
    }
    ResizeObserver.prototype.observe = function (target, options) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options);
    };
    ResizeObserver.prototype.unobserve = function (target) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
    };
    ResizeObserver.prototype.disconnect = function () {
        ResizeObserverController.disconnect(this);
    };
    ResizeObserver.toString = function () {
        return 'function ResizeObserver () { [polyfill code] }';
    };
    return ResizeObserver;
}());

const zeaScrollPaneCss = ":host{max-height:100%;width:100%;display:block;position:relative;height:100%}:host(.disabled){height:auto}.zea-scroll-pane{pointer-events:auto;max-height:100%;overflow:auto;scrollbar-width:none;-ms-overflow-style:none;}.zea-scroll-pane::-webkit-scrollbar{width:0px;background:transparent;}.v-scroll-track{position:absolute;right:0;top:0;bottom:0;width:10px;background-color:var(--color-background-4);z-index:1000}.v-scroll-bar{position:absolute;right:0px;width:10px;top:0;background-color:var(--color-grey-3);z-index:10000;box-shadow:-2px 4px 7px -3px var(--color-background-1)}:host(.disabled) .v-scroll-track,:host(.disabled) .v-scroll-bar{display:none}";

const ZeaScrollPane = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.vMouseDown = false;
  }
  /**
   *
   */
  onResize() {
    this.refreshScrollbar();
  }
  /**
   *
   */
  onOrientationchange() {
    this.refreshScrollbar();
  }
  /**
   *
   */
  onMouseUp() {
    this.vMouseDown = false;
    this.scrollPane.style.userSelect = 'initial';
  }
  /**
   * @param {any} e The event
   */
  onMouseMove(e) {
    if (this.vMouseDown) {
      const mouseDelta = e.clientY - this.prevClientY;
      const newScroll = (this.vBarTop - this.vTrackTop + mouseDelta) / this.scrollRatio;
      this.scrollPane.scrollTop = this.scrollPane.scrollTop + newScroll;
      this.prevClientY = e.clientY;
    }
  }
  /**
   *
   */
  componentDidLoad() {
    this.refreshScrollbar();
    this.scrollPane.addEventListener('scroll', () => {
      this.vScrollBar.style.top = `${this.scrollPane.scrollTop * this.scrollRatio}px`;
    });
    this.vScrollBar.addEventListener('mousedown', (e) => {
      this.vMouseDown = true;
      this.vMouseOffet = e.clientY;
      this.vCurrentScroll = this.scrollPane.scrollTop;
      const vBarBbox = this.vScrollBar.getBoundingClientRect();
      this.vBarTop = vBarBbox.top;
      this.vBarHeight = vBarBbox.height;
      this.prevClientY = e.clientY;
      const vTrackBbox = this.vScrollBar.getBoundingClientRect();
      this.vTrackTop = vTrackBbox.top;
      this.scrollPane.style.userSelect = 'none';
    });
    const ro = new ResizeObserver(() => {
      this.refreshScrollbar();
    });
    ro.observe(this.scrollContent);
    const observer = new MutationObserver((mutations) => {
      console.log(mutations);
      this.refreshScrollbar();
    });
    observer.observe(this.scrollContent, {
      attributes: true,
    });
  }
  /**
   *
   */
  async refreshScrollbar() {
    this.scrollRatio =
      Math.ceil((this.rootElement.offsetHeight / this.scrollContent.offsetHeight) * 1000) / 1000;
    if (this.scrollRatio < 0.999) {
      this.rootElement.classList.remove('disabled');
      const handleHeight = this.rootElement.offsetHeight * this.scrollRatio;
      this.scrollDelta = this.rootElement.offsetHeight - handleHeight;
      this.vScrollBar.style.height = `${handleHeight}px`;
    }
    else {
      this.rootElement.classList.add('disabled');
    }
  }
  /**
   *
   */
  render() {
    return (h$4(Host, null, h$4("div", { ref: (el) => (this.vScrollTrack = el), draggable: false, class: "v-scroll-track" }), h$4("div", { draggable: false, class: "v-scroll-bar", ref: (el) => (this.vScrollBar = el) }), h$4("div", { class: "zea-scroll-pane", ref: (el) => (this.scrollPane = el) }, h$4("div", { class: "scroll-content", ref: (el) => (this.scrollContent = el) }, h$4("slot", null)))));
  }
  get rootElement() { return this; }
  static get style() { return zeaScrollPaneCss; }
};

const zeaSwitchCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-switch{display:inline-block;overflow:hidden;width:45px;height:16px;position:relative;color:var(--color-foreground-1)}.zea-switch-wrap{width:100%;height:100%}.zea-switch-track{width:25px;height:10px;border-radius:5px;position:absolute;top:3px;left:2px;background-color:var(--color-foreground-3)}.zea-switch-button{width:16px;height:16px;border-radius:8px;position:absolute;background-color:var(--color-foreground-1)}.zea-switch.checked .zea-switch-button{background-color:var(--color-primary-1);left:13px}.zea-switch.disabled .zea-switch-button{background-color:var(--color-foreground-3)}.zea-switch.checked.disabled .zea-switch-button{background-color:var(--color-foreground-3)}.zea-switch.checked .zea-switch-track{background-color:var(--color-primary-3)}.zea-switch.disabled .zea-switch-track{background-color:var(--color-disabled-2)}.zea-switch.checked.disabled .zea-switch-track{background-color:var(--color-disabled-2)}input[type='checkbox']{position:relative;left:-50000px}.zea-switch-label{position:absolute;left:32px;top:2px;font-size:10px}.zea-switch.disabled .zea-switch-label{color:var(--color-foreground-3)}";

const ZeaSwitch = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Whether the switch is disabled
     */
    this.disabled = false;
    /**
     * Whether the switch is checked
     */
    this.checked = false;
  }
  /**
   * Listen for changes on the checked prop
   * @param {boolean} checked the checked state
   */
  onCheckedChanged(checked) {
    this.element.shadowRoot.querySelector('input').checked = checked;
    this.updateElementClass();
    this.stateLabel = checked ? 'On' : 'Off';
  }
  /**
   * Listen for changes on the disabled prop
   * @param {boolean} disabled the disabled state
   */
  onDisabledChanged(disabled) {
    this.element.shadowRoot.querySelector('input').disabled = disabled;
    this.updateElementClass();
  }
  /**
   * Update element class according to switch state
   */
  updateElementClass() {
    this.elementClass = this.checked ? 'checked' : '';
    this.elementClass += this.disabled ? ' disabled ' : '';
  }
  /**
   * Change switch state on click
   */
  toggleCheck() {
    if (!this.disabled) {
      this.checked = !this.checked;
    }
  }
  /**
   * Runs when component loads
   */
  componentDidLoad() {
    this.onCheckedChanged(this.checked);
    this.onDisabledChanged(this.disabled);
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("div", { class: 'zea-switch ' + this.elementClass, onClick: () => {
        this.toggleCheck();
      } }, h$4("span", { class: "zea-switch-wrap" }, h$4("span", { class: "zea-switch-track" }), h$4("span", { class: "zea-switch-button" }), h$4("span", { class: "zea-switch-label" }, this.stateLabel)), h$4("input", { type: "checkbox", name: this.name })));
  }
  get element() { return this; }
  static get watchers() { return {
    "checked": ["onCheckedChanged"],
    "disabled": ["onDisabledChanged"]
  }; }
  static get style() { return zeaSwitchCss; }
};

const zeaTabsCss = "@import url('https://unpkg.com/tachyons@4/css/tachyons.min.css');:host{display:block;height:100%}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-tabs{color:var(--color-foreground-1);display:flex;width:100%;height:100%}.zea-tabs *{box-sizing:border-box}.zea-tabs.small{font-size:11px}.zea-tabs{flex-direction:column}.zea-tabs.vertical{flex-direction:row}.zea-tabs .zea-tabs-bar{flex-shrink:0;border-bottom:1px solid var(--color-grey-3)}.zea-tabs.vertical .zea-tabs-bar{width:10em;flex-shrink:0;height:auto;border-bottom:none;border-right:1px solid var(--color-grey-3)}.zea-tabs-content{flex-grow:1;padding-top:1em;height:calc(100% - 30px)}::slotted(:not([slot='tab-bar'])){display:none}::slotted(.active:not([slot='tab-bar'])){display:block;max-height:100%;}::slotted([slot='tab-bar']){font-weight:bold;color:var(--color-foreground-1);cursor:pointer;display:inline-block;padding:1em 1em 0.5em}.small ::slotted([slot='tab-bar']){padding:0.5em 1em 0.5em}::slotted([slot='tab-bar']:hover){color:var(--color-secondary-1)}::slotted(.active[slot='tab-bar']){border-bottom:0.2em solid var(--color-secondary-1);color:var(--color-secondary-1)}.vertical ::slotted([slot='tab-bar']){border-bottom:none;border-left:0.3em solid transparent;padding:1.4em 1em}.vertical ::slotted(.active[slot='tab-bar']){border-bottom:none;border-left:0.3em solid var(--color-secondary-1)}.vertical .zea-tabs-bar{padding-top:2em;padding-left:0}";

const ZeaTabs = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.orientation = 'horizontal';
    this.density = 'medium';
  }
  /**
   * Listen to click events
   * @param {any} event The event
   */
  clickHandler(event) {
    if (event.target.getAttribute('slot') == 'tab-bar') {
      let tabIndex = this.getTabIndex(event.target);
      this.showPanelByIndex(tabIndex);
      this.resetActiveTab();
      event.target.classList.add('active');
    }
  }
  /**
   * Show panel by index
   * @param {any} tabIndex The tab index
   */
  showPanelByIndex(tabIndex) {
    const contentSlot = this.mainElement.shadowRoot.querySelector('slot:not([name])');
    const contentItems = contentSlot.assignedElements();
    const nodes = Array.prototype.slice.call(contentItems);
    for (const i in contentItems) {
      if (contentItems.hasOwnProperty(i)) {
        contentItems[i].classList.remove('active');
      }
    }
    const contentElement = nodes[tabIndex];
    contentElement.classList.add('active');
  }
  /**
   * Get the index of a tab
   * @param {any} tabElement The tab index
   * @return {int} The index of the tab
   */
  getTabIndex(tabElement) {
    const tabsSlot = this.mainElement.shadowRoot.querySelector('slot[name="tab-bar"]');
    const tabItems = tabsSlot.assignedElements();
    const nodes = Array.prototype.slice.call(tabItems);
    return nodes.indexOf(tabElement);
  }
  /**
   * Show panel by index
   */
  resetActiveTab() {
    const tabsSlot = this.mainElement.shadowRoot.querySelector('slot[name="tab-bar"]');
    const tabItems = tabsSlot.assignedElements();
    for (const i in tabItems) {
      if (tabItems.hasOwnProperty(i)) {
        tabItems[i].classList.remove('active');
      }
    }
  }
  /**
   * Activate first tab on load
   */
  componentDidLoad() {
    const tabsSlot = this.mainElement.shadowRoot.querySelector('slot[name="tab-bar"]');
    const firstTab = tabsSlot.assignedElements()[0];
    const evObj = document.createEvent('Events');
    evObj.initEvent('click', true, false);
    firstTab.dispatchEvent(evObj);
  }
  /**
   * Main render function
   * @return {JSX} the generated html
   */
  render() {
    return (h$4("div", { class: `zea-tabs ${this.orientation} ${this.density}` }, h$4("div", { class: "zea-tabs-bar" }, h$4("slot", { name: "tab-bar" })), h$4("div", { class: "zea-tabs-content" }, h$4("slot", null))));
  }
  get mainElement() { return this; }
  static get style() { return zeaTabsCss; }
};

const zeaToolbarCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}:root{--toolbar-active-color:var(--color-primary-2)}.zea-toolbar{color:var(--color-foreground-1);background-color:var(--color-background-2);position:fixed;border-radius:30px}";

const ZeaToolbar = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.offset = [0, 0];
    /**
     * Array of tools
     */
    this.tools = {};
  }
  /**
   * Listen to mousedown event
   * @param {any} event the event
   */
  mousedownHandler(event) {
    if (event.currentTarget.tagName == 'ZEA-TOOLBAR') {
      this.mouseIsDown = true;
      this.offset = [
        this.toolbarElement.offsetLeft - event.clientX,
        this.toolbarElement.offsetTop - event.clientY,
      ];
    }
  }
  /**
   * Listen to mouseup event
   */
  mouseupHandler() {
    this.mouseIsDown = false;
  }
  /**
   * Listen to mousemove event
   * @param {any} event the event
   */
  mousemoveHandler(event) {
    if (this.mouseIsDown) {
      this.toolbarElement.style.left = `${event.clientX + this.offset[0]}px`;
      this.toolbarElement.style.top = `${event.clientY + this.offset[1]}px`;
    }
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    const toolKeys = Object.keys(this.tools);
    return (h$4("div", { class: "zea-toolbar", ref: (el) => (this.toolbarElement = el) }, toolKeys &&
      toolKeys.map((toolKey) => {
        const tool = this.tools[toolKey];
        return h$4(tool.tag, { data: tool.data, key: toolKey });
      })));
  }
  static get style() { return zeaToolbarCss; }
};

const zeaToolbarColorpickerCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-colopicker{background-repeat:no-repeat;background-position:37px 20px;background-size:5px;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ4IDc5LjE2NDAzNiwgMjAxOS8wOC8xMy0wMTowNjo1NyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjAxQzcxOEE3NjJFQjExRUFBQzdFRTU5MkM3MEIwNjY1IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjAxQzcxOEE4NjJFQjExRUFBQzdFRTU5MkM3MEIwNjY1Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDFDNzE4QTU2MkVCMTFFQUFDN0VFNTkyQzcwQjA2NjUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDFDNzE4QTY2MkVCMTFFQUFDN0VFNTkyQzcwQjA2NjUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz59SANnAAAAN0lEQVR42qTMwQ0AIAwDsTI5oxt1Be6kPJ2DCd3Zg89dFatYxSpWsYpVrGIVq1jFKlaxircnwACIPE/UtxKEdgAAAABJRU5ErkJggg==')}.children{position:absolute;margin-left:56px;margin-top:-42px;background-color:var(--color-background-2);border-radius:20px;display:grid;grid-gap:10px;padding:10px;grid-template-columns:1fr 1fr 1fr}.colorpicker-color{width:26px;height:26px;border-radius:15px;margin:11px}.children .colorpicker-color{margin:0px}";

const ZeaToolbarColorpicker = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.children = [];
    this.mouseIsdown = false;
  }
  /**
   * Called everytime component renders
   */
  componentDidLoad() {
    this.setActiveTool({});
  }
  /**
   * Set the active tool
   * @param {any} e The event
   */
  setActiveTool(e) {
    if (!this.currentTool) {
      this.currentTool = this.children.shift();
    }
    this.currentContainer.appendChild(this.currentTool);
    this.displayChildren = false;
    document.documentElement.style.setProperty('--toolbar-active-fg-color', this.currentTool.style.color);
    document.documentElement.style.setProperty('--toolbar-active-bg-color', this.currentTool.style.backgroundColor);
    const key = this.currentTool.getAttribute('data-key');
    if ('callback' in this.data.colors[key])
      this.data.colors[key].callback(e);
  }
  /**
   * Handle click on color
   * @param {any} e the event
   */
  handleChildrenClick(e) {
    this.childrenContainer.style.display = 'none';
    const clickedTool = e.currentTarget;
    if (clickedTool == this.currentTool) {
      if (this.displayChildren) {
        this.displayChildren = false;
      }
      else {
        this.displayChildren = true;
        this.currentTool = clickedTool;
      }
    }
    else if (this.children.includes(clickedTool)) {
      this.childrenContainer.appendChild(this.currentTool);
      this.children.push(this.currentTool);
      this.currentTool = clickedTool;
      this.setActiveTool(e);
    }
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    const colorKeys = Object.keys(this.data.colors);
    return (h$4("div", { class: "zea-colopicker", ref: (el) => (this.colopickerElement = el) }, h$4("div", { class: "current", ref: (el) => (this.currentContainer = el) }), h$4("div", { class: "children", style: { display: this.displayChildren ? 'grid' : 'none' }, ref: (el) => (this.childrenContainer = el) }, colorKeys &&
      colorKeys.map((colorKey) => {
        const color = this.data.colors[colorKey];
        return (h$4("div", { class: "colorpicker-color", style: {
            backgroundColor: color.background,
            color: color.foreground,
          }, "data-key": colorKey, key: colorKey, onClick: this.handleChildrenClick.bind(this), ref: (el) => this.children.push(el) }));
      }))));
  }
  static get style() { return zeaToolbarColorpickerCss; }
};

const zeaToolbarToolCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.tool-wrap{padding:8px;margin:4px;border-radius:20px;color:var(--color-foreground-1)}.tool-wrap:hover{background-color:var(--color-grey-3)}.tool-wrap.active,.tool-wrap.active:hover{background-color:var(--toolbar-active-bg-color, var(--color-primary-1));color:var(--toolbar-active-fg-color, var(--color-background-1))}";

const ZeaToolbarTool = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.zeaToolbarToolClick = createEvent(this, "zeaToolbarToolClick", 7);
  }
  /**
   * zeaToolbarToolClickHandler
   * @param {any} event the event data
   */
  zeaToolbarToolClickHandler() {
    this.isActive = false;
  }
  /**
   * Handle click on user chip
   * @param {any} e the event
   */
  toolClickHandler(e) {
    this.zeaToolbarToolClick.emit(this.hostElement);
    this.isActive = true;
    if ('callback' in this.data) {
      this.data.callback(e);
    }
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4("div", { ref: (el) => (this.outerWrap = el), class: `tool-wrap ${this.isActive ? 'active' : ''}`, title: this.data.toolName, onClick: this.toolClickHandler.bind(this) }, h$4("zea-icon", { name: this.data.iconName, type: this.data.iconType })));
  }
  get hostElement() { return this; }
  static get style() { return zeaToolbarToolCss; }
};

const zeaToolbarToolsetCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-toolset{background-repeat:no-repeat;background-position:38px 34px;background-size:5px;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ4IDc5LjE2NDAzNiwgMjAxOS8wOC8xMy0wMTowNjo1NyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjAxQzcxOEE3NjJFQjExRUFBQzdFRTU5MkM3MEIwNjY1IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjAxQzcxOEE4NjJFQjExRUFBQzdFRTU5MkM3MEIwNjY1Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDFDNzE4QTU2MkVCMTFFQUFDN0VFNTkyQzcwQjA2NjUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDFDNzE4QTY2MkVCMTFFQUFDN0VFNTkyQzcwQjA2NjUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz59SANnAAAAN0lEQVR42qTMwQ0AIAwDsTI5oxt1Be6kPJ2DCd3Zg89dFatYxSpWsYpVrGIVq1jFKlaxircnwACIPE/UtxKEdgAAAABJRU5ErkJggg==')}.children{position:absolute;margin-left:56px;margin-top:-48px;background-color:var(--color-background-2);border-radius:30px;display:flex}";

const ZeaToolbar$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.children = [];
    this.mouseIsdown = false;
  }
  /**
   * zeaToolbarToolClickHandler
   * @param {any} e the event data
   */
  zeaToolbarToolClickHandler(e) {
    this.childrenContainer.style.display = 'none';
    const clickedTool = e.detail;
    if (this.currentTool == clickedTool) {
      if (clickedTool.isActive) {
        this.childrenContainer.style.display = 'flex';
      }
      return;
    }
    if (this.children.includes(clickedTool)) {
      this.children.push(this.currentTool);
      this.childrenContainer.appendChild(this.currentTool);
      this.currentTool = clickedTool;
      this.setActiveTool();
    }
  }
  /**
   * Called everytime component renders
   */
  componentDidLoad() {
    this.setActiveTool();
  }
  /**
   * setActiveTool
   */
  setActiveTool() {
    if (!this.currentTool) {
      this.currentTool = this.children.shift();
    }
    this.currentContainer.appendChild(this.currentTool);
    this.childrenContainer.style.display = 'none';
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    const toolKeys = Object.keys(this.data.tools);
    return (h$4("div", { class: "zea-toolset", ref: (el) => (this.toolsetElement = el) }, h$4("div", { class: "current", ref: (el) => (this.currentContainer = el) }), h$4("div", { class: "children", ref: (el) => (this.childrenContainer = el) }, toolKeys &&
      toolKeys.map((toolKey) => {
        const tool = this.data.tools[toolKey];
        return (h$4(tool.tag, { key: toolKey, data: tool.data, ref: (el) => this.children.push(el) }));
      }))));
  }
  get hostElement() { return this; }
  static get style() { return zeaToolbarToolsetCss; }
};

var zeaEngine_cjs = createCommonjsModule(function (module, exports) {
function e(t,a){if(!e.watchedElementData){e.watchedElementData=[];const t=function(){e.watchedElementData.forEach((function(e){e.element.offsetWidth===e.offsetWidth&&e.element.offsetHeight===e.offsetHeight||(e.offsetWidth=e.element.offsetWidth,e.offsetHeight=e.element.offsetHeight,e.callback());}));};window.addEventListener("resize",t),new MutationObserver(t).observe(document.body,{attributes:!0,childList:!0,characterData:!0,subtree:!0});}e.watchedElementData.push({element:t,offsetWidth:t.offsetWidth,offsetHeight:t.offsetHeight,callback:a});}Object.defineProperty(exports,"__esModule",{value:!0});const t=function(){const e=null!=(navigator.userAgent.match(/Android/i)||navigator.userAgent.match(/webOS/i)||navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPod/i)||navigator.userAgent.match(/BlackBerry/i)||navigator.userAgent.match(/Pixel/i)||navigator.userAgent.match(/Windows Phone/i)),t=function(){const e=navigator.userAgent;let t,a,i,s=navigator.appName,n=""+parseFloat(navigator.appVersion),l=parseInt(navigator.appVersion,10);return -1!=(a=e.indexOf("Opera"))?(s="Opera",n=e.substring(a+6),-1!=(a=e.indexOf("Version"))&&(n=e.substring(a+8))):-1!=(a=e.indexOf("MSIE"))?(s="Microsoft Internet Explorer",n=e.substring(a+5)):-1!=(a=e.indexOf("Edge"))?(s="Edge",n=e.substring(a+4)):-1!=(a=e.indexOf("Chrome"))?(s="Chrome",n=e.substring(a+7)):-1!=(a=e.indexOf("Safari"))?(s="Safari",n=e.substring(a+7),-1!=(a=e.indexOf("Version"))&&(n=e.substring(a+8))):-1!=(a=e.indexOf("Firefox"))?(s="Firefox",n=e.substring(a+8)):(t=e.lastIndexOf(" ")+1)<(a=e.lastIndexOf("/"))&&(s=e.substring(t,a),n=e.substring(a+1),s.toLowerCase()==s.toUpperCase()&&(s=navigator.appName)),-1!=(i=n.indexOf(";"))&&(n=n.substring(0,i)),-1!=(i=n.indexOf(" "))&&(n=n.substring(0,i)),l=parseInt(""+n,10),isNaN(l)&&(n=""+parseFloat(navigator.appVersion),l=parseInt(navigator.appVersion,10)),{browserName:s,fullVersion:n,majorVersion:l,appName:navigator.appName,userAgent:navigator.userAgent}}(),a=function(){let e,t;try{e=document.createElement("canvas").getContext("webgl");}catch(e){}if(!e)return;try{t=document.createElement("canvas").getContext("webgl2");}catch(e){}const a=e.getExtension("WEBGL_debug_renderer_info"),i=e.getParameter(a.UNMASKED_VENDOR_WEBGL),s=e.getParameter(a.UNMASKED_RENDERER_WEBGL),n=e.getParameter(e.MAX_TEXTURE_SIZE);let l;return s.match(/NVIDIA/i)?l="NVidia":s.match(/AMD/i)||s.match(/Radeon/i)?l="AMD":s.match(/Intel/i)?l="Intel":s.match(/Mali/i)?l="ARM":s.match(/Adreno/i)?l="Adreno":console.warn("Unable to determine GPU vendor:",s),{vendor:i,renderer:s,gpuVendor:l,maxTextureSize:n,supportsWebGL2:null!=t}}();let i="Low";if(a)if(e)i="Low";else {const e=a.renderer.replace(/[()]/g,"").split(" ");if("NVidia"==a.gpuVendor){const t=e.indexOf("GTX");if(-1!=t){const a=e[t+1];if(a.endsWith("M")){i=parseInt(a.substring(0,a.length-2))>=900?"Medium":"Low";}else {i=parseInt(a)>=1030?"High":"Medium";}}else i=-1!=e.indexOf("TITAN")||-1!=e.indexOf("Quadro")?"High":"Low";}else if("AMD"==a.gpuVendor){const t=e.indexOf("Radeon");if(-1!=t){const a=e.indexOf("RX");if(-1!=a)if("Vega"==e[a+1])i="High";else {const t=e[a+1];let s;t.endsWith("X")?(s=parseInt(t.substring(0,t.length-2)),i="High"):s=parseInt(t),i=s>=480?"High":"Medium";}else if("Pro"==e[t+1]){i=parseInt(e[a+1])>=450?"Medium":"Low";}else if("Sky"==e[t+1]){i=parseInt(e[a+1])>=700?"Medium":"Low";}else i="Low";}else i=-1!=e.indexOf("FirePro")||-1!=e.indexOf("Quadro")?"High":"Low";}else ("Adreno"==a.gpuVendor||"Intel"==a.gpuVendor)&&(i="Low");}return {isMobileDevice:e,isIOSDevice:null!=(navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPod/i)),browserName:t.browserName,fullVersion:t.fullVersion,majorVersion:t.majorVersion,appName:t.appName,userAgent:t.userAgent,webGLSupported:null!=a,gpuDesc:a,deviceCategory:i}}();var a=Object.freeze({__proto__:null,SystemDesc:t});const i=Math.PI/180;Math.HALF_PI=.5*Math.PI,Math.TWO_PI=2*Math.PI;Math.radToDeg=function(e){return e/i},Math.degToRad=function(e){return e*i},Number.isNumeric=e=>!isNaN(parseFloat(e))&&isFinite(e),String.prototype.replaceAll=function(e,t){return this.replace(new RegExp(e,"g"),t)};const s=function(e){let t,a,i,s=0;if(0===e.length)return s;for(t=0,i=e.length;t<i;t++)a=e.charCodeAt(t),s=(s<<5)-s+a,s|=0;return Math.abs(s)};function n(e,t=0,a=5){return JSON.stringify(e,(function(e,t){return t&&t.toFixed?Number(t.toFixed(a)):t}),t)}String.prototype.hash=function(){return s(this)},String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")},String.prototype.ltrim=function(){return this.replace(/^\s+/,"")},String.prototype.rtrim=function(){return this.replace(/\s+$/,"")},String.prototype.lpad=function(e,t){let a=this;for(;a.length<t;)a=e+a;return a},String.prototype.rpad=function(e,t){let a=this;for(;a.length<t;)a+=e;return a},Math.randomInt=function(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e))+e},Math.lerp=(e,t,a)=>e+a*(t-e),Math.clamp=function(e,t,a){return Math.min(Math.max(e,t),a)},Math.nearestPow2=function(e){return Math.pow(2,Math.round(Math.log(e)/Math.log(2)))},Math.nearestPow10=function(e){return Math.pow(10,Math.round(Math.log10(e)/Math.log10(10)))},Math.nextPow2=function(e){let t=0;for(;e>0;)t++,e>>=1;return 1<<t},Math.fract=function(e){return 0==e?0:e<0?e>-1?-e:-e%Math.floor(-e):e<1?e:e%Math.floor(e)},Math.remap=function(e,t,a,i,s){return i+(e-t)/(a-t)*(s-i)},Math.convertFloat32ArrayToUInt16Array=function(e){const t=new Uint16Array(e.length),a=new Int32Array(e.buffer),i=e=>{let t=e>>16&32768,a=e>>12&2047;const i=e>>23&255;return i<103?t:i>142?(t|=31744,t|=(255==i?0:1)&&8388607&e,t):i<113?(a|=2048,t|=(a>>114-i)+(a>>113-i&1),t):(t|=i-112<<10|a>>1,t+=1&a,t)};for(let s=0;s<e.length;s++)t[s]=i(a[s]);return t},Math.decode16BitFloatFrom2xUInt8=e=>{const t=e[0],a=(120&t)>>3;let i=0==a?0:2048;const s=i+((7&t)<<8)+e[1];return i=0==a?1:0,(128&t?1:-1)*s*Math.pow(2,a+i-16)},Math.encode16BitFloatInto2xUInt8=e=>{c||(c=new Uint8Array(2));const t=e>=0?128:0;e=Math.abs(e);let a,i=15,s=1024;for(let t=15;t>0;t--)e<s&&(s/=2,i--);a=0==i?e/s/2:(e-s)/s;const n=Math.round(2048*a),l=n/256,r=n-256*l;return c[0]=t+8*i+l,c[1]=r,e>=2048&&(c[0]=255),c},Math.encode16BitFloat=e=>{const t=new Float32Array(1);t[0]=e;return (e=>{let t=e>>16&32768,a=e>>12&2047;const i=e>>23&255;return i<103?t:i>142?(t|=31744,t|=(255==i?0:1)&&8388607&e,t):i<113?(a|=2048,t|=(a>>114-i)+(a>>113-i&1),t):(t|=i-112<<10|a>>1,t+=1&a,t)})(new Int32Array(t.buffer)[0])},Math.decode16BitFloat=e=>{const t=(32768&e)>>15,a=(31744&e)>>10,i=1023&e;return 0==a?(t?-1:1)*Math.pow(2,-14)*(i/Math.pow(2,10)):31==a?i?NaN:1/0*(t?-1:1):(t?-1:1)*Math.pow(2,a-15)*(1+i/Math.pow(2,10))},Math.smoothStep=(e,t,a)=>{const i=Math.clamp((a-e)/(t-e),0,1);return i*i*(3-2*i)},Math.linStep=(e,t,a)=>Math.clamp((a-e)/(t-e),0,1);class l{isValid(){for(const e of this.__data)if(e==1/0||isNaN(e))return !1;return !0}static createFromFloat32Buffer(e,t){throw new Error("Not yet implemented for this type:"+this.constructor.name)}static numElements(){throw new Error("Not yet implemented for this type:"+this.constructor.name)}asArray(){return this.__data}toString(){return n(this.toJSON())}}const r=new class{constructor(){this.__types={},this.__names={},this.registerType("SInt32",5),this.registerType("UInt32",4),this.registerType("Float32",6);}registerType(e,t){this.__types[e]=t,t.name?this.__names[t.name]=e:this.__names[t]=e;}getType(e){return this.__types[e]}getTypeName(e){if(this.__names[e])return this.__names[e];if(this.__names[e.name])return this.__names[e.name];throw e}};class o extends l{constructor(e=0,t=0){if(super(),e instanceof Float32Array||e instanceof Uint32Array||e instanceof Int32Array)this.__data=e;else if(e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,2);}else null!=e&&"object"==typeof e?(this.__data=new Float32Array(2),this.fromJSON(e)):(this.__data=new Float32Array(2),this.__data[0]=e,this.__data[1]=t);}get x(){return this.__data[0]}set x(e){this.__data[0]=e;}get y(){return this.__data[1]}set y(e){this.__data[1]=e;}set(e,t){this.__data[0]=e,this.__data[1]=t;}setFromOther(e){this.x=e.x,this.y=e.y;}equal(e){return this.x==e.x&&this.y==e.y}notEquals(e){return this.x!=e.x&&this.y!=e.y}approxEqual(e,t=Number.EPSILON){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t}add(e){return new o(this.x+e.x,this.y+e.y)}addInPlace(e){this.x+=e.x,this.y+=e.y;}subtract(e){return new o(this.x-e.x,this.y-e.y)}subtractInPlace(e){return this.x-=e.x,this.y-=e.y,this}scale(e){return new o(this.x*e,this.y*e)}scaleInPlace(e){this.x*=e,this.y*=e;}invert(){return new o(1/this.x,1/this.y)}invertInPlace(){return this.x=1/this.x,this.y=1/this.y,this}multiply(e){return new o(this.x*e.x,this.y*e.y)}multiplyInPlace(e){this.x*=e.x,this.y*=e.y;}lengthSquared(){const e=this.__data[0],t=this.__data[1];return e*e+t*t}length(){return Math.sqrt(this.lengthSquared())}distanceTo(e){const t=this.__data[0]-e.x,a=this.__data[1]-e.y;return Math.sqrt(t*t+a*a)}normalize(){const e=this.__data[0],t=this.__data[1];let a=e*e+t*t;return a<Number.EPSILON?new o:(a=1/Math.sqrt(a),new o(e*a,t*a))}normalizeInPlace(){const e=this.__data[0],t=this.__data[1];let a=e*e+t*t;a<Number.EPSILON||(a=1/Math.sqrt(a),this.set(e*a,t*a));}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}angleTo(e){const t=this.normalize().dot(e.normalize());return t>1?0:t<-1?Math.PI:Math.acos(t)}signedAngleTo(e){const t=this.angleTo(e);return this.cross(e)<0?-t:t}rotate(e){const t=Math.cos(e),a=Math.sin(e);return new o(this.x*t-this.y*a,this.x*a+this.y*t)}lerp(e,t){const a=this.x,i=this.y;return new o(a+t*(e.x-a),i+t*(e.y-i))}setRandomDir(e=1){const t=2*Math.random()*Math.PI;return this.__data[0]=Math.cos(t)*zScale,this.__data[1]=Math.sin(t)*zScale,this}setRandom(e=1){return this.__data[0]=Math.random()*e,this.__data[1]=Math.random()*e,this}clone(){return new o(this.__data[0],this.__data[1])}asArray(){return this.__data}static create(...e){return new o(...e)}static createFromFloat32Buffer(e,t=0){return new o(e,4*t)}static createFromFloat32Array(e){return new o(e)}static numElements(){return 2}toJSON(){return {x:this.x,y:this.y}}fromJSON(e){this.x=e.x,this.y=e.y;}}r.registerType("Vec2",o);class d extends l{constructor(e=0,t=0,a=0){if(super(),e instanceof Float32Array||e instanceof Uint32Array)this.__data=e;else if(e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,3);}else null!=e&&"object"==typeof e?(this.__data=new Float32Array(3),this.fromJSON(e)):(this.__data=new Float32Array(3),this.__data[0]=e,this.__data[1]=t,this.__data[2]=a);}get x(){return this.__data[0]}set x(e){this.__data[0]=e;}get y(){return this.__data[1]}set y(e){this.__data[1]=e;}get z(){return this.__data[2]}set z(e){this.__data[2]=e;}get xy(){return new o(this.__data[0],this.__data[1])}get yz(){return new o(this.__data[1],this.__data[2])}set(e,t,a){this.x=e,this.y=void 0!==t?t:e,this.z=void 0!==a?a:e;}setDataArray(e){this.__data=e;}setFromOther(e){this.x=e.x,this.y=e.y,this.z=e.z;}isNull(){return Math.abs(this.x)<Number.EPSILON&&Math.abs(this.y)<Number.EPSILON&&Math.abs(this.z)<Number.EPSILON}is111(){return Math.abs(1-this.x)<Number.EPSILON&&Math.abs(1-this.y)<Number.EPSILON&&Math.abs(1-this.z)<Number.EPSILON}equal(e){return this.x==e.x&&this.y==e.y&&this.z==e.z}notEquals(e){return this.x!=e.x&&this.y!=e.y&&this.z!=e.z}approxEqual(e,t=Number.EPSILON){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t&&Math.abs(this.z-e.z)<t}add(e){return new d(this.x+e.x,this.y+e.y,this.z+e.z)}addInPlace(e){this.x+=e.x,this.y+=e.y,this.z+=e.z;}subtract(e){return new d(this.x-e.x,this.y-e.y,this.z-e.z)}subtractInPlace(e){this.x-=e.x,this.y-=e.y,this.z-=e.z;}multiply(e){return new d(this.x*e.x,this.y*e.y,this.z*e.z)}multiplyInPlace(e){this.x*=e.x,this.y*=e.y,this.z*=e.z;}divide(e){return new d(this.x/e.x,this.y/e.y,this.z/e.z)}divideInPlace(e){this.x/=e.x,this.y/=e.y,this.z/=e.z;}scale(e){return new d(this.x*e,this.y*e,this.z*e)}scaleInPlace(e){this.x*=e,this.y*=e,this.z*=e;}negate(){return new d(-this.x,-this.y,-this.z)}inverse(){return new d(1/this.x,1/this.y,1/this.z)}lengthSquared(){const e=this.__data[0],t=this.__data[1],a=this.__data[2];return e*e+t*t+a*a}length(){return Math.sqrt(this.lengthSquared())}distanceTo(e){const t=this.__data[0]-e.x,a=this.__data[1]-e.y,i=this.__data[2]-e.z;return Math.sqrt(t*t+a*a+i*i)}normalize(){let e=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];return e<Number.EPSILON?new d:(e=1/Math.sqrt(e),new d(this.__data[0]*e,this.__data[1]*e,this.__data[2]*e))}normalizeInPlace(){let e=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];if(e<Number.EPSILON)return;e=Math.sqrt(e);const t=1/e;return this.__data[0]*=t,this.__data[1]*=t,this.__data[2]*=t,e}resize(e){const t=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];if(t<Number.EPSILON)return;const a=e/Math.sqrt(t);return new d(this.__data[0]*a,this.__data[1]*a,this.__data[2]*a)}resizeInPlace(e){const t=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];if(t<Number.EPSILON)return;const a=e/Math.sqrt(t);this.__data[0]*=a,this.__data[1]*=a,this.__data[2]*=a;}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e){const t=this.x,a=this.y,i=this.z,s=e.x,n=e.y,l=e.z;return new d(a*l-i*n,i*s-t*l,t*n-a*s)}angleTo(e){const t=this.dot(e);return t>1?0:Math.acos(t)}lerp(e,t){const a=this.x,i=this.y,s=this.z;return new d(a+t*(e.x-a),i+t*(e.y-i),s+t*(e.z-s))}abs(){return new d(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}setRandomDir(e=1){const t=2*Math.random()*Math.PI,a=2*Math.random()-1,i=Math.sqrt(1-a*a)*e;return this.__data[0]=Math.cos(t)*i,this.__data[1]=Math.sin(t)*i,this.__data[2]=a*e,this}setRandom(e=1){return this.__data[0]=(Math.random()-.5)*e,this.__data[1]=(Math.random()-.5)*e,this.__data[2]=(Math.random()-.5)*e,this}clone(){return new d(this.__data[0],this.__data[1],this.__data[2])}asArray(){return this.__data}static create(...e){return new d(...e)}static createFromJSON(e){const t=new d;return t.fromJSON(e),t}static createFromFloat32Buffer(e,t=0){return new d(e,4*t)}static createFromFloat32Array(e){return new d(e)}static numElements(){return 3}toJSON(){return {x:this.x,y:this.y,z:this.z}}fromJSON(e){this.x=e.x,this.y=e.y,this.z=e.z;}}r.registerType("Vec3",d);class h extends l{constructor(e=0,t=0,a=0,i=0){if(super(),e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,4);}else null!=e&&"object"==typeof e?(this.__data=new Float32Array(4),this.fromJSON(e)):(this.__data=new Float32Array(4),this.__data[0]=e,this.__data[1]=t,this.__data[2]=a,this.__data[3]=i);}get x(){return this.__data[0]}set x(e){this.__data[0]=e;}get y(){return this.__data[1]}set y(e){this.__data[1]=e;}get z(){return this.__data[2]}set z(e){this.__data[2]=e;}get t(){return this.__data[3]}set t(e){this.__data[3]=e;}get xyz(){return new d(this.__data[0],this.__data[1],this.__data[2])}set(e,t,a,i){this.x=e,this.y=t,this.z=a,this.t=i;}setFromOther(e){this.x=e.x,this.y=e.y,this.z=e.z,this.t=e.t;}equal(e){return this.x==e.x&&this.y==e.y&&this.z==e.z&&this.t==e.t}notEquals(e){return this.x!=e.x&&this.y!=e.y&&this.z!=e.z&&this.t!=e.t}approxEqual(e,t=Number.EPSILON){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t&&Math.abs(this.z-e.z)<t&&Math.abs(this.t-e.t)<t}add(e){return new h(this.x+e.x,this.y+e.y,this.z+e.z,this.t+e.t)}addInPlace(e){this.x+=e.x,this.y+=e.y,this.z+=e.z,this.t+=e.t;}subtract(e){return new h(this.x-e.x,this.y-e.y,this.z-e.z,this.t-e.t)}subtractInPlace(e){this.x-=e.x,this.y-=e.y,this.z-=e.z,this.t-=e.t;}multiply(e){return new h(this.x*e.x,this.y*e.y,this.z*e.z,this.t*e.t)}multiplyInPlace(e){this.x*=e.x,this.y*=e.y,this.z*=e.z,this.t*=e.t;}divide(e){return new h(this.x/e.x,this.y/e.y,this.z/e.z,this.t/e.t)}divideInPlace(e){this.x/=e.x,this.y/=e.y,this.z/=e.z,this.t/=e.t;}scale(e){return new h(this.x*e,this.y*e,this.z*e,this.t*e)}scaleInPlace(e){this.set(this.x*e,this.y*e,this.z*e,this.t*e);}length(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[2];return Math.sqrt(e*e+t*t+a*a+i*i)}lengthSquared(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3];return e*e+t*t+a*a+i*i}normalize(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3];let s=e*e+t*t+a*a+i*i;return s<Number.EPSILON?new h:(s=1/Math.sqrt(s),new h(e*s,t*s,a*s))}normalizeInPlace(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3];let s=e*e+t*t+a*a+i*i;s<Number.EPSILON||(s=1/Math.sqrt(s),this.set(e*s,t*s,a*s,i*s));}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.t*b.t}cross(e){const t=this.x,a=this.y,i=this.z,s=this.t,n=e.x,l=e.y,r=e.z,o=e.t;return new h(a*r-i*l,i*o-s*r,s*n-t*o,t*l-a*n)}angleTo(e){const t=this.normalize(),a=e.normalize(),i=t.dot(a);return i>1?0:Math.acos(i)}lerp(e,t){const a=this.x,i=this.y,s=this.z;return at=this.t,new h(a+t*(e.x-a),i+t*(e.y-i),s+t*(e.z-s),at+t*(e.t-at))}random(e=1){const t=2*glMatrix.RANDOM()*Math.PI,a=2*glMatrix.RANDOM()-1,i=Math.sqrt(1-a*a)*e;return out[0]=Math.cos(t)*i,out[1]=Math.sin(t)*i,out[2]=a*e,out}clone(){return new h(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}toVec3(){return new d(this.__data[0],this.__data[1],this.__data[2])}asArray(){return this.__data}static create(...e){return new d(...e)}static createFromFloat32Buffer(e,t=0){return new h(e,4*t)}static numElements(){return 4}toJSON(){return {x:this.x,y:this.y,z:this.z,t:this.t}}}r.registerType("Vec4",h);class m extends l{constructor(e=0,t=0,a=0,i=255){if(super(),e instanceof Uint8Array)this.__data=e;else if(e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Uint8Array(a,i,4);}else this.__data=new Uint8Array(4),"string"==typeof e?e.startsWith("#")?this.setFromHex(e):this.setFromCSSColorName(e):(this.__data[0]=e,this.__data[1]=t,this.__data[2]=a,this.__data[3]=i);}get r(){return this.__data[0]}set r(e){this.__data[0]=e;}get g(){return this.__data[1]}set g(e){this.__data[1]=e;}get b(){return this.__data[2]}set b(e){this.__data[2]=e;}get a(){return this.__data[3]}set a(e){this.__data[3]=e;}set(e,t,a,i=255){this.r=e,this.g=t,this.b=a,this.a=i;}setFromOther(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a;}setFromArray(e){this.r=e[0],this.g=e[1],this.b=e[2],this.a=4==e.length?e[3]:1;}setFromHex(e){const t=function(e){const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t?{r:parseInt(t[1],16),g:parseInt(t[2],16),b:parseInt(t[3],16)}:null}(e);t?this.set(t.r,t.g,t.b):console.warn("Invalid hex code:"+e);}setFromCSSColorName(e){e.startsWith("#")?this.setFromHex(e):this.setFromHex((e=>{const t={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4","indianred ":"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"};return void 0!==t[e.toLowerCase()]&&t[e.toLowerCase()]})(e));}toHex(){function e(e){const t=e.toString(16);return 1==t.length?"0"+t:t}return "#"+e(this.r)+e(this.g)+e(this.b)}equal(e){return this.r==e.r&&this.g==e.g&&this.b==e.b&&this.a==e.a}notequals(e){return this.r!=e.r&&this.g!=e.g&&this.b!=e.b&&this.a!=e.a}approxEqual(e,t=Number.EPSILON){return Math.abs(this.r-e.r)<t&&Math.abs(this.g-e.g)<t&&Math.abs(this.b-e.b)<t&&Math.abs(this.a-e.a)<t}add(e){return new m(this.r+e.r,this.g+e.g,this.b+e.b,this.a+e.a)}subtract(e){return new m(this.r-e.r,this.g-e.g,this.b-e.b,this.a-e.a)}scale(e){return new m(this.r*e,this.g*e,this.b*e,this.a*e)}scaleInPlace(e){this.r*=e,this.g*=e,this.b*=e,this.a*=e;}applyGamma(e){this.set(Math.pow(this.r,e),Math.pow(this.g,e),Math.pow(this.b,e),this.a);}toLinear(e=2.2){return new m(Math.pow(this.r,e),Math.pow(this.g,e),Math.pow(this.b,e),this.a)}toGamma(e=2.2){return new m(Math.pow(this.r,1/e),Math.pow(this.g,1/e),Math.pow(this.b,1/e),this.a)}luminance(){return .2126*this.r+.7152*this.g+.0722*this.b}lerp(e,t){const a=this.r,i=this.g,s=this.b,n=this.a;return new m(a+t*(e.r-a),i+t*(e.g-i),s+t*(e.b-s),n+t*(e.a-n))}static random(e=0,t=!1){return e>0?new m(e+Math.random()*(1-e),e+Math.random()*(1-e),e+Math.random()*(1-e),t?e+Math.random()*(1-e):1):e<0?new m(Math.random()*(1+e),Math.random()*(1+e),Math.random()*(1+e),t?Math.random()*(1+e):1):new m(Math.random(),Math.random(),Math.random(),t?Math.random():1)}clone(){return new m(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}asArray(){return this.__data}as3ComponentArray(){return [this.__data[0],this.__data[1],this.__data[2]]}static create(...e){return new m(...e)}static createFromFloat32Buffer(e,t=0){return new m(e,4*t)}static numElements(){return 4}toJSON(){return {r:this.r,g:this.g,b:this.b,a:this.a}}fromJSON(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a;}toCSSString(){return "rgba("+Math.round(255*this.r)+", "+Math.round(255*this.g)+", "+Math.round(255*this.b)+", "+this.a+")"}}r.registerType("RGBA",m);class u extends l{constructor(e=0,t=0,a=0,i=1){if(super(),e instanceof Float32Array)this.__data=e;else if(e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,4);}else this.__data=new Float32Array(4),"string"==typeof e?e.startsWith("#")?this.setFromHex(e):this.setFromCSSColorName(e):(this.__data[0]=e,this.__data[1]=t,this.__data[2]=a,this.__data[3]=i);}get r(){return this.__data[0]}set r(e){this.__data[0]=e;}get g(){return this.__data[1]}set g(e){this.__data[1]=e;}get b(){return this.__data[2]}set b(e){this.__data[2]=e;}get a(){return this.__data[3]}set a(e){this.__data[3]=e;}set(e,t,a,i=1){this.r=e,this.g=t,this.b=a,this.a=i;}setFromOther(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a;}setFromScalarArray(e){this.r=e[0],this.g=e[1],this.b=e[2],this.a=4==e.length?e[3]:1;}getAsRGBArray(){return [255*this.r,255*this.g,255*this.b]}getAsRGBDict(){return {r:255*this.r,g:255*this.g,b:255*this.b}}setFromRGB(e,t,a,i){this.r=e/255,this.g=t/255,this.b=a/255,this.a=i?i/255:1;}setFromRGBArray(e){this.r=e[0]/255,this.g=e[1]/255,this.b=e[2]/255,this.a=4==e.length?e[3]/255:1;}setFromRGBDict(e){this.r=e.r/255,this.g=e.g/255,this.b=e.b/255,this.a=4==e.a?e.a/255:1;}setFromHex(e){const t=function(e){const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t?{r:parseInt(t[1],16),g:parseInt(t[2],16),b:parseInt(t[3],16)}:null}(e);t?this.setFromRGB(t.r,t.g,t.b):console.warn("Invalid hex code:"+e);}setFromCSSColorName(e){e.startsWith("#")?this.setFromHex(e):this.setFromHex((e=>{const t={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4","indianred ":"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"};return void 0!==t[e.toLowerCase()]&&t[e.toLowerCase()]})(e));}toHex(){function e(e){const t=Math.round(255*e).toString(16);return 1==t.length?"0"+t:t}return "#"+e(this.r)+e(this.g)+e(this.b)}equal(e){return this.r==e.r&&this.g==e.g&&this.b==e.b&&this.a==e.a}notequals(e){return this.r!=e.r&&this.g!=e.g&&this.b!=e.b&&this.a!=e.a}approxEqual(e,t=Number.EPSILON){return Math.abs(this.r-e.r)<t&&Math.abs(this.g-e.g)<t&&Math.abs(this.b-e.b)<t&&Math.abs(this.a-e.a)<t}add(e){return new u(this.r+e.r,this.g+e.g,this.b+e.b,this.a+e.a)}subtract(e){return new u(this.r-e.r,this.g-e.g,this.b-e.b,this.a-e.a)}scale(e){return new u(this.r*e,this.g*e,this.b*e,this.a*e)}scaleInPlace(e){this.r*=e,this.g*=e,this.b*=e,this.a*=e;}applyGamma(e){this.set(Math.pow(this.r,e),Math.pow(this.g,e),Math.pow(this.b,e),this.a);}toLinear(e=2.2){return new u(Math.pow(this.r,e),Math.pow(this.g,e),Math.pow(this.b,e),this.a)}toGamma(e=2.2){return new u(Math.pow(this.r,1/e),Math.pow(this.g,1/e),Math.pow(this.b,1/e),this.a)}luminance(){return .2126*this.r+.7152*this.g+.0722*this.b}lerp(e,t){const a=this.r,i=this.g,s=this.b,n=this.a;return new u(a+t*(e.r-a),i+t*(e.g-i),s+t*(e.b-s),n+t*(e.a-n))}static random(e=0,t=!1){return e>0?new u(e+Math.random()*(1-e),e+Math.random()*(1-e),e+Math.random()*(1-e),t?e+Math.random()*(1-e):1):e<0?new u(Math.random()*(1+e),Math.random()*(1+e),Math.random()*(1+e),t?Math.random()*(1+e):1):new u(Math.random(),Math.random(),Math.random(),t?Math.random():1)}clone(){return new u(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}asArray(){return this.__data}as3ComponentArray(){return [this.__data[0],this.__data[1],this.__data[2]]}static create(...e){return new u(...e)}static createFromFloat32Buffer(e,t=0){return new u(e,4*t)}static numElements(){return 4}toJSON(){return {r:this.r,g:this.g,b:this.b,a:this.a}}fromJSON(e){this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a;}toCSSString(){return "rgba("+Math.round(255*this.r)+", "+Math.round(255*this.g)+", "+Math.round(255*this.b)+", "+this.a+")"}}r.registerType("Color",u);class p extends l{constructor(e=0,t=0,a=0,i=0){if(super(),isNaN(i))switch(i){case"XYZ":this.order=0;break;case"YZX":this.order=1;break;case"ZXY":this.order=2;break;case"XZY":this.order=3;break;case"ZYX":this.order=4;break;case"YXZ":this.order=5;break;default:throw new Error("Invalid Euler Angles Order:"+i)}else this.order=i;if(e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,4);}else this.__data=new Float32Array(3),this.__data[0]=e,this.__data[1]=t,this.__data[2]=a;}get x(){return this.__data[0]}set x(e){this.__data[0]=e;}get y(){return this.__data[1]}set y(e){this.__data[1]=e;}get z(){return this.__data[2]}set z(e){this.__data[2]=e;}set(e,t,a){this.__data[0]=e,this.__data[1]=t,this.__data[2]=a;}}r.registerType("EulerAngles",p);class g extends l{constructor(e=1,t=0,a=0,i=0,s=1,n=0,l=0,r=0,o=1){if(super(),e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,9);}else this.__data=new Float32Array(9),this.set(e,t,a,i,s,n,l,r,o);}get m00(){return this.__data[0]}set m00(e){this.__data[0]=e;}get m01(){return this.__data[1]}set m01(e){this.__data[1]=e;}get m02(){return this.__data[2]}set m02(e){this.__data[2]=e;}get m10(){return this.__data[3]}set m10(e){this.__data[3]=e;}get m11(){return this.__data[4]}set m11(e){this.__data[4]=e;}get m12(){return this.__data[5]}set m12(e){this.__data[5]=e;}get m20(){return this.__data[6]}set m20(e){this.__data[6]=e;}get m21(){return this.__data[7]}set m21(e){this.__data[7]=e;}get m22(){return this.__data[8]}set m22(e){this.__data[8]=e;}get xAxis(){return d.createFromFloat32Buffer(this.__data.buffer,0)}set xAxis(e){this.xAxis.set(e.x,e.y,e.z);}get yAxis(){return d.createFromFloat32Buffer(this.__data.buffer,3)}set yAxis(e){this.yAxis.set(e.x,e.y,e.z);}get zAxis(){return d.createFromFloat32Buffer(this.__data.buffer,6)}set zAxis(e){this.zAxis.set(e.x,e.y,e.z);}set(e=1,t=0,a=0,i=0,s=1,n=0,l=0,r=0,o=1){this.__data[0]=e,this.__data[1]=t,this.__data[2]=a,this.__data[3]=i,this.__data[4]=s,this.__data[5]=n,this.__data[6]=l,this.__data[7]=r,this.__data[8]=o;}setIdentity(){this.set();}setFromMat(e){this.__data[0]=e.m00,this.__data[1]=e.m01,this.__data[2]=e.m02,this.__data[3]=e.m10,this.__data[4]=e.m11,this.__data[5]=e.m12,this.__data[6]=e.m20,this.__data[7]=e.m21,this.__data[8]=e.m22;}setFromDirectionAndUpvector(e,t){const a=e,i=a.length();if(i<Number.EPSILON)return void this.setIdentity();a.scaleInPlace(1/i);const s=t.cross(a),n=s.length();n>Number.EPSILON&&s.scaleInPlace(1/n);const l=a.cross(s),r=l.length();r>Number.EPSILON&&l.scaleInPlace(1/r),this.set(s.x,s.y,s.z,l.x,l.y,l.z,a.x,a.y,a.z);}inverse(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3],s=this.__data[4],n=this.__data[5],l=this.__data[6],r=this.__data[7],o=this.__data[8],d=o*s-n*r,h=-o*i+n*l,c=r*i-s*l,m=e*d+t*h+a*c;return m?(m=1/m,new g(d*m,(-o*t+a*r)*m,(n*t-a*s)*m,h*m,(o*e-a*l)*m,(-n*e+a*i)*m,c*m,(-r*e+t*l)*m,(s*e-t*i)*m)):(console.warn("Unable to invert Mat3"),null)}invertInPlace(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3],s=this.__data[4],n=this.__data[5],l=this.__data[6],r=this.__data[7],o=this.__data[8],d=o*s-n*r,h=-o*i+n*l,c=r*i-s*l,m=e*d+t*h+a*c;return m?(m=1/m,this.set(d*m,(-o*t+a*r)*m,(n*t-a*s)*m,h*m,(o*e-a*l)*m,(-n*e+a*i)*m,c*m,(-r*e+t*l)*m,(s*e-t*i)*m),!0):(console.warn("Unable to invert Mat3"),!1)}transpose(){return g(this.__data[0],this.__data[3],this.__data[6],this.__data[1],this.__data[4],this.__data[7],this.__data[2],this.__data[5],this.__data[8])}transposeInPlace(){const e=this.__data[1],t=this.__data[2],a=this.__data[5];this.__data[1]=this.__data[3],this.__data[2]=this.__data[6],this.__data[3]=e,this.__data[5]=this.__data[7],this.__data[6]=t,this.__data[7]=a;}transformVec3(e){return new d(this.__data[0]*e.x+this.__data[1]*e.y+this.__data[2]*e.z,this.__data[3]*e.x+this.__data[4]*e.y+this.__data[5]*e.z,this.__data[6]*e.x+this.__data[7]*e.y+this.__data[8]*e.z)}clone(){return new g(this.__data[0],this.__data[1],this.__data[2],this.__data[3],this.__data[4],this.__data[5],this.__data[6],this.__data[7],this.__data[8],this.__data[9])}static create(...e){return new g(...e)}static createFromFloat32Buffer(e,t=0){return new g(e,4*t)}toJSON(){return this.__data}fromJSON(e){this.__data=new Float32Array(e);}toString(){return this.toJSON().toString()}}r.registerType("Mat3",g);class _ extends l{constructor(e=1,t=0,a=0,i=0,s=0,n=1,l=0,r=0,o=0,d=0,h=1,c=0,m=0,u=0,b=0,p=1){if(super(),e instanceof Float32Array)this.__data=e;else if(e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,16);}else this.__data=new Float32Array(16),this.set(e,t,a,i,s,n,l,r,o,d,h,c,m,u,b,p);}get m00(){return this.__data[0]}set m00(e){this.__data[0]=e;}get m01(){return this.__data[1]}set m01(e){this.__data[1]=e;}get m02(){return this.__data[2]}set m02(e){this.__data[2]=e;}get m03(){return this.__data[3]}set m03(e){this.__data[3]=e;}get m10(){return this.__data[4]}set m10(e){this.__data[4]=e;}get m11(){return this.__data[5]}set m11(e){this.__data[5]=e;}get m12(){return this.__data[6]}set m12(e){this.__data[6]=e;}get m13(){return this.__data[7]}set m13(e){this.__data[7]=e;}get m20(){return this.__data[8]}set m20(e){this.__data[8]=e;}get m21(){return this.__data[9]}set m21(e){this.__data[9]=e;}get m22(){return this.__data[10]}set m22(e){this.__data[10]=e;}get m23(){return this.__data[11]}set m23(e){this.__data[11]=e;}get m30(){return this.__data[12]}set m30(e){this.__data[12]=e;}get m31(){return this.__data[13]}set m31(e){this.__data[13]=e;}get m32(){return this.__data[14]}set m32(e){this.__data[14]=e;}get m33(){return this.__data[15]}set m33(e){this.__data[15]=e;}get xAxis(){return d.createFromFloat32Buffer(this.__data.buffer,0)}set xAxis(e){this.xAxis.set(e.x,e.y,e.z);}get yAxis(){return d.createFromFloat32Buffer(this.__data.buffer,4)}set yAxis(e){this.yAxis.set(e.x,e.y,e.z);}get zAxis(){return d.createFromFloat32Buffer(this.__data.buffer,8)}set zAxis(e){this.zAxis.set(e.x,e.y,e.z);}get translation(){return d.createFromFloat32Buffer(this.__data.buffer,12)}set translation(e){this.translation.set(e.x,e.y,e.z);}set(e=1,t=0,a=0,i=0,s=0,n=1,l=0,r=0,o=0,d=0,h=1,c=0,m=0,u=0,b=0,p=1){this.__data[0]=e,this.__data[1]=t,this.__data[2]=a,this.__data[3]=i,this.__data[4]=s,this.__data[5]=n,this.__data[6]=l,this.__data[7]=r,this.__data[8]=o,this.__data[9]=d,this.__data[10]=h,this.__data[11]=c,this.__data[12]=m,this.__data[13]=u,this.__data[14]=b,this.__data[15]=p;}setIdentity(){this.set();}setDataArray(e){this.__data=e;}setFromMat4(e){this.__data[0]=e.m00,this.__data[1]=e.m01,this.__data[2]=e.m02,this.__data[3]=e.m03,this.__data[4]=e.m10,this.__data[5]=e.m11,this.__data[6]=e.m12,this.__data[7]=e.m13,this.__data[8]=e.m20,this.__data[9]=e.m21,this.__data[10]=e.m22,this.__data[11]=e.m23,this.__data[12]=e.m30,this.__data[13]=e.m31,this.__data[14]=e.m32,this.__data[15]=e.m33;}toMat3(e){return new g(this.__data[0],this.__data[1],this.__data[2],this.__data[4],this.__data[5],this.__data[6],this.__data[8],this.__data[9],this.__data[10])}transposeInPlace(){const e=this.__data[1],t=this.__data[2],a=this.__data[3],i=this.__data[6],s=this.__data[7],n=this.__data[11];this.__data[1]=this.__data[4],this.__data[2]=this.__data[8],this.__data[3]=this.__data[12],this.__data[4]=e,this.__data[6]=this.__data[9],this.__data[7]=this.__data[13],this.__data[8]=t,this.__data[9]=i,this.__data[11]=this.__data[14],this.__data[12]=a,this.__data[13]=s,this.__data[14]=n;}transpose(){return new _(this.__data[0],this.__data[4],this.__data[8],this.__data[12],this.__data[1],this.__data[5],this.__data[9],this.__data[13],this.__data[2],this.__data[6],this.__data[10],this.__data[14],this.__data[3],this.__data[7],this.__data[11],this.__data[15])}inverse(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3],s=this.__data[4],n=this.__data[5],l=this.__data[6],r=this.__data[7],o=this.__data[8],d=this.__data[9],h=this.__data[10],c=this.__data[11],m=this.__data[12],u=this.__data[13],b=this.__data[14],p=this.__data[15],g=e*n-t*s,Z=e*l-a*s,G=e*r-i*s,X=t*l-a*n,y=t*r-i*n,f=a*r-i*l,V=o*u-d*m,x=o*b-h*m,I=o*p-c*m,R=d*b-h*u,S=d*p-c*u,W=h*p-c*b;let L=g*W-Z*S+G*R+X*I-y*x+f*V;return L?(L=1/L,new _((n*W-l*S+r*R)*L,(a*S-t*W-i*R)*L,(u*f-b*y+p*X)*L,(h*y-d*f-c*X)*L,(l*I-s*W-r*x)*L,(e*W-a*I+i*x)*L,(b*G-m*f-p*Z)*L,(o*f-h*G+c*Z)*L,(s*S-n*I+r*V)*L,(t*I-e*S-i*V)*L,(m*y-u*G+p*g)*L,(d*G-o*y-c*g)*L,(n*x-s*R-l*V)*L,(e*R-t*x+a*V)*L,(u*Z-m*X-b*g)*L,(o*X-d*Z+h*g)*L)):(console.warn("Unable to invert Mat4"),null)}invertInPlace(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3],s=this.__data[4],n=this.__data[5],l=this.__data[6],r=this.__data[7],o=this.__data[8],d=this.__data[9],h=this.__data[10],c=this.__data[11],m=this.__data[12],u=this.__data[13],b=this.__data[14],p=this.__data[15],g=e*n-t*s,_=e*l-a*s,Z=e*r-i*s,G=t*l-a*n,X=t*r-i*n,y=a*r-i*l,f=o*u-d*m,V=o*b-h*m,x=o*p-c*m,I=d*b-h*u,R=d*p-c*u,S=h*p-c*b;let W=g*S-_*R+Z*I+G*x-X*V+y*f;return W?(W=1/W,this.set((n*S-l*R+r*I)*W,(a*R-t*S-i*I)*W,(u*y-b*X+p*G)*W,(h*X-d*y-c*G)*W,(l*x-s*S-r*V)*W,(e*S-a*x+i*V)*W,(b*Z-m*y-p*_)*W,(o*y-h*Z+c*_)*W,(s*R-n*x+r*f)*W,(t*x-e*R-i*f)*W,(m*X-u*Z+p*g)*W,(d*Z-o*X-c*g)*W,(n*V-s*I-l*f)*W,(e*I-t*V+a*f)*W,(u*_-m*G-b*g)*W,(o*G-d*_+h*g)*W),!0):(console.warn("Unable to invert Mat4"),!1)}setInverse(e){const t=e.__data[0],a=e.__data[1],i=e.__data[2],s=e.__data[3],n=e.__data[4],l=e.__data[5],r=e.__data[6],o=e.__data[7],d=e.__data[8],h=e.__data[9],c=e.__data[10],m=e.__data[11],u=e.__data[12],b=e.__data[13],p=e.__data[14],g=e.__data[15],_=t*l-a*n,Z=t*r-i*n,G=t*o-s*n,X=a*r-i*l,y=a*o-s*l,f=i*o-s*r,V=d*b-h*u,x=d*p-c*u,I=d*g-m*u,R=h*p-c*b,S=h*g-m*b,W=c*g-m*p;let L=_*W-Z*S+G*R+X*I-y*x+f*V;if(!L)throw new Error("Unable to invert Mat4");L=1/L,this.set((l*W-r*S+o*R)*L,(i*S-a*W-s*R)*L,(b*f-p*y+g*X)*L,(c*y-h*f-m*X)*L,(r*I-n*W-o*x)*L,(t*W-i*I+s*x)*L,(p*G-u*f-g*Z)*L,(d*f-c*G+m*Z)*L,(n*S-l*I+o*V)*L,(a*I-t*S-s*V)*L,(u*y-b*G+g*_)*L,(h*G-d*y-m*_)*L,(l*x-n*R-r*V)*L,(t*R-a*x+i*V)*L,(b*Z-u*X-p*_)*L,(d*X-h*Z+c*_)*L);}multiply(e){const t=this.__data[0],a=this.__data[1],i=this.__data[2],s=this.__data[3],n=this.__data[4],l=this.__data[5],r=this.__data[6],o=this.__data[7],d=this.__data[8],h=this.__data[9],c=this.__data[10],m=this.__data[11],u=this.__data[12],b=this.__data[13],p=this.__data[14],g=this.__data[15],Z=e.asArray();let G=Z[0],X=Z[1],y=Z[2],f=Z[3];const V=new _;return V.m00=G*t+X*n+y*d+f*u,V.m01=G*a+X*l+y*h+f*b,V.m02=G*i+X*r+y*c+f*p,V.m03=G*s+X*o+y*m+f*g,G=Z[4],X=Z[5],y=Z[6],f=Z[7],V.m10=G*t+X*n+y*d+f*u,V.m11=G*a+X*l+y*h+f*b,V.m12=G*i+X*r+y*c+f*p,V.m13=G*s+X*o+y*m+f*g,G=Z[8],X=Z[9],y=Z[10],f=Z[11],V.m20=G*t+X*n+y*d+f*u,V.m21=G*a+X*l+y*h+f*b,V.m22=G*i+X*r+y*c+f*p,V.m23=G*s+X*o+y*m+f*g,G=Z[12],X=Z[13],y=Z[14],f=Z[15],V.m30=G*t+X*n+y*d+f*u,V.m31=G*a+X*l+y*h+f*b,V.m32=G*i+X*r+y*c+f*p,V.m33=G*s+X*o+y*m+f*g,V}multiplyInPlace(e){const t=this.asArray(),a=t[0],i=t[1],s=t[2],n=t[3],l=t[4],r=t[5],o=t[6],d=t[7],h=t[8],c=t[9],m=t[10],u=t[11],b=t[12],p=t[13],g=t[14],_=t[15],Z=e.asArray();let G=Z[0],X=Z[1],y=Z[2],f=Z[3];return this.m00=G*a+X*l+y*h+f*b,this.m01=G*i+X*r+y*c+f*p,this.m02=G*s+X*o+y*m+f*g,this.m03=G*n+X*d+y*u+f*_,G=Z[4],X=Z[5],y=Z[6],f=Z[7],this.m10=G*a+X*l+y*h+f*b,this.m11=G*i+X*r+y*c+f*p,this.m12=G*s+X*o+y*m+f*g,this.m13=G*n+X*d+y*u+f*_,G=Z[8],X=Z[9],y=Z[10],f=Z[11],this.m20=G*a+X*l+y*h+f*b,this.m21=G*i+X*r+y*c+f*p,this.m22=G*s+X*o+y*m+f*g,this.m23=G*n+X*d+y*u+f*_,G=Z[12],X=Z[13],y=Z[14],f=Z[15],this.m30=G*a+X*l+y*h+f*b,this.m31=G*i+X*r+y*c+f*p,this.m32=G*s+X*o+y*m+f*g,this.m33=G*n+X*d+y*u+f*_,this}postmultiplyInPlace(e){const t=e.asArray(),a=t[0],i=t[1],s=t[2],n=t[3],l=t[4],r=t[5],o=t[6],d=t[7],h=t[8],c=t[9],m=t[10],u=t[11],b=t[12],p=t[13],g=t[14],_=t[15],Z=this.asArray();let G=Z[0],X=Z[1],y=Z[2],f=Z[3];return this.m00=G*a+X*l+y*h+f*b,this.m01=G*i+X*r+y*c+f*p,this.m02=G*s+X*o+y*m+f*g,this.m03=G*n+X*d+y*u+f*_,G=Z[4],X=Z[5],y=Z[6],f=Z[7],this.m10=G*a+X*l+y*h+f*b,this.m11=G*i+X*r+y*c+f*p,this.m12=G*s+X*o+y*m+f*g,this.m13=G*n+X*d+y*u+f*_,G=Z[8],X=Z[9],y=Z[10],f=Z[11],this.m20=G*a+X*l+y*h+f*b,this.m21=G*i+X*r+y*c+f*p,this.m22=G*s+X*o+y*m+f*g,this.m23=G*n+X*d+y*u+f*_,G=Z[12],X=Z[13],y=Z[14],f=Z[15],this.m30=G*a+X*l+y*h+f*b,this.m31=G*i+X*r+y*c+f*p,this.m32=G*s+X*o+y*m+f*g,this.m33=G*n+X*d+y*u+f*_,this}translateInPlace(e){const t=this.__data,a=e.x,i=e.y,s=e.z;return t[12]=t[0]*a+t[4]*i+t[8]*s+t[12],t[13]=t[1]*a+t[5]*i+t[9]*s+t[13],t[14]=t[2]*a+t[6]*i+t[10]*s+t[14],t[15]=t[3]*a+t[7]*i+t[11]*s+t[15],this}setLookAt(e,t,a){const i=e.subtract(t),s=i.length();if(s<Number.EPSILON)return void this.setIdentity();i.scaleInPlace(1/s);const n=a.cross(i),l=n.length();l>Number.EPSILON&&n.scaleInPlace(1/l);const r=i.cross(n),o=r.length();o>Number.EPSILON&&r.scaleInPlace(1/o),this.set(n.x,n.y,n.z,0,r.x,r.y,r.z,0,i.x,i.y,i.z,0,e.x,e.y,e.z,1);}setRotation(e,t){const a=e.length();if(Math.abs(a)<Number.EPSILON)return null;const i=e.x/a,s=e.y/a,n=e.z/a,l=Math.sin(t),r=Math.cos(t),o=1-r,d=this.__data;return d[0]=i*i*o+r,d[1]=s*i*o+n*l,d[2]=n*i*o-s*l,d[3]=0,d[4]=i*s*o-n*l,d[5]=s*s*o+r,d[6]=n*s*o+i*l,d[7]=0,d[8]=i*n*o+s*l,d[9]=s*n*o-i*l,d[10]=n*n*o+r,d[11]=0,d[12]=0,d[13]=0,d[14]=0,d[15]=1,this}setXRotation(e){const t=Math.sin(e),a=Math.cos(e),i=this.__data;return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=a,i[6]=t,i[7]=0,i[8]=0,i[9]=-t,i[10]=a,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setYRotation(e){const t=Math.sin(e),a=Math.cos(e),i=this.__data;return i[0]=a,i[1]=0,i[2]=-t,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=t,i[9]=0,i[10]=a,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setZRotation(e){const t=Math.sin(e),a=Math.cos(e),i=this.__data;return i[0]=a,i[1]=t,i[2]=0,i[3]=0,i[4]=-t,i[5]=a,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}transformVec4(e){const t=this.__data,a=e.x,i=e.y,s=e.z,n=e.t;return new Vec4(t[0]*a+t[4]*i+t[8]*s+t[12]*n,t[1]*a+t[5]*i+t[9]*s+t[13]*n,t[2]*a+t[6]*i+t[10]*s+t[14]*n,t[3]*a+t[7]*i+t[11]*s+t[15]*n)}transformVec3(e){const t=this.__data,a=e.x,i=e.y,s=e.z;return new d(t[0]*a+t[4]*i+t[8]*s+t[12],t[1]*a+t[5]*i+t[9]*s+t[13],t[2]*a+t[6]*i+t[10]*s+t[14])}rotateVec3(e){const t=this.__data,a=e.x,i=e.y,s=e.z;return new d(t[0]*a+t[4]*i+t[8]*s,t[1]*a+t[5]*i+t[9]*s,t[2]*a+t[6]*i+t[10]*s)}setPerspectiveMatrix(e,t,a,i){const s=Math.tan(.5*Math.PI-.5*e),n=1/(a-i);this.set(s/t,0,0,0,0,s,0,0,0,0,(a+i)*n,-1,0,0,a*i*n*2,0);}setOrthographicMatrix(e,t,a,i,s,n){const l=1/(e-t),r=1/(a-i),o=1/(s-n);this.set(-2*l,0,0,0,0,-2*r,0,0,0,0,2*o,0,(e+t)*l,(i+a)*r,(n+s)*o,1);}setScale(e,t,a){e instanceof d?this.set(e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1):this.set(e,0,0,0,0,t,0,0,0,0,a,0,0,0,0,1);}setFromMat3x4Array(e){this.set(e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,e[9],e[10],e[11],1);}static createFromFloat32Buffer(e,t=0){return new _(e,4*t)}clone(){return new _(this.__data[0],this.__data[1],this.__data[2],this.__data[3],this.__data[4],this.__data[5],this.__data[6],this.__data[7],this.__data[8],this.__data[9],this.__data[10],this.__data[11],this.__data[12],this.__data[13],this.__data[14],this.__data[15])}static create(...e){return new _(...e)}toJSON(){return this.__data}fromJSON(e){this.__data=new Float32Array(e);}}r.registerType("Mat4",_);class Z extends l{constructor(e=0,t=0,a=0,i=1){if(super(),e instanceof ArrayBuffer){const a=e,i=t;this.__data=new Float32Array(a,i,4);}else if(this.__data=new Float32Array(4),"object"==typeof e){this.__data[0]=0,this.__data[1]=0,this.__data[2]=0,this.__data[3]=1;for(const t in e)Array.isArray(e[t])?this[t].call(this,...e[t]):this[t].call(this,e[t]);}else this.__data[0]=e,this.__data[1]=t,this.__data[2]=a,this.__data[3]=i;}get x(){return this.__data[0]}set x(e){this.__data[0]=e;}get y(){return this.__data[1]}set y(e){this.__data[1]=e;}get z(){return this.__data[2]}set z(e){this.__data[2]=e;}get w(){return this.__data[3]}set w(e){this.__data[3]=e;}set(e,t,a,i){this.__data[0]=e,this.__data[1]=t,this.__data[2]=a,this.__data[3]=i;}setDataArray(e){this.__data=e;}setFromOther(e){this.__data[0]=e.x,this.__data[1]=e.y,this.__data[2]=e.z,this.__data[3]=e.w;}setFromEulerAngles(e){const t=new d;switch(e.order){case 0:t.set(e.x,-e.y,e.z);break;case 1:t.set(e.y,-e.z,e.x);break;case 2:t.set(e.z,-e.x,e.y);break;case 3:t.set(e.x,e.z,e.y);break;case 4:t.set(e.z,e.y,e.x);break;case 5:t.set(e.y,e.x,e.z);break;default:throw new Error("sdrty")}const a=.5*t.x,i=.5*t.y,s=.5*t.z,n=Math.cos(a),l=Math.cos(i),r=Math.cos(s),o=Math.sin(a),h=Math.sin(i),c=Math.sin(s),m=n*r,u=n*c,b=o*r,p=o*c,g=l*b-h*u,_=l*p+h*m,Z=l*u-h*b;switch(this.w=l*m+h*p,e.order){case 0:this.x=g,this.y=-_,this.z=Z;break;case 1:this.x=Z,this.y=g,this.z=-_;break;case 2:this.x=-_,this.y=Z,this.z=g;break;case 3:this.x=g,this.y=Z,this.z=_;break;case 4:this.x=Z,this.y=_,this.z=g;break;case 5:this.x=_,this.y=g,this.z=Z;break;default:throw new Error("sdrty")}}toEulerAngles(e){const t=new d;switch(e){case 0:t.set(this.z,this.x,this.y);break;case 1:t.set(this.x,this.y,this.z);break;case 2:t.set(this.y,this.z,this.x);break;case 3:t.set(this.y,-this.x,this.z);break;case 4:t.set(this.x,-this.z,this.y);break;case 5:t.set(this.z,-this.y,this.x);break;default:throw new Error("Invalid rotation order:"+e)}const a=new d,i=t.x*t.y+t.z*this.w;if(i>.49999)a.y=2*Math.atan2(t.x,this.w),a.z=.5*Math.PI,a.x=0;else if(i<-.49999)a.y=-2*Math.atan2(t.x,this.w),a.z=-.5*Math.PI,a.x=0;else {const e=t.x*t.x,s=t.y*t.y,n=t.z*t.z;a.y=Math.atan2(2*t.y*this.w-2*t.x*t.z,1-2*s-2*n),a.z=Math.asin(2*i),a.x=Math.atan2(2*t.x*this.w-2*t.y*t.z,1-2*e-2*n);}switch(e){case 0:return new p(a.y,a.z,a.x,e);case 1:return new p(a.x,a.y,a.z,e);case 2:return new p(a.z,a.x,a.y,e);case 3:return new p(-a.y,a.x,a.z,e);case 4:return new p(a.x,a.z,-a.y,e);case 5:return new p(a.z,-a.y,a.x,e)}}setFromAxisAndAngle(e,t){const a=t/2,i=e.normalize().scale(Math.sin(a));this.set(i.x,i.y,i.z,Math.cos(a));}setFromDirectionAndUpvector(e,t){const a=new g;a.setFromDirectionAndUpvector(e,t),this.setFromMat3(a);}setFrom2Vectors(e,t){e.normalize(),t.normalize();const a=e.cross(t),i=e.dot(t),s=Math.sqrt(2*(1+i));this.set(a.x/s,a.y/s,a.z/s,s/2),this.normalizeInPlace();}setFromMat3(e){const t=e.__data[0]+e.__data[4]+e.__data[8];let a;if(t>0)a=Math.sqrt(t+1),this.__data[3]=.5*a,a=.5/a,this.__data[0]=(e.__data[5]-e.__data[7])*a,this.__data[1]=(e.__data[6]-e.__data[2])*a,this.__data[2]=(e.__data[1]-e.__data[3])*a;else {let t=0;e.__data[4]>e.__data[0]&&(t=1),e.__data[8]>e.__data[3*t+t]&&(t=2);const i=(t+1)%3,s=(t+2)%3;a=Math.sqrt(e.__data[3*t+t]-e.__data[3*i+i]-e.__data[3*s+s]+1),this.__data[t]=.5*a,a=.5/a,this.__data[3]=(e.__data[3*i+s]-e.__data[3*s+i])*a,this.__data[i]=(e.__data[3*i+t]+e.__data[3*t+i])*a,this.__data[s]=(e.__data[3*s+t]+e.__data[3*t+s])*a;}this.normalizeInPlace();}setFromMat4(e){const t=e.__data[0]+e.__data[5]+e.__data[10];let a;if(t>0)a=Math.sqrt(t+1),this.__data[3]=.5*a,a=.5/a,this.__data[0]=(e.__data[6]-e.__data[9])*a,this.__data[1]=(e.__data[8]-e.__data[2])*a,this.__data[2]=(e.__data[1]-e.__data[4])*a;else {let t=0;e.__data[5]>e.__data[0]&&(t=1),e.__data[10]>e.__data[4*t+t]&&(t=2);const i=(t+1)%3,s=(t+2)%3;a=Math.sqrt(e.__data[4*t+t]-e.__data[4*i+i]-e.__data[4*s+s]+1),this.__data[t]=.5*a,a=.5/a,this.__data[3]=(e.__data[4*i+s]-e.__data[4*s+i])*a,this.__data[i]=(e.__data[4*i+t]+e.__data[4*t+i])*a,this.__data[s]=(e.__data[4*s+t]+e.__data[4*t+s])*a;}this.normalizeInPlace();}isIdentity(){return this.getAngle()<Number.EPSILON}getAngle(){return 2*Math.acos(this.w)}equal(e){return this.x==e.x&&this.y==e.y&&this.z==e.z&&this.w==e.w}notequals(e){return this.x!=e.x&&this.y!=e.y&&this.z!=e.z&&this.w!=e.w}approxEqual(e,t=Number.EPSILON){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t&&Math.abs(this.z-e.z)<t&&Math.abs(this.w-e.w)<t}add(e){return new Z(this.x+e.x,this.y+e.y,this.z+e.z,this.w+e.w)}addInPlace(e){this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w;}subtract(e){return new Z(this.x-e.x,this.y-e.y,this.z-e.z,this.w-e.w)}scale(e){return new Z(this.x*e,this.y*e,this.z*e,this.w*e)}scaleInPlace(e){this.x*=e,this.y*=e,this.z*=e,this.w*=e;}length(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3];return Math.sqrt(e*e+t*t+a*a+i*i)}lengthSquared(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3];return e*e+t*t+a*a+i*i}normalize(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3];let s=e*e+t*t+a*a+i*i;return s<Number.EPSILON?new Z:(s=1/Math.sqrt(s),new Z(e*s,t*s,a*s))}normalizeInPlace(){const e=this.__data[0],t=this.__data[1],a=this.__data[2],i=this.__data[3];let s=e*e+t*t+a*a+i*i;s<Number.EPSILON||(s=1/Math.sqrt(s),this.set(e*s,t*s,a*s,i*s));}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}cross(e){const t=this.x,a=this.y,i=this.z,s=this.w,n=e.x,l=e.y,r=e.z,o=e.w;return new Z(a*r-i*l,i*o-s*r,s*n-t*o,t*l-a*n)}conjugate(){return new Z(-this.x,-this.y,-this.z,this.w)}inverse(){return this.conjugate()}alignWith(e){this.dot(e)<0&&this.set(-this.x,-this.y,-this.z,-this.w);}multiply(e){const t=this.__data[0],a=this.__data[1],i=this.__data[2],s=this.__data[3],n=e.__data[0],l=e.__data[1],r=e.__data[2],o=e.__data[3];return new Z(t*o+s*n+a*r-i*l,a*o+s*l+i*n-t*r,i*o+s*r+t*l-a*n,s*o-t*n-a*l-i*r)}multiplyInPlace(e){const t=this.__data[0],a=this.__data[1],i=this.__data[2],s=this.__data[3],n=e.__data[0],l=e.__data[1],r=e.__data[2],o=e.__data[3];this.set(t*o+s*n+a*r-i*l,a*o+s*l+i*n-t*r,i*o+s*r+t*l-a*n,s*o-t*n-a*l-i*r);}rotateVec3(e){const t=new Z(e.x,e.y,e.z,0),a=this.multiply(t).multiply(this.conjugate());return new d(a.x,a.y,a.z)}rotateX(e){e*=.5;const t=this.x,a=this.y,i=this.z,s=this.w,n=Math.sin(e),l=Math.cos(e);this.x=t*l+s*n,this.y=a*l+i*n,this.z=i*l-a*n,this.w=s*l-t*n;}rotateY(e){e*=.5;const t=this.x,a=this.y,i=this.z,s=this.w,n=Math.sin(e),l=Math.cos(e);this.x=t*l-i*n,this.y=a*l+s*n,this.z=i*l+t*n,this.w=s*l-a*n;}rotateZ(e){e*=.5;const t=this.x,a=this.y,i=this.z,s=this.w,n=Math.sin(e),l=Math.cos(e);this.x=t*l+a*n,this.y=a*l-t*n,this.z=i*l+s*n,this.w=s*l-i*n;}toMat3(){const e=this.x,t=this.y,a=this.z,i=this.w,s=e+e,n=t+t,l=a+a,r=e*s,o=t*s,d=t*n,h=a*s,c=a*n,m=a*l,u=i*s,b=i*n,p=i*l,_=new g;return _.__data[0]=1-d-m,_.__data[3]=o-p,_.__data[6]=h+b,_.__data[1]=o+p,_.__data[4]=1-r-m,_.__data[7]=c-u,_.__data[2]=h-b,_.__data[5]=c+u,_.__data[8]=1-r-d,_}getXaxis(){const e=this.x*this.y,t=this.x*this.z,a=this.y*this.y,i=this.y*this.w,s=this.z*this.z,n=this.z*this.w;return new d(1-2*(s+a),2*(e+n),2*(t-i))}getYaxis(){const e=this.x*this.x,t=this.x*this.y,a=this.x*this.w,i=this.y*this.z,s=this.z*this.z,n=this.z*this.w;return new d(2*(t-n),1-2*(s+e),2*(i+a))}getZaxis(){const e=this.x*this.x,t=this.x*this.z,a=this.x*this.w,i=this.y*this.y,s=this.y*this.z,n=this.y*this.w;new d;return new d(2*(n+t),2*(s-a),1-2*(i+e))}mirror(e){switch(e){case 0:return new Z(this.z,this.w,this.x,this.y);case 1:return new Z(-this.w,this.z,this.y,-this.x);case 2:return new Z(this.x,this.y,this.z,-this.w)}}toMat4(){const e=this.x,t=this.y,a=this.z,i=this.w,s=e+e,n=t+t,l=a+a,r=e*s,o=t*s,d=t*n,h=a*s,c=a*n,m=a*l,u=i*s,b=i*n,p=i*l,g=new _;return g.__data[0]=1-d-m,g.__data[4]=o-p,g.__data[8]=h+b,g.__data[1]=o+p,g.__data[5]=1-r-m,g.__data[9]=c-u,g.__data[2]=h-b,g.__data[6]=c+u,g.__data[10]=1-r-d,g}lerp(e,t){const a=new Z(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),this.z+t*(e.z-this.z),this.w+t*(e.w-this.w));return a.normalizeInPlace(),a}static create(...e){return new Z(...e)}static createFromFloat32Buffer(e,t=0){return new Z(e,4*t)}static numElements(){return 4}clone(){return new Z(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}toJSON(){return {x:this.x,y:this.y,z:this.z,w:this.w}}fromJSON(e){this.__data[0]=e.x,this.__data[1]=e.y,this.__data[2]=e.z,this.__data[3]=e.w,this.normalizeInPlace();}}r.registerType("Quat",Z);class G{constructor(e,t){this.start=e instanceof d?e:new d,this.dir=t instanceof d?t:new d;}closestPoint(e){const t=e.subtract(this.start).dot(this.dir);if(t<Number.EPSILON)return this.start;const a=t/this.dir.dot(this.dir);return this.start.add(this.dir.scale(a))}pointAtDist(e){return this.start.add(this.dir.scale(e))}intersectRayVector(e){const t=this.dir,a=e.dir,i=this.start.subtract(e.start),s=t.dot(t),n=t.dot(a),l=a.dot(a),r=t.dot(i),o=a.dot(i);if(0==s&&0==l)return this.start.distanceTo(e.start);if(0==s)return e.closestPoint(this.start);if(0==l)return this.closestPoint(e.start);const d=s*l-n*n;let h,c;return d<.001?(h=0,c=n>l?r/n:o/l):(h=(n*o-l*r)/d,c=(s*o-n*r)/d),[h,c]}intersectRayPlane(e){const t=this.start.subtract(e.start),a=e.dir.dot(this.dir),i=-e.dir.dot(t);if(Math.abs(a)<Number.PRECISION)return -1;const s=i/a;return s<-Number.PRECISION?-1:s}clone(){return new G(this.start.clone(),this.dir.clone())}static create(...e){return new G(...e)}toJSON(){return {start:this.start,dir:this.dir}}fromJSON(e){this.start.fromJSON(e.start),this.dir.fromJSON(e.dir);}toString(){return n(this.toJSON())}}r.registerType("Ray",G);new d(1,1,1);class X{constructor(e,t,a){if(e instanceof Float32Array)this.setFromFloat32Array(e);else {if(e instanceof d)this.tr=e;else {if(e instanceof Z&&null==t&&null==a)return this.tr=new d,this.ori=e,void(this.sc=new d(1,1,1));this.tr=new d;}this.ori=t instanceof Z?t:new Z,this.sc=a instanceof d?a:new d(1,1,1);}}set(e,t,a){this.tr=e,this.ori=t,a instanceof d&&(this.sc=a);}setFromOther(e){this.tr=e.tr,this.ori=e.ori,this.sc=e.sc;}isIdentity(){return this.tr.isNull()&&this.ori.isIdentity()&&this.sc.is111()}setLookAt(e,t,a){const i=e.subtract(t);if(i.length()<Number.EPSILON)throw new Error("Invalid dir");this.ori.setFromDirectionAndUpvector(i,a),this.tr=e;}multiply(e){let t=this.sc;return this.sc.x==this.sc.y&&this.sc.x==this.sc.z||(t=e.ori.rotateVec3(this.sc),Math.sign(t.x)!=Math.sign(this.sc.x)&&(t.x=-t.x),Math.sign(t.y)!=Math.sign(this.sc.y)&&(t.y=-t.y),Math.sign(t.z)!=Math.sign(this.sc.z)&&(t.z=-t.z)),new X(this.tr.add(this.ori.rotateVec3(t.multiply(e.tr))),this.ori.multiply(e.ori),t.multiply(e.sc))}inverse(){const e=new X;return e.ori=this.ori.inverse(),this.sc.x!=this.sc.y||this.sc.x!=this.sc.z?(e.sc=e.ori.rotateVec3(this.sc),Math.sign(e.sc.x)!=Math.sign(this.sc.x)&&(e.sc.x=-e.sc.x),Math.sign(e.sc.y)!=Math.sign(this.sc.y)&&(e.sc.y=-e.sc.y),Math.sign(e.sc.z)!=Math.sign(this.sc.z)&&(e.sc.z=-e.sc.z)):e.sc=this.sc.inverse(),e.tr=e.ori.rotateVec3(this.tr.negate().multiply(e.sc)),e}transformVec3(e){return this.tr.add(this.ori.rotateVec3(this.sc.multiply(e)))}toMat4(){const e=new _(this.sc.x,0,0,0,0,this.sc.y,0,0,0,0,this.sc.z,0,0,0,0,1),t=this.ori.toMat4(),a=new _;return a.translation=this.tr,a.multiply(t).multiply(e)}fromMat4(e){this.tr=e.translation,this.ori.setFromMat4(e);}setFromFloat32Array(e){if(7==e.length)return this.tr=new d(e.buffer,e.byteOffset),this.ori=new Z(e.buffer,e.byteOffset+12),void(this.sc=new d(1,1,1));if(8!=e.length)return 10==e.length?(this.tr=new d(e.buffer,e.byteOffset),this.ori=new Z(e.buffer,e.byteOffset+12),void(this.sc=new d(e.buffer,e.byteOffset+21))):void 0;{this.tr=new d(e.buffer,e.byteOffset),this.ori=new Z(e.buffer,e.byteOffset+12);const t=e[7];this.sc=new d(t,t,t);}}clone(){return new X(this.tr.clone(),this.ori.clone(),this.sc.clone())}static create(...e){return new X(...e)}toJSON(){const e={tr:this.tr.toJSON(),ori:this.ori.toJSON()};return this.sc.is111()||(e.sc=this.sc.toJSON()),e}fromJSON(e){this.tr.fromJSON(e.tr),this.ori.fromJSON(e.ori),e.sc&&this.sc.fromJSON(e.sc);}toString(){return n(this.toJSON())}}r.registerType("Xfo",X);class y{constructor(e,t){this.p0=e instanceof o?e:new o(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),this.p1=t instanceof o?t:new o(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);}set(e,t){this.p0=e,this.p1=t;}reset(){this.p0.x=Number.POSITIVE_INFINITY,this.p1.x=Number.NEGATIVE_INFINITY,this.p0.y=Number.POSITIVE_INFINITY,this.p1.y=Number.NEGATIVE_INFINITY;}isValid(){return this.p0.x!=Number.POSITIVE_INFINITY&&this.p1.x!=Number.NEGATIVE_INFINITY&&this.p0.y!=Number.POSITIVE_INFINITY&&this.p1.y!=Number.NEGATIVE_INFINITY}addPoint(e){(this.p0.x==Number.POSITIVE_INFINITY||e.x<this.p0.x)&&(this.p0.x=e.x),(this.p0.y==Number.POSITIVE_INFINITY||e.y<this.p0.y)&&(this.p0.y=e.y),(this.p1.y==Number.NEGATIVE_INFINITY||e.x>this.p1.x)&&(this.p1.x=e.x),(this.p1.y==Number.NEGATIVE_INFINITY||e.y>this.p1.y)&&(this.p1.y=e.y);}size(){return this.p1.subtract(this.p0)}diagonal(){return this.p1.subtract(this.p0)}center(){const e=this.p1.subtract(this.p0);return e.scaleInPlace(.5),e.addInPlace(this.p0),e}static create(...e){return new y(...e)}toJSON(){return {p0:this.p0.toJSON(),p1:this.p1.toJSON()}}toString(){return n(this.toJSON())}}r.registerType("Box2",y);class f extends l{constructor(e,t=0){super(),this.pos=e instanceof d?e:new d,this.radius=t;}clone(){return new Sphere(this.pos.clone(),this.radius)}intersectsBox(e){return e.intersectsSphere(this)}static create(...e){return new Sphere(...e)}toJSON(){return {pos:this.pos.toJSON(),radius:this.radius}}toString(){return n(this.toJSON())}}r.registerType("SphereType",f);class V{constructor(e,t){e instanceof Float32Array?this.setFromFloat32Array(e):(this.p0=e instanceof d?e:new d(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),this.p1=t instanceof d?t:new d(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY));}get min(){return this.p0}get max(){return this.p1}set(e,t){this.p0=e,this.p1=t;}reset(){this.p0.x=Number.POSITIVE_INFINITY,this.p1.x=Number.NEGATIVE_INFINITY,this.p0.y=Number.POSITIVE_INFINITY,this.p1.y=Number.NEGATIVE_INFINITY,this.p0.z=Number.POSITIVE_INFINITY,this.p1.z=Number.NEGATIVE_INFINITY;}isValid(){return this.p0.x!=Number.POSITIVE_INFINITY&&this.p1.x!=Number.NEGATIVE_INFINITY&&this.p0.y!=Number.POSITIVE_INFINITY&&this.p1.y!=Number.NEGATIVE_INFINITY&&this.p0.z!=Number.POSITIVE_INFINITY&&this.p1.z!=Number.NEGATIVE_INFINITY}addPoint(e){e.x!=Number.POSITIVE_INFINITY&&e.x!=Number.NEGATIVE_INFINITY&&(e.x<this.p0.x&&(this.p0.x=e.x),e.x>this.p1.x&&(this.p1.x=e.x)),e.y!=Number.POSITIVE_INFINITY&&e.y!=Number.NEGATIVE_INFINITY&&(e.y<this.p0.y&&(this.p0.y=e.y),e.y>this.p1.y&&(this.p1.y=e.y)),e.z!=Number.POSITIVE_INFINITY&&e.z!=Number.NEGATIVE_INFINITY&&(e.z<this.p0.z&&(this.p0.z=e.z),e.z>this.p1.z&&(this.p1.z=e.z));}addBox3(e,t){t?(this.addPoint(t.transformVec3(e.p0)),this.addPoint(t.transformVec3(new d(e.p0.x,e.p0.y,e.p1.z))),this.addPoint(t.transformVec3(new d(e.p0.x,e.p1.y,e.p0.z))),this.addPoint(t.transformVec3(new d(e.p1.x,e.p0.y,e.p0.z))),this.addPoint(t.transformVec3(new d(e.p0.x,e.p1.y,e.p1.z))),this.addPoint(t.transformVec3(new d(e.p1.x,e.p0.y,e.p1.z))),this.addPoint(t.transformVec3(new d(e.p1.x,e.p1.y,e.p0.z))),this.addPoint(t.transformVec3(e.p1))):(this.addPoint(e.p0),this.addPoint(e.p1));}size(){return this.p1.subtract(this.p0)}diagonal(){return this.p1.subtract(this.p0)}center(){const e=this.p1.subtract(this.p0);return e.scaleInPlace(.5),e.addInPlace(this.p0),e}toMat4(){const e=this.p1.x-this.p0.x,t=this.p1.y-this.p0.y,a=this.p1.z-this.p0.z;return new _(e,0,0,0,0,t,0,0,0,0,a,0,this.p0.x,this.p0.y,this.p0.z,1)}getBoundingSphere(){return new f(this.center(),.5*this.diagonal().length())}intersectsBox(e){return !(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return closestPoint.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,a;return e.normal.x>0?(t=e.normal.x*this.min.x,a=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,a=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,a+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,a+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,a+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,a+=e.normal.z*this.min.z),t<=-e.constant&&a>=-e.constant}clone(){return new V(this.p0.clone(),this.p1.clone())}static create(...e){return new V(...e)}static sizeInBytes(){return 24}toJSON(){return {p0:this.p0.toJSON(),p1:this.p1.toJSON()}}fromJSON(e){this.p0.fromJSON(e.p0),this.p1.fromJSON(e.p1);}loadBin(e,t){this.p0.loadBin(e,t),this.p0.loadBin(e,t+12);}setFromFloat32Array(e){this.p0=new d(e.buffer,e.byteOffset),this.p1=new d(e.buffer,e.byteOffset+12);}toString(){return n(this.toJSON())}}r.registerType("Box3",V);class x extends l{constructor(e,t=0){super(),this.normal=e instanceof d?e:new d,this.w=t;}set(e,t,a,i){this.normal.set(e,t,a),this.w=i;}divideScalar(e){this.normal.scaleInPlace(1/e),this.w/=e;}distanceToPoint(e){return e.dot(this.normal)+this.w}normalizeInPlace(){const e=1/this.normal.length();this.normal.scaleInPlace(e),this.w*=e;}clone(){return new Plane(this.normal.clone(),this.w)}static create(...e){return new Plane(...e)}toJSON(){return {normal:this.normal.toJSON(),w:this.w}}toString(){return n(this.toJSON())}}r.registerType("PlaneType",x);class I{constructor(e,t,a,i,s,n){this.planes=[e||new x,t||new x,a||new x,i||new x,s||new x,n||new x];}setFromMatrix(e){const t=e,a=this.planes;a[0].set(t.m03-t.m00,t.m13-t.m10,t.m23-t.m20,t.m33-t.m30),a[1].set(t.m03+t.m00,t.m13+t.m10,t.m23+t.m20,t.m33+t.m30),a[2].set(t.m03+t.m01,t.m13+t.m11,t.m23+t.m21,t.m33+t.m31),a[3].set(t.m03-t.m01,t.m13-t.m11,t.m23-t.m21,t.m33-t.m31),a[4].set(t.m03-t.m02,t.m13-t.m12,t.m23-t.m22,t.m33-t.m32),a[5].set(t.m03+t.m02,t.m13+t.m12,t.m23+t.m22,t.m33+t.m32),a.forEach(e=>e.normalizeInPlace());}intersectsBox(e){const t=new d,a=this.planes,{min:i,max:s}=e;for(let e=0;e<6;e++){const n=a[e];if(t.x=n.normal.x>0?s.x:i.x,t.y=n.normal.y>0?s.y:i.y,t.z=n.normal.z>0?s.z:i.z,n.distanceToPoint(t)<0)return !1}return !0}toJSON(){return {p0:this.p0.toJSON(),p1:this.p1.toJSON(),p2:this.p2.toJSON(),p3:this.p3.toJSON(),p4:this.p4.toJSON(),p5:this.p5.toJSON()}}fromJSON(e){this.p0.fromJSON(e.p0),this.p1.fromJSON(e.p1),this.p2.fromJSON(e.p2),this.p3.fromJSON(e.p3),this.p4.fromJSON(e.p4),this.p5.fromJSON(e.p5);}toString(){return n(this.toJSON())}}r.registerType("Frustum",I);var R=Object.freeze({__proto__:null,UInt8:0,SInt8:1,SInt16:3,UInt16:2,SInt32:5,UInt32:4,Float32:6,hashStr:s,JSON_stringify_fixedPrecision:n,AttrValue:l,Vec2:o,Vec3:d,Vec4:h,RGBA:m,Color:u,EulerAngles:p,Quat:Z,Ray:G,Mat3:g,Mat4:_,Xfo:X,Box2:y,Box3:V,Frustum:I,PlaneType:x,SphereType:f,typeRegistry:r});class S{constructor(e=!1){this.__slots=[],this.__toggledSignal=e,this.__toggled=!1,this.__data=null,this.connect=this.connect.bind(this),this.disconnect=this.disconnect.bind(this),this.emit=this.emit.bind(this);}connect(e){if(null==e)throw new Error("a function callback must be passed to Signal.connect");if(-1!=this.__slots.indexOf(e))return void console.warn("fn '"+e.name+"' already connected to Signal.");const t=this.__slots.length;return this.__slots[t]=e,this.__toggledSignal&&this.__toggled&&(this.__data?e(...this.__data):e()),t}disconnect(e){if(null==e)throw new Error("a function callback must be passed to Signal.disconnect");const t=[];if(this.__slots.forEach((function(a,i){a===e&&t.push(i);})),0!=t.length)for(const e of t)this.__slots[e]=void 0;else console.warn("callback :"+e.name+" was not connected to this signal:"+this.__name);}disconnectId(e){if(!this.__slots[e])throw new Error("Invalid ID");this.__slots[e]=void 0;}emit(...e){this.__toggledSignal&&(this.__toggled?console.warn("Toggled signals should only be fired once, or untoggled before re-firing.."):(this.__toggled=!0,this.__data=e));const t=this.__slots.length;for(let a=0;a<t;a++){const t=this.__slots[a];t&&t(...e);}}isToggled(){return this.__toggled}setToggled(e){this.__toggled=e,this.__data=void 0;}getNumConnections(){return this.__slots.length}untoggle(){this.__toggled=!1,this.__data=void 0;}}class W{constructor(e=0,t=0){this.root={x:0,y:0,w:e,h:t},this.resized=new S;}fit(e){if(0==e.length)return;let t=!1;this.root.w<e[0].w&&(this.root.w=e[0].w,t=!0),this.root.h<e[0].h&&(this.root.h=e[0].h,t=!0),t&&this.resized.emit(this.root.w,this.root.h);e.forEach(e=>{e.fit=this.__addBlock(e);});}__addBlock(e){const t=this.findNode(this.root,e.w,e.h);return t?this.splitNode(t,e.w,e.h):this.growNode(e.w,e.h)}addBlock(e){let t=!1;this.root.w<e.w&&(this.root.w=e.w,t=!0),this.root.h<e.h&&(this.root.h=e.h,t=!0),t&&this.resized.emit(this.root.w,this.root.h);const a=this.findNode(this.root,e.w,e.h);return a?this.splitNode(a,e.w,e.h):this.growNode(e.w,e.h)}findNode(e,t,a){return e.used?this.findNode(e.right,t,a)||this.findNode(e.down,t,a):t<=e.w&&a<=e.h?e:null}splitNode(e,t,a){return e.used=!0,e.down={x:e.x,y:e.y+a,w:e.w,h:e.h-a},e.right={x:e.x+t,y:e.y,w:e.w-t,h:a},e}growNode(e,t){const a=e<=this.root.w,i=t<=this.root.h,s=i&&this.root.h>=this.root.w+e,n=a&&this.root.w>=this.root.h+t;return s?this.growRight(e,t):n?this.growDown(e,t):i?this.growRight(e,t):a?this.growDown(e,t):null}growRight(e,t){this.root={used:!0,x:0,y:0,w:this.root.w+e,h:this.root.h,down:this.root,right:{x:this.root.w,y:0,w:e,h:this.root.h}};const a=this.findNode(this.root,e,t);let i;return a&&(i=this.splitNode(a,e,t)),this.resized.emit(this.root.w,this.root.h),i}growDown(e,t){this.root={used:!0,x:0,y:0,w:this.root.w,h:this.root.h+t,down:{x:0,y:this.root.h,w:this.root.w,h:t},right:this.root};const a=this.findNode(this.root,e,t);let i;return a&&(i=this.splitNode(a,e,t)),this.resized.emit(this.root.w,this.root.h),i}}class L{constructor(e=0){this.__asyncCount=e,this.ready=new S(!0),this.incAsyncCount=function(e=1){this.__asyncCount+=e,this.ready.setToggled(!1);}.bind(this),this.decAsyncCount=function(){this.__asyncCount>0&&(this.__asyncCount--,0==this.__asyncCount&&this.__asyncsCompleted());}.bind(this),this.__asyncsCompleted=function(){this.ready.emit();}.bind(this);}get count(){return this.__asyncCount}}const v=e=>{if(window.TextDecoder)return new TextDecoder("utf-8").decode(e);{let t="";for(let a=0;a<e.length;a++)t+=String.fromCharCode(e[a]);return t}};var M=Object.freeze({__proto__:null,GrowingPacker:W,Async:L,Signal:S,decodeText:v});let F=0;class T{constructor(){if("RefCounted"==this.constructor.name)throw new Error("RefCounted should not be instantiated directly.");this.__id=++F,this.__refs=[],this.destructing=new S,this.__destroyed=!1;}getId(){return this.__id}numRefs(){return this.__refs.length}addRef(e){if(!e)throw new Error("Error in RefCounted.addRef: Must provide a referer");return this.__refs.push(e),!0}removeRef(e){if(!e)throw new Error("Error in RefCounted.removeRef: Must provide a referer");const t=this.__refs.indexOf(e);if(-1==t)throw new Error("Error in RefCounted.removeRef: referer not found in refs list.");this.__refs.splice(t,1),0==this.__refs.length&&this.destroy();}getRefer(e){return this.__refs[e]}getRefIndex(e){return this.__refs.indexOf(e)}isDestroyed(){return this.__destroyed}destroy(){this.__destroyed=!0,this.destructing.emit(this);}}const C=new class{constructor(){this.__registeredClasses={},this.__classNames={};}registerClass(e,t){this.__registeredClasses[e]={cls:t,callbacks:[]},this.__classNames[t.name]=e;}registerCallback(e,t){const a=this.__registeredClasses[e];a?a.callbacks.push(t):console.warn("Factory not registered:"+e);}getClass(e){if(this.__registeredClasses[e])return this.__registeredClasses[e].cls}getClassName(e){return this.__classNames[e.constructor.name]?this.__classNames[e.constructor.name]:e.constructor.name}isConstructing(){return this.__constructing}constructClass(e){const t=this.__registeredClasses[e];if(!t)return console.warn("Factory not registered:"+e),null;this.__constructing=!0;const a=Array.prototype.slice.call(arguments,1),i=new t.cls(...a);return this.__constructing=!1,this.invokeCallbacks(i),i}invokeCallbacks(e){if(this.__classNames[e.constructor.name]){const t=this.__registeredClasses[this.__classNames[e.constructor.name]];for(const a of t.callbacks)a(e);}}},Y={NORMAL:0,OPERATOR_GETVALUE:1},N={USER_SETVALUE:0,REMOTEUSER_SETVALUE:1,USER_SETVALUE_DONE:2,OPERATOR_SETVALUE:3,OPERATOR_DIRTIED:4,COMPUTED_VALUE:4,GENERATED_VALUE:4,DATA_LOAD:4},K={USER_EDITED:2,DISABLED:4},w=0,z=1,U=2;class J{constructor(e){this.__name=e,this.__cleanerFns=[],this.__boundOps=[],this.__state=w,this.__flags=0,this.valueChanged=new S,this.nameChanged=new S,this.getName=this.getName.bind(this),this.setName=this.setName.bind(this),this.getValue=this.getValue.bind(this),this.setValue=this.setValue.bind(this);}getName(){return this.__name}setName(e){if(e!=this.__name){const t=this.__name;this.__name=e,this.nameChanged.emit(this.__name,t);}}getOwner(){return this.ownerItem}addOwner(e){this.ownerItem=e;}getPath(){const e=this.getOwner();if(e&&e.getName){if(e.getPath){const t=e.getPath().slice();return t.push(this.__name),t}return [e.getName(),this.__name]}return [this.__name]}setFlag(e){this.__flags|=e;}clearFlag(e){this.__flags&=~e;}testFlag(e){return 0!=(this.__flags&e)}getValue(){}setValue(e){}setEnabled(e){console.warn("Deprecated Method: This method will be removed soon."),e?this.setFlag(K.DISABLED):this.clearFlag(K.DISABLED);}isEnabled(){console.warn("Deprecated Method: This method will be removed soon."),this.testFlag(K.DISABLED);}bindOperator(e){this.__boundOps.push(e),this.__state=z,this.valueChanged.emit(N.OPERATOR_DIRTIED);}unbindOperator(e){const t=this.__boundOps.indexOf(e);if(-1==t)return !1;this.__boundOps.splice(t,1),this.__state=z,this.valueChanged.emit(N.OPERATOR_DIRTIED);}setDirty(e){return -1==this.__cleanerFns.indexOf(e)&&(this.__cleanerFns.push(e),this.__state=z,this.valueChanged.emit(N.OPERATOR_DIRTIED),!0)}setDirtyFromOp(){return this.__state==w&&(this.__state=z,this.valueChanged.emit(N.OPERATOR_DIRTIED)),!0}isDirty(){return this.__state==z}_clean(){this.__state=U;const e=this.__cleanerFns;this.__cleanerFns=[];for(const t of e){const e=t(this.__value);null!=e&&(this.__value=e);}for(const e of this.__boundOps)e.evaluate();this.__state=w;}removeCleanerFn(e){const t=this.__cleanerFns.indexOf(e);if(-1==t)return 0;this.__cleanerFns.splice(t,1);}clone(e){console.error("TOOD: implment me");}destroy(){}}class P extends J{constructor(e,t,a){super(e),this.__value=t,this.__dataType=a||t.constructor.name;}getDataType(){return this.__dataType}getValue(e=Y.NORMAL){return this.__state==z&&this._clean(),this.__value}setClean(e){this.__value=e;}setValue(e,t=N.USER_SETVALUE){this.__cleanerFns.length>0&&(this.__cleanerFns=[]),(e.fromJSON||this.__value!=e)&&(this.__value=e,t!=N.USER_SETVALUE&&t!=N.REMOTEUSER_SETVALUE||this.setFlag(K.USER_EDITED),t!=N.OPERATOR_SETVALUE&&this.valueChanged.emit(t));}setValueDone(){this.valueChanged.emit(N.USER_SETVALUE_DONE);}toJSON(e,t){return this.__value.toJSON?{value:this.__value.toJSON(e,t)}:{value:this.__value}}fromJSON(e,t,a){null!=e.value?(this.setFlag(K.USER_EDITED),e.value.type&&null==this.__value&&(this.__value=C.constructClass(e.value.type)),null!=this.__value&&this.__value.fromJSON?(this.__value.fromJSON(e.value,t),this.valueChanged.emit(N.DATA_LOAD)):this.setValue(e.value,N.DATA_LOAD)):console.warn("Invalid Parameter JSON");}readBinary(e,t){console.error("TODO");}clone(e){const t=this.__value;return t.clone&&(t=t.clone()),new P(this.__name,t,this.__dataType)}}let E=0;class H{constructor(){this.__id=++E,this.__params=[],this.__paramMapping={},this.__paramSignalIds={},this.parameterAdded=new S,this.parameterRemoved=new S,this.parameterValueChanged=new S;}getId(){return this.__id}numParameters(){return this.__params.length}getParameters(){return this.__params}getParameterIndex(e){return this.__paramMapping[e]}getParameterByIndex(e){return this.__params[e]}hasParameter(e){return e in this.__paramMapping}getParameter(e){const t=this.__paramMapping[e];return -1==t?null:this.__params[t]}__parameterValueChanged(e,t){this.parameterValueChanged.emit(e,t);}addParameter(e){const t=e.getName();return null!=this.__paramMapping[t]&&(console.warn("Replacing Parameter:"+t),this.removeParameter(t)),this.__paramSignalIds[t]=e.valueChanged.connect(t=>this.__parameterValueChanged(e,t)),this.__params.push(e),this.__paramMapping[t]=this.__params.length-1,this.parameterAdded.emit(t),e}insertParameter(e,t){const a=e.getName();null!=this.__paramMapping[a]&&(console.warn("Replacing Parameter:"+a),this.removeParameter(a)),this.__paramSignalIds[a]=e.valueChanged.connect(t=>this.__parameterValueChanged(e,t)),this.__params.splice(t,0,e);const i={};for(let e=0;e<this.__params.length;e++)i[this.__params[e].getName()]=e;return this.__paramMapping=i,this.parameterAdded.emit(a),e}removeParameter(e){null==this.__paramMapping[e]&&console.throw("Unable to Remove Parameter:"+e);const t=this.__paramMapping[e];this.__params[this.__paramMapping[e]].valueChanged.disconnectId(this.__paramSignalIds[e]),this.__params.splice(t,1);const a={};for(let e=0;e<this.__params.length;e++)a[this.__params[e].getName()]=e;this.__paramMapping=a,this.parameterRemoved.emit(e);}replaceParameter(e){const t=e.getName(),a=this.__paramMapping[t];return this.__params[this.__paramMapping[t]].valueChanged.disconnectId(this.__paramSignalIds[t]),this.__paramSignalIds[t]=e.valueChanged.connect(t=>this.__parameterValueChanged(e,t)),this.__params[a]=e,e}toJSON(e,t){const a={};let i=0;for(const s of this.__params)if(s.testFlag(K.USER_EDITED))if(s.numRefs()>1&&0!=s.getRefIndex(this))a[s.getName()]={paramPath:e.makeRelative(s.getPath())},i++;else {const n=s.toJSON(e,t);n&&(a[s.getName()]=n,i++);}if(i>0)return {params:a}}fromJSON(e,t,a){if(e.params)for(const a in e.params){const i=e.params[a],s=this.getParameter(a);s?i.paramPath?t.resolvePath(i.paramPath,e=>{this.replaceParameter(e);},e=>{console.warn("Unable to resolve shared parameter:"+i.paramPath);}):s.fromJSON(i,t):console.warn("Param not found:"+a);}}readBinary(e,t){if(t.versions["zea-engine"].greaterOrEqualThan([0,0,3])){const a=e.loadUInt32();for(let i=0;i<a;i++){const a=e.loadStr(),i=e.loadStr();let s=this.getParameter(i);if(!s){if(s=C.constructClass(a,i),!s){console.error("Unable to construct prop:"+i+" of type:"+a);continue}this.addParameter(s);}s.readBinary(e,t);}}}toString(){return JSON.stringify(this.toJSON(),null,2)}copyFrom(e,t){let a=e.numParameters();for(;a--;){const t=e.getParameterByIndex(a),i=this.getParameter(t.getName());i?i.setValue(t.getValue(),N.OPERATOR_SETVALUE):this.addParameter(t.clone());}}destroy(){for(const e of this.__params)e.destroy();super.destroy();}}const k={USER_EDITED:2,IGNORE_BBOX:4,BIN_NODE:8,INVISIBLE:16};let B=0;class D extends H{constructor(e){super(),null==e&&(e=C.getClassName(this)),this.__name=e,this.__path=[e],this.__ownerItem=void 0,this.__flags=0,this.__selectable=!0,this.__selected=!1,this.selectedChanged=new S,this.__metaData={},this.nameChanged=new S,B++;}static getNumBaseItems(){return B}__parameterValueChanged(e,t){super.__parameterValueChanged(e,t),t!=N.USER_SETVALUE&&t!=N.REMOTEUSER_SETVALUE||this.setFlag(k.USER_EDITED);}getName(){return this.__name}setName(e,t=N.USER_SETVALUE){if(this.__name!=e){const a=this.__name;this.__name=e,this.__updatePath(),this.nameChanged.emit(e,a,t);}}__updatePath(){null==this.__ownerItem?this.__path=[this.__name]:(this.__path=this.__ownerItem.getPath().slice(),this.__path.push(this.__name));}getPath(){return this.__path}setFlag(e){this.__flags|=e;}clearFlag(e){this.__flags&=~e;}testFlag(e){return 0!=(this.__flags&e)}resolvePath(e,t){if(t==e.length)return this;if(">"==e[t]&&t==e.length-1)return this.getParameter(e[t+1]);const a=this.getParameter(e[t]);if(a)return a;throw new Error("Invalid path:"+e+" member not found")}getOwner(){return this.__ownerItem}setOwner(e){this.__ownerItem!==e&&(this.__ownerItem=e,this.__updatePath());}getSelectable(){return this.__selectable}setSelectable(e){return this.__selectable!=e&&(this.__selectable=e,!0)}isSelected(){return this.__selected}getSelected(){return this.__selected}setSelected(e){this.__selected=e,this.selectedChanged.emit(this.__selected);}getMetadata(e){return this.__metaData[e]}hasMetadata(e){return e in this.__metaData}setMetadata(e,t){this.__metaData[e]=t;}deleteMetadata(e){delete this.__metaData[e];}toJSON(e,t){let a=super.toJSON(e,t);return !a&&this.testFlag(k.USER_EDITED)&&(a={}),a&&(a.name=this.__name,this.testFlag(k.BIN_NODE)||(a.type=C.getClassName(this))),a}fromJSON(e,t,a){e.name&&(this.__name=e.name),super.fromJSON(e,t,a),this.__flags|=k.USER_EDITED;}readBinary(e,t){e.loadStr();this.setName(e.loadStr()),super.readBinary(e,t);}clone(e){throw new Error(this.constructor.name+" does not implment its clone method")}copyFrom(e,t){super.copyFrom(e,t),this.setName(e.getName());}destroy(){super.destroy();}}const O=function(e){return e.substring(0,e.lastIndexOf("/"))+"/"},Q=function(e,t,a,i,s){const n=new XMLHttpRequest;n.responseType=t;try{n.addEventListener("timeout",(function(t){throw new Error("The request for "+e+" timed out.")})),n.addEventListener("error",(function(t){throw new Error("The request for "+e+": xhr.readyState:"+n.readyState)})),n.addEventListener("abort",(function(t){throw new Error("The request for "+e+": xhr.readyState:"+n.readyState)})),n.addEventListener("loadend",(function(e){200==n.status?a(n):i(n.statusText);})),n.open("GET",e,!0),n.send();}catch(e){i(e);}},A=function(e,t,a,i){Q(e,"text",e=>{t(e.responseText);},t=>{if(null==a)throw new Error("Unable to XHR File:"+e);a(t);});},q=function(e,t,a,i){Q(e,"json",e=>{t(e.response,e);},t=>{if(null==a)throw new Error("Unable to XHR File:"+e);a(t);});},$=function(e,t,a,i){Q(e,"document",e=>{t(e.responseXML);},t=>{if(null==a)throw new Error("Unable to XHR File:"+e);a(t);});},ee=function(e,t,a,i){Q(e,"arraybuffer",e=>{t(e.response);},t=>{if(null==a)throw new Error("Unable to XHR File:"+e);a(t);});},te="[object process]"===Object.prototype.toString.call("undefined"!=typeof process?process:0),ae=te&&"function"==typeof module.require?module.require:null;function ie(e,t=null,a=!1){const i=te?function(e,t){return Buffer.from(e,"base64").toString(t?"utf16":"utf8")}(e,a):function(e,t){const a=atob(e);if(t){const e=new Uint8Array(a.length);return Array.prototype.forEach.call(e,(e,t,i)=>{i[t]=a.charCodeAt(t);}),String.fromCharCode.apply(null,new Uint16Array(e.buffer))}return a}(e,a),s=i.indexOf("\n",10)+1,n=i.substring(s)+(t?`//# sourceMappingURL=${t}`:"");if(ae){const e=ae("worker_threads").Worker;return function(t){return new e(n,Object.assign({},t,{eval:!0}))}}const l=new Blob([n],{type:"application/javascript"}),r=URL.createObjectURL(l);return function(e){return new Worker(r,e)}}const se=ie("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwpNb2R1bGU9e0VOVklST05NRU5UOiJXT1JLRVIifTtjb25zdCBlPXt9O3ZhciB0Oyh0PWUpLnVucGFja0JyaWRnZT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIG89dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsciksby5sPSEwLG8uZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7InVuZGVmaW5lZCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiYib2JqZWN0Ij09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobiwiZGVmYXVsdCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmInN0cmluZyIhPXR5cGVvZiBlKWZvcih2YXIgbyBpbiBlKXIuZChuLG8sZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxvKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsImEiLHQpLHR9LHIubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sci5wPSIiLHIoci5zPTIpfShbZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtjb25zdCBvPXIoMSksaT17MDoiRVJBUl9TVUNDRVNTIiwxMDoiRVJBUl9FTkRfQVJDSElWRSIsMTE6IkVSQVJfTk9fTUVNT1JZIiwxMjoiRVJBUl9CQURfREFUQSIsMTM6IkVSQVJfQkFEX0FSQ0hJVkUiLDE0OiJFUkFSX1VOS05PV05fRk9STUFUIiwxNToiRVJBUl9FT1BFTiIsMTY6IkVSQVJfRUNSRUFURSIsMTc6IkVSQVJfRUNMT1NFIiwxODoiRVJBUl9FUkVBRCIsMTk6IkVSQVJfRVdSSVRFIiwyMDoiRVJBUl9TTUFMTF9CVUYiLDIxOiJFUkFSX1VOS05PV04iLDIyOiJFUkFSX01JU1NJTkdfUEFTU1dPUkQiLDIzOiJFUkFSX0VSRUZFUkVOQ0UiLDI0OiJFUkFSX0JBRF9QQVNTV09SRCJ9LGE9ezA6IlN1Y2Nlc3MiLDExOiJOb3QgZW5vdWdoIG1lbW9yeSIsMTI6IkFyY2hpdmUgaGVhZGVyIG9yIGRhdGEgYXJlIGRhbWFnZWQiLDEzOiJGaWxlIGlzIG5vdCBSQVIgYXJjaGl2ZSIsMTQ6IlVua25vd24gYXJjaGl2ZSBmb3JtYXQiLDE1OiJGaWxlIG9wZW4gZXJyb3IiLDE2OiJGaWxlIGNyZWF0ZSBlcnJvciIsMTc6IkZpbGUgY2xvc2UgZXJyb3IiLDE4OiJGaWxlIHJlYWQgZXJyb3IiLDE5OiJGaWxlIHdyaXRlIGVycm9yIiwyMDoiQnVmZmVyIGZvciBhcmNoaXZlIGNvbW1lbnQgaXMgdG9vIHNtYWxsLCBjb21tZW50IHRydW5jYXRlZCIsMjE6IlVua25vd24gZXJyb3IiLDIyOiJQYXNzd29yZCBmb3IgZW5jcnlwdGVkIGZpbGUgb3IgaGVhZGVyIGlzIG5vdCBzcGVjaWZpZWQiLDIzOiJDYW5ub3Qgb3BlbiBmaWxlIHNvdXJjZSBmb3IgcmVmZXJlbmNlIHJlY29yZCIsMjQ6Ildyb25nIHBhc3N3b3JkIGlzIHNwZWNpZmllZCJ9O2NsYXNzIHN7Y29uc3RydWN0b3IoZT0iIil7dGhpcy5fcGFzc3dvcmQ9ZSx0aGlzLl9hcmNoaXZlPW51bGx9Z2V0RmlsZUxpc3QoKXtsZXQgZSxbdCxyXT10aGlzLm9wZW5BcmMoITApO2lmKCJTVUNDRVNTIiE9PXQuc3RhdGUpZT1bdCxudWxsXTtlbHNle2xldCB0LG4sbz1bXTtmb3IoO1t0LG5dPXRoaXMucHJvY2Vzc05leHRGaWxlKCgpPT4hMCksIlNVQ0NFU1MiPT09dC5zdGF0ZTspby5wdXNoKG4uZmlsZUhlYWRlcik7ZT0iRVJBUl9FTkRfQVJDSElWRSIhPT10LnJlYXNvbj9bdCxudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2FyY0hlYWRlcjpyLGZpbGVIZWFkZXJzOm99XX1yZXR1cm4gdGhpcy5jbG9zZUFyYygpLGV9ZXh0cmFjdEFsbCgpe2xldCBlLFt0LHJdPXRoaXMub3BlbkFyYyghMSk7aWYoIlNVQ0NFU1MiIT09dC5zdGF0ZSllPVt0LG51bGxdO2Vsc2V7bGV0IHQsbixvPVtdO2Zvcig7W3Qsbl09dGhpcy5wcm9jZXNzTmV4dEZpbGUoKCk9PiExKSwiU1VDQ0VTUyI9PT10LnN0YXRlOylvLnB1c2gobik7ZT0iRVJBUl9FTkRfQVJDSElWRSIhPT10LnJlYXNvbj9bdCxudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2FyY0hlYWRlcjpyLGZpbGVzOm99XX1yZXR1cm4gdGhpcy5jbG9zZUFyYygpLGV9ZXh0cmFjdEZpbGVzKGUsdCl7bGV0IHIsW24sb109dGhpcy5vcGVuQXJjKCExLHQpLGk9e307Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDsrK3QpaVtlW3RdXT10O2lmKCJTVUNDRVNTIiE9PW4uc3RhdGUpcj1bbixudWxsXTtlbHNle2xldCB0LG4sYT1BcnJheShlLmxlbmd0aCkuZmlsbChudWxsKSxzPTA7Zm9yKDs7KXtsZXQgcj0hMSxvPW51bGw7aWYoW3Qsbl09dGhpcy5wcm9jZXNzTmV4dEZpbGUoZT0+ZSBpbiBpPyhvPWlbZV0sITEpOihyPSEwLCEwKSksIlNVQ0NFU1MiIT09dC5zdGF0ZSlicmVhaztpZighciYmKGFbb109biwrK3M9PT1lLmxlbmd0aCkpe3QucmVhc29uPSJFUkFSX0VORF9BUkNISVZFIjticmVha319cj0iRVJBUl9FTkRfQVJDSElWRSIhPT10LnJlYXNvbj9bdCxudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2FyY0hlYWRlcjpvLGZpbGVzOmF9XX1yZXR1cm4gdGhpcy5jbG9zZUFyYygpLHJ9ZmlsZUNyZWF0ZWQoZSl7fWNsb3NlKGUpe3RoaXMuX2xhc3RGaWxlQ29udGVudD10aGlzLmNsb3NlRmlsZShlKX1vcGVuQXJjKGUsdCl7by5FeHQuY3VycmVudD10aGlzLHRoaXMuX2FyY2hpdmU9bmV3IG4uUmFyQXJjaGl2ZTtsZXQgcixpPXRoaXMuX2FyY2hpdmUub3Blbih0aGlzLl9maWxlUGF0aCx0fHx0aGlzLl9wYXNzd29yZCxlKTtyZXR1cm4gcj0wIT09aS5zdGF0ZS5lcnJDb2RlP1t0aGlzLmdldEZhaWxJbmZvKGkuc3RhdGUuZXJyQ29kZSxpLnN0YXRlLmVyclR5cGUpLG51bGxdOlt7c3RhdGU6IlNVQ0NFU1MifSx7Y29tbWVudDppLmNvbW1lbnQsZmxhZ3M6e3ZvbHVtZTowIT0oMSZpLmZsYWdzKSxsb2NrOjAhPSg0JmkuZmxhZ3MpLHNvbGlkOjAhPSg4JmkuZmxhZ3MpLGF1dGhJbmZvOjAhPSgzMiZpLmZsYWdzKSxyZWNvdmVyeVJlY29yZDowIT0oNjQmaS5mbGFncyksaGVhZGVyRW5jcnlwdGVkOjAhPSgxMjgmaS5mbGFncyl9fV0sby5FeHQuY3VycmVudD1udWxsLHJ9cHJvY2Vzc05leHRGaWxlKGUpe2xldCB0O28uRXh0LmN1cnJlbnQ9dGhpcztsZXQgcj10aGlzLl9hcmNoaXZlLmdldEZpbGVIZWFkZXIoKSxuPVt7c3RhdGU6IlNVQ0NFU1MifSxudWxsXTtpZigwPT09ci5zdGF0ZS5lcnJDb2RlKXtsZXQgdD1lKHIubmFtZSk7dGhpcy5fbGFzdEZpbGVDb250ZW50PW51bGw7bGV0IG89dGhpcy5fYXJjaGl2ZS5yZWFkRmlsZSh0KTswPT09by5lcnJDb2RlfHx0fHwoblswXT10aGlzLmdldEZhaWxJbmZvKG8uZXJyQ29kZSxvLmVyclR5cGUpLDIyPT09by5lcnJDb2RlP289dGhpcy5fYXJjaGl2ZS5yZWFkRmlsZSghMCk6by5lcnJDb2RlPTApLDA9PT1vLmVyckNvZGU/blsxXT10aGlzLl9sYXN0RmlsZUNvbnRlbnQ6KHIuc3RhdGUuZXJyQ29kZT1vLmVyckNvZGUsci5zdGF0ZS5lcnJUeXBlPW8uZXJyVHlwZSksdGhpcy5fbGFzdEZpbGVDb250ZW50PW51bGx9cmV0dXJuIHQ9MCE9PXIuc3RhdGUuZXJyQ29kZT9bdGhpcy5nZXRGYWlsSW5mbyhyLnN0YXRlLmVyckNvZGUsci5zdGF0ZS5lcnJUeXBlKSxudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2ZpbGVIZWFkZXI6e25hbWU6ci5uYW1lLGZsYWdzOntlbmNyeXB0ZWQ6MCE9KDQmci5mbGFncyksc29saWQ6MCE9KDE2JnIuZmxhZ3MpLGRpcmVjdG9yeTowIT0oMzImci5mbGFncyl9LHBhY2tTaXplOnIucGFja1NpemUsdW5wU2l6ZTpyLnVucFNpemUsY3JjOnIuY3JjLHRpbWU6ZnVuY3Rpb24oZSl7Y29uc3QgdD1bNSw2LDUsNSw0LDddO2xldCByPVtdO2ZvcihsZXQgbiBvZiB0KXIucHVzaChlJigxPDxuKS0xKSxlPj49bjtsZXQgbj1lPT5lPDEwPyIwIitlOiIiK2U7cmV0dXJuYCR7MTk4MCsocj1yLnJldmVyc2UoKSlbMF19LSR7bihyWzFdKX0tJHtuKHJbMl0pfWArYFQke24oclszXSl9OiR7bihyWzRdKX06JHtuKDIqcls1XSl9LjAwMGB9KHIudGltZSksdW5wVmVyOmAke01hdGguZmxvb3Ioci51bnBWZXIvMTApfS4ke3IudW5wVmVyJTEwfWAsbWV0aG9kOmZ1bmN0aW9uKGUpe3JldHVybns0ODoiU3RvcmluZyIsNDk6IkZhc3Rlc3QiLDUwOiJGYXN0Iiw1MToiTm9ybWFsIiw1MjoiR29vZCIsNTM6IkJlc3QifVtlXXx8IlVua25vd24ifShyLm1ldGhvZCl9LGV4dHJhY3Q6bn1dLG8uRXh0LmN1cnJlbnQ9bnVsbCx0fWNsb3NlQXJjKCl7by5FeHQuY3VycmVudD10aGlzLHRoaXMuX2FyY2hpdmUuZGVsZXRlKCksby5FeHQuY3VycmVudD1udWxsLHRoaXMuX2FyY2hpdmU9bnVsbH1nZXRGYWlsSW5mbyhlLHQpe3JldHVybntzdGF0ZToiRkFJTCIscmVhc29uOmlbZV0sbXNnOmFbZV19fX1zLl9jdXJyZW50PW51bGwsdC5FeHRyYWN0b3I9c30sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSx0LkV4dD17Y3VycmVudDpudWxsfX0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxmdW5jdGlvbihlKXtmb3IodmFyIHIgaW4gZSl0Lmhhc093blByb3BlcnR5KHIpfHwodFtyXT1lW3JdKX0ocigzKSk7dmFyIG49cigxKTt0LkV4dD1uLkV4dH0sZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoNCksbz1yKDYpO3QuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGE9ZnVuY3Rpb24oZSx0PSIiKXtyZXR1cm4gbmV3IG4uRGF0YUV4dHJhY3RvcihlLHQpfSx0LmNyZWF0ZUV4dHJhY3RvckZyb21GaWxlPWZ1bmN0aW9uKGUsdD0iIixyPSIiKXtyZXR1cm4gbmV3IG8uRmlsZUV4dHJhY3RvcihlLHQscil9fSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2NvbnN0IG89cig1KSxpPXIoMCk7dC5EYXRhRXh0cmFjdG9yPWNsYXNzIGV4dGVuZHMgaS5FeHRyYWN0b3J7Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KSx0aGlzLmRhdGFGaWxlcz17fSx0aGlzLmRhdGFGaWxlTWFwPXt9LHRoaXMuY3VycmVudEZkPTE7bGV0IHI9e2ZpbGU6bmV3IG8uRGF0YUZpbGUobmV3IFVpbnQ4QXJyYXkoZSkpLGZkOnRoaXMuY3VycmVudEZkKyt9O3RoaXMuX2ZpbGVQYXRoPSJfZGVmYXVsdFVucmFySlNfLnJhciIsdGhpcy5kYXRhRmlsZXNbdGhpcy5fZmlsZVBhdGhdPXIsdGhpcy5kYXRhRmlsZU1hcFtyLmZkXT10aGlzLl9maWxlUGF0aH1vcGVuKGUpe2xldCB0PXRoaXMuZGF0YUZpbGVzW2VdO3JldHVybiB0P3QuZmQ6MH1jcmVhdGUoZSl7bGV0IHQ9dGhpcy5jdXJyZW50RmQrKztyZXR1cm4gdGhpcy5kYXRhRmlsZXNbZV09e2ZpbGU6bmV3IG8uRGF0YUZpbGUsZmQ6dGhpcy5jdXJyZW50RmQrK30sdGhpcy5kYXRhRmlsZU1hcFt0XT1lLHR9Y2xvc2VGaWxlKGUpe2xldCB0PXRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbZV1dO2lmKCF0KXJldHVybiBudWxsO2xldCByPXQuZmlsZS5yZWFkQWxsKCk7cmV0dXJuIDEhPT1lPyhkZWxldGUgdGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFtlXV0sZGVsZXRlIHRoaXMuZGF0YUZpbGVNYXBbZV0pOnQuZmlsZS5zZWVrKDAsIlNFVCIpLHJ9cmVhZChlLHQscil7bGV0IG89dGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFtlXV07aWYoIW8pcmV0dXJuLTE7bGV0IGk9by5maWxlLnJlYWQocik7cmV0dXJuIG51bGw9PT1pPy0xOihuLkhFQVBVOC5zZXQoaSx0KSxpLmJ5dGVMZW5ndGgpfXdyaXRlKGUsdCxyKXtsZXQgbz10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW2VdXTtyZXR1cm4hIW8mJihvLmZpbGUud3JpdGUobi5IRUFQVTguc2xpY2UodCx0K3IpKSwhMCl9dGVsbChlKXtsZXQgdD10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW2VdXTtyZXR1cm4gdD90LmZpbGUudGVsbCgpOi0xfXNlZWsoZSx0LHIpe2xldCBuPXRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbZV1dO3JldHVybiEhbiYmbi5maWxlLnNlZWsodCxyKX19fSxmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pLHQuRGF0YUZpbGU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5idWZmZXJzPVtdLHRoaXMucG9zPTAsdGhpcy5zaXplPTAsZSYmKHRoaXMuYnVmZmVycy5wdXNoKGUpLHRoaXMuc2l6ZT1lLmJ5dGVMZW5ndGgsdGhpcy5wb3M9MCl9cmVhZChlKXtpZih0aGlzLmZsYXR0ZW4oKSxlK3RoaXMucG9zPnRoaXMuc2l6ZSlyZXR1cm4gbnVsbDtsZXQgdD10aGlzLnBvcztyZXR1cm4gdGhpcy5wb3MrPWUsdGhpcy5idWZmZXJzWzBdLnNsaWNlKHQsdGhpcy5wb3MpfXJlYWRBbGwoKXtyZXR1cm4gdGhpcy5mbGF0dGVuKCksdGhpcy5idWZmZXJzWzBdfXdyaXRlKGUpe3JldHVybiB0aGlzLmJ1ZmZlcnMucHVzaChlKSx0aGlzLnNpemUrPWUuYnl0ZUxlbmd0aCx0aGlzLnBvcys9ZS5ieXRlTGVuZ3RoLCEwfXRlbGwoKXtyZXR1cm4gdGhpcy5wb3N9c2VlayhlLHQpe2xldCByPXRoaXMucG9zO3JldHVybiJTRVQiPT09dD9yPWU6IkNVUiI9PT10P3IrPWU6cj10aGlzLnNpemUtZSwhKHI8MHx8cj50aGlzLnNpemV8fCh0aGlzLnBvcz1yLDApKX1mbGF0dGVuKCl7aWYodGhpcy5idWZmZXJzLmxlbmd0aDw9MSlyZXR1cm47bGV0IGU9bmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKSx0PTA7Zm9yKGxldCByIG9mIHRoaXMuYnVmZmVycyllLnNldChyLHQpLHQrPXIuYnl0ZUxlbmd0aDt0aGlzLmJ1ZmZlcnM9W2VdfX19LGZ1bmN0aW9uKGUsdCxyKXsoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO2NvbnN0IG89cigxMiksaT1yKDEzKSxhPXIoMCk7dC5GaWxlRXh0cmFjdG9yPWNsYXNzIGV4dGVuZHMgYS5FeHRyYWN0b3J7Y29uc3RydWN0b3IoZSx0LHIpe3N1cGVyKHIpLHRoaXMuX2ZpbGVQYXRoPWUsdGhpcy5maWxlTWFwPXt9LHRoaXMuX3RhcmdldD10fW9wZW4oZSl7bGV0IHQ9by5vcGVuU3luYyhlLCJyIik7cmV0dXJuIHRoaXMuZmlsZU1hcFt0XT17c2l6ZTpvLmZzdGF0U3luYyh0KS5zaXplLHBvczowLG5hbWU6ZX0sdH1jcmVhdGUoZSl7bGV0IHQ9aS5qb2luKHRoaXMuX3RhcmdldCxlKTtpLnBhcnNlKHQpLmRpci5zcGxpdCgiLyIpLnJlZHVjZSgoZSx0KT0+KGUrPXQrIi8iLG8uZXhpc3RzU3luYyhlKXx8by5ta2RpclN5bmMoZSksZSksIiIpO2xldCByPW8ub3BlblN5bmModCwidyIpO3JldHVybiB0aGlzLmZpbGVNYXBbcl09e3NpemU6MCxwb3M6MCxuYW1lOmV9LHJ9Y2xvc2VGaWxlKGUpe3JldHVybiBkZWxldGUgdGhpcy5maWxlTWFwW2VdLG8uY2xvc2VTeW5jKGUpLG51bGx9cmVhZCh0LHIsaSl7bGV0IGE9dGhpcy5maWxlTWFwW3RdLHM9bmV3IGUoaSksdT1vLnJlYWRTeW5jKHQscywwLGksYS5wb3MpO3JldHVybiBuLkhFQVBVOC5zZXQocyxyKSxhLnBvcys9dSx1fXdyaXRlKHQscixpKXtsZXQgYT10aGlzLmZpbGVNYXBbdF0scz1vLndyaXRlU3luYyh0LG5ldyBlKG4uSEVBUFU4LnN1YmFycmF5KHIscitpKSksMCxpKTtyZXR1cm4gYS5wb3MrPXMsYS5zaXplKz1zLHM9PT1pfXRlbGwoZSl7cmV0dXJuIHRoaXMuZmlsZU1hcFtlXS5wb3N9c2VlayhlLHQscil7bGV0IG49dGhpcy5maWxlTWFwW2VdLG89bi5wb3M7cmV0dXJuIlNFVCI9PT1yP289MDoiRU5EIj09PXImJihvPW4uc2l6ZSksISgobys9dCk8MHx8bz5uLnNpemV8fChuLnBvcz1vLDApKX19fSkuY2FsbCh0aGlzLHIoNykuQnVmZmVyKX0sZnVuY3Rpb24oZSx0LHIpeyhmdW5jdGlvbihlKXsKLyohCiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz4KICogQGxpY2Vuc2UgIE1JVAogKi8KdmFyIG49cig5KSxvPXIoMTApLGk9cigxMSk7ZnVuY3Rpb24gYSgpe3JldHVybiB1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIHMoZSx0KXtpZihhKCk8dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgiKTtyZXR1cm4gdS5UWVBFRF9BUlJBWV9TVVBQT1JUPyhlPW5ldyBVaW50OEFycmF5KHQpKS5fX3Byb3RvX189dS5wcm90b3R5cGU6KG51bGw9PT1lJiYoZT1uZXcgdSh0KSksZS5sZW5ndGg9dCksZX1mdW5jdGlvbiB1KGUsdCxyKXtpZighKHUuVFlQRURfQVJSQVlfU1VQUE9SVHx8dGhpcyBpbnN0YW5jZW9mIHUpKXJldHVybiBuZXcgdShlLHQscik7aWYoIm51bWJlciI9PXR5cGVvZiBlKXtpZigic3RyaW5nIj09dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKCJJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyIpO3JldHVybiBmKHRoaXMsZSl9cmV0dXJuIGModGhpcyxlLHQscil9ZnVuY3Rpb24gYyhlLHQscixuKXtpZigibnVtYmVyIj09dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO3JldHVybiJ1bmRlZmluZWQiIT10eXBlb2YgQXJyYXlCdWZmZXImJnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9mdW5jdGlvbihlLHQscixuKXtpZih0LmJ5dGVMZW5ndGgscjwwfHx0LmJ5dGVMZW5ndGg8cil0aHJvdyBuZXcgUmFuZ2VFcnJvcigiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kcyIpO2lmKHQuYnl0ZUxlbmd0aDxyKyhufHwwKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiJ2xlbmd0aCcgaXMgb3V0IG9mIGJvdW5kcyIpO3JldHVybiB0PXZvaWQgMD09PXImJnZvaWQgMD09PW4/bmV3IFVpbnQ4QXJyYXkodCk6dm9pZCAwPT09bj9uZXcgVWludDhBcnJheSh0LHIpOm5ldyBVaW50OEFycmF5KHQscixuKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KGU9dCkuX19wcm90b19fPXUucHJvdG90eXBlOmU9ZChlLHQpLGV9KGUsdCxyLG4pOiJzdHJpbmciPT10eXBlb2YgdD9mdW5jdGlvbihlLHQscil7aWYoInN0cmluZyI9PXR5cGVvZiByJiYiIiE9PXJ8fChyPSJ1dGY4IiksIXUuaXNFbmNvZGluZyhyKSl0aHJvdyBuZXcgVHlwZUVycm9yKCciZW5jb2RpbmciIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKTt2YXIgbj0wfHAodCxyKSxvPShlPXMoZSxuKSkud3JpdGUodCxyKTtyZXR1cm4gbyE9PW4mJihlPWUuc2xpY2UoMCxvKSksZX0oZSx0LHIpOmZ1bmN0aW9uKGUsdCl7aWYodS5pc0J1ZmZlcih0KSl7dmFyIHI9MHxoKHQubGVuZ3RoKTtyZXR1cm4gMD09PShlPXMoZSxyKSkubGVuZ3RofHx0LmNvcHkoZSwwLDAsciksZX1pZih0KXtpZigidW5kZWZpbmVkIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZ0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHwibGVuZ3RoImluIHQpcmV0dXJuIm51bWJlciIhPXR5cGVvZiB0Lmxlbmd0aHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPWV9KHQubGVuZ3RoKT9zKGUsMCk6ZChlLHQpO2lmKCJCdWZmZXIiPT09dC50eXBlJiZpKHQuZGF0YSkpcmV0dXJuIGQoZSx0LmRhdGEpfXRocm93IG5ldyBUeXBlRXJyb3IoIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4iKX0oZSx0KX1mdW5jdGlvbiBsKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpO2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJyl9ZnVuY3Rpb24gZihlLHQpe2lmKGwodCksZT1zKGUsdDwwPzA6MHxoKHQpKSwhdS5UWVBFRF9BUlJBWV9TVVBQT1JUKWZvcih2YXIgcj0wO3I8dDsrK3IpZVtyXT0wO3JldHVybiBlfWZ1bmN0aW9uIGQoZSx0KXt2YXIgcj10Lmxlbmd0aDwwPzA6MHxoKHQubGVuZ3RoKTtlPXMoZSxyKTtmb3IodmFyIG49MDtuPHI7bis9MSllW25dPTI1NSZ0W25dO3JldHVybiBlfWZ1bmN0aW9uIGgoZSl7aWYoZT49YSgpKXRocm93IG5ldyBSYW5nZUVycm9yKCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4IithKCkudG9TdHJpbmcoMTYpKyIgYnl0ZXMiKTtyZXR1cm4gMHxlfWZ1bmN0aW9uIHAoZSx0KXtpZih1LmlzQnVmZmVyKGUpKXJldHVybiBlLmxlbmd0aDtpZigidW5kZWZpbmVkIiE9dHlwZW9mIEFycmF5QnVmZmVyJiYiZnVuY3Rpb24iPT10eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3JiYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXJldHVybiBlLmJ5dGVMZW5ndGg7InN0cmluZyIhPXR5cGVvZiBlJiYoZT0iIitlKTt2YXIgcj1lLmxlbmd0aDtpZigwPT09cilyZXR1cm4gMDtmb3IodmFyIG49ITE7Oylzd2l0Y2godCl7Y2FzZSJhc2NpaSI6Y2FzZSJsYXRpbjEiOmNhc2UiYmluYXJ5IjpyZXR1cm4gcjtjYXNlInV0ZjgiOmNhc2UidXRmLTgiOmNhc2Ugdm9pZCAwOnJldHVybiBVKGUpLmxlbmd0aDtjYXNlInVjczIiOmNhc2UidWNzLTIiOmNhc2UidXRmMTZsZSI6Y2FzZSJ1dGYtMTZsZSI6cmV0dXJuIDIqcjtjYXNlImhleCI6cmV0dXJuIHI+Pj4xO2Nhc2UiYmFzZTY0IjpyZXR1cm4geihlKS5sZW5ndGg7ZGVmYXVsdDppZihuKXJldHVybiBVKGUpLmxlbmd0aDt0PSgiIit0KS50b0xvd2VyQ2FzZSgpLG49ITB9fWZ1bmN0aW9uIG0oZSx0LHIpe3ZhciBuPWVbdF07ZVt0XT1lW3JdLGVbcl09bn1mdW5jdGlvbiB5KGUsdCxyLG4sbyl7aWYoMD09PWUubGVuZ3RoKXJldHVybi0xO2lmKCJzdHJpbmciPT10eXBlb2Ygcj8obj1yLHI9MCk6cj4yMTQ3NDgzNjQ3P3I9MjE0NzQ4MzY0NzpyPC0yMTQ3NDgzNjQ4JiYocj0tMjE0NzQ4MzY0OCkscj0rcixpc05hTihyKSYmKHI9bz8wOmUubGVuZ3RoLTEpLHI8MCYmKHI9ZS5sZW5ndGgrcikscj49ZS5sZW5ndGgpe2lmKG8pcmV0dXJuLTE7cj1lLmxlbmd0aC0xfWVsc2UgaWYocjwwKXtpZighbylyZXR1cm4tMTtyPTB9aWYoInN0cmluZyI9PXR5cGVvZiB0JiYodD11LmZyb20odCxuKSksdS5pc0J1ZmZlcih0KSlyZXR1cm4gMD09PXQubGVuZ3RoPy0xOkUoZSx0LHIsbixvKTtpZigibnVtYmVyIj09dHlwZW9mIHQpcmV0dXJuIHQmPTI1NSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQmJiJmdW5jdGlvbiI9PXR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mP28/VWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUsdCxyKTpVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUsdCxyKTpFKGUsW3RdLHIsbixvKTt0aHJvdyBuZXcgVHlwZUVycm9yKCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXIiKX1mdW5jdGlvbiBFKGUsdCxyLG4sbyl7dmFyIGksYT0xLHM9ZS5sZW5ndGgsdT10Lmxlbmd0aDtpZih2b2lkIDAhPT1uJiYoInVjczIiPT09KG49U3RyaW5nKG4pLnRvTG93ZXJDYXNlKCkpfHwidWNzLTIiPT09bnx8InV0ZjE2bGUiPT09bnx8InV0Zi0xNmxlIj09PW4pKXtpZihlLmxlbmd0aDwyfHx0Lmxlbmd0aDwyKXJldHVybi0xO2E9MixzLz0yLHUvPTIsci89Mn1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuIDE9PT1hP2VbdF06ZS5yZWFkVUludDE2QkUodCphKX1pZihvKXt2YXIgbD0tMTtmb3IoaT1yO2k8cztpKyspaWYoYyhlLGkpPT09Yyh0LC0xPT09bD8wOmktbCkpe2lmKC0xPT09bCYmKGw9aSksaS1sKzE9PT11KXJldHVybiBsKmF9ZWxzZS0xIT09bCYmKGktPWktbCksbD0tMX1lbHNlIGZvcihyK3U+cyYmKHI9cy11KSxpPXI7aT49MDtpLS0pe2Zvcih2YXIgZj0hMCxkPTA7ZDx1O2QrKylpZihjKGUsaStkKSE9PWModCxkKSl7Zj0hMTticmVha31pZihmKXJldHVybiBpfXJldHVybi0xfWZ1bmN0aW9uIGcoZSx0LHIsbil7cj1OdW1iZXIocil8fDA7dmFyIG89ZS5sZW5ndGgtcjtuPyhuPU51bWJlcihuKSk+byYmKG49byk6bj1vO3ZhciBpPXQubGVuZ3RoO2lmKGklMiE9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGhleCBzdHJpbmciKTtuPmkvMiYmKG49aS8yKTtmb3IodmFyIGE9MDthPG47KythKXt2YXIgcz1wYXJzZUludCh0LnN1YnN0cigyKmEsMiksMTYpO2lmKGlzTmFOKHMpKXJldHVybiBhO2VbcithXT1zfXJldHVybiBhfWZ1bmN0aW9uIHYoZSx0LHIsbil7cmV0dXJuICQoVSh0LGUubGVuZ3RoLXIpLGUscixuKX1mdW5jdGlvbiB3KGUsdCxyLG4pe3JldHVybiAkKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxyPTA7cjxlLmxlbmd0aDsrK3IpdC5wdXNoKDI1NSZlLmNoYXJDb2RlQXQocikpO3JldHVybiB0fSh0KSxlLHIsbil9ZnVuY3Rpb24gXyhlLHQscixuKXtyZXR1cm4gdyhlLHQscixuKX1mdW5jdGlvbiBiKGUsdCxyLG4pe3JldHVybiAkKHoodCksZSxyLG4pfWZ1bmN0aW9uIEEoZSx0LHIsbil7cmV0dXJuICQoZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIsbixvLGk9W10sYT0wO2E8ZS5sZW5ndGgmJiEoKHQtPTIpPDApOysrYSluPShyPWUuY2hhckNvZGVBdChhKSk+Pjgsbz1yJTI1NixpLnB1c2gobyksaS5wdXNoKG4pO3JldHVybiBpfSh0LGUubGVuZ3RoLXIpLGUscixuKX1mdW5jdGlvbiBUKGUsdCxyKXtyZXR1cm4gMD09PXQmJnI9PT1lLmxlbmd0aD9uLmZyb21CeXRlQXJyYXkoZSk6bi5mcm9tQnl0ZUFycmF5KGUuc2xpY2UodCxyKSl9ZnVuY3Rpb24gUyhlLHQscil7cj1NYXRoLm1pbihlLmxlbmd0aCxyKTtmb3IodmFyIG49W10sbz10O288cjspe3ZhciBpLGEscyx1LGM9ZVtvXSxsPW51bGwsZj1jPjIzOT80OmM+MjIzPzM6Yz4xOTE/MjoxO2lmKG8rZjw9cilzd2l0Y2goZil7Y2FzZSAxOmM8MTI4JiYobD1jKTticmVhaztjYXNlIDI6MTI4PT0oMTkyJihpPWVbbysxXSkpJiYodT0oMzEmYyk8PDZ8NjMmaSk+MTI3JiYobD11KTticmVhaztjYXNlIDM6aT1lW28rMV0sYT1lW28rMl0sMTI4PT0oMTkyJmkpJiYxMjg9PSgxOTImYSkmJih1PSgxNSZjKTw8MTJ8KDYzJmkpPDw2fDYzJmEpPjIwNDcmJih1PDU1Mjk2fHx1PjU3MzQzKSYmKGw9dSk7YnJlYWs7Y2FzZSA0Omk9ZVtvKzFdLGE9ZVtvKzJdLHM9ZVtvKzNdLDEyOD09KDE5MiZpKSYmMTI4PT0oMTkyJmEpJiYxMjg9PSgxOTImcykmJih1PSgxNSZjKTw8MTh8KDYzJmkpPDwxMnwoNjMmYSk8PDZ8NjMmcyk+NjU1MzUmJnU8MTExNDExMiYmKGw9dSl9bnVsbD09PWw/KGw9NjU1MzMsZj0xKTpsPjY1NTM1JiYobC09NjU1MzYsbi5wdXNoKGw+Pj4xMCYxMDIzfDU1Mjk2KSxsPTU2MzIwfDEwMjMmbCksbi5wdXNoKGwpLG8rPWZ9cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKHQ8PWspcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpO2Zvcih2YXIgcj0iIixuPTA7bjx0OylyKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlLnNsaWNlKG4sbis9aykpO3JldHVybiByfShuKX10LkJ1ZmZlcj11LHQuU2xvd0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4rZSE9ZSYmKGU9MCksdS5hbGxvYygrZSl9LHQuSU5TUEVDVF9NQVhfQllURVM9NTAsdS5UWVBFRF9BUlJBWV9TVVBQT1JUPXZvaWQgMCE9PWUuVFlQRURfQVJSQVlfU1VQUE9SVD9lLlRZUEVEX0FSUkFZX1NVUFBPUlQ6ZnVuY3Rpb24oKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuIGUuX19wcm90b19fPXtfX3Byb3RvX186VWludDhBcnJheS5wcm90b3R5cGUsZm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX0sNDI9PT1lLmZvbygpJiYiZnVuY3Rpb24iPT10eXBlb2YgZS5zdWJhcnJheSYmMD09PWUuc3ViYXJyYXkoMSwxKS5ieXRlTGVuZ3RofWNhdGNoKGUpe3JldHVybiExfX0oKSx0LmtNYXhMZW5ndGg9YSgpLHUucG9vbFNpemU9ODE5Mix1Ll9hdWdtZW50PWZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fXz11LnByb3RvdHlwZSxlfSx1LmZyb209ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBjKG51bGwsZSx0LHIpfSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQmJih1LnByb3RvdHlwZS5fX3Byb3RvX189VWludDhBcnJheS5wcm90b3R5cGUsdS5fX3Byb3RvX189VWludDhBcnJheSwidW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnNwZWNpZXMmJnVbU3ltYm9sLnNwZWNpZXNdPT09dSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwfSkpLHUuYWxsb2M9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBmdW5jdGlvbihlLHQscixuKXtyZXR1cm4gbCh0KSx0PD0wP3MoZSx0KTp2b2lkIDAhPT1yPyJzdHJpbmciPT10eXBlb2Ygbj9zKGUsdCkuZmlsbChyLG4pOnMoZSx0KS5maWxsKHIpOnMoZSx0KX0obnVsbCxlLHQscil9LHUuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGYobnVsbCxlKX0sdS5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGYobnVsbCxlKX0sdS5pc0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4hKG51bGw9PWV8fCFlLl9pc0J1ZmZlcil9LHUuY29tcGFyZT1mdW5jdGlvbihlLHQpe2lmKCF1LmlzQnVmZmVyKGUpfHwhdS5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzIik7aWYoZT09PXQpcmV0dXJuIDA7Zm9yKHZhciByPWUubGVuZ3RoLG49dC5sZW5ndGgsbz0wLGk9TWF0aC5taW4ocixuKTtvPGk7KytvKWlmKGVbb10hPT10W29dKXtyPWVbb10sbj10W29dO2JyZWFrfXJldHVybiByPG4/LTE6bjxyPzE6MH0sdS5pc0VuY29kaW5nPWZ1bmN0aW9uKGUpe3N3aXRjaChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSl7Y2FzZSJoZXgiOmNhc2UidXRmOCI6Y2FzZSJ1dGYtOCI6Y2FzZSJhc2NpaSI6Y2FzZSJsYXRpbjEiOmNhc2UiYmluYXJ5IjpjYXNlImJhc2U2NCI6Y2FzZSJ1Y3MyIjpjYXNlInVjcy0yIjpjYXNlInV0ZjE2bGUiOmNhc2UidXRmLTE2bGUiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSx1LmNvbmNhdD1mdW5jdGlvbihlLHQpe2lmKCFpKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIHUuYWxsb2MoMCk7dmFyIHI7aWYodm9pZCAwPT09dClmb3IodD0wLHI9MDtyPGUubGVuZ3RoOysrcil0Kz1lW3JdLmxlbmd0aDt2YXIgbj11LmFsbG9jVW5zYWZlKHQpLG89MDtmb3Iocj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgYT1lW3JdO2lmKCF1LmlzQnVmZmVyKGEpKXRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTthLmNvcHkobixvKSxvKz1hLmxlbmd0aH1yZXR1cm4gbn0sdS5ieXRlTGVuZ3RoPXAsdS5wcm90b3R5cGUuX2lzQnVmZmVyPSEwLHUucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlMiE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMiKTtmb3IodmFyIHQ9MDt0PGU7dCs9MiltKHRoaXMsdCx0KzEpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzIik7Zm9yKHZhciB0PTA7dDxlO3QrPTQpbSh0aGlzLHQsdCszKSxtKHRoaXMsdCsxLHQrMik7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMiKTtmb3IodmFyIHQ9MDt0PGU7dCs9OCltKHRoaXMsdCx0KzcpLG0odGhpcyx0KzEsdCs2KSxtKHRoaXMsdCsyLHQrNSksbSh0aGlzLHQrMyx0KzQpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBlPTB8dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT1lPyIiOjA9PT1hcmd1bWVudHMubGVuZ3RoP1ModGhpcywwLGUpOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0hMTtpZigodm9pZCAwPT09dHx8dDwwKSYmKHQ9MCksdD50aGlzLmxlbmd0aClyZXR1cm4iIjtpZigodm9pZCAwPT09cnx8cj50aGlzLmxlbmd0aCkmJihyPXRoaXMubGVuZ3RoKSxyPD0wKXJldHVybiIiO2lmKChyPj4+PTApPD0odD4+Pj0wKSlyZXR1cm4iIjtmb3IoZXx8KGU9InV0ZjgiKTs7KXN3aXRjaChlKXtjYXNlImhleCI6cmV0dXJuIFIodGhpcyx0LHIpO2Nhc2UidXRmOCI6Y2FzZSJ1dGYtOCI6cmV0dXJuIFModGhpcyx0LHIpO2Nhc2UiYXNjaWkiOnJldHVybiBQKHRoaXMsdCxyKTtjYXNlImxhdGluMSI6Y2FzZSJiaW5hcnkiOnJldHVybiBEKHRoaXMsdCxyKTtjYXNlImJhc2U2NCI6cmV0dXJuIFQodGhpcyx0LHIpO2Nhc2UidWNzMiI6Y2FzZSJ1Y3MtMiI6Y2FzZSJ1dGYxNmxlIjpjYXNlInV0Zi0xNmxlIjpyZXR1cm4gTyh0aGlzLHQscik7ZGVmYXVsdDppZihuKXRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIrZSk7ZT0oZSsiIikudG9Mb3dlckNhc2UoKSxuPSEwfX0uYXBwbHkodGhpcyxhcmd1bWVudHMpfSx1LnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oZSl7aWYoIXUuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciIpO3JldHVybiB0aGlzPT09ZXx8MD09PXUuY29tcGFyZSh0aGlzLGUpfSx1LnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7dmFyIGU9IiIscj10LklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiB0aGlzLmxlbmd0aD4wJiYoZT10aGlzLnRvU3RyaW5nKCJoZXgiLDAscikubWF0Y2goLy57Mn0vZykuam9pbigiICIpLHRoaXMubGVuZ3RoPnImJihlKz0iIC4uLiAiKSksIjxCdWZmZXIgIitlKyI+In0sdS5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihlLHQscixuLG8pe2lmKCF1LmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTtpZih2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1yJiYocj1lP2UubGVuZ3RoOjApLHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PW8mJihvPXRoaXMubGVuZ3RoKSx0PDB8fHI+ZS5sZW5ndGh8fG48MHx8bz50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigib3V0IG9mIHJhbmdlIGluZGV4Iik7aWYobj49byYmdD49cilyZXR1cm4gMDtpZihuPj1vKXJldHVybi0xO2lmKHQ+PXIpcmV0dXJuIDE7aWYodGhpcz09PWUpcmV0dXJuIDA7Zm9yKHZhciBpPShvPj4+PTApLShuPj4+PTApLGE9KHI+Pj49MCktKHQ+Pj49MCkscz1NYXRoLm1pbihpLGEpLGM9dGhpcy5zbGljZShuLG8pLGw9ZS5zbGljZSh0LHIpLGY9MDtmPHM7KytmKWlmKGNbZl0hPT1sW2ZdKXtpPWNbZl0sYT1sW2ZdO2JyZWFrfXJldHVybiBpPGE/LTE6YTxpPzE6MH0sdS5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybi0xIT09dGhpcy5pbmRleE9mKGUsdCxyKX0sdS5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbihlLHQscil7cmV0dXJuIHkodGhpcyxlLHQsciwhMCl9LHUucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4geSh0aGlzLGUsdCxyLCExKX0sdS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSx0LHIsbil7aWYodm9pZCAwPT09dCluPSJ1dGY4IixyPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKHZvaWQgMD09PXImJiJzdHJpbmciPT10eXBlb2YgdCluPXQscj10aGlzLmxlbmd0aCx0PTA7ZWxzZXtpZighaXNGaW5pdGUodCkpdGhyb3cgbmV3IEVycm9yKCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCIpO3R8PTAsaXNGaW5pdGUocik/KHJ8PTAsdm9pZCAwPT09biYmKG49InV0ZjgiKSk6KG49cixyPXZvaWQgMCl9dmFyIG89dGhpcy5sZW5ndGgtdDtpZigodm9pZCAwPT09cnx8cj5vKSYmKHI9byksZS5sZW5ndGg+MCYmKHI8MHx8dDwwKXx8dD50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMiKTtufHwobj0idXRmOCIpO2Zvcih2YXIgaT0hMTs7KXN3aXRjaChuKXtjYXNlImhleCI6cmV0dXJuIGcodGhpcyxlLHQscik7Y2FzZSJ1dGY4IjpjYXNlInV0Zi04IjpyZXR1cm4gdih0aGlzLGUsdCxyKTtjYXNlImFzY2lpIjpyZXR1cm4gdyh0aGlzLGUsdCxyKTtjYXNlImxhdGluMSI6Y2FzZSJiaW5hcnkiOnJldHVybiBfKHRoaXMsZSx0LHIpO2Nhc2UiYmFzZTY0IjpyZXR1cm4gYih0aGlzLGUsdCxyKTtjYXNlInVjczIiOmNhc2UidWNzLTIiOmNhc2UidXRmMTZsZSI6Y2FzZSJ1dGYtMTZsZSI6cmV0dXJuIEEodGhpcyxlLHQscik7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZW5jb2Rpbmc6ICIrbik7bj0oIiIrbikudG9Mb3dlckNhc2UoKSxpPSEwfX0sdS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6IkJ1ZmZlciIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTt2YXIgaz00MDk2O2Z1bmN0aW9uIFAoZSx0LHIpe3ZhciBuPSIiO3I9TWF0aC5taW4oZS5sZW5ndGgscik7Zm9yKHZhciBvPXQ7bzxyOysrbyluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyZlW29dKTtyZXR1cm4gbn1mdW5jdGlvbiBEKGUsdCxyKXt2YXIgbj0iIjtyPU1hdGgubWluKGUubGVuZ3RoLHIpO2Zvcih2YXIgbz10O288cjsrK28pbis9U3RyaW5nLmZyb21DaGFyQ29kZShlW29dKTtyZXR1cm4gbn1mdW5jdGlvbiBSKGUsdCxyKXt2YXIgbj1lLmxlbmd0aDsoIXR8fHQ8MCkmJih0PTApLCghcnx8cjwwfHxyPm4pJiYocj1uKTtmb3IodmFyIG89IiIsaT10O2k8cjsrK2kpbys9aihlW2ldKTtyZXR1cm4gb31mdW5jdGlvbiBPKGUsdCxyKXtmb3IodmFyIG49ZS5zbGljZSh0LHIpLG89IiIsaT0wO2k8bi5sZW5ndGg7aSs9MilvKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG5baV0rMjU2Km5baSsxXSk7cmV0dXJuIG99ZnVuY3Rpb24gQyhlLHQscil7aWYoZSUxIT0wfHxlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm9mZnNldCBpcyBub3QgdWludCIpO2lmKGUrdD5yKXRocm93IG5ldyBSYW5nZUVycm9yKCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoIil9ZnVuY3Rpb24gTihlLHQscixuLG8saSl7aWYoIXUuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignImJ1ZmZlciIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKHQ+b3x8dDxpKXRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZihyK24+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIEYoZSx0LHIsbil7dDwwJiYodD02NTUzNSt0KzEpO2Zvcih2YXIgbz0wLGk9TWF0aC5taW4oZS5sZW5ndGgtciwyKTtvPGk7KytvKWVbcitvXT0odCYyNTU8PDgqKG4/bzoxLW8pKT4+PjgqKG4/bzoxLW8pfWZ1bmN0aW9uIE0oZSx0LHIsbil7dDwwJiYodD00Mjk0OTY3Mjk1K3QrMSk7Zm9yKHZhciBvPTAsaT1NYXRoLm1pbihlLmxlbmd0aC1yLDQpO288aTsrK28pZVtyK29dPXQ+Pj44KihuP286My1vKSYyNTV9ZnVuY3Rpb24gSShlLHQscixuLG8saSl7aWYocituPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKTtpZihyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkluZGV4IG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIEIoZSx0LHIsbixpKXtyZXR1cm4gaXx8SShlLDAsciw0KSxvLndyaXRlKGUsdCxyLG4sMjMsNCkscis0fWZ1bmN0aW9uIEwoZSx0LHIsbixpKXtyZXR1cm4gaXx8SShlLDAsciw4KSxvLndyaXRlKGUsdCxyLG4sNTIsOCkscis4fXUucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbj10aGlzLmxlbmd0aDtpZigoZT1+fmUpPDA/KGUrPW4pPDAmJihlPTApOmU+biYmKGU9biksKHQ9dm9pZCAwPT09dD9uOn5+dCk8MD8odCs9bik8MCYmKHQ9MCk6dD5uJiYodD1uKSx0PGUmJih0PWUpLHUuVFlQRURfQVJSQVlfU1VQUE9SVCkocj10aGlzLnN1YmFycmF5KGUsdCkpLl9fcHJvdG9fXz11LnByb3RvdHlwZTtlbHNle3ZhciBvPXQtZTtyPW5ldyB1KG8sdm9pZCAwKTtmb3IodmFyIGk9MDtpPG87KytpKXJbaV09dGhpc1tpK2VdfXJldHVybiByfSx1LnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uKGUsdCxyKXtlfD0wLHR8PTAscnx8QyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW2VdLG89MSxpPTA7KytpPHQmJihvKj0yNTYpOyluKz10aGlzW2UraV0qbztyZXR1cm4gbn0sdS5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbihlLHQscil7ZXw9MCx0fD0wLHJ8fEMoZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIG49dGhpc1tlKy0tdF0sbz0xO3Q+MCYmKG8qPTI1Nik7KW4rPXRoaXNbZSstLXRdKm87cmV0dXJuIG59LHUucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxDKGUsMSx0aGlzLmxlbmd0aCksdGhpc1tlXX0sdS5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fEMoZSwyLHRoaXMubGVuZ3RoKSx0aGlzW2VdfHRoaXNbZSsxXTw8OH0sdS5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fEMoZSwyLHRoaXMubGVuZ3RoKSx0aGlzW2VdPDw4fHRoaXNbZSsxXX0sdS5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fEMoZSw0LHRoaXMubGVuZ3RoKSwodGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrMTY3NzcyMTYqdGhpc1tlKzNdfSx1LnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8QyhlLDQsdGhpcy5sZW5ndGgpLDE2Nzc3MjE2KnRoaXNbZV0rKHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXSl9LHUucHJvdG90eXBlLnJlYWRJbnRMRT1mdW5jdGlvbihlLHQscil7ZXw9MCx0fD0wLHJ8fEMoZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIG49dGhpc1tlXSxvPTEsaT0wOysraTx0JiYobyo9MjU2KTspbis9dGhpc1tlK2ldKm87cmV0dXJuIG4+PShvKj0xMjgpJiYobi09TWF0aC5wb3coMiw4KnQpKSxufSx1LnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24oZSx0LHIpe2V8PTAsdHw9MCxyfHxDKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXQsbz0xLGk9dGhpc1tlKy0tbl07bj4wJiYobyo9MjU2KTspaSs9dGhpc1tlKy0tbl0qbztyZXR1cm4gaT49KG8qPTEyOCkmJihpLT1NYXRoLnBvdygyLDgqdCkpLGl9LHUucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fEMoZSwxLHRoaXMubGVuZ3RoKSwxMjgmdGhpc1tlXT8tMSooMjU1LXRoaXNbZV0rMSk6dGhpc1tlXX0sdS5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24oZSx0KXt0fHxDKGUsMix0aGlzLmxlbmd0aCk7dmFyIHI9dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIDMyNzY4JnI/NDI5NDkwMTc2MHxyOnJ9LHUucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uKGUsdCl7dHx8QyhlLDIsdGhpcy5sZW5ndGgpO3ZhciByPXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiAzMjc2OCZyPzQyOTQ5MDE3NjB8cjpyfSx1LnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxDKGUsNCx0aGlzLmxlbmd0aCksdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fSx1LnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxDKGUsNCx0aGlzLmxlbmd0aCksdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfSx1LnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxDKGUsNCx0aGlzLmxlbmd0aCksby5yZWFkKHRoaXMsZSwhMCwyMyw0KX0sdS5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8QyhlLDQsdGhpcy5sZW5ndGgpLG8ucmVhZCh0aGlzLGUsITEsMjMsNCl9LHUucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxDKGUsOCx0aGlzLmxlbmd0aCksby5yZWFkKHRoaXMsZSwhMCw1Miw4KX0sdS5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fEMoZSw4LHRoaXMubGVuZ3RoKSxvLnJlYWQodGhpcyxlLCExLDUyLDgpfSx1LnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbihlLHQscixuKXtlPStlLHR8PTAscnw9MCxufHxOKHRoaXMsZSx0LHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIG89MSxpPTA7Zm9yKHRoaXNbdF09MjU1JmU7KytpPHImJihvKj0yNTYpOyl0aGlzW3QraV09ZS9vJjI1NTtyZXR1cm4gdCtyfSx1LnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbihlLHQscixuKXtlPStlLHR8PTAscnw9MCxufHxOKHRoaXMsZSx0LHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIG89ci0xLGk9MTtmb3IodGhpc1t0K29dPTI1NSZlOy0tbz49MCYmKGkqPTI1Nik7KXRoaXNbdCtvXT1lL2kmMjU1O3JldHVybiB0K3J9LHUucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlPStlLHR8PTAscnx8Tih0aGlzLGUsdCwxLDI1NSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlR8fChlPU1hdGguZmxvb3IoZSkpLHRoaXNbdF09MjU1JmUsdCsxfSx1LnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT0rZSx0fD0wLHJ8fE4odGhpcyxlLHQsMiw2NTUzNSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09MjU1JmUsdGhpc1t0KzFdPWU+Pj44KTpGKHRoaXMsZSx0LCEwKSx0KzJ9LHUucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlPStlLHR8PTAscnx8Tih0aGlzLGUsdCwyLDY1NTM1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+OCx0aGlzW3QrMV09MjU1JmUpOkYodGhpcyxlLHQsITEpLHQrMn0sdS5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9K2UsdHw9MCxyfHxOKHRoaXMsZSx0LDQsNDI5NDk2NzI5NSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdCszXT1lPj4+MjQsdGhpc1t0KzJdPWU+Pj4xNix0aGlzW3QrMV09ZT4+PjgsdGhpc1t0XT0yNTUmZSk6TSh0aGlzLGUsdCwhMCksdCs0fSx1LnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT0rZSx0fD0wLHJ8fE4odGhpcyxlLHQsNCw0Mjk0OTY3Mjk1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+MjQsdGhpc1t0KzFdPWU+Pj4xNix0aGlzW3QrMl09ZT4+PjgsdGhpc1t0KzNdPTI1NSZlKTpNKHRoaXMsZSx0LCExKSx0KzR9LHUucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24oZSx0LHIsbil7aWYoZT0rZSx0fD0wLCFuKXt2YXIgbz1NYXRoLnBvdygyLDgqci0xKTtOKHRoaXMsZSx0LHIsby0xLC1vKX12YXIgaT0wLGE9MSxzPTA7Zm9yKHRoaXNbdF09MjU1JmU7KytpPHImJihhKj0yNTYpOyllPDAmJjA9PT1zJiYwIT09dGhpc1t0K2ktMV0mJihzPTEpLHRoaXNbdCtpXT0oZS9hPj4wKS1zJjI1NTtyZXR1cm4gdCtyfSx1LnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKGUsdCxyLG4pe2lmKGU9K2UsdHw9MCwhbil7dmFyIG89TWF0aC5wb3coMiw4KnItMSk7Tih0aGlzLGUsdCxyLG8tMSwtbyl9dmFyIGk9ci0xLGE9MSxzPTA7Zm9yKHRoaXNbdCtpXT0yNTUmZTstLWk+PTAmJihhKj0yNTYpOyllPDAmJjA9PT1zJiYwIT09dGhpc1t0K2krMV0mJihzPTEpLHRoaXNbdCtpXT0oZS9hPj4wKS1zJjI1NTtyZXR1cm4gdCtyfSx1LnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlPStlLHR8PTAscnx8Tih0aGlzLGUsdCwxLDEyNywtMTI4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlR8fChlPU1hdGguZmxvb3IoZSkpLGU8MCYmKGU9MjU1K2UrMSksdGhpc1t0XT0yNTUmZSx0KzF9LHUucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9K2UsdHw9MCxyfHxOKHRoaXMsZSx0LDIsMzI3NjcsLTMyNzY4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09MjU1JmUsdGhpc1t0KzFdPWU+Pj44KTpGKHRoaXMsZSx0LCEwKSx0KzJ9LHUucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9K2UsdHw9MCxyfHxOKHRoaXMsZSx0LDIsMzI3NjcsLTMyNzY4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09ZT4+PjgsdGhpc1t0KzFdPTI1NSZlKTpGKHRoaXMsZSx0LCExKSx0KzJ9LHUucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9K2UsdHw9MCxyfHxOKHRoaXMsZSx0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW3RdPTI1NSZlLHRoaXNbdCsxXT1lPj4+OCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCszXT1lPj4+MjQpOk0odGhpcyxlLHQsITApLHQrNH0sdS5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT0rZSx0fD0wLHJ8fE4odGhpcyxlLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxlPDAmJihlPTQyOTQ5NjcyOTUrZSsxKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09ZT4+PjI0LHRoaXNbdCsxXT1lPj4+MTYsdGhpc1t0KzJdPWU+Pj44LHRoaXNbdCszXT0yNTUmZSk6TSh0aGlzLGUsdCwhMSksdCs0fSx1LnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBCKHRoaXMsZSx0LCEwLHIpfSx1LnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBCKHRoaXMsZSx0LCExLHIpfSx1LnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gTCh0aGlzLGUsdCwhMCxyKX0sdS5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIEwodGhpcyxlLHQsITEscil9LHUucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oZSx0LHIsbil7aWYocnx8KHI9MCksbnx8MD09PW58fChuPXRoaXMubGVuZ3RoKSx0Pj1lLmxlbmd0aCYmKHQ9ZS5sZW5ndGgpLHR8fCh0PTApLG4+MCYmbjxyJiYobj1yKSxuPT09cilyZXR1cm4gMDtpZigwPT09ZS5sZW5ndGh8fDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMiKTtpZihyPDB8fHI+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzIik7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcyIpO24+dGhpcy5sZW5ndGgmJihuPXRoaXMubGVuZ3RoKSxlLmxlbmd0aC10PG4tciYmKG49ZS5sZW5ndGgtdCtyKTt2YXIgbyxpPW4tcjtpZih0aGlzPT09ZSYmcjx0JiZ0PG4pZm9yKG89aS0xO28+PTA7LS1vKWVbbyt0XT10aGlzW28rcl07ZWxzZSBpZihpPDFlM3x8IXUuVFlQRURfQVJSQVlfU1VQUE9SVClmb3Iobz0wO288aTsrK28pZVtvK3RdPXRoaXNbbytyXTtlbHNlIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheShyLHIraSksdCk7cmV0dXJuIGl9LHUucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oZSx0LHIsbil7aWYoInN0cmluZyI9PXR5cGVvZiBlKXtpZigic3RyaW5nIj09dHlwZW9mIHQ/KG49dCx0PTAscj10aGlzLmxlbmd0aCk6InN0cmluZyI9PXR5cGVvZiByJiYobj1yLHI9dGhpcy5sZW5ndGgpLDE9PT1lLmxlbmd0aCl7dmFyIG89ZS5jaGFyQ29kZUF0KDApO288MjU2JiYoZT1vKX1pZih2b2lkIDAhPT1uJiYic3RyaW5nIiE9dHlwZW9mIG4pdGhyb3cgbmV3IFR5cGVFcnJvcigiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZyIpO2lmKCJzdHJpbmciPT10eXBlb2YgbiYmIXUuaXNFbmNvZGluZyhuKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiK24pfWVsc2UibnVtYmVyIj09dHlwZW9mIGUmJihlJj0yNTUpO2lmKHQ8MHx8dGhpcy5sZW5ndGg8dHx8dGhpcy5sZW5ndGg8cil0aHJvdyBuZXcgUmFuZ2VFcnJvcigiT3V0IG9mIHJhbmdlIGluZGV4Iik7aWYocjw9dClyZXR1cm4gdGhpczt2YXIgaTtpZih0Pj4+PTAscj12b2lkIDA9PT1yP3RoaXMubGVuZ3RoOnI+Pj4wLGV8fChlPTApLCJudW1iZXIiPT10eXBlb2YgZSlmb3IoaT10O2k8cjsrK2kpdGhpc1tpXT1lO2Vsc2V7dmFyIGE9dS5pc0J1ZmZlcihlKT9lOlUobmV3IHUoZSxuKS50b1N0cmluZygpKSxzPWEubGVuZ3RoO2ZvcihpPTA7aTxyLXQ7KytpKXRoaXNbaSt0XT1hW2klc119cmV0dXJuIHRoaXN9O3ZhciB4PS9bXitcLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIGooZSl7cmV0dXJuIGU8MTY/IjAiK2UudG9TdHJpbmcoMTYpOmUudG9TdHJpbmcoMTYpfWZ1bmN0aW9uIFUoZSx0KXt2YXIgcjt0PXR8fDEvMDtmb3IodmFyIG49ZS5sZW5ndGgsbz1udWxsLGk9W10sYT0wO2E8bjsrK2Epe2lmKChyPWUuY2hhckNvZGVBdChhKSk+NTUyOTUmJnI8NTczNDQpe2lmKCFvKXtpZihyPjU2MzE5KXsodC09Myk+LTEmJmkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9aWYoYSsxPT09bil7KHQtPTMpPi0xJiZpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW89cjtjb250aW51ZX1pZihyPDU2MzIwKXsodC09Myk+LTEmJmkucHVzaCgyMzksMTkxLDE4OSksbz1yO2NvbnRpbnVlfXI9NjU1MzYrKG8tNTUyOTY8PDEwfHItNTYzMjApfWVsc2UgbyYmKHQtPTMpPi0xJiZpLnB1c2goMjM5LDE5MSwxODkpO2lmKG89bnVsbCxyPDEyOCl7aWYoKHQtPTEpPDApYnJlYWs7aS5wdXNoKHIpfWVsc2UgaWYocjwyMDQ4KXtpZigodC09Mik8MClicmVhaztpLnB1c2gocj4+NnwxOTIsNjMmcnwxMjgpfWVsc2UgaWYocjw2NTUzNil7aWYoKHQtPTMpPDApYnJlYWs7aS5wdXNoKHI+PjEyfDIyNCxyPj42JjYzfDEyOCw2MyZyfDEyOCl9ZWxzZXtpZighKHI8MTExNDExMikpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGNvZGUgcG9pbnQiKTtpZigodC09NCk8MClicmVhaztpLnB1c2gocj4+MTh8MjQwLHI+PjEyJjYzfDEyOCxyPj42JjYzfDEyOCw2MyZyfDEyOCl9fXJldHVybiBpfWZ1bmN0aW9uIHooZSl7cmV0dXJuIG4udG9CeXRlQXJyYXkoZnVuY3Rpb24oZSl7aWYoKGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJpbT9lLnRyaW0oKTplLnJlcGxhY2UoL15ccyt8XHMrJC9nLCIiKX0oZSkucmVwbGFjZSh4LCIiKSkubGVuZ3RoPDIpcmV0dXJuIiI7Zm9yKDtlLmxlbmd0aCU0IT0wOyllKz0iPSI7cmV0dXJuIGV9KGUpKX1mdW5jdGlvbiAkKGUsdCxyLG4pe2Zvcih2YXIgbz0wO288biYmIShvK3I+PXQubGVuZ3RofHxvPj1lLmxlbmd0aCk7KytvKXRbbytyXT1lW29dO3JldHVybiBvfX0pLmNhbGwodGhpcyxyKDgpKX0sZnVuY3Rpb24oZSx0KXt2YXIgcjtyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3I9cnx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKXx8KDAsZXZhbCkoInRoaXMiKX1jYXRjaChlKXsib2JqZWN0Ij09dHlwZW9mIHdpbmRvdyYmKHI9d2luZG93KX1lLmV4cG9ydHM9cn0sZnVuY3Rpb24oZSx0LHIpe3QuYnl0ZUxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1jKGUpLHI9dFswXSxuPXRbMV07cmV0dXJuIDMqKHIrbikvNC1ufSx0LnRvQnl0ZUFycmF5PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPWMoZSksbj1yWzBdLGE9clsxXSxzPW5ldyBpKGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gMyoodCtyKS80LXJ9KDAsbixhKSksdT0wLGw9YT4wP24tNDpuLGY9MDtmPGw7Zis9NCl0PW9bZS5jaGFyQ29kZUF0KGYpXTw8MTh8b1tlLmNoYXJDb2RlQXQoZisxKV08PDEyfG9bZS5jaGFyQ29kZUF0KGYrMildPDw2fG9bZS5jaGFyQ29kZUF0KGYrMyldLHNbdSsrXT10Pj4xNiYyNTUsc1t1KytdPXQ+PjgmMjU1LHNbdSsrXT0yNTUmdDtyZXR1cm4gMj09PWEmJih0PW9bZS5jaGFyQ29kZUF0KGYpXTw8MnxvW2UuY2hhckNvZGVBdChmKzEpXT4+NCxzW3UrK109MjU1JnQpLDE9PT1hJiYodD1vW2UuY2hhckNvZGVBdChmKV08PDEwfG9bZS5jaGFyQ29kZUF0KGYrMSldPDw0fG9bZS5jaGFyQ29kZUF0KGYrMildPj4yLHNbdSsrXT10Pj44JjI1NSxzW3UrK109MjU1JnQpLHN9LHQuZnJvbUJ5dGVBcnJheT1mdW5jdGlvbihlKXtmb3IodmFyIHQscj1lLmxlbmd0aCxvPXIlMyxpPVtdLGE9MCxzPXItbzthPHM7YSs9MTYzODMpaS5wdXNoKGYoZSxhLGErMTYzODM+cz9zOmErMTYzODMpKTtyZXR1cm4gMT09PW8/KHQ9ZVtyLTFdLGkucHVzaChuW3Q+PjJdK25bdDw8NCY2M10rIj09IikpOjI9PT1vJiYodD0oZVtyLTJdPDw4KStlW3ItMV0saS5wdXNoKG5bdD4+MTBdK25bdD4+NCY2M10rblt0PDwyJjYzXSsiPSIpKSxpLmpvaW4oIiIpfTtmb3IodmFyIG49W10sbz1bXSxpPSJ1bmRlZmluZWQiIT10eXBlb2YgVWludDhBcnJheT9VaW50OEFycmF5OkFycmF5LGE9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLHM9MCx1PWEubGVuZ3RoO3M8dTsrK3MpbltzXT1hW3NdLG9bYS5jaGFyQ29kZUF0KHMpXT1zO2Z1bmN0aW9uIGMoZSl7dmFyIHQ9ZS5sZW5ndGg7aWYodCU0PjApdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Iik7dmFyIHI9ZS5pbmRleE9mKCI9Iik7cmV0dXJuLTE9PT1yJiYocj10KSxbcixyPT09dD8wOjQtciU0XX1mdW5jdGlvbiBsKGUpe3JldHVybiBuW2U+PjE4JjYzXStuW2U+PjEyJjYzXStuW2U+PjYmNjNdK25bNjMmZV19ZnVuY3Rpb24gZihlLHQscil7Zm9yKHZhciBuLG89W10saT10O2k8cjtpKz0zKW49KGVbaV08PDE2JjE2NzExNjgwKSsoZVtpKzFdPDw4JjY1MjgwKSsoMjU1JmVbaSsyXSksby5wdXNoKGwobikpO3JldHVybiBvLmpvaW4oIiIpfW9bIi0iLmNoYXJDb2RlQXQoMCldPTYyLG9bIl8iLmNoYXJDb2RlQXQoMCldPTYzfSxmdW5jdGlvbihlLHQpe3QucmVhZD1mdW5jdGlvbihlLHQscixuLG8pe3ZhciBpLGEscz04Km8tbi0xLHU9KDE8PHMpLTEsYz11Pj4xLGw9LTcsZj1yP28tMTowLGQ9cj8tMToxLGg9ZVt0K2ZdO2ZvcihmKz1kLGk9aCYoMTw8LWwpLTEsaD4+PS1sLGwrPXM7bD4wO2k9MjU2KmkrZVt0K2ZdLGYrPWQsbC09OCk7Zm9yKGE9aSYoMTw8LWwpLTEsaT4+PS1sLGwrPW47bD4wO2E9MjU2KmErZVt0K2ZdLGYrPWQsbC09OCk7aWYoMD09PWkpaT0xLWM7ZWxzZXtpZihpPT09dSlyZXR1cm4gYT9OYU46MS8wKihoPy0xOjEpO2ErPU1hdGgucG93KDIsbiksaS09Y31yZXR1cm4oaD8tMToxKSphKk1hdGgucG93KDIsaS1uKX0sdC53cml0ZT1mdW5jdGlvbihlLHQscixuLG8saSl7dmFyIGEscyx1LGM9OCppLW8tMSxsPSgxPDxjKS0xLGY9bD4+MSxkPTIzPT09bz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAsaD1uPzA6aS0xLHA9bj8xOi0xLG09dDwwfHwwPT09dCYmMS90PDA/MTowO2Zvcih0PU1hdGguYWJzKHQpLGlzTmFOKHQpfHx0PT09MS8wPyhzPWlzTmFOKHQpPzE6MCxhPWwpOihhPU1hdGguZmxvb3IoTWF0aC5sb2codCkvTWF0aC5MTjIpLHQqKHU9TWF0aC5wb3coMiwtYSkpPDEmJihhLS0sdSo9MiksKHQrPWErZj49MT9kL3U6ZCpNYXRoLnBvdygyLDEtZikpKnU+PTImJihhKyssdS89MiksYStmPj1sPyhzPTAsYT1sKTphK2Y+PTE/KHM9KHQqdS0xKSpNYXRoLnBvdygyLG8pLGErPWYpOihzPXQqTWF0aC5wb3coMixmLTEpKk1hdGgucG93KDIsbyksYT0wKSk7bz49ODtlW3IraF09MjU1JnMsaCs9cCxzLz0yNTYsby09OCk7Zm9yKGE9YTw8b3xzLGMrPW87Yz4wO2VbcitoXT0yNTUmYSxoKz1wLGEvPTI1NixjLT04KTtlW3IraC1wXXw9MTI4Km19fSxmdW5jdGlvbihlLHQpe3ZhciByPXt9LnRvU3RyaW5nO2UuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4iW29iamVjdCBBcnJheV0iPT1yLmNhbGwoZSl9fSxmdW5jdGlvbih0LHIpe3QuZXhwb3J0cz1lfSxmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIoZSx0KXtmb3IodmFyIHI9MCxuPWUubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciBvPWVbbl07Ii4iPT09bz9lLnNwbGljZShuLDEpOiIuLiI9PT1vPyhlLnNwbGljZShuLDEpLHIrKyk6ciYmKGUuc3BsaWNlKG4sMSksci0tKX1pZih0KWZvcig7ci0tO3IpZS51bnNoaWZ0KCIuLiIpO3JldHVybiBlfXZhciBuPS9eKFwvP3wpKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteXC9dKz98KShcLlteLlwvXSp8KSkoPzpbXC9dKikkLyxvPWZ1bmN0aW9uKGUpe3JldHVybiBuLmV4ZWMoZSkuc2xpY2UoMSl9O2Z1bmN0aW9uIGkoZSx0KXtpZihlLmZpbHRlcilyZXR1cm4gZS5maWx0ZXIodCk7Zm9yKHZhciByPVtdLG49MDtuPGUubGVuZ3RoO24rKyl0KGVbbl0sbixlKSYmci5wdXNoKGVbbl0pO3JldHVybiByfXQucmVzb2x2ZT1mdW5jdGlvbigpe2Zvcih2YXIgdD0iIixuPSExLG89YXJndW1lbnRzLmxlbmd0aC0xO28+PS0xJiYhbjtvLS0pe3ZhciBhPW8+PTA/YXJndW1lbnRzW29dOmUuY3dkKCk7aWYoInN0cmluZyIhPXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzIik7YSYmKHQ9YSsiLyIrdCxuPSIvIj09PWEuY2hhckF0KDApKX1yZXR1cm4obj8iLyI6IiIpKyh0PXIoaSh0LnNwbGl0KCIvIiksKGZ1bmN0aW9uKGUpe3JldHVybiEhZX0pKSwhbikuam9pbigiLyIpKXx8Ii4ifSx0Lm5vcm1hbGl6ZT1mdW5jdGlvbihlKXt2YXIgbj10LmlzQWJzb2x1dGUoZSksbz0iLyI9PT1hKGUsLTEpO3JldHVybihlPXIoaShlLnNwbGl0KCIvIiksKGZ1bmN0aW9uKGUpe3JldHVybiEhZX0pKSwhbikuam9pbigiLyIpKXx8bnx8KGU9Ii4iKSxlJiZvJiYoZSs9Ii8iKSwobj8iLyI6IiIpK2V9LHQuaXNBYnNvbHV0ZT1mdW5jdGlvbihlKXtyZXR1cm4iLyI9PT1lLmNoYXJBdCgwKX0sdC5qb2luPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO3JldHVybiB0Lm5vcm1hbGl6ZShpKGUsKGZ1bmN0aW9uKGUsdCl7aWYoInN0cmluZyIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzIik7cmV0dXJuIGV9KSkuam9pbigiLyIpKX0sdC5yZWxhdGl2ZT1mdW5jdGlvbihlLHIpe2Z1bmN0aW9uIG4oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aCYmIiI9PT1lW3RdO3QrKyk7Zm9yKHZhciByPWUubGVuZ3RoLTE7cj49MCYmIiI9PT1lW3JdO3ItLSk7cmV0dXJuIHQ+cj9bXTplLnNsaWNlKHQsci10KzEpfWU9dC5yZXNvbHZlKGUpLnN1YnN0cigxKSxyPXQucmVzb2x2ZShyKS5zdWJzdHIoMSk7Zm9yKHZhciBvPW4oZS5zcGxpdCgiLyIpKSxpPW4oci5zcGxpdCgiLyIpKSxhPU1hdGgubWluKG8ubGVuZ3RoLGkubGVuZ3RoKSxzPWEsdT0wO3U8YTt1KyspaWYob1t1XSE9PWlbdV0pe3M9dTticmVha312YXIgYz1bXTtmb3IodT1zO3U8by5sZW5ndGg7dSsrKWMucHVzaCgiLi4iKTtyZXR1cm4oYz1jLmNvbmNhdChpLnNsaWNlKHMpKSkuam9pbigiLyIpfSx0LnNlcD0iLyIsdC5kZWxpbWl0ZXI9IjoiLHQuZGlybmFtZT1mdW5jdGlvbihlKXt2YXIgdD1vKGUpLHI9dFswXSxuPXRbMV07cmV0dXJuIHJ8fG4/KG4mJihuPW4uc3Vic3RyKDAsbi5sZW5ndGgtMSkpLHIrbik6Ii4ifSx0LmJhc2VuYW1lPWZ1bmN0aW9uKGUsdCl7dmFyIHI9byhlKVsyXTtyZXR1cm4gdCYmci5zdWJzdHIoLTEqdC5sZW5ndGgpPT09dCYmKHI9ci5zdWJzdHIoMCxyLmxlbmd0aC10Lmxlbmd0aCkpLHJ9LHQuZXh0bmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gbyhlKVszXX07dmFyIGE9ImIiPT09ImFiIi5zdWJzdHIoLTEpP2Z1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZS5zdWJzdHIodCxyKX06ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0PDAmJih0PWUubGVuZ3RoK3QpLGUuc3Vic3RyKHQscil9fSkuY2FsbCh0aGlzLHIoMTQpKX0sZnVuY3Rpb24oZSx0KXt2YXIgcixuLG89ZS5leHBvcnRzPXt9O2Z1bmN0aW9uIGkoKXt0aHJvdyBuZXcgRXJyb3IoInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBhKCl7dGhyb3cgbmV3IEVycm9yKCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBzKGUpe2lmKHI9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKHI9PT1pfHwhcikmJnNldFRpbWVvdXQpcmV0dXJuIHI9c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19IWZ1bmN0aW9uKCl7dHJ5e3I9ImZ1bmN0aW9uIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDppfWNhdGNoKGUpe3I9aX10cnl7bj0iZnVuY3Rpb24iPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDphfWNhdGNoKGUpe249YX19KCk7dmFyIHUsYz1bXSxsPSExLGY9LTE7ZnVuY3Rpb24gZCgpe2wmJnUmJihsPSExLHUubGVuZ3RoP2M9dS5jb25jYXQoYyk6Zj0tMSxjLmxlbmd0aCYmaCgpKX1mdW5jdGlvbiBoKCl7aWYoIWwpe3ZhciBlPXMoZCk7bD0hMDtmb3IodmFyIHQ9Yy5sZW5ndGg7dDspe2Zvcih1PWMsYz1bXTsrK2Y8dDspdSYmdVtmXS5ydW4oKTtmPS0xLHQ9Yy5sZW5ndGh9dT1udWxsLGw9ITEsZnVuY3Rpb24oZSl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KGUpO2lmKChuPT09YXx8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChlKTt0cnl7bihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fShlKX19ZnVuY3Rpb24gcChlLHQpe3RoaXMuZnVuPWUsdGhpcy5hcnJheT10fWZ1bmN0aW9uIG0oKXt9by5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl0W3ItMV09YXJndW1lbnRzW3JdO2MucHVzaChuZXcgcChlLHQpKSwxIT09Yy5sZW5ndGh8fGx8fHMoaCl9LHAucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LG8udGl0bGU9ImJyb3dzZXIiLG8uYnJvd3Nlcj0hMCxvLmVudj17fSxvLmFyZ3Y9W10sby52ZXJzaW9uPSIiLG8udmVyc2lvbnM9e30sby5vbj1tLG8uYWRkTGlzdGVuZXI9bSxvLm9uY2U9bSxvLm9mZj1tLG8ucmVtb3ZlTGlzdGVuZXI9bSxvLnJlbW92ZUFsbExpc3RlbmVycz1tLG8uZW1pdD1tLG8ucHJlcGVuZExpc3RlbmVyPW0sby5wcmVwZW5kT25jZUxpc3RlbmVyPW0sby5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119LG8uYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIil9LG8uY3dkPWZ1bmN0aW9uKCl7cmV0dXJuIi8ifSxvLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkIil9LG8udW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19XSl9KHQuZnMpO2NvbnN0IHI9ZS51bnBhY2tCcmlkZ2U7bGV0IG47dmFyIG89ZnVuY3Rpb24oZSl7Y29uc3QgdD17fTtjcmVkZW50aWFscz0ib21pdCI7dmFyIG4sbz12b2lkIDAhPT10P3Q6e30saT1yLkV4dCxhPXtvcGVuOmZ1bmN0aW9uKCl7cmV0dXJuIGkuY3VycmVudC5vcGVuLmFwcGx5KGkuY3VycmVudCxhcmd1bWVudHMpfSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBpLmN1cnJlbnQuY2xvc2UuYXBwbHkoaS5jdXJyZW50LGFyZ3VtZW50cyl9LHJlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5jdXJyZW50LnJlYWQuYXBwbHkoaS5jdXJyZW50LGFyZ3VtZW50cyl9LHdyaXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGkuY3VycmVudC53cml0ZS5hcHBseShpLmN1cnJlbnQsYXJndW1lbnRzKX0sdGVsbDpmdW5jdGlvbigpe3JldHVybiBpLmN1cnJlbnQudGVsbC5hcHBseShpLmN1cnJlbnQsYXJndW1lbnRzKX0sc2VlazpmdW5jdGlvbigpe3JldHVybiBpLmN1cnJlbnQuc2Vlay5hcHBseShpLmN1cnJlbnQsYXJndW1lbnRzKX0sY3JlYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGkuY3VycmVudC5jcmVhdGUuYXBwbHkoaS5jdXJyZW50LGFyZ3VtZW50cyl9fSxzPXt9O2ZvcihuIGluIG8pby5oYXNPd25Qcm9wZXJ0eShuKSYmKHNbbl09b1tuXSk7by5hcmd1bWVudHM9W10sby50aGlzUHJvZ3JhbT0iLi90aGlzLnByb2dyYW0iLG8ucXVpdD1mdW5jdGlvbihlLHQpe3Rocm93IHR9LG8ucHJlUnVuPVtdLG8ucG9zdFJ1bj1bXTt2YXIgdT0hMSxjPSExLGw9ITE7aWYoby5FTlZJUk9OTUVOVCl7aWYoIldFQiI9PT1vLkVOVklST05NRU5UKXU9ITA7ZWxzZSBpZigiV09SS0VSIj09PW8uRU5WSVJPTk1FTlQpYz0hMDtlbHNlIGlmKCJOT0RFIj09PW8uRU5WSVJPTk1FTlQpbD0hMDtlbHNlIGlmKCJTSEVMTCIhPT1vLkVOVklST05NRU5UKXRocm93IG5ldyBFcnJvcigiTW9kdWxlWydFTlZJUk9OTUVOVCddIHZhbHVlIGlzIG5vdCB2YWxpZC4gbXVzdCBiZSBvbmUgb2Y6IFdFQnxXT1JLRVJ8Tk9ERXxTSEVMTC4iKX1lbHNlIHU9Im9iamVjdCI9PXR5cGVvZiB3aW5kb3csYz0iZnVuY3Rpb24iPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxsPSJvYmplY3QiPT10eXBlb2YgcHJvY2VzcyYmImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVpcmUmJiF1JiYhYztmb3IobiBpbih1fHxjKSYmKG8ucmVhZD1mdW5jdGlvbihlKXt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbigiR0VUIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LGMmJihvLnJlYWRCaW5hcnk9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oIkdFVCIsZSwhMSksdC5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSxvLnJlYWRBc3luYz1mdW5jdGlvbihlLHQscil7dmFyIG49bmV3IFhNTEh0dHBSZXF1ZXN0O24ub3BlbigiR0VUIixlLCEwKSxuLnJlc3BvbnNlVHlwZT0iYXJyYXlidWZmZXIiLG4ub25sb2FkPWZ1bmN0aW9uKCl7MjAwPT1uLnN0YXR1c3x8MD09bi5zdGF0dXMmJm4ucmVzcG9uc2U/dChuLnJlc3BvbnNlKTpyKCl9LG4ub25lcnJvcj1yLG4uc2VuZChudWxsKX0sby5zZXRXaW5kb3dUaXRsZT1mdW5jdGlvbihlKXtkb2N1bWVudC50aXRsZT1lfSksby5wcmludD0idW5kZWZpbmVkIiE9dHlwZW9mIGNvbnNvbGU/Y29uc29sZS5sb2cuYmluZChjb25zb2xlKToidW5kZWZpbmVkIiE9dHlwZW9mIHByaW50P3ByaW50Om51bGwsby5wcmludEVycj0idW5kZWZpbmVkIiE9dHlwZW9mIHByaW50RXJyP3ByaW50RXJyOiJ1bmRlZmluZWQiIT10eXBlb2YgY29uc29sZSYmY29uc29sZS53YXJuLmJpbmQoY29uc29sZSl8fG8ucHJpbnQsby5wcmludD1vLnByaW50LG8ucHJpbnRFcnI9by5wcmludEVycixzKXMuaGFzT3duUHJvcGVydHkobikmJihvW25dPXNbbl0pO3M9dm9pZCAwO2Z1bmN0aW9uIGYoZSl7eSgheCk7dmFyIHQ9TDtyZXR1cm4gTD1MK2UrMTUmLTE2LHR9ZnVuY3Rpb24gZChlKXt5KCQpO3ZhciB0PUZbJD4+Ml0scj10K2UrMTUmLTE2O2lmKChGWyQ+PjJdPXIscj49cSkmJiFIKCkpcmV0dXJuIEZbJD4+Ml09dCwwO3JldHVybiB0fWZ1bmN0aW9uIGgoZSx0KXtyZXR1cm4gdHx8KHQ9MTYpLGU9TWF0aC5jZWlsKGUvdCkqdH1mdW5jdGlvbiBwKGUpe3N3aXRjaChlKXtjYXNlImkxIjpjYXNlImk4IjpyZXR1cm4gMTtjYXNlImkxNiI6cmV0dXJuIDI7Y2FzZSJpMzIiOnJldHVybiA0O2Nhc2UiaTY0IjpyZXR1cm4gODtjYXNlImZsb2F0IjpyZXR1cm4gNDtjYXNlImRvdWJsZSI6cmV0dXJuIDg7ZGVmYXVsdDppZigiKiI9PT1lW2UubGVuZ3RoLTFdKXJldHVybiA0O2lmKCJpIj09PWVbMF0pe3ZhciB0PXBhcnNlSW50KGUuc3Vic3RyKDEpKTtyZXR1cm4geSh0JTg9PTApLHQvOH1yZXR1cm4gMH19bmV3IEFycmF5KDApO3ZhciBtPTA7ZnVuY3Rpb24geShlLHQpe2V8fHJyKCJBc3NlcnRpb24gZmFpbGVkOiAiK3QpfWZ1bmN0aW9uIEUoZSx0LHIsbil7c3dpdGNoKCIqIj09PShyPXJ8fCJpOCIpLmNoYXJBdChyLmxlbmd0aC0xKSYmKHI9ImkzMiIpLHIpe2Nhc2UiaTEiOmNhc2UiaTgiOlJbZT4+MF09dDticmVhaztjYXNlImkxNiI6Q1tlPj4xXT10O2JyZWFrO2Nhc2UiaTMyIjpGW2U+PjJdPXQ7YnJlYWs7Y2FzZSJpNjQiOnRlbXBJNjQ9W3Q+Pj4wLCh0ZW1wRG91YmxlPXQsK25lKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8oMHxhZSgraWUodGVtcERvdWJsZS80Mjk0OTY3Mjk2KSw0Mjk0OTY3Mjk1KSk+Pj4wOn5+K29lKCh0ZW1wRG91YmxlLSsofn50ZW1wRG91YmxlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sRltlPj4yXT10ZW1wSTY0WzBdLEZbZSs0Pj4yXT10ZW1wSTY0WzFdO2JyZWFrO2Nhc2UiZmxvYXQiOklbZT4+Ml09dDticmVhaztjYXNlImRvdWJsZSI6QltlPj4zXT10O2JyZWFrO2RlZmF1bHQ6cnIoImludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICIrcil9fWZ1bmN0aW9uIGcoZSx0LHIsbil7dmFyIG8saTsibnVtYmVyIj09dHlwZW9mIGU/KG89ITAsaT1lKToobz0hMSxpPWUubGVuZ3RoKTt2YXIgYSxzPSJzdHJpbmciPT10eXBlb2YgdD90Om51bGw7aWYoYT00PT1yP246WyJmdW5jdGlvbiI9PXR5cGVvZiBKdD9KdDpmLFF0LGYsZF1bdm9pZCAwPT09cj8yOnJdKE1hdGgubWF4KGkscz8xOnQubGVuZ3RoKSksbyl7dmFyIHU7Zm9yKG49YSx5KDA9PSgzJmEpKSx1PWErKC00JmkpO248dTtuKz00KUZbbj4+Ml09MDtmb3IodT1hK2k7bjx1OylSW24rKz4+MF09MDtyZXR1cm4gYX1pZigiaTgiPT09cylyZXR1cm4gZS5zdWJhcnJheXx8ZS5zbGljZT9PLnNldChlLGEpOk8uc2V0KG5ldyBVaW50OEFycmF5KGUpLGEpLGE7Zm9yKHZhciBjLGwsaCxtPTA7bTxpOyl7dmFyIGc9ZVttXTswIT09KGM9c3x8dFttXSk/KCJpNjQiPT1jJiYoYz0iaTMyIiksRShhK20sZyxjKSxoIT09YyYmKGw9cChjKSxoPWMpLG0rPWwpOm0rK31yZXR1cm4gYX1mdW5jdGlvbiB2KGUsdCl7aWYoMD09PXR8fCFlKXJldHVybiIiO2Zvcih2YXIgcixuPTAsbz0wO258PXI9T1tlK28+PjBdLCgwIT1yfHx0KSYmKG8rKywhdHx8byE9dCk7KTt0fHwodD1vKTt2YXIgaT0iIjtpZihuPDEyOCl7Zm9yKHZhciBhO3Q+MDspYT1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxPLnN1YmFycmF5KGUsZStNYXRoLm1pbih0LDEwMjQpKSksaT1pP2krYTphLGUrPTEwMjQsdC09MTAyNDtyZXR1cm4gaX1yZXR1cm4gYihlKX12YXIgdz0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnZvaWQgMDtmdW5jdGlvbiBfKGUsdCl7Zm9yKHZhciByPXQ7ZVtyXTspKytyO2lmKHItdD4xNiYmZS5zdWJhcnJheSYmdylyZXR1cm4gdy5kZWNvZGUoZS5zdWJhcnJheSh0LHIpKTtmb3IodmFyIG4sbyxpLGEscyx1PSIiOzspe2lmKCEobj1lW3QrK10pKXJldHVybiB1O2lmKDEyOCZuKWlmKG89NjMmZVt0KytdLDE5MiE9KDIyNCZuKSlpZihpPTYzJmVbdCsrXSwyMjQ9PSgyNDAmbik/bj0oMTUmbik8PDEyfG88PDZ8aTooYT02MyZlW3QrK10sMjQwPT0oMjQ4Jm4pP249KDcmbik8PDE4fG88PDEyfGk8PDZ8YToocz02MyZlW3QrK10sbj0yNDg9PSgyNTImbik/KDMmbik8PDI0fG88PDE4fGk8PDEyfGE8PDZ8czooMSZuKTw8MzB8bzw8MjR8aTw8MTh8YTw8MTJ8czw8Nnw2MyZlW3QrK10pKSxuPDY1NTM2KXUrPVN0cmluZy5mcm9tQ2hhckNvZGUobik7ZWxzZXt2YXIgYz1uLTY1NTM2O3UrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Yz4+MTAsNTYzMjB8MTAyMyZjKX1lbHNlIHUrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJm4pPDw2fG8pO2Vsc2UgdSs9U3RyaW5nLmZyb21DaGFyQ29kZShuKX19ZnVuY3Rpb24gYihlKXtyZXR1cm4gXyhPLGUpfWZ1bmN0aW9uIEEoZSx0LHIsbil7aWYoIShuPjApKXJldHVybiAwO2Zvcih2YXIgbz1yLGk9cituLTEsYT0wO2E8ZS5sZW5ndGg7KythKXt2YXIgcz1lLmNoYXJDb2RlQXQoYSk7aWYocz49NTUyOTYmJnM8PTU3MzQzJiYocz02NTUzNisoKDEwMjMmcyk8PDEwKXwxMDIzJmUuY2hhckNvZGVBdCgrK2EpKSxzPD0xMjcpe2lmKHI+PWkpYnJlYWs7dFtyKytdPXN9ZWxzZSBpZihzPD0yMDQ3KXtpZihyKzE+PWkpYnJlYWs7dFtyKytdPTE5MnxzPj42LHRbcisrXT0xMjh8NjMmc31lbHNlIGlmKHM8PTY1NTM1KXtpZihyKzI+PWkpYnJlYWs7dFtyKytdPTIyNHxzPj4xMix0W3IrK109MTI4fHM+PjYmNjMsdFtyKytdPTEyOHw2MyZzfWVsc2UgaWYoczw9MjA5NzE1MSl7aWYociszPj1pKWJyZWFrO3RbcisrXT0yNDB8cz4+MTgsdFtyKytdPTEyOHxzPj4xMiY2Myx0W3IrK109MTI4fHM+PjYmNjMsdFtyKytdPTEyOHw2MyZzfWVsc2UgaWYoczw9NjcxMDg4NjMpe2lmKHIrND49aSlicmVhazt0W3IrK109MjQ4fHM+PjI0LHRbcisrXT0xMjh8cz4+MTgmNjMsdFtyKytdPTEyOHxzPj4xMiY2Myx0W3IrK109MTI4fHM+PjYmNjMsdFtyKytdPTEyOHw2MyZzfWVsc2V7aWYocis1Pj1pKWJyZWFrO3RbcisrXT0yNTJ8cz4+MzAsdFtyKytdPTEyOHxzPj4yNCY2Myx0W3IrK109MTI4fHM+PjE4JjYzLHRbcisrXT0xMjh8cz4+MTImNjMsdFtyKytdPTEyOHxzPj42JjYzLHRbcisrXT0xMjh8NjMmc319cmV0dXJuIHRbcl09MCxyLW99ZnVuY3Rpb24gVChlLHQscil7cmV0dXJuIEEoZSxPLHQscil9ZnVuY3Rpb24gUyhlKXtmb3IodmFyIHQ9MCxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBuPWUuY2hhckNvZGVBdChyKTtuPj01NTI5NiYmbjw9NTczNDMmJihuPTY1NTM2KygoMTAyMyZuKTw8MTApfDEwMjMmZS5jaGFyQ29kZUF0KCsrcikpLG48PTEyNz8rK3Q6dCs9bjw9MjA0Nz8yOm48PTY1NTM1PzM6bjw9MjA5NzE1MT80Om48PTY3MTA4ODYzPzU6Nn1yZXR1cm4gdH0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik7ZnVuY3Rpb24gayhlKXtmb3IodmFyIHQ9MCxyPSIiOzspe3ZhciBuPUZbZSs0KnQ+PjJdO2lmKDA9PW4pcmV0dXJuIHI7aWYoKyt0LG4+PTY1NTM2KXt2YXIgbz1uLTY1NTM2O3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8bz4+MTAsNTYzMjB8MTAyMyZvKX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUobil9fWZ1bmN0aW9uIFAoKXt2YXIgZT1mdW5jdGlvbigpe3ZhciBlPW5ldyBFcnJvcjtpZighZS5zdGFjayl7dHJ5e3Rocm93IG5ldyBFcnJvcigwKX1jYXRjaCh0KXtlPXR9aWYoIWUuc3RhY2spcmV0dXJuIihubyBzdGFjayB0cmFjZSBhdmFpbGFibGUpIn1yZXR1cm4gZS5zdGFjay50b1N0cmluZygpfSgpO3JldHVybiBvLmV4dHJhU3RhY2tUcmFjZSYmKGUrPSJcbiIrby5leHRyYVN0YWNrVHJhY2UoKSksZS5yZXBsYWNlKC9fX1pbXHdcZF9dKy9nLChmdW5jdGlvbihlKXtyZXR1cm4gZT09ZT9lOmUrIiBbIitlKyJdIn0pKX12YXIgRCxSLE8sQyxOLEYsTSxJLEIsTCx4LGosVSx6LCQ7ZnVuY3Rpb24gVyhlLHQpe3JldHVybiBlJXQ+MCYmKGUrPXQtZSV0KSxlfWZ1bmN0aW9uIFkoZSl7by5idWZmZXI9RD1lfWZ1bmN0aW9uIFYoKXtvLkhFQVA4PVI9bmV3IEludDhBcnJheShEKSxvLkhFQVAxNj1DPW5ldyBJbnQxNkFycmF5KEQpLG8uSEVBUDMyPUY9bmV3IEludDMyQXJyYXkoRCksby5IRUFQVTg9Tz1uZXcgVWludDhBcnJheShEKSxvLkhFQVBVMTY9Tj1uZXcgVWludDE2QXJyYXkoRCksby5IRUFQVTMyPU09bmV3IFVpbnQzMkFycmF5KEQpLG8uSEVBUEYzMj1JPW5ldyBGbG9hdDMyQXJyYXkoRCksby5IRUFQRjY0PUI9bmV3IEZsb2F0NjRBcnJheShEKX1mdW5jdGlvbiBIKCl7dmFyIGU9by51c2luZ1dhc20/NjU1MzY6MTY3NzcyMTYsdD0yMTQ3NDgzNjQ4LWU7aWYoRlskPj4yXT50KXJldHVybiExO3ZhciByPXE7Zm9yKHE9TWF0aC5tYXgocSwxNjc3NzIxNik7cTxGWyQ+PjJdOylxPXE8PTUzNjg3MDkxMj9XKDIqcSxlKTpNYXRoLm1pbihXKCgzKnErMjE0NzQ4MzY0OCkvNCxlKSx0KTt2YXIgbj1vLnJlYWxsb2NCdWZmZXIocSk7cmV0dXJuIG4mJm4uYnl0ZUxlbmd0aD09cT8oWShuKSxWKCksITApOihxPXIsITEpfUw9VT0kPTAseD0hMSxvLnJlYWxsb2NCdWZmZXJ8fChvLnJlYWxsb2NCdWZmZXI9ZnVuY3Rpb24oZSl7dmFyIHQ7dHJ5e2lmKEFycmF5QnVmZmVyLnRyYW5zZmVyKXQ9QXJyYXlCdWZmZXIudHJhbnNmZXIoRCxlKTtlbHNle3ZhciByPVI7dD1uZXcgQXJyYXlCdWZmZXIoZSksbmV3IEludDhBcnJheSh0KS5zZXQocil9fWNhdGNoKGUpe3JldHVybiExfXJldHVybiEhWHQodCkmJnR9KTt0cnl7RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEFycmF5QnVmZmVyLnByb3RvdHlwZSwiYnl0ZUxlbmd0aCIpLmdldCkobmV3IEFycmF5QnVmZmVyKDQpKX1jYXRjaChlKXsoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYnl0ZUxlbmd0aH0pfXZhciBHPW8uVE9UQUxfU1RBQ0t8fDUyNDI4ODAscT1vLlRPVEFMX01FTU9SWXx8MTY3NzcyMTY7aWYocTxHJiZvLnByaW50RXJyKCJUT1RBTF9NRU1PUlkgc2hvdWxkIGJlIGxhcmdlciB0aGFuIFRPVEFMX1NUQUNLLCB3YXMgIitxKyIhIChUT1RBTF9TVEFDSz0iK0crIikiKSxvLmJ1ZmZlcj9EPW8uYnVmZmVyOigib2JqZWN0Ij09dHlwZW9mIFdlYkFzc2VtYmx5JiYiZnVuY3Rpb24iPT10eXBlb2YgV2ViQXNzZW1ibHkuTWVtb3J5PyhvLndhc21NZW1vcnk9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpxLzY1NTM2fSksRD1vLndhc21NZW1vcnkuYnVmZmVyKTpEPW5ldyBBcnJheUJ1ZmZlcihxKSxvLmJ1ZmZlcj1EKSxWKCksRlswXT0xNjY4NTA5MDI5LENbMV09MjU0NTksMTE1IT09T1syXXx8OTkhPT1PWzNdKXRocm93IlJ1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEiO2Z1bmN0aW9uIFgoZSl7Zm9yKDtlLmxlbmd0aD4wOyl7dmFyIHQ9ZS5zaGlmdCgpO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiB0KXt2YXIgcj10LmZ1bmM7Im51bWJlciI9PXR5cGVvZiByP3ZvaWQgMD09PXQuYXJnP28uZHluQ2FsbF92KHIpOm8uZHluQ2FsbF92aShyLHQuYXJnKTpyKHZvaWQgMD09PXQuYXJnP251bGw6dC5hcmcpfWVsc2UgdCgpfX12YXIgSz1bXSxKPVtdLFo9W10sUT1bXSxlZT1bXSx0ZT0hMTtmdW5jdGlvbiByZShlLHQscil7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDsrK24pUlt0Kys+PjBdPWUuY2hhckNvZGVBdChuKTtyfHwoUlt0Pj4wXT0wKX12YXIgbmU9TWF0aC5hYnMsb2U9TWF0aC5jZWlsLGllPU1hdGguZmxvb3IsYWU9TWF0aC5taW4sc2U9MCx1ZT1udWxsO2Z1bmN0aW9uIGNlKGUpe3NlKyssby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZvLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoc2UpfWZ1bmN0aW9uIGxlKGUpe2lmKHNlLS0sby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZvLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoc2UpLDA9PXNlJiZ1ZSl7dmFyIHQ9dWU7dWU9bnVsbCx0KCl9fW8ucHJlbG9hZGVkSW1hZ2VzPXt9LG8ucHJlbG9hZGVkQXVkaW9zPXt9O2Z1bmN0aW9uIGZlKGUpe3JldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg/ZS5zdGFydHNXaXRoKCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsIik6MD09PWUuaW5kZXhPZigiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCIpfSFmdW5jdGlvbigpe3ZhciB0PSJ1bnBhY2sud2FzdCIscj0idW5wYWNrLnRlbXAuYXNtLmpzIjsiZnVuY3Rpb24iPT10eXBlb2Ygby5sb2NhdGVGaWxlJiYoZmUodCl8fCh0PW8ubG9jYXRlRmlsZSh0KSksZmUoZSl8fChlPW8ubG9jYXRlRmlsZShlKSksZmUocil8fChyPW8ubG9jYXRlRmlsZShyKSkpO3ZhciBuPXtnbG9iYWw6bnVsbCxlbnY6bnVsbCxhc20yd2FzbTp7ImY2NC1yZW0iOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUldH0sZGVidWdnZXI6ZnVuY3Rpb24oKXt9fSxwYXJlbnQ6b30saT1udWxsO2Z1bmN0aW9uIGEoKXt0cnl7aWYoby53YXNtQmluYXJ5KXJldHVybiBuZXcgVWludDhBcnJheShvLndhc21CaW5hcnkpO2lmKG8ucmVhZEJpbmFyeSlyZXR1cm4gby5yZWFkQmluYXJ5KGUpO3Rocm93Im9uIHRoZSB3ZWIsIHdlIG5lZWQgdGhlIHdhc20gYmluYXJ5IHRvIGJlIHByZWxvYWRlZCBhbmQgc2V0IG9uIE1vZHVsZVsnd2FzbUJpbmFyeSddLiBlbWNjLnB5IHdpbGwgZG8gdGhhdCBmb3IgeW91IHdoZW4gZ2VuZXJhdGluZyBIVE1MIChidXQgbm90IEpTKSJ9Y2F0Y2goZSl7cnIoZSl9fWZ1bmN0aW9uIHModCxyLHMpe2lmKCJvYmplY3QiIT10eXBlb2YgV2ViQXNzZW1ibHkpcmV0dXJuIG8ucHJpbnRFcnIoIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQiKSwhMTtpZighKG8ud2FzbU1lbW9yeSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpcmV0dXJuIG8ucHJpbnRFcnIoIm5vIG5hdGl2ZSB3YXNtIE1lbW9yeSBpbiB1c2UiKSwhMTtmdW5jdGlvbiBsKGUsdCl7KGk9ZS5leHBvcnRzKS5tZW1vcnkmJmZ1bmN0aW9uKGUpe3ZhciB0PW8uYnVmZmVyO2UuYnl0ZUxlbmd0aDx0LmJ5dGVMZW5ndGgmJm8ucHJpbnRFcnIoInRoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmUiKTt2YXIgcj1uZXcgSW50OEFycmF5KHQpO25ldyBJbnQ4QXJyYXkoZSkuc2V0KHIpLFkoZSksVigpfShpLm1lbW9yeSksby5hc209aSxvLnVzaW5nV2FzbT0hMCxsZSgpfWlmKHIubWVtb3J5PW8ud2FzbU1lbW9yeSxuLmdsb2JhbD17TmFOOk5hTixJbmZpbml0eToxLzB9LG5bImdsb2JhbC5NYXRoIl09TWF0aCxuLmVudj1yLGNlKCksby5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBvLmluc3RhbnRpYXRlV2FzbShuLGwpfWNhdGNoKGUpe3JldHVybiBvLnByaW50RXJyKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfWZ1bmN0aW9uIGYoZSl7bChlLmluc3RhbmNlLGUubW9kdWxlKX1mdW5jdGlvbiBkKHQpeyhvLndhc21CaW5hcnl8fCF1JiYhY3x8ImZ1bmN0aW9uIiE9dHlwZW9mIGZldGNoP25ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe2UoYSgpKX0pKTpmZXRjaChlLHtjcmVkZW50aWFsczoib21pdCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvdyJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICciK2UrIiciO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIGEoKX0pKSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsbil9KSkudGhlbih0KS5jYXRjaCgoZnVuY3Rpb24oZSl7by5wcmludEVycigiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogIitlKSxycihlKX0pKX1yZXR1cm4gby53YXNtQmluYXJ5fHwiZnVuY3Rpb24iIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fGZlKGUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/ZChmKTpXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhmZXRjaChlLHtjcmVkZW50aWFsczoib21pdCJ9KSxuKS50aGVuKGYpLmNhdGNoKChmdW5jdGlvbihlKXtvLnByaW50RXJyKCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogIitlKSxvLnByaW50RXJyKCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbiIpLGQoZil9KSkse319by5hc21QcmVsb2FkPW8uYXNtLG8ucmVhbGxvY0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZT1XKGUsby51c2luZ1dhc20/NjU1MzY6MTY3NzcyMTYpO3ZhciB0PW8uYnVmZmVyLmJ5dGVMZW5ndGg7aWYoby51c2luZ1dhc20pdHJ5e3JldHVybi0xIT09by53YXNtTWVtb3J5Lmdyb3coKGUtdCkvNjU1MzYpP28uYnVmZmVyPW8ud2FzbU1lbW9yeS5idWZmZXI6bnVsbH1jYXRjaChlKXtyZXR1cm4gbnVsbH19KGUpfSxvLmFzbT1mdW5jdGlvbihlLHQscil7aWYoISh0PXQpLnRhYmxlKXt2YXIgbj1vLndhc21UYWJsZVNpemU7dm9pZCAwPT09biYmKG49MTAyNCk7dmFyIGk9by53YXNtTWF4VGFibGVTaXplOyJvYmplY3QiPT10eXBlb2YgV2ViQXNzZW1ibHkmJiJmdW5jdGlvbiI9PXR5cGVvZiBXZWJBc3NlbWJseS5UYWJsZT90LnRhYmxlPXZvaWQgMCE9PWk/bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOm4sbWF4aW11bTppLGVsZW1lbnQ6ImFueWZ1bmMifSk6bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOm4sZWxlbWVudDoiYW55ZnVuYyJ9KTp0LnRhYmxlPW5ldyBBcnJheShuKSxvLndhc21UYWJsZT10LnRhYmxlfXZhciBhO3JldHVybiB0Lm1lbW9yeUJhc2V8fCh0Lm1lbW9yeUJhc2U9by5TVEFUSUNfQkFTRSksdC50YWJsZUJhc2V8fCh0LnRhYmxlQmFzZT0wKSwoYT1zKDAsdCkpfHxycigibm8gYmluYXJ5ZW4gbWV0aG9kIHN1Y2NlZWRlZC4gY29uc2lkZXIgZW5hYmxpbmcgbW9yZSBvcHRpb25zLCBsaWtlIGludGVycHJldGluZywgaWYgeW91IHdhbnQgdGhhdDogaHR0cHM6Ly9naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbi93aWtpL1dlYkFzc2VtYmx5I2JpbmFyeWVuLW1ldGhvZHMiKSxhfX0oKSxMPTY3OTg0LEoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe0d0KCl9fSx7ZnVuYzpmdW5jdGlvbigpe0h0KCl9fSx7ZnVuYzpmdW5jdGlvbigpe1Z0KCl9fSx7ZnVuYzpmdW5jdGlvbigpe1l0KCl9fSk7by5TVEFUSUNfQkFTRT0xMDI0LG8uU1RBVElDX0JVTVA9NjY5NjAsTCs9MTY7dmFyIGRlPXtsYXN0OjAsY2F1Z2h0OltdLGluZm9zOnt9LGRlQWRqdXN0OmZ1bmN0aW9uKGUpe2lmKCFlfHxkZS5pbmZvc1tlXSlyZXR1cm4gZTtmb3IodmFyIHQgaW4gZGUuaW5mb3Mpe3ZhciByPSt0O2lmKGRlLmluZm9zW3JdLmFkanVzdGVkPT09ZSlyZXR1cm4gcn1yZXR1cm4gZX0sYWRkUmVmOmZ1bmN0aW9uKGUpe2UmJmRlLmluZm9zW2VdLnJlZmNvdW50Kyt9LGRlY1JlZjpmdW5jdGlvbihlKXtpZihlKXt2YXIgdD1kZS5pbmZvc1tlXTt5KHQucmVmY291bnQ+MCksdC5yZWZjb3VudC0tLDAhPT10LnJlZmNvdW50fHx0LnJldGhyb3dufHwodC5kZXN0cnVjdG9yJiZvLmR5bkNhbGxfdmkodC5kZXN0cnVjdG9yLGUpLGRlbGV0ZSBkZS5pbmZvc1tlXSxoZShlKSl9fSxjbGVhclJlZjpmdW5jdGlvbihlKXtlJiYoZGUuaW5mb3NbZV0ucmVmY291bnQ9MCl9fTtmdW5jdGlvbiBoZShlKXt0cnl7cmV0dXJuIEt0KGUpfWNhdGNoKGUpe319ZnVuY3Rpb24gcGUoKXt2YXIgZT1kZS5sYXN0O2lmKCFlKXJldHVybiAwfChadCgwKSwwKTt2YXIgdD1kZS5pbmZvc1tlXSxyPXQudHlwZTtpZighcilyZXR1cm4gMHwoWnQoMCksZSk7dmFyIG49QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtvLl9fX2N4YV9pc19wb2ludGVyX3R5cGUocik7cGUuYnVmZmVyfHwocGUuYnVmZmVyPUp0KDQpKSxGW3BlLmJ1ZmZlcj4+Ml09ZSxlPXBlLmJ1ZmZlcjtmb3IodmFyIGk9MDtpPG4ubGVuZ3RoO2krKylpZihuW2ldJiZvLl9fX2N4YV9jYW5fY2F0Y2gobltpXSxyLGUpKXJldHVybiBlPUZbZT4+Ml0sdC5hZGp1c3RlZD1lLDB8KFp0KG5baV0pLGUpO3JldHVybiBlPUZbZT4+Ml0sMHwoWnQociksZSl9dmFyIG1lPXtFUEVSTToxLEVOT0VOVDoyLEVTUkNIOjMsRUlOVFI6NCxFSU86NSxFTlhJTzo2LEUyQklHOjcsRU5PRVhFQzo4LEVCQURGOjksRUNISUxEOjEwLEVBR0FJTjoxMSxFV09VTERCTE9DSzoxMSxFTk9NRU06MTIsRUFDQ0VTOjEzLEVGQVVMVDoxNCxFTk9UQkxLOjE1LEVCVVNZOjE2LEVFWElTVDoxNyxFWERFVjoxOCxFTk9ERVY6MTksRU5PVERJUjoyMCxFSVNESVI6MjEsRUlOVkFMOjIyLEVORklMRToyMyxFTUZJTEU6MjQsRU5PVFRZOjI1LEVUWFRCU1k6MjYsRUZCSUc6MjcsRU5PU1BDOjI4LEVTUElQRToyOSxFUk9GUzozMCxFTUxJTks6MzEsRVBJUEU6MzIsRURPTTozMyxFUkFOR0U6MzQsRU5PTVNHOjQyLEVJRFJNOjQzLEVDSFJORzo0NCxFTDJOU1lOQzo0NSxFTDNITFQ6NDYsRUwzUlNUOjQ3LEVMTlJORzo0OCxFVU5BVENIOjQ5LEVOT0NTSTo1MCxFTDJITFQ6NTEsRURFQURMSzozNSxFTk9MQ0s6MzcsRUJBREU6NTIsRUJBRFI6NTMsRVhGVUxMOjU0LEVOT0FOTzo1NSxFQkFEUlFDOjU2LEVCQURTTFQ6NTcsRURFQURMT0NLOjM1LEVCRk9OVDo1OSxFTk9TVFI6NjAsRU5PREFUQTo2MSxFVElNRTo2MixFTk9TUjo2MyxFTk9ORVQ6NjQsRU5PUEtHOjY1LEVSRU1PVEU6NjYsRU5PTElOSzo2NyxFQURWOjY4LEVTUk1OVDo2OSxFQ09NTTo3MCxFUFJPVE86NzEsRU1VTFRJSE9QOjcyLEVET1RET1Q6NzMsRUJBRE1TRzo3NCxFTk9UVU5JUTo3NixFQkFERkQ6NzcsRVJFTUNIRzo3OCxFTElCQUNDOjc5LEVMSUJCQUQ6ODAsRUxJQlNDTjo4MSxFTElCTUFYOjgyLEVMSUJFWEVDOjgzLEVOT1NZUzozOCxFTk9URU1QVFk6MzksRU5BTUVUT09MT05HOjM2LEVMT09QOjQwLEVPUE5PVFNVUFA6OTUsRVBGTk9TVVBQT1JUOjk2LEVDT05OUkVTRVQ6MTA0LEVOT0JVRlM6MTA1LEVBRk5PU1VQUE9SVDo5NyxFUFJPVE9UWVBFOjkxLEVOT1RTT0NLOjg4LEVOT1BST1RPT1BUOjkyLEVTSFVURE9XTjoxMDgsRUNPTk5SRUZVU0VEOjExMSxFQUREUklOVVNFOjk4LEVDT05OQUJPUlRFRDoxMDMsRU5FVFVOUkVBQ0g6MTAxLEVORVRET1dOOjEwMCxFVElNRURPVVQ6MTEwLEVIT1NURE9XTjoxMTIsRUhPU1RVTlJFQUNIOjExMyxFSU5QUk9HUkVTUzoxMTUsRUFMUkVBRFk6MTE0LEVERVNUQUREUlJFUTo4OSxFTVNHU0laRTo5MCxFUFJPVE9OT1NVUFBPUlQ6OTMsRVNPQ0tUTk9TVVBQT1JUOjk0LEVBRERSTk9UQVZBSUw6OTksRU5FVFJFU0VUOjEwMixFSVNDT05OOjEwNixFTk9UQ09OTjoxMDcsRVRPT01BTllSRUZTOjEwOSxFVVNFUlM6ODcsRURRVU9UOjEyMixFU1RBTEU6MTE2LEVOT1RTVVA6OTUsRU5PTUVESVVNOjEyMyxFSUxTRVE6ODQsRU9WRVJGTE9XOjc1LEVDQU5DRUxFRDoxMjUsRU5PVFJFQ09WRVJBQkxFOjEzMSxFT1dORVJERUFEOjEzMCxFU1RSUElQRTo4Nn07ZnVuY3Rpb24geWUoZSl7cmV0dXJuIG8uX19fZXJybm9fbG9jYXRpb24mJihGW28uX19fZXJybm9fbG9jYXRpb24oKT4+Ml09ZSksZX12YXIgRWU9ezA6IlN1Y2Nlc3MiLDE6Ik5vdCBzdXBlci11c2VyIiwyOiJObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IiwzOiJObyBzdWNoIHByb2Nlc3MiLDQ6IkludGVycnVwdGVkIHN5c3RlbSBjYWxsIiw1OiJJL08gZXJyb3IiLDY6Ik5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MiLDc6IkFyZyBsaXN0IHRvbyBsb25nIiw4OiJFeGVjIGZvcm1hdCBlcnJvciIsOToiQmFkIGZpbGUgbnVtYmVyIiwxMDoiTm8gY2hpbGRyZW4iLDExOiJObyBtb3JlIHByb2Nlc3NlcyIsMTI6Ik5vdCBlbm91Z2ggY29yZSIsMTM6IlBlcm1pc3Npb24gZGVuaWVkIiwxNDoiQmFkIGFkZHJlc3MiLDE1OiJCbG9jayBkZXZpY2UgcmVxdWlyZWQiLDE2OiJNb3VudCBkZXZpY2UgYnVzeSIsMTc6IkZpbGUgZXhpc3RzIiwxODoiQ3Jvc3MtZGV2aWNlIGxpbmsiLDE5OiJObyBzdWNoIGRldmljZSIsMjA6Ik5vdCBhIGRpcmVjdG9yeSIsMjE6IklzIGEgZGlyZWN0b3J5IiwyMjoiSW52YWxpZCBhcmd1bWVudCIsMjM6IlRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtIiwyNDoiVG9vIG1hbnkgb3BlbiBmaWxlcyIsMjU6Ik5vdCBhIHR5cGV3cml0ZXIiLDI2OiJUZXh0IGZpbGUgYnVzeSIsMjc6IkZpbGUgdG9vIGxhcmdlIiwyODoiTm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UiLDI5OiJJbGxlZ2FsIHNlZWsiLDMwOiJSZWFkIG9ubHkgZmlsZSBzeXN0ZW0iLDMxOiJUb28gbWFueSBsaW5rcyIsMzI6IkJyb2tlbiBwaXBlIiwzMzoiTWF0aCBhcmcgb3V0IG9mIGRvbWFpbiBvZiBmdW5jIiwzNDoiTWF0aCByZXN1bHQgbm90IHJlcHJlc2VudGFibGUiLDM1OiJGaWxlIGxvY2tpbmcgZGVhZGxvY2sgZXJyb3IiLDM2OiJGaWxlIG9yIHBhdGggbmFtZSB0b28gbG9uZyIsMzc6Ik5vIHJlY29yZCBsb2NrcyBhdmFpbGFibGUiLDM4OiJGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQiLDM5OiJEaXJlY3Rvcnkgbm90IGVtcHR5Iiw0MDoiVG9vIG1hbnkgc3ltYm9saWMgbGlua3MiLDQyOiJObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZSIsNDM6IklkZW50aWZpZXIgcmVtb3ZlZCIsNDQ6IkNoYW5uZWwgbnVtYmVyIG91dCBvZiByYW5nZSIsNDU6IkxldmVsIDIgbm90IHN5bmNocm9uaXplZCIsNDY6IkxldmVsIDMgaGFsdGVkIiw0NzoiTGV2ZWwgMyByZXNldCIsNDg6IkxpbmsgbnVtYmVyIG91dCBvZiByYW5nZSIsNDk6IlByb3RvY29sIGRyaXZlciBub3QgYXR0YWNoZWQiLDUwOiJObyBDU0kgc3RydWN0dXJlIGF2YWlsYWJsZSIsNTE6IkxldmVsIDIgaGFsdGVkIiw1MjoiSW52YWxpZCBleGNoYW5nZSIsNTM6IkludmFsaWQgcmVxdWVzdCBkZXNjcmlwdG9yIiw1NDoiRXhjaGFuZ2UgZnVsbCIsNTU6Ik5vIGFub2RlIiw1NjoiSW52YWxpZCByZXF1ZXN0IGNvZGUiLDU3OiJJbnZhbGlkIHNsb3QiLDU5OiJCYWQgZm9udCBmaWxlIGZtdCIsNjA6IkRldmljZSBub3QgYSBzdHJlYW0iLDYxOiJObyBkYXRhIChmb3Igbm8gZGVsYXkgaW8pIiw2MjoiVGltZXIgZXhwaXJlZCIsNjM6Ik91dCBvZiBzdHJlYW1zIHJlc291cmNlcyIsNjQ6Ik1hY2hpbmUgaXMgbm90IG9uIHRoZSBuZXR3b3JrIiw2NToiUGFja2FnZSBub3QgaW5zdGFsbGVkIiw2NjoiVGhlIG9iamVjdCBpcyByZW1vdGUiLDY3OiJUaGUgbGluayBoYXMgYmVlbiBzZXZlcmVkIiw2ODoiQWR2ZXJ0aXNlIGVycm9yIiw2OToiU3Jtb3VudCBlcnJvciIsNzA6IkNvbW11bmljYXRpb24gZXJyb3Igb24gc2VuZCIsNzE6IlByb3RvY29sIGVycm9yIiw3MjoiTXVsdGlob3AgYXR0ZW1wdGVkIiw3MzoiQ3Jvc3MgbW91bnQgcG9pbnQgKG5vdCByZWFsbHkgZXJyb3IpIiw3NDoiVHJ5aW5nIHRvIHJlYWQgdW5yZWFkYWJsZSBtZXNzYWdlIiw3NToiVmFsdWUgdG9vIGxhcmdlIGZvciBkZWZpbmVkIGRhdGEgdHlwZSIsNzY6IkdpdmVuIGxvZy4gbmFtZSBub3QgdW5pcXVlIiw3NzoiZi5kLiBpbnZhbGlkIGZvciB0aGlzIG9wZXJhdGlvbiIsNzg6IlJlbW90ZSBhZGRyZXNzIGNoYW5nZWQiLDc5OiJDYW4gICBhY2Nlc3MgYSBuZWVkZWQgc2hhcmVkIGxpYiIsODA6IkFjY2Vzc2luZyBhIGNvcnJ1cHRlZCBzaGFyZWQgbGliIiw4MToiLmxpYiBzZWN0aW9uIGluIGEub3V0IGNvcnJ1cHRlZCIsODI6IkF0dGVtcHRpbmcgdG8gbGluayBpbiB0b28gbWFueSBsaWJzIiw4MzoiQXR0ZW1wdGluZyB0byBleGVjIGEgc2hhcmVkIGxpYnJhcnkiLDg0OiJJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UiLDg2OiJTdHJlYW1zIHBpcGUgZXJyb3IiLDg3OiJUb28gbWFueSB1c2VycyIsODg6IlNvY2tldCBvcGVyYXRpb24gb24gbm9uLXNvY2tldCIsODk6IkRlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQiLDkwOiJNZXNzYWdlIHRvbyBsb25nIiw5MToiUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0Iiw5MjoiUHJvdG9jb2wgbm90IGF2YWlsYWJsZSIsOTM6IlVua25vd24gcHJvdG9jb2wiLDk0OiJTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkIiw5NToiTm90IHN1cHBvcnRlZCIsOTY6IlByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkIiw5NzoiQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbCBmYW1pbHkiLDk4OiJBZGRyZXNzIGFscmVhZHkgaW4gdXNlIiw5OToiQWRkcmVzcyBub3QgYXZhaWxhYmxlIiwxMDA6Ik5ldHdvcmsgaW50ZXJmYWNlIGlzIG5vdCBjb25maWd1cmVkIiwxMDE6Ik5ldHdvcmsgaXMgdW5yZWFjaGFibGUiLDEwMjoiQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrIiwxMDM6IkNvbm5lY3Rpb24gYWJvcnRlZCIsMTA0OiJDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIiLDEwNToiTm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZSIsMTA2OiJTb2NrZXQgaXMgYWxyZWFkeSBjb25uZWN0ZWQiLDEwNzoiU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQiLDEwODoiQ2FuJ3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24iLDEwOToiVG9vIG1hbnkgcmVmZXJlbmNlcyIsMTEwOiJDb25uZWN0aW9uIHRpbWVkIG91dCIsMTExOiJDb25uZWN0aW9uIHJlZnVzZWQiLDExMjoiSG9zdCBpcyBkb3duIiwxMTM6Ikhvc3QgaXMgdW5yZWFjaGFibGUiLDExNDoiU29ja2V0IGFscmVhZHkgY29ubmVjdGVkIiwxMTU6IkNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcyIsMTE2OiJTdGFsZSBmaWxlIGhhbmRsZSIsMTIyOiJRdW90YSBleGNlZWRlZCIsMTIzOiJObyBtZWRpdW0gKGluIHRhcGUgZHJpdmUpIiwxMjU6Ik9wZXJhdGlvbiBjYW5jZWxlZCIsMTMwOiJQcmV2aW91cyBvd25lciBkaWVkIiwxMzE6IlN0YXRlIG5vdCByZWNvdmVyYWJsZSJ9LGdlPXtzcGxpdFBhdGg6ZnVuY3Rpb24oZSl7cmV0dXJuL14oXC8/fCkoW1xzXFNdKj8pKCg/OlwuezEsMn18W15cL10rP3wpKFwuW14uXC9dKnwpKSg/OltcL10qKSQvLmV4ZWMoZSkuc2xpY2UoMSl9LG5vcm1hbGl6ZUFycmF5OmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPTAsbj1lLmxlbmd0aC0xO24+PTA7bi0tKXt2YXIgbz1lW25dOyIuIj09PW8/ZS5zcGxpY2UobiwxKToiLi4iPT09bz8oZS5zcGxpY2UobiwxKSxyKyspOnImJihlLnNwbGljZShuLDEpLHItLSl9aWYodClmb3IoO3I7ci0tKWUudW5zaGlmdCgiLi4iKTtyZXR1cm4gZX0sbm9ybWFsaXplOmZ1bmN0aW9uKGUpe3ZhciB0PSIvIj09PWUuY2hhckF0KDApLHI9Ii8iPT09ZS5zdWJzdHIoLTEpO3JldHVybihlPWdlLm5vcm1hbGl6ZUFycmF5KGUuc3BsaXQoIi8iKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiEhZX0pKSwhdCkuam9pbigiLyIpKXx8dHx8KGU9Ii4iKSxlJiZyJiYoZSs9Ii8iKSwodD8iLyI6IiIpK2V9LGRpcm5hbWU6ZnVuY3Rpb24oZSl7dmFyIHQ9Z2Uuc3BsaXRQYXRoKGUpLHI9dFswXSxuPXRbMV07cmV0dXJuIHJ8fG4/KG4mJihuPW4uc3Vic3RyKDAsbi5sZW5ndGgtMSkpLHIrbik6Ii4ifSxiYXNlbmFtZTpmdW5jdGlvbihlKXtpZigiLyI9PT1lKXJldHVybiIvIjt2YXIgdD1lLmxhc3RJbmRleE9mKCIvIik7cmV0dXJuLTE9PT10P2U6ZS5zdWJzdHIodCsxKX0sZXh0bmFtZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2Uuc3BsaXRQYXRoKGUpWzNdfSxqb2luOmZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO3JldHVybiBnZS5ub3JtYWxpemUoZS5qb2luKCIvIikpfSxqb2luMjpmdW5jdGlvbihlLHQpe3JldHVybiBnZS5ub3JtYWxpemUoZSsiLyIrdCl9LHJlc29sdmU6ZnVuY3Rpb24oKXtmb3IodmFyIGU9IiIsdD0hMSxyPWFyZ3VtZW50cy5sZW5ndGgtMTtyPj0tMSYmIXQ7ci0tKXt2YXIgbj1yPj0wP2FyZ3VtZW50c1tyXTpUZS5jd2QoKTtpZigic3RyaW5nIiE9dHlwZW9mIG4pdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTtpZighbilyZXR1cm4iIjtlPW4rIi8iK2UsdD0iLyI9PT1uLmNoYXJBdCgwKX1yZXR1cm4odD8iLyI6IiIpKyhlPWdlLm5vcm1hbGl6ZUFycmF5KGUuc3BsaXQoIi8iKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiEhZX0pKSwhdCkuam9pbigiLyIpKXx8Ii4ifSxyZWxhdGl2ZTpmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aCYmIiI9PT1lW3RdO3QrKyk7Zm9yKHZhciByPWUubGVuZ3RoLTE7cj49MCYmIiI9PT1lW3JdO3ItLSk7cmV0dXJuIHQ+cj9bXTplLnNsaWNlKHQsci10KzEpfWU9Z2UucmVzb2x2ZShlKS5zdWJzdHIoMSksdD1nZS5yZXNvbHZlKHQpLnN1YnN0cigxKTtmb3IodmFyIG49cihlLnNwbGl0KCIvIikpLG89cih0LnNwbGl0KCIvIikpLGk9TWF0aC5taW4obi5sZW5ndGgsby5sZW5ndGgpLGE9aSxzPTA7czxpO3MrKylpZihuW3NdIT09b1tzXSl7YT1zO2JyZWFrfXZhciB1PVtdO2ZvcihzPWE7czxuLmxlbmd0aDtzKyspdS5wdXNoKCIuLiIpO3JldHVybih1PXUuY29uY2F0KG8uc2xpY2UoYSkpKS5qb2luKCIvIil9fSx2ZT17dHR5czpbXSxpbml0OmZ1bmN0aW9uKCl7fSxzaHV0ZG93bjpmdW5jdGlvbigpe30scmVnaXN0ZXI6ZnVuY3Rpb24oZSx0KXt2ZS50dHlzW2VdPXtpbnB1dDpbXSxvdXRwdXQ6W10sb3BzOnR9LFRlLnJlZ2lzdGVyRGV2aWNlKGUsdmUuc3RyZWFtX29wcyl9LHN0cmVhbV9vcHM6e29wZW46ZnVuY3Rpb24oZSl7dmFyIHQ9dmUudHR5c1tlLm5vZGUucmRldl07aWYoIXQpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PREVWKTtlLnR0eT10LGUuc2Vla2FibGU9ITF9LGNsb3NlOmZ1bmN0aW9uKGUpe2UudHR5Lm9wcy5mbHVzaChlLnR0eSl9LGZsdXNoOmZ1bmN0aW9uKGUpe2UudHR5Lm9wcy5mbHVzaChlLnR0eSl9LHJlYWQ6ZnVuY3Rpb24oZSx0LHIsbixvKXtpZighZS50dHl8fCFlLnR0eS5vcHMuZ2V0X2NoYXIpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5YSU8pO2Zvcih2YXIgaT0wLGE9MDthPG47YSsrKXt2YXIgczt0cnl7cz1lLnR0eS5vcHMuZ2V0X2NoYXIoZS50dHkpfWNhdGNoKGUpe3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTyl9aWYodm9pZCAwPT09cyYmMD09PWkpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUFHQUlOKTtpZihudWxsPT1zKWJyZWFrO2krKyx0W3IrYV09c31yZXR1cm4gaSYmKGUubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKSksaX0sd3JpdGU6ZnVuY3Rpb24oZSx0LHIsbixvKXtpZighZS50dHl8fCFlLnR0eS5vcHMucHV0X2NoYXIpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5YSU8pO2Zvcih2YXIgaT0wO2k8bjtpKyspdHJ5e2UudHR5Lm9wcy5wdXRfY2hhcihlLnR0eSx0W3IraV0pfWNhdGNoKGUpe3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTyl9cmV0dXJuIG4mJihlLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpLGl9fSxkZWZhdWx0X3R0eV9vcHM6e2dldF9jaGFyOmZ1bmN0aW9uKGUpe2lmKCFlLmlucHV0Lmxlbmd0aCl7dmFyIHQ9bnVsbDtpZihsKXt2YXIgcj1uZXcgQnVmZmVyKDI1Niksbj0wLG89IndpbjMyIiE9cHJvY2Vzcy5wbGF0Zm9ybSxpPXByb2Nlc3Muc3RkaW4uZmQ7aWYobyl7dmFyIGE9ITE7dHJ5e2k9ZnMub3BlblN5bmMoIi9kZXYvc3RkaW4iLCJyIiksYT0hMH1jYXRjaChlKXt9fXRyeXtuPWZzLnJlYWRTeW5jKGksciwwLDI1NixudWxsKX1jYXRjaChlKXtpZigtMT09ZS50b1N0cmluZygpLmluZGV4T2YoIkVPRiIpKXRocm93IGU7bj0wfWEmJmZzLmNsb3NlU3luYyhpKSx0PW4+MD9yLnNsaWNlKDAsbikudG9TdHJpbmcoInV0Zi04Iik6bnVsbH1lbHNlInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJiJmdW5jdGlvbiI9PXR5cGVvZiB3aW5kb3cucHJvbXB0P251bGwhPT0odD13aW5kb3cucHJvbXB0KCJJbnB1dDogIikpJiYodCs9IlxuIik6ImZ1bmN0aW9uIj09dHlwZW9mIHJlYWRsaW5lJiZudWxsIT09KHQ9cmVhZGxpbmUoKSkmJih0Kz0iXG4iKTtpZighdClyZXR1cm4gbnVsbDtlLmlucHV0PSR0KHQsITApfXJldHVybiBlLmlucHV0LnNoaWZ0KCl9LHB1dF9jaGFyOmZ1bmN0aW9uKGUsdCl7bnVsbD09PXR8fDEwPT09dD8oby5wcmludChfKGUub3V0cHV0LDApKSxlLm91dHB1dD1bXSk6MCE9dCYmZS5vdXRwdXQucHVzaCh0KX0sZmx1c2g6ZnVuY3Rpb24oZSl7ZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aD4wJiYoby5wcmludChfKGUub3V0cHV0LDApKSxlLm91dHB1dD1bXSl9fSxkZWZhdWx0X3R0eTFfb3BzOntwdXRfY2hhcjpmdW5jdGlvbihlLHQpe251bGw9PT10fHwxMD09PXQ/KG8ucHJpbnRFcnIoXyhlLm91dHB1dCwwKSksZS5vdXRwdXQ9W10pOjAhPXQmJmUub3V0cHV0LnB1c2godCl9LGZsdXNoOmZ1bmN0aW9uKGUpe2Uub3V0cHV0JiZlLm91dHB1dC5sZW5ndGg+MCYmKG8ucHJpbnRFcnIoXyhlLm91dHB1dCwwKSksZS5vdXRwdXQ9W10pfX19LHdlPXtvcHNfdGFibGU6bnVsbCxtb3VudDpmdW5jdGlvbihlKXtyZXR1cm4gd2UuY3JlYXRlTm9kZShudWxsLCIvIiwxNjg5NSwwKX0sY3JlYXRlTm9kZTpmdW5jdGlvbihlLHQscixuKXtpZihUZS5pc0Jsa2RldihyKXx8VGUuaXNGSUZPKHIpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVQRVJNKTt3ZS5vcHNfdGFibGV8fCh3ZS5vcHNfdGFibGU9e2Rpcjp7bm9kZTp7Z2V0YXR0cjp3ZS5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6d2Uubm9kZV9vcHMuc2V0YXR0cixsb29rdXA6d2Uubm9kZV9vcHMubG9va3VwLG1rbm9kOndlLm5vZGVfb3BzLm1rbm9kLHJlbmFtZTp3ZS5ub2RlX29wcy5yZW5hbWUsdW5saW5rOndlLm5vZGVfb3BzLnVubGluayxybWRpcjp3ZS5ub2RlX29wcy5ybWRpcixyZWFkZGlyOndlLm5vZGVfb3BzLnJlYWRkaXIsc3ltbGluazp3ZS5ub2RlX29wcy5zeW1saW5rfSxzdHJlYW06e2xsc2Vlazp3ZS5zdHJlYW1fb3BzLmxsc2Vla319LGZpbGU6e25vZGU6e2dldGF0dHI6d2Uubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOndlLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTp7bGxzZWVrOndlLnN0cmVhbV9vcHMubGxzZWVrLHJlYWQ6d2Uuc3RyZWFtX29wcy5yZWFkLHdyaXRlOndlLnN0cmVhbV9vcHMud3JpdGUsYWxsb2NhdGU6d2Uuc3RyZWFtX29wcy5hbGxvY2F0ZSxtbWFwOndlLnN0cmVhbV9vcHMubW1hcCxtc3luYzp3ZS5zdHJlYW1fb3BzLm1zeW5jfX0sbGluazp7bm9kZTp7Z2V0YXR0cjp3ZS5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6d2Uubm9kZV9vcHMuc2V0YXR0cixyZWFkbGluazp3ZS5ub2RlX29wcy5yZWFkbGlua30sc3RyZWFtOnt9fSxjaHJkZXY6e25vZGU6e2dldGF0dHI6d2Uubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOndlLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTpUZS5jaHJkZXZfc3RyZWFtX29wc319KTt2YXIgbz1UZS5jcmVhdGVOb2RlKGUsdCxyLG4pO3JldHVybiBUZS5pc0RpcihvLm1vZGUpPyhvLm5vZGVfb3BzPXdlLm9wc190YWJsZS5kaXIubm9kZSxvLnN0cmVhbV9vcHM9d2Uub3BzX3RhYmxlLmRpci5zdHJlYW0sby5jb250ZW50cz17fSk6VGUuaXNGaWxlKG8ubW9kZSk/KG8ubm9kZV9vcHM9d2Uub3BzX3RhYmxlLmZpbGUubm9kZSxvLnN0cmVhbV9vcHM9d2Uub3BzX3RhYmxlLmZpbGUuc3RyZWFtLG8udXNlZEJ5dGVzPTAsby5jb250ZW50cz1udWxsKTpUZS5pc0xpbmsoby5tb2RlKT8oby5ub2RlX29wcz13ZS5vcHNfdGFibGUubGluay5ub2RlLG8uc3RyZWFtX29wcz13ZS5vcHNfdGFibGUubGluay5zdHJlYW0pOlRlLmlzQ2hyZGV2KG8ubW9kZSkmJihvLm5vZGVfb3BzPXdlLm9wc190YWJsZS5jaHJkZXYubm9kZSxvLnN0cmVhbV9vcHM9d2Uub3BzX3RhYmxlLmNocmRldi5zdHJlYW0pLG8udGltZXN0YW1wPURhdGUubm93KCksZSYmKGUuY29udGVudHNbdF09byksb30sZ2V0RmlsZURhdGFBc1JlZ3VsYXJBcnJheTpmdW5jdGlvbihlKXtpZihlLmNvbnRlbnRzJiZlLmNvbnRlbnRzLnN1YmFycmF5KXtmb3IodmFyIHQ9W10scj0wO3I8ZS51c2VkQnl0ZXM7KytyKXQucHVzaChlLmNvbnRlbnRzW3JdKTtyZXR1cm4gdH1yZXR1cm4gZS5jb250ZW50c30sZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29udGVudHM/ZS5jb250ZW50cy5zdWJhcnJheT9lLmNvbnRlbnRzLnN1YmFycmF5KDAsZS51c2VkQnl0ZXMpOm5ldyBVaW50OEFycmF5KGUuY29udGVudHMpOm5ldyBVaW50OEFycmF5fSxleHBhbmRGaWxlU3RvcmFnZTpmdW5jdGlvbihlLHQpe2lmKGUuY29udGVudHMmJmUuY29udGVudHMuc3ViYXJyYXkmJnQ+ZS5jb250ZW50cy5sZW5ndGgmJihlLmNvbnRlbnRzPXdlLmdldEZpbGVEYXRhQXNSZWd1bGFyQXJyYXkoZSksZS51c2VkQnl0ZXM9ZS5jb250ZW50cy5sZW5ndGgpLCFlLmNvbnRlbnRzfHxlLmNvbnRlbnRzLnN1YmFycmF5KXt2YXIgcj1lLmNvbnRlbnRzP2UuY29udGVudHMubGVuZ3RoOjA7aWYocj49dClyZXR1cm47dD1NYXRoLm1heCh0LHIqKHI8MTA0ODU3Nj8yOjEuMTI1KXwwKSwwIT1yJiYodD1NYXRoLm1heCh0LDI1NikpO3ZhciBuPWUuY29udGVudHM7cmV0dXJuIGUuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkodCksdm9pZChlLnVzZWRCeXRlcz4wJiZlLmNvbnRlbnRzLnNldChuLnN1YmFycmF5KDAsZS51c2VkQnl0ZXMpLDApKX1mb3IoIWUuY29udGVudHMmJnQ+MCYmKGUuY29udGVudHM9W10pO2UuY29udGVudHMubGVuZ3RoPHQ7KWUuY29udGVudHMucHVzaCgwKX0scmVzaXplRmlsZVN0b3JhZ2U6ZnVuY3Rpb24oZSx0KXtpZihlLnVzZWRCeXRlcyE9dCl7aWYoMD09dClyZXR1cm4gZS5jb250ZW50cz1udWxsLHZvaWQoZS51c2VkQnl0ZXM9MCk7aWYoIWUuY29udGVudHN8fGUuY29udGVudHMuc3ViYXJyYXkpe3ZhciByPWUuY29udGVudHM7cmV0dXJuIGUuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKHQpKSxyJiZlLmNvbnRlbnRzLnNldChyLnN1YmFycmF5KDAsTWF0aC5taW4odCxlLnVzZWRCeXRlcykpKSx2b2lkKGUudXNlZEJ5dGVzPXQpfWlmKGUuY29udGVudHN8fChlLmNvbnRlbnRzPVtdKSxlLmNvbnRlbnRzLmxlbmd0aD50KWUuY29udGVudHMubGVuZ3RoPXQ7ZWxzZSBmb3IoO2UuY29udGVudHMubGVuZ3RoPHQ7KWUuY29udGVudHMucHVzaCgwKTtlLnVzZWRCeXRlcz10fX0sbm9kZV9vcHM6e2dldGF0dHI6ZnVuY3Rpb24oZSl7dmFyIHQ9e307cmV0dXJuIHQuZGV2PVRlLmlzQ2hyZGV2KGUubW9kZSk/ZS5pZDoxLHQuaW5vPWUuaWQsdC5tb2RlPWUubW9kZSx0Lm5saW5rPTEsdC51aWQ9MCx0LmdpZD0wLHQucmRldj1lLnJkZXYsVGUuaXNEaXIoZS5tb2RlKT90LnNpemU9NDA5NjpUZS5pc0ZpbGUoZS5tb2RlKT90LnNpemU9ZS51c2VkQnl0ZXM6VGUuaXNMaW5rKGUubW9kZSk/dC5zaXplPWUubGluay5sZW5ndGg6dC5zaXplPTAsdC5hdGltZT1uZXcgRGF0ZShlLnRpbWVzdGFtcCksdC5tdGltZT1uZXcgRGF0ZShlLnRpbWVzdGFtcCksdC5jdGltZT1uZXcgRGF0ZShlLnRpbWVzdGFtcCksdC5ibGtzaXplPTQwOTYsdC5ibG9ja3M9TWF0aC5jZWlsKHQuc2l6ZS90LmJsa3NpemUpLHR9LHNldGF0dHI6ZnVuY3Rpb24oZSx0KXt2b2lkIDAhPT10Lm1vZGUmJihlLm1vZGU9dC5tb2RlKSx2b2lkIDAhPT10LnRpbWVzdGFtcCYmKGUudGltZXN0YW1wPXQudGltZXN0YW1wKSx2b2lkIDAhPT10LnNpemUmJndlLnJlc2l6ZUZpbGVTdG9yYWdlKGUsdC5zaXplKX0sbG9va3VwOmZ1bmN0aW9uKGUsdCl7dGhyb3cgVGUuZ2VuZXJpY0Vycm9yc1ttZS5FTk9FTlRdfSxta25vZDpmdW5jdGlvbihlLHQscixuKXtyZXR1cm4gd2UuY3JlYXRlTm9kZShlLHQscixuKX0scmVuYW1lOmZ1bmN0aW9uKGUsdCxyKXtpZihUZS5pc0RpcihlLm1vZGUpKXt2YXIgbjt0cnl7bj1UZS5sb29rdXBOb2RlKHQscil9Y2F0Y2goZSl7fWlmKG4pZm9yKHZhciBvIGluIG4uY29udGVudHMpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PVEVNUFRZKX1kZWxldGUgZS5wYXJlbnQuY29udGVudHNbZS5uYW1lXSxlLm5hbWU9cix0LmNvbnRlbnRzW3JdPWUsZS5wYXJlbnQ9dH0sdW5saW5rOmZ1bmN0aW9uKGUsdCl7ZGVsZXRlIGUuY29udGVudHNbdF19LHJtZGlyOmZ1bmN0aW9uKGUsdCl7dmFyIHI9VGUubG9va3VwTm9kZShlLHQpO2Zvcih2YXIgbiBpbiByLmNvbnRlbnRzKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT1RFTVBUWSk7ZGVsZXRlIGUuY29udGVudHNbdF19LHJlYWRkaXI6ZnVuY3Rpb24oZSl7dmFyIHQ9WyIuIiwiLi4iXTtmb3IodmFyIHIgaW4gZS5jb250ZW50cyllLmNvbnRlbnRzLmhhc093blByb3BlcnR5KHIpJiZ0LnB1c2gocik7cmV0dXJuIHR9LHN5bWxpbms6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXdlLmNyZWF0ZU5vZGUoZSx0LDQxNDcxLDApO3JldHVybiBuLmxpbms9cixufSxyZWFkbGluazpmdW5jdGlvbihlKXtpZighVGUuaXNMaW5rKGUubW9kZSkpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUlOVkFMKTtyZXR1cm4gZS5saW5rfX0sc3RyZWFtX29wczp7cmVhZDpmdW5jdGlvbihlLHQscixuLG8pe3ZhciBpPWUubm9kZS5jb250ZW50cztpZihvPj1lLm5vZGUudXNlZEJ5dGVzKXJldHVybiAwO3ZhciBhPU1hdGgubWluKGUubm9kZS51c2VkQnl0ZXMtbyxuKTtpZih5KGE+PTApLGE+OCYmaS5zdWJhcnJheSl0LnNldChpLnN1YmFycmF5KG8sbythKSxyKTtlbHNlIGZvcih2YXIgcz0wO3M8YTtzKyspdFtyK3NdPWlbbytzXTtyZXR1cm4gYX0sd3JpdGU6ZnVuY3Rpb24oZSx0LHIsbixvLGkpe2lmKCFuKXJldHVybiAwO3ZhciBhPWUubm9kZTtpZihhLnRpbWVzdGFtcD1EYXRlLm5vdygpLHQuc3ViYXJyYXkmJighYS5jb250ZW50c3x8YS5jb250ZW50cy5zdWJhcnJheSkpe2lmKGkpcmV0dXJuIGEuY29udGVudHM9dC5zdWJhcnJheShyLHIrbiksYS51c2VkQnl0ZXM9bixuO2lmKDA9PT1hLnVzZWRCeXRlcyYmMD09PW8pcmV0dXJuIGEuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkodC5zdWJhcnJheShyLHIrbikpLGEudXNlZEJ5dGVzPW4sbjtpZihvK248PWEudXNlZEJ5dGVzKXJldHVybiBhLmNvbnRlbnRzLnNldCh0LnN1YmFycmF5KHIscituKSxvKSxufWlmKHdlLmV4cGFuZEZpbGVTdG9yYWdlKGEsbytuKSxhLmNvbnRlbnRzLnN1YmFycmF5JiZ0LnN1YmFycmF5KWEuY29udGVudHMuc2V0KHQuc3ViYXJyYXkocixyK24pLG8pO2Vsc2UgZm9yKHZhciBzPTA7czxuO3MrKylhLmNvbnRlbnRzW28rc109dFtyK3NdO3JldHVybiBhLnVzZWRCeXRlcz1NYXRoLm1heChhLnVzZWRCeXRlcyxvK24pLG59LGxsc2VlazpmdW5jdGlvbihlLHQscil7dmFyIG49dDtpZigxPT09cj9uKz1lLnBvc2l0aW9uOjI9PT1yJiZUZS5pc0ZpbGUoZS5ub2RlLm1vZGUpJiYobis9ZS5ub2RlLnVzZWRCeXRlcyksbjwwKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7cmV0dXJuIG59LGFsbG9jYXRlOmZ1bmN0aW9uKGUsdCxyKXt3ZS5leHBhbmRGaWxlU3RvcmFnZShlLm5vZGUsdCtyKSxlLm5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KGUubm9kZS51c2VkQnl0ZXMsdCtyKX0sbW1hcDpmdW5jdGlvbihlLHQscixuLG8saSxhKXtpZighVGUuaXNGaWxlKGUubm9kZS5tb2RlKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTk9ERVYpO3ZhciBzLHUsYz1lLm5vZGUuY29udGVudHM7aWYoMiZhfHxjLmJ1ZmZlciE9PXQmJmMuYnVmZmVyIT09dC5idWZmZXIpe2lmKChvPjB8fG8rbjxlLm5vZGUudXNlZEJ5dGVzKSYmKGM9Yy5zdWJhcnJheT9jLnN1YmFycmF5KG8sbytuKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjLG8sbytuKSksdT0hMCwhKHM9SnQobikpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT01FTSk7dC5zZXQoYyxzKX1lbHNlIHU9ITEscz1jLmJ5dGVPZmZzZXQ7cmV0dXJue3B0cjpzLGFsbG9jYXRlZDp1fX0sbXN5bmM6ZnVuY3Rpb24oZSx0LHIsbixvKXtpZighVGUuaXNGaWxlKGUubm9kZS5tb2RlKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTk9ERVYpO2lmKDImbylyZXR1cm4gMDt3ZS5zdHJlYW1fb3BzLndyaXRlKGUsdCwwLG4sciwhMSk7cmV0dXJuIDB9fX0sX2U9e2Riczp7fSxpbmRleGVkREI6ZnVuY3Rpb24oKXtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGluZGV4ZWREQilyZXR1cm4gaW5kZXhlZERCO3ZhciBlPW51bGw7cmV0dXJuIm9iamVjdCI9PXR5cGVvZiB3aW5kb3cmJihlPXdpbmRvdy5pbmRleGVkREJ8fHdpbmRvdy5tb3pJbmRleGVkREJ8fHdpbmRvdy53ZWJraXRJbmRleGVkREJ8fHdpbmRvdy5tc0luZGV4ZWREQikseShlLCJJREJGUyB1c2VkLCBidXQgaW5kZXhlZERCIG5vdCBzdXBwb3J0ZWQiKSxlfSxEQl9WRVJTSU9OOjIxLERCX1NUT1JFX05BTUU6IkZJTEVfREFUQSIsbW91bnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHdlLm1vdW50LmFwcGx5KG51bGwsYXJndW1lbnRzKX0sc3luY2ZzOmZ1bmN0aW9uKGUsdCxyKXtfZS5nZXRMb2NhbFNldChlLChmdW5jdGlvbihuLG8pe2lmKG4pcmV0dXJuIHIobik7X2UuZ2V0UmVtb3RlU2V0KGUsKGZ1bmN0aW9uKGUsbil7aWYoZSlyZXR1cm4gcihlKTt2YXIgaT10P246byxhPXQ/bzpuO19lLnJlY29uY2lsZShpLGEscil9KSl9KSl9LGdldERCOmZ1bmN0aW9uKGUsdCl7dmFyIHIsbj1fZS5kYnNbZV07aWYobilyZXR1cm4gdChudWxsLG4pO3RyeXtyPV9lLmluZGV4ZWREQigpLm9wZW4oZSxfZS5EQl9WRVJTSU9OKX1jYXRjaChlKXtyZXR1cm4gdChlKX1pZighcilyZXR1cm4gdCgiVW5hYmxlIHRvIGNvbm5lY3QgdG8gSW5kZXhlZERCIik7ci5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oZSl7dmFyIHQscj1lLnRhcmdldC5yZXN1bHQsbj1lLnRhcmdldC50cmFuc2FjdGlvbjsodD1yLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoX2UuREJfU1RPUkVfTkFNRSk/bi5vYmplY3RTdG9yZShfZS5EQl9TVE9SRV9OQU1FKTpyLmNyZWF0ZU9iamVjdFN0b3JlKF9lLkRCX1NUT1JFX05BTUUpKS5pbmRleE5hbWVzLmNvbnRhaW5zKCJ0aW1lc3RhbXAiKXx8dC5jcmVhdGVJbmRleCgidGltZXN0YW1wIiwidGltZXN0YW1wIix7dW5pcXVlOiExfSl9LHIub25zdWNjZXNzPWZ1bmN0aW9uKCl7bj1yLnJlc3VsdCxfZS5kYnNbZV09bix0KG51bGwsbil9LHIub25lcnJvcj1mdW5jdGlvbihlKXt0KHRoaXMuZXJyb3IpLGUucHJldmVudERlZmF1bHQoKX19LGdldExvY2FsU2V0OmZ1bmN0aW9uKGUsdCl7dmFyIHI9e307ZnVuY3Rpb24gbihlKXtyZXR1cm4iLiIhPT1lJiYiLi4iIT09ZX1mdW5jdGlvbiBvKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZ2Uuam9pbjIoZSx0KX19Zm9yKHZhciBpPVRlLnJlYWRkaXIoZS5tb3VudHBvaW50KS5maWx0ZXIobikubWFwKG8oZS5tb3VudHBvaW50KSk7aS5sZW5ndGg7KXt2YXIgYSxzPWkucG9wKCk7dHJ5e2E9VGUuc3RhdChzKX1jYXRjaChlKXtyZXR1cm4gdChlKX1UZS5pc0RpcihhLm1vZGUpJiZpLnB1c2guYXBwbHkoaSxUZS5yZWFkZGlyKHMpLmZpbHRlcihuKS5tYXAobyhzKSkpLHJbc109e3RpbWVzdGFtcDphLm10aW1lfX1yZXR1cm4gdChudWxsLHt0eXBlOiJsb2NhbCIsZW50cmllczpyfSl9LGdldFJlbW90ZVNldDpmdW5jdGlvbihlLHQpe3ZhciByPXt9O19lLmdldERCKGUubW91bnRwb2ludCwoZnVuY3Rpb24oZSxuKXtpZihlKXJldHVybiB0KGUpO3RyeXt2YXIgbz1uLnRyYW5zYWN0aW9uKFtfZS5EQl9TVE9SRV9OQU1FXSwicmVhZG9ubHkiKTtvLm9uZXJyb3I9ZnVuY3Rpb24oZSl7dCh0aGlzLmVycm9yKSxlLnByZXZlbnREZWZhdWx0KCl9LG8ub2JqZWN0U3RvcmUoX2UuREJfU1RPUkVfTkFNRSkuaW5kZXgoInRpbWVzdGFtcCIpLm9wZW5LZXlDdXJzb3IoKS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oZSl7dmFyIG89ZS50YXJnZXQucmVzdWx0O2lmKCFvKXJldHVybiB0KG51bGwse3R5cGU6InJlbW90ZSIsZGI6bixlbnRyaWVzOnJ9KTtyW28ucHJpbWFyeUtleV09e3RpbWVzdGFtcDpvLmtleX0sby5jb250aW51ZSgpfX1jYXRjaChlKXtyZXR1cm4gdChlKX19KSl9LGxvYWRMb2NhbEVudHJ5OmZ1bmN0aW9uKGUsdCl7dmFyIHIsbjt0cnl7bj1UZS5sb29rdXBQYXRoKGUpLm5vZGUscj1UZS5zdGF0KGUpfWNhdGNoKGUpe3JldHVybiB0KGUpfXJldHVybiBUZS5pc0RpcihyLm1vZGUpP3QobnVsbCx7dGltZXN0YW1wOnIubXRpbWUsbW9kZTpyLm1vZGV9KTpUZS5pc0ZpbGUoci5tb2RlKT8obi5jb250ZW50cz13ZS5nZXRGaWxlRGF0YUFzVHlwZWRBcnJheShuKSx0KG51bGwse3RpbWVzdGFtcDpyLm10aW1lLG1vZGU6ci5tb2RlLGNvbnRlbnRzOm4uY29udGVudHN9KSk6dChuZXcgRXJyb3IoIm5vZGUgdHlwZSBub3Qgc3VwcG9ydGVkIikpfSxzdG9yZUxvY2FsRW50cnk6ZnVuY3Rpb24oZSx0LHIpe3RyeXtpZihUZS5pc0Rpcih0Lm1vZGUpKVRlLm1rZGlyKGUsdC5tb2RlKTtlbHNle2lmKCFUZS5pc0ZpbGUodC5tb2RlKSlyZXR1cm4gcihuZXcgRXJyb3IoIm5vZGUgdHlwZSBub3Qgc3VwcG9ydGVkIikpO1RlLndyaXRlRmlsZShlLHQuY29udGVudHMse2Nhbk93bjohMH0pfVRlLmNobW9kKGUsdC5tb2RlKSxUZS51dGltZShlLHQudGltZXN0YW1wLHQudGltZXN0YW1wKX1jYXRjaChlKXtyZXR1cm4gcihlKX1yKG51bGwpfSxyZW1vdmVMb2NhbEVudHJ5OmZ1bmN0aW9uKGUsdCl7dHJ5e1RlLmxvb2t1cFBhdGgoZSk7dmFyIHI9VGUuc3RhdChlKTtUZS5pc0RpcihyLm1vZGUpP1RlLnJtZGlyKGUpOlRlLmlzRmlsZShyLm1vZGUpJiZUZS51bmxpbmsoZSl9Y2F0Y2goZSl7cmV0dXJuIHQoZSl9dChudWxsKX0sbG9hZFJlbW90ZUVudHJ5OmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1lLmdldCh0KTtuLm9uc3VjY2Vzcz1mdW5jdGlvbihlKXtyKG51bGwsZS50YXJnZXQucmVzdWx0KX0sbi5vbmVycm9yPWZ1bmN0aW9uKGUpe3IodGhpcy5lcnJvciksZS5wcmV2ZW50RGVmYXVsdCgpfX0sc3RvcmVSZW1vdGVFbnRyeTpmdW5jdGlvbihlLHQscixuKXt2YXIgbz1lLnB1dChyLHQpO28ub25zdWNjZXNzPWZ1bmN0aW9uKCl7bihudWxsKX0sby5vbmVycm9yPWZ1bmN0aW9uKGUpe24odGhpcy5lcnJvciksZS5wcmV2ZW50RGVmYXVsdCgpfX0scmVtb3ZlUmVtb3RlRW50cnk6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuZGVsZXRlKHQpO24ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cihudWxsKX0sbi5vbmVycm9yPWZ1bmN0aW9uKGUpe3IodGhpcy5lcnJvciksZS5wcmV2ZW50RGVmYXVsdCgpfX0scmVjb25jaWxlOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0wLG89W107T2JqZWN0LmtleXMoZS5lbnRyaWVzKS5mb3JFYWNoKChmdW5jdGlvbihyKXt2YXIgaT1lLmVudHJpZXNbcl0sYT10LmVudHJpZXNbcl07KCFhfHxpLnRpbWVzdGFtcD5hLnRpbWVzdGFtcCkmJihvLnB1c2gociksbisrKX0pKTt2YXIgaT1bXTtpZihPYmplY3Qua2V5cyh0LmVudHJpZXMpLmZvckVhY2goKGZ1bmN0aW9uKHIpe3QuZW50cmllc1tyXTtlLmVudHJpZXNbcl18fChpLnB1c2gociksbisrKX0pKSwhbilyZXR1cm4gcihudWxsKTt2YXIgYT0wLHM9KCJyZW1vdGUiPT09ZS50eXBlP2UuZGI6dC5kYikudHJhbnNhY3Rpb24oW19lLkRCX1NUT1JFX05BTUVdLCJyZWFkd3JpdGUiKSx1PXMub2JqZWN0U3RvcmUoX2UuREJfU1RPUkVfTkFNRSk7ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZT9jLmVycm9yZWQ/dm9pZCAwOihjLmVycm9yZWQ9ITAscihlKSk6KythPj1uP3IobnVsbCk6dm9pZCAwfXMub25lcnJvcj1mdW5jdGlvbihlKXtjKHRoaXMuZXJyb3IpLGUucHJldmVudERlZmF1bHQoKX0sby5zb3J0KCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ImxvY2FsIj09PXQudHlwZT9fZS5sb2FkUmVtb3RlRW50cnkodSxlLChmdW5jdGlvbih0LHIpe2lmKHQpcmV0dXJuIGModCk7X2Uuc3RvcmVMb2NhbEVudHJ5KGUscixjKX0pKTpfZS5sb2FkTG9jYWxFbnRyeShlLChmdW5jdGlvbih0LHIpe2lmKHQpcmV0dXJuIGModCk7X2Uuc3RvcmVSZW1vdGVFbnRyeSh1LGUscixjKX0pKX0pKSxpLnNvcnQoKS5yZXZlcnNlKCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ImxvY2FsIj09PXQudHlwZT9fZS5yZW1vdmVMb2NhbEVudHJ5KGUsYyk6X2UucmVtb3ZlUmVtb3RlRW50cnkodSxlLGMpfSkpfX0sYmU9e2lzV2luZG93czohMSxzdGF0aWNJbml0OmZ1bmN0aW9uKCl7YmUuaXNXaW5kb3dzPSEhcHJvY2Vzcy5wbGF0Zm9ybS5tYXRjaCgvXndpbi8pO3ZhciBlPXByb2Nlc3MuYmluZGluZygiY29uc3RhbnRzIik7ZS5mcyYmKGU9ZS5mcyksYmUuZmxhZ3NGb3JOb2RlTWFwPXsxMDI0OmUuT19BUFBFTkQsNjQ6ZS5PX0NSRUFULDEyODplLk9fRVhDTCwwOmUuT19SRE9OTFksMjplLk9fUkRXUiw0MDk2OmUuT19TWU5DLDUxMjplLk9fVFJVTkMsMTplLk9fV1JPTkxZfX0sYnVmZmVyRnJvbTpmdW5jdGlvbihlKXtyZXR1cm4gQnVmZmVyLmFsbG9jP0J1ZmZlci5mcm9tKGUpOm5ldyBCdWZmZXIoZSl9LG1vdW50OmZ1bmN0aW9uKGUpe3JldHVybiB5KGwpLGJlLmNyZWF0ZU5vZGUobnVsbCwiLyIsYmUuZ2V0TW9kZShlLm9wdHMucm9vdCksMCl9LGNyZWF0ZU5vZGU6ZnVuY3Rpb24oZSx0LHIsbil7aWYoIVRlLmlzRGlyKHIpJiYhVGUuaXNGaWxlKHIpJiYhVGUuaXNMaW5rKHIpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7dmFyIG89VGUuY3JlYXRlTm9kZShlLHQscik7cmV0dXJuIG8ubm9kZV9vcHM9YmUubm9kZV9vcHMsby5zdHJlYW1fb3BzPWJlLnN0cmVhbV9vcHMsb30sZ2V0TW9kZTpmdW5jdGlvbihlKXt2YXIgdDt0cnl7dD1mcy5sc3RhdFN5bmMoZSksYmUuaXNXaW5kb3dzJiYodC5tb2RlPXQubW9kZXwoMjkyJnQubW9kZSk+PjIpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX1yZXR1cm4gdC5tb2RlfSxyZWFsUGF0aDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9W107ZS5wYXJlbnQhPT1lOyl0LnB1c2goZS5uYW1lKSxlPWUucGFyZW50O3JldHVybiB0LnB1c2goZS5tb3VudC5vcHRzLnJvb3QpLHQucmV2ZXJzZSgpLGdlLmpvaW4uYXBwbHkobnVsbCx0KX0sZmxhZ3NGb3JOb2RlOmZ1bmN0aW9uKGUpe2UmPS0yMDk3MTUzLGUmPS0yMDQ5LGUmPS0zMjc2OSxlJj0tNTI0Mjg5O3ZhciB0PTA7Zm9yKHZhciByIGluIGJlLmZsYWdzRm9yTm9kZU1hcCllJnImJih0fD1iZS5mbGFnc0Zvck5vZGVNYXBbcl0sZV49cik7aWYoZSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSU5WQUwpO3JldHVybiB0fSxub2RlX29wczp7Z2V0YXR0cjpmdW5jdGlvbihlKXt2YXIgdCxyPWJlLnJlYWxQYXRoKGUpO3RyeXt0PWZzLmxzdGF0U3luYyhyKX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWVbZS5jb2RlXSl9cmV0dXJuIGJlLmlzV2luZG93cyYmIXQuYmxrc2l6ZSYmKHQuYmxrc2l6ZT00MDk2KSxiZS5pc1dpbmRvd3MmJiF0LmJsb2NrcyYmKHQuYmxvY2tzPSh0LnNpemUrdC5ibGtzaXplLTEpL3QuYmxrc2l6ZXwwKSx7ZGV2OnQuZGV2LGlubzp0Lmlubyxtb2RlOnQubW9kZSxubGluazp0Lm5saW5rLHVpZDp0LnVpZCxnaWQ6dC5naWQscmRldjp0LnJkZXYsc2l6ZTp0LnNpemUsYXRpbWU6dC5hdGltZSxtdGltZTp0Lm10aW1lLGN0aW1lOnQuY3RpbWUsYmxrc2l6ZTp0LmJsa3NpemUsYmxvY2tzOnQuYmxvY2tzfX0sc2V0YXR0cjpmdW5jdGlvbihlLHQpe3ZhciByPWJlLnJlYWxQYXRoKGUpO3RyeXtpZih2b2lkIDAhPT10Lm1vZGUmJihmcy5jaG1vZFN5bmMocix0Lm1vZGUpLGUubW9kZT10Lm1vZGUpLHZvaWQgMCE9PXQudGltZXN0YW1wKXt2YXIgbj1uZXcgRGF0ZSh0LnRpbWVzdGFtcCk7ZnMudXRpbWVzU3luYyhyLG4sbil9dm9pZCAwIT09dC5zaXplJiZmcy50cnVuY2F0ZVN5bmMocix0LnNpemUpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX19LGxvb2t1cDpmdW5jdGlvbihlLHQpe3ZhciByPWdlLmpvaW4yKGJlLnJlYWxQYXRoKGUpLHQpLG49YmUuZ2V0TW9kZShyKTtyZXR1cm4gYmUuY3JlYXRlTm9kZShlLHQsbil9LG1rbm9kOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPWJlLmNyZWF0ZU5vZGUoZSx0LHIsbiksaT1iZS5yZWFsUGF0aChvKTt0cnl7VGUuaXNEaXIoby5tb2RlKT9mcy5ta2RpclN5bmMoaSxvLm1vZGUpOmZzLndyaXRlRmlsZVN5bmMoaSwiIix7bW9kZTpvLm1vZGV9KX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWVbZS5jb2RlXSl9cmV0dXJuIG99LHJlbmFtZTpmdW5jdGlvbihlLHQscil7dmFyIG49YmUucmVhbFBhdGgoZSksbz1nZS5qb2luMihiZS5yZWFsUGF0aCh0KSxyKTt0cnl7ZnMucmVuYW1lU3luYyhuLG8pfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX19LHVubGluazpmdW5jdGlvbihlLHQpe3ZhciByPWdlLmpvaW4yKGJlLnJlYWxQYXRoKGUpLHQpO3RyeXtmcy51bmxpbmtTeW5jKHIpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX19LHJtZGlyOmZ1bmN0aW9uKGUsdCl7dmFyIHI9Z2Uuam9pbjIoYmUucmVhbFBhdGgoZSksdCk7dHJ5e2ZzLnJtZGlyU3luYyhyKX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWVbZS5jb2RlXSl9fSxyZWFkZGlyOmZ1bmN0aW9uKGUpe3ZhciB0PWJlLnJlYWxQYXRoKGUpO3RyeXtyZXR1cm4gZnMucmVhZGRpclN5bmModCl9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lW2UuY29kZV0pfX0sc3ltbGluazpmdW5jdGlvbihlLHQscil7dmFyIG49Z2Uuam9pbjIoYmUucmVhbFBhdGgoZSksdCk7dHJ5e2ZzLnN5bWxpbmtTeW5jKHIsbil9Y2F0Y2goZSl7aWYoIWUuY29kZSl0aHJvdyBlO3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lW2UuY29kZV0pfX0scmVhZGxpbms6ZnVuY3Rpb24oZSl7dmFyIHQ9YmUucmVhbFBhdGgoZSk7dHJ5e3JldHVybiB0PWZzLnJlYWRsaW5rU3luYyh0KSx0PU5PREVKU19QQVRILnJlbGF0aXZlKE5PREVKU19QQVRILnJlc29sdmUoZS5tb3VudC5vcHRzLnJvb3QpLHQpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX19fSxzdHJlYW1fb3BzOntvcGVuOmZ1bmN0aW9uKGUpe3ZhciB0PWJlLnJlYWxQYXRoKGUubm9kZSk7dHJ5e1RlLmlzRmlsZShlLm5vZGUubW9kZSkmJihlLm5mZD1mcy5vcGVuU3luYyh0LGJlLmZsYWdzRm9yTm9kZShlLmZsYWdzKSkpfWNhdGNoKGUpe2lmKCFlLmNvZGUpdGhyb3cgZTt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX19LGNsb3NlOmZ1bmN0aW9uKGUpe3RyeXtUZS5pc0ZpbGUoZS5ub2RlLm1vZGUpJiZlLm5mZCYmZnMuY2xvc2VTeW5jKGUubmZkKX1jYXRjaChlKXtpZighZS5jb2RlKXRocm93IGU7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWVbZS5jb2RlXSl9fSxyZWFkOmZ1bmN0aW9uKGUsdCxyLG4sbyl7aWYoMD09PW4pcmV0dXJuIDA7dHJ5e3JldHVybiBmcy5yZWFkU3luYyhlLm5mZCxiZS5idWZmZXJGcm9tKHQuYnVmZmVyKSxyLG4sbyl9Y2F0Y2goZSl7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWVbZS5jb2RlXSl9fSx3cml0ZTpmdW5jdGlvbihlLHQscixuLG8pe3RyeXtyZXR1cm4gZnMud3JpdGVTeW5jKGUubmZkLGJlLmJ1ZmZlckZyb20odC5idWZmZXIpLHIsbixvKX1jYXRjaChlKXt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX19LGxsc2VlazpmdW5jdGlvbihlLHQscil7dmFyIG49dDtpZigxPT09ciluKz1lLnBvc2l0aW9uO2Vsc2UgaWYoMj09PXImJlRlLmlzRmlsZShlLm5vZGUubW9kZSkpdHJ5e24rPWZzLmZzdGF0U3luYyhlLm5mZCkuc2l6ZX1jYXRjaChlKXt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZVtlLmNvZGVdKX1pZihuPDApdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUlOVkFMKTtyZXR1cm4gbn19fSxBZT17RElSX01PREU6MTY4OTUsRklMRV9NT0RFOjMzMjc5LHJlYWRlcjpudWxsLG1vdW50OmZ1bmN0aW9uKGUpe3koYyksQWUucmVhZGVyfHwoQWUucmVhZGVyPW5ldyBGaWxlUmVhZGVyU3luYyk7dmFyIHQ9QWUuY3JlYXRlTm9kZShudWxsLCIvIixBZS5ESVJfTU9ERSwwKSxyPXt9O2Z1bmN0aW9uIG4oZSl7Zm9yKHZhciBuPWUuc3BsaXQoIi8iKSxvPXQsaT0wO2k8bi5sZW5ndGgtMTtpKyspe3ZhciBhPW4uc2xpY2UoMCxpKzEpLmpvaW4oIi8iKTtyW2FdfHwoclthXT1BZS5jcmVhdGVOb2RlKG8sbltpXSxBZS5ESVJfTU9ERSwwKSksbz1yW2FdfXJldHVybiBvfWZ1bmN0aW9uIG8oZSl7dmFyIHQ9ZS5zcGxpdCgiLyIpO3JldHVybiB0W3QubGVuZ3RoLTFdfXJldHVybiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGUub3B0cy5maWxlc3x8W10sKGZ1bmN0aW9uKGUpe0FlLmNyZWF0ZU5vZGUobihlLm5hbWUpLG8oZS5uYW1lKSxBZS5GSUxFX01PREUsMCxlLGUubGFzdE1vZGlmaWVkRGF0ZSl9KSksKGUub3B0cy5ibG9ic3x8W10pLmZvckVhY2goKGZ1bmN0aW9uKGUpe0FlLmNyZWF0ZU5vZGUobihlLm5hbWUpLG8oZS5uYW1lKSxBZS5GSUxFX01PREUsMCxlLmRhdGEpfSkpLChlLm9wdHMucGFja2FnZXN8fFtdKS5mb3JFYWNoKChmdW5jdGlvbihlKXtlLm1ldGFkYXRhLmZpbGVzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXQuZmlsZW5hbWUuc3Vic3RyKDEpO0FlLmNyZWF0ZU5vZGUobihyKSxvKHIpLEFlLkZJTEVfTU9ERSwwLGUuYmxvYi5zbGljZSh0LnN0YXJ0LHQuZW5kKSl9KSl9KSksdH0sY3JlYXRlTm9kZTpmdW5jdGlvbihlLHQscixuLG8saSl7dmFyIGE9VGUuY3JlYXRlTm9kZShlLHQscik7cmV0dXJuIGEubW9kZT1yLGEubm9kZV9vcHM9QWUubm9kZV9vcHMsYS5zdHJlYW1fb3BzPUFlLnN0cmVhbV9vcHMsYS50aW1lc3RhbXA9KGl8fG5ldyBEYXRlKS5nZXRUaW1lKCkseShBZS5GSUxFX01PREUhPT1BZS5ESVJfTU9ERSkscj09PUFlLkZJTEVfTU9ERT8oYS5zaXplPW8uc2l6ZSxhLmNvbnRlbnRzPW8pOihhLnNpemU9NDA5NixhLmNvbnRlbnRzPXt9KSxlJiYoZS5jb250ZW50c1t0XT1hKSxhfSxub2RlX29wczp7Z2V0YXR0cjpmdW5jdGlvbihlKXtyZXR1cm57ZGV2OjEsaW5vOnZvaWQgMCxtb2RlOmUubW9kZSxubGluazoxLHVpZDowLGdpZDowLHJkZXY6dm9pZCAwLHNpemU6ZS5zaXplLGF0aW1lOm5ldyBEYXRlKGUudGltZXN0YW1wKSxtdGltZTpuZXcgRGF0ZShlLnRpbWVzdGFtcCksY3RpbWU6bmV3IERhdGUoZS50aW1lc3RhbXApLGJsa3NpemU6NDA5NixibG9ja3M6TWF0aC5jZWlsKGUuc2l6ZS80MDk2KX19LHNldGF0dHI6ZnVuY3Rpb24oZSx0KXt2b2lkIDAhPT10Lm1vZGUmJihlLm1vZGU9dC5tb2RlKSx2b2lkIDAhPT10LnRpbWVzdGFtcCYmKGUudGltZXN0YW1wPXQudGltZXN0YW1wKX0sbG9va3VwOmZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PRU5UKX0sbWtub2Q6ZnVuY3Rpb24oZSx0LHIsbil7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRVBFUk0pfSxyZW5hbWU6ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVQRVJNKX0sdW5saW5rOmZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRVBFUk0pfSxybWRpcjpmdW5jdGlvbihlLHQpe3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVQRVJNKX0scmVhZGRpcjpmdW5jdGlvbihlKXt2YXIgdD1bIi4iLCIuLiJdO2Zvcih2YXIgciBpbiBlLmNvbnRlbnRzKWUuY29udGVudHMuaGFzT3duUHJvcGVydHkocikmJnQucHVzaChyKTtyZXR1cm4gdH0sc3ltbGluazpmdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRVBFUk0pfSxyZWFkbGluazpmdW5jdGlvbihlKXt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FUEVSTSl9fSxzdHJlYW1fb3BzOntyZWFkOmZ1bmN0aW9uKGUsdCxyLG4sbyl7aWYobz49ZS5ub2RlLnNpemUpcmV0dXJuIDA7dmFyIGk9ZS5ub2RlLmNvbnRlbnRzLnNsaWNlKG8sbytuKSxhPUFlLnJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihpKTtyZXR1cm4gdC5zZXQobmV3IFVpbnQ4QXJyYXkoYSksciksaS5zaXplfSx3cml0ZTpmdW5jdGlvbihlLHQscixuLG8pe3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTyl9LGxsc2VlazpmdW5jdGlvbihlLHQscil7dmFyIG49dDtpZigxPT09cj9uKz1lLnBvc2l0aW9uOjI9PT1yJiZUZS5pc0ZpbGUoZS5ub2RlLm1vZGUpJiYobis9ZS5ub2RlLnNpemUpLG48MCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSU5WQUwpO3JldHVybiBufX19O0wrPTE2LEwrPTE2O3ZhciBUZT17cm9vdDpudWxsLG1vdW50czpbXSxkZXZpY2VzOnt9LHN0cmVhbXM6W10sbmV4dElub2RlOjEsbmFtZVRhYmxlOm51bGwsY3VycmVudFBhdGg6Ii8iLGluaXRpYWxpemVkOiExLGlnbm9yZVBlcm1pc3Npb25zOiEwLHRyYWNraW5nRGVsZWdhdGU6e30sdHJhY2tpbmc6e29wZW5GbGFnczp7UkVBRDoxLFdSSVRFOjJ9fSxFcnJub0Vycm9yOm51bGwsZ2VuZXJpY0Vycm9yczp7fSxmaWxlc3lzdGVtczpudWxsLHN5bmNGU1JlcXVlc3RzOjAsaGFuZGxlRlNFcnJvcjpmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBUZS5FcnJub0Vycm9yKSl0aHJvdyBlKyIgOiAiK1AoKTtyZXR1cm4geWUoZS5lcnJubyl9LGxvb2t1cFBhdGg6ZnVuY3Rpb24oZSx0KXtpZih0PXR8fHt9LCEoZT1nZS5yZXNvbHZlKFRlLmN3ZCgpLGUpKSlyZXR1cm57cGF0aDoiIixub2RlOm51bGx9O3ZhciByPXtmb2xsb3dfbW91bnQ6ITAscmVjdXJzZV9jb3VudDowfTtmb3IodmFyIG4gaW4gcil2b2lkIDA9PT10W25dJiYodFtuXT1yW25dKTtpZih0LnJlY3Vyc2VfY291bnQ+OCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTE9PUCk7Zm9yKHZhciBvPWdlLm5vcm1hbGl6ZUFycmF5KGUuc3BsaXQoIi8iKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiEhZX0pKSwhMSksaT1UZS5yb290LGE9Ii8iLHM9MDtzPG8ubGVuZ3RoO3MrKyl7dmFyIHU9cz09PW8ubGVuZ3RoLTE7aWYodSYmdC5wYXJlbnQpYnJlYWs7aWYoaT1UZS5sb29rdXBOb2RlKGksb1tzXSksYT1nZS5qb2luMihhLG9bc10pLFRlLmlzTW91bnRwb2ludChpKSYmKCF1fHx1JiZ0LmZvbGxvd19tb3VudCkmJihpPWkubW91bnRlZC5yb290KSwhdXx8dC5mb2xsb3cpZm9yKHZhciBjPTA7VGUuaXNMaW5rKGkubW9kZSk7KXt2YXIgbD1UZS5yZWFkbGluayhhKTtpZihhPWdlLnJlc29sdmUoZ2UuZGlybmFtZShhKSxsKSxpPVRlLmxvb2t1cFBhdGgoYSx7cmVjdXJzZV9jb3VudDp0LnJlY3Vyc2VfY291bnR9KS5ub2RlLGMrKz40MCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTE9PUCl9fXJldHVybntwYXRoOmEsbm9kZTppfX0sZ2V0UGF0aDpmdW5jdGlvbihlKXtmb3IodmFyIHQ7Oyl7aWYoVGUuaXNSb290KGUpKXt2YXIgcj1lLm1vdW50Lm1vdW50cG9pbnQ7cmV0dXJuIHQ/Ii8iIT09cltyLmxlbmd0aC0xXT9yKyIvIit0OnIrdDpyfXQ9dD9lLm5hbWUrIi8iK3Q6ZS5uYW1lLGU9ZS5wYXJlbnR9fSxoYXNoTmFtZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0wLG49MDtuPHQubGVuZ3RoO24rKylyPShyPDw1KS1yK3QuY2hhckNvZGVBdChuKXwwO3JldHVybihlK3I+Pj4wKSVUZS5uYW1lVGFibGUubGVuZ3RofSxoYXNoQWRkTm9kZTpmdW5jdGlvbihlKXt2YXIgdD1UZS5oYXNoTmFtZShlLnBhcmVudC5pZCxlLm5hbWUpO2UubmFtZV9uZXh0PVRlLm5hbWVUYWJsZVt0XSxUZS5uYW1lVGFibGVbdF09ZX0saGFzaFJlbW92ZU5vZGU6ZnVuY3Rpb24oZSl7dmFyIHQ9VGUuaGFzaE5hbWUoZS5wYXJlbnQuaWQsZS5uYW1lKTtpZihUZS5uYW1lVGFibGVbdF09PT1lKVRlLm5hbWVUYWJsZVt0XT1lLm5hbWVfbmV4dDtlbHNlIGZvcih2YXIgcj1UZS5uYW1lVGFibGVbdF07cjspe2lmKHIubmFtZV9uZXh0PT09ZSl7ci5uYW1lX25leHQ9ZS5uYW1lX25leHQ7YnJlYWt9cj1yLm5hbWVfbmV4dH19LGxvb2t1cE5vZGU6ZnVuY3Rpb24oZSx0KXt2YXIgcj1UZS5tYXlMb29rdXAoZSk7aWYocil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihyLGUpO2Zvcih2YXIgbj1UZS5oYXNoTmFtZShlLmlkLHQpLG89VGUubmFtZVRhYmxlW25dO287bz1vLm5hbWVfbmV4dCl7dmFyIGk9by5uYW1lO2lmKG8ucGFyZW50LmlkPT09ZS5pZCYmaT09PXQpcmV0dXJuIG99cmV0dXJuIFRlLmxvb2t1cChlLHQpfSxjcmVhdGVOb2RlOmZ1bmN0aW9uKGUsdCxyLG4pe2lmKCFUZS5GU05vZGUpe1RlLkZTTm9kZT1mdW5jdGlvbihlLHQscixuKXtlfHwoZT10aGlzKSx0aGlzLnBhcmVudD1lLHRoaXMubW91bnQ9ZS5tb3VudCx0aGlzLm1vdW50ZWQ9bnVsbCx0aGlzLmlkPVRlLm5leHRJbm9kZSsrLHRoaXMubmFtZT10LHRoaXMubW9kZT1yLHRoaXMubm9kZV9vcHM9e30sdGhpcy5zdHJlYW1fb3BzPXt9LHRoaXMucmRldj1ufSxUZS5GU05vZGUucHJvdG90eXBlPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRlLkZTTm9kZS5wcm90b3R5cGUse3JlYWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiAzNjU9PSgzNjUmdGhpcy5tb2RlKX0sc2V0OmZ1bmN0aW9uKGUpe2U/dGhpcy5tb2RlfD0zNjU6dGhpcy5tb2RlJj0tMzY2fX0sd3JpdGU6e2dldDpmdW5jdGlvbigpe3JldHVybiAxNDY9PSgxNDYmdGhpcy5tb2RlKX0sc2V0OmZ1bmN0aW9uKGUpe2U/dGhpcy5tb2RlfD0xNDY6dGhpcy5tb2RlJj0tMTQ3fX0saXNGb2xkZXI6e2dldDpmdW5jdGlvbigpe3JldHVybiBUZS5pc0Rpcih0aGlzLm1vZGUpfX0saXNEZXZpY2U6e2dldDpmdW5jdGlvbigpe3JldHVybiBUZS5pc0NocmRldih0aGlzLm1vZGUpfX19KX12YXIgbz1uZXcgVGUuRlNOb2RlKGUsdCxyLG4pO3JldHVybiBUZS5oYXNoQWRkTm9kZShvKSxvfSxkZXN0cm95Tm9kZTpmdW5jdGlvbihlKXtUZS5oYXNoUmVtb3ZlTm9kZShlKX0saXNSb290OmZ1bmN0aW9uKGUpe3JldHVybiBlPT09ZS5wYXJlbnR9LGlzTW91bnRwb2ludDpmdW5jdGlvbihlKXtyZXR1cm4hIWUubW91bnRlZH0saXNGaWxlOmZ1bmN0aW9uKGUpe3JldHVybiAzMjc2OD09KDYxNDQwJmUpfSxpc0RpcjpmdW5jdGlvbihlKXtyZXR1cm4gMTYzODQ9PSg2MTQ0MCZlKX0saXNMaW5rOmZ1bmN0aW9uKGUpe3JldHVybiA0MDk2MD09KDYxNDQwJmUpfSxpc0NocmRldjpmdW5jdGlvbihlKXtyZXR1cm4gODE5Mj09KDYxNDQwJmUpfSxpc0Jsa2RldjpmdW5jdGlvbihlKXtyZXR1cm4gMjQ1NzY9PSg2MTQ0MCZlKX0saXNGSUZPOmZ1bmN0aW9uKGUpe3JldHVybiA0MDk2PT0oNjE0NDAmZSl9LGlzU29ja2V0OmZ1bmN0aW9uKGUpe3JldHVybiA0OTE1Mj09KDQ5MTUyJmUpfSxmbGFnTW9kZXM6e3I6MCxyczoxMDUyNjcyLCJyKyI6Mix3OjU3Nyx3eDo3MDUseHc6NzA1LCJ3KyI6NTc4LCJ3eCsiOjcwNiwieHcrIjo3MDYsYToxMDg5LGF4OjEyMTcseGE6MTIxNywiYSsiOjEwOTAsImF4KyI6MTIxOCwieGErIjoxMjE4fSxtb2RlU3RyaW5nVG9GbGFnczpmdW5jdGlvbihlKXt2YXIgdD1UZS5mbGFnTW9kZXNbZV07aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gZmlsZSBvcGVuIG1vZGU6ICIrZSk7cmV0dXJuIHR9LGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nOmZ1bmN0aW9uKGUpe3ZhciB0PVsiciIsInciLCJydyJdWzMmZV07cmV0dXJuIDUxMiZlJiYodCs9InciKSx0fSxub2RlUGVybWlzc2lvbnM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gVGUuaWdub3JlUGVybWlzc2lvbnN8fCgtMT09PXQuaW5kZXhPZigiciIpfHwyOTImZS5tb2RlKSYmKC0xPT09dC5pbmRleE9mKCJ3Iil8fDE0NiZlLm1vZGUpJiYoLTE9PT10LmluZGV4T2YoIngiKXx8NzMmZS5tb2RlKT8wOm1lLkVBQ0NFU30sbWF5TG9va3VwOmZ1bmN0aW9uKGUpe3ZhciB0PVRlLm5vZGVQZXJtaXNzaW9ucyhlLCJ4Iik7cmV0dXJuIHR8fChlLm5vZGVfb3BzLmxvb2t1cD8wOm1lLkVBQ0NFUyl9LG1heUNyZWF0ZTpmdW5jdGlvbihlLHQpe3RyeXtUZS5sb29rdXBOb2RlKGUsdCk7cmV0dXJuIG1lLkVFWElTVH1jYXRjaChlKXt9cmV0dXJuIFRlLm5vZGVQZXJtaXNzaW9ucyhlLCJ3eCIpfSxtYXlEZWxldGU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuO3RyeXtuPVRlLmxvb2t1cE5vZGUoZSx0KX1jYXRjaChlKXtyZXR1cm4gZS5lcnJub312YXIgbz1UZS5ub2RlUGVybWlzc2lvbnMoZSwid3giKTtpZihvKXJldHVybiBvO2lmKHIpe2lmKCFUZS5pc0RpcihuLm1vZGUpKXJldHVybiBtZS5FTk9URElSO2lmKFRlLmlzUm9vdChuKXx8VGUuZ2V0UGF0aChuKT09PVRlLmN3ZCgpKXJldHVybiBtZS5FQlVTWX1lbHNlIGlmKFRlLmlzRGlyKG4ubW9kZSkpcmV0dXJuIG1lLkVJU0RJUjtyZXR1cm4gMH0sbWF5T3BlbjpmdW5jdGlvbihlLHQpe3JldHVybiBlP1RlLmlzTGluayhlLm1vZGUpP21lLkVMT09QOlRlLmlzRGlyKGUubW9kZSkmJigiciIhPT1UZS5mbGFnc1RvUGVybWlzc2lvblN0cmluZyh0KXx8NTEyJnQpP21lLkVJU0RJUjpUZS5ub2RlUGVybWlzc2lvbnMoZSxUZS5mbGFnc1RvUGVybWlzc2lvblN0cmluZyh0KSk6bWUuRU5PRU5UfSxNQVhfT1BFTl9GRFM6NDA5NixuZXh0ZmQ6ZnVuY3Rpb24oZSx0KXtlPWV8fDAsdD10fHxUZS5NQVhfT1BFTl9GRFM7Zm9yKHZhciByPWU7cjw9dDtyKyspaWYoIVRlLnN0cmVhbXNbcl0pcmV0dXJuIHI7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU1GSUxFKX0sZ2V0U3RyZWFtOmZ1bmN0aW9uKGUpe3JldHVybiBUZS5zdHJlYW1zW2VdfSxjcmVhdGVTdHJlYW06ZnVuY3Rpb24oZSx0LHIpe1RlLkZTU3RyZWFtfHwoVGUuRlNTdHJlYW09ZnVuY3Rpb24oKXt9LFRlLkZTU3RyZWFtLnByb3RvdHlwZT17fSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUZS5GU1N0cmVhbS5wcm90b3R5cGUse29iamVjdDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMubm9kZT1lfX0saXNSZWFkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMSE9KDIwOTcxNTUmdGhpcy5mbGFncyl9fSxpc1dyaXRlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMCE9KDIwOTcxNTUmdGhpcy5mbGFncyl9fSxpc0FwcGVuZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDEwMjQmdGhpcy5mbGFnc319fSkpO3ZhciBuPW5ldyBUZS5GU1N0cmVhbTtmb3IodmFyIG8gaW4gZSluW29dPWVbb107ZT1uO3ZhciBpPVRlLm5leHRmZCh0LHIpO3JldHVybiBlLmZkPWksVGUuc3RyZWFtc1tpXT1lLGV9LGNsb3NlU3RyZWFtOmZ1bmN0aW9uKGUpe1RlLnN0cmVhbXNbZV09bnVsbH0sY2hyZGV2X3N0cmVhbV9vcHM6e29wZW46ZnVuY3Rpb24oZSl7dmFyIHQ9VGUuZ2V0RGV2aWNlKGUubm9kZS5yZGV2KTtlLnN0cmVhbV9vcHM9dC5zdHJlYW1fb3BzLGUuc3RyZWFtX29wcy5vcGVuJiZlLnN0cmVhbV9vcHMub3BlbihlKX0sbGxzZWVrOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRVNQSVBFKX19LG1ham9yOmZ1bmN0aW9uKGUpe3JldHVybiBlPj44fSxtaW5vcjpmdW5jdGlvbihlKXtyZXR1cm4gMjU1JmV9LG1ha2VkZXY6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZTw8OHx0fSxyZWdpc3RlckRldmljZTpmdW5jdGlvbihlLHQpe1RlLmRldmljZXNbZV09e3N0cmVhbV9vcHM6dH19LGdldERldmljZTpmdW5jdGlvbihlKXtyZXR1cm4gVGUuZGV2aWNlc1tlXX0sZ2V0TW91bnRzOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxyPVtlXTtyLmxlbmd0aDspe3ZhciBuPXIucG9wKCk7dC5wdXNoKG4pLHIucHVzaC5hcHBseShyLG4ubW91bnRzKX1yZXR1cm4gdH0sc3luY2ZzOmZ1bmN0aW9uKGUsdCl7ImZ1bmN0aW9uIj09dHlwZW9mIGUmJih0PWUsZT0hMSksVGUuc3luY0ZTUmVxdWVzdHMrKyxUZS5zeW5jRlNSZXF1ZXN0cz4xJiZjb25zb2xlLmxvZygid2FybmluZzogIitUZS5zeW5jRlNSZXF1ZXN0cysiIEZTLnN5bmNmcyBvcGVyYXRpb25zIGluIGZsaWdodCBhdCBvbmNlLCBwcm9iYWJseSBqdXN0IGRvaW5nIGV4dHJhIHdvcmsiKTt2YXIgcj1UZS5nZXRNb3VudHMoVGUucm9vdC5tb3VudCksbj0wO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIHkoVGUuc3luY0ZTUmVxdWVzdHM+MCksVGUuc3luY0ZTUmVxdWVzdHMtLSx0KGUpfWZ1bmN0aW9uIGkoZSl7aWYoZSlyZXR1cm4gaS5lcnJvcmVkP3ZvaWQgMDooaS5lcnJvcmVkPSEwLG8oZSkpOysrbj49ci5sZW5ndGgmJm8obnVsbCl9ci5mb3JFYWNoKChmdW5jdGlvbih0KXtpZighdC50eXBlLnN5bmNmcylyZXR1cm4gaShudWxsKTt0LnR5cGUuc3luY2ZzKHQsZSxpKX0pKX0sbW91bnQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLG89Ii8iPT09cixpPSFyO2lmKG8mJlRlLnJvb3QpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUJVU1kpO2lmKCFvJiYhaSl7dmFyIGE9VGUubG9va3VwUGF0aChyLHtmb2xsb3dfbW91bnQ6ITF9KTtpZihyPWEucGF0aCxuPWEubm9kZSxUZS5pc01vdW50cG9pbnQobikpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUJVU1kpO2lmKCFUZS5pc0RpcihuLm1vZGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT1RESVIpfXZhciBzPXt0eXBlOmUsb3B0czp0LG1vdW50cG9pbnQ6cixtb3VudHM6W119LHU9ZS5tb3VudChzKTtyZXR1cm4gdS5tb3VudD1zLHMucm9vdD11LG8/VGUucm9vdD11Om4mJihuLm1vdW50ZWQ9cyxuLm1vdW50JiZuLm1vdW50Lm1vdW50cy5wdXNoKHMpKSx1fSx1bm1vdW50OmZ1bmN0aW9uKGUpe3ZhciB0PVRlLmxvb2t1cFBhdGgoZSx7Zm9sbG93X21vdW50OiExfSk7aWYoIVRlLmlzTW91bnRwb2ludCh0Lm5vZGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7dmFyIHI9dC5ub2RlLG49ci5tb3VudGVkLG89VGUuZ2V0TW91bnRzKG4pO09iamVjdC5rZXlzKFRlLm5hbWVUYWJsZSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVRlLm5hbWVUYWJsZVtlXTt0Oyl7dmFyIHI9dC5uYW1lX25leHQ7LTEhPT1vLmluZGV4T2YodC5tb3VudCkmJlRlLmRlc3Ryb3lOb2RlKHQpLHQ9cn19KSksci5tb3VudGVkPW51bGw7dmFyIGk9ci5tb3VudC5tb3VudHMuaW5kZXhPZihuKTt5KC0xIT09aSksci5tb3VudC5tb3VudHMuc3BsaWNlKGksMSl9LGxvb2t1cDpmdW5jdGlvbihlLHQpe3JldHVybiBlLm5vZGVfb3BzLmxvb2t1cChlLHQpfSxta25vZDpmdW5jdGlvbihlLHQscil7dmFyIG49VGUubG9va3VwUGF0aChlLHtwYXJlbnQ6ITB9KS5ub2RlLG89Z2UuYmFzZW5hbWUoZSk7aWYoIW98fCIuIj09PW98fCIuLiI9PT1vKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7dmFyIGk9VGUubWF5Q3JlYXRlKG4sbyk7aWYoaSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihpKTtpZighbi5ub2RlX29wcy5ta25vZCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FUEVSTSk7cmV0dXJuIG4ubm9kZV9vcHMubWtub2QobixvLHQscil9LGNyZWF0ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0PXZvaWQgMCE9PXQ/dDo0MzgsdCY9NDA5NSx0fD0zMjc2OCxUZS5ta25vZChlLHQsMCl9LG1rZGlyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9dm9pZCAwIT09dD90OjUxMSx0Jj0xMDIzLHR8PTE2Mzg0LFRlLm1rbm9kKGUsdCwwKX0sbWtkaXJUcmVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPWUuc3BsaXQoIi8iKSxuPSIiLG89MDtvPHIubGVuZ3RoOysrbylpZihyW29dKXtuKz0iLyIrcltvXTt0cnl7VGUubWtkaXIobix0KX1jYXRjaChlKXtpZihlLmVycm5vIT1tZS5FRVhJU1QpdGhyb3cgZX19fSxta2RldjpmdW5jdGlvbihlLHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPXQsdD00MzgpLHR8PTgxOTIsVGUubWtub2QoZSx0LHIpfSxzeW1saW5rOmZ1bmN0aW9uKGUsdCl7aWYoIWdlLnJlc29sdmUoZSkpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PRU5UKTt2YXIgcj1UZS5sb29rdXBQYXRoKHQse3BhcmVudDohMH0pLm5vZGU7aWYoIXIpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PRU5UKTt2YXIgbj1nZS5iYXNlbmFtZSh0KSxvPVRlLm1heUNyZWF0ZShyLG4pO2lmKG8pdGhyb3cgbmV3IFRlLkVycm5vRXJyb3Iobyk7aWYoIXIubm9kZV9vcHMuc3ltbGluayl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FUEVSTSk7cmV0dXJuIHIubm9kZV9vcHMuc3ltbGluayhyLG4sZSl9LHJlbmFtZTpmdW5jdGlvbihlLHQpe3ZhciByLG4sbz1nZS5kaXJuYW1lKGUpLGk9Z2UuZGlybmFtZSh0KSxhPWdlLmJhc2VuYW1lKGUpLHM9Z2UuYmFzZW5hbWUodCk7dHJ5e3I9VGUubG9va3VwUGF0aChlLHtwYXJlbnQ6ITB9KS5ub2RlLG49VGUubG9va3VwUGF0aCh0LHtwYXJlbnQ6ITB9KS5ub2RlfWNhdGNoKGUpe3Rocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCVVNZKX1pZighcnx8IW4pdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PRU5UKTtpZihyLm1vdW50IT09bi5tb3VudCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FWERFVik7dmFyIHUsYz1UZS5sb29rdXBOb2RlKHIsYSksbD1nZS5yZWxhdGl2ZShlLGkpO2lmKCIuIiE9PWwuY2hhckF0KDApKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7aWYoIi4iIT09KGw9Z2UucmVsYXRpdmUodCxvKSkuY2hhckF0KDApKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT1RFTVBUWSk7dHJ5e3U9VGUubG9va3VwTm9kZShuLHMpfWNhdGNoKGUpe31pZihjIT09dSl7dmFyIGY9VGUuaXNEaXIoYy5tb2RlKSxkPVRlLm1heURlbGV0ZShyLGEsZik7aWYoZCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihkKTtpZihkPXU/VGUubWF5RGVsZXRlKG4scyxmKTpUZS5tYXlDcmVhdGUobixzKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihkKTtpZighci5ub2RlX29wcy5yZW5hbWUpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRVBFUk0pO2lmKFRlLmlzTW91bnRwb2ludChjKXx8dSYmVGUuaXNNb3VudHBvaW50KHUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCVVNZKTtpZihuIT09ciYmKGQ9VGUubm9kZVBlcm1pc3Npb25zKHIsInciKSkpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IoZCk7dHJ5e1RlLnRyYWNraW5nRGVsZWdhdGUud2lsbE1vdmVQYXRoJiZUZS50cmFja2luZ0RlbGVnYXRlLndpbGxNb3ZlUGF0aChlLHQpfWNhdGNoKHIpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsTW92ZVBhdGgnXSgnIitlKyInLCAnIit0KyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrci5tZXNzYWdlKX1UZS5oYXNoUmVtb3ZlTm9kZShjKTt0cnl7ci5ub2RlX29wcy5yZW5hbWUoYyxuLHMpfWNhdGNoKGUpe3Rocm93IGV9ZmluYWxseXtUZS5oYXNoQWRkTm9kZShjKX10cnl7VGUudHJhY2tpbmdEZWxlZ2F0ZS5vbk1vdmVQYXRoJiZUZS50cmFja2luZ0RlbGVnYXRlLm9uTW92ZVBhdGgoZSx0KX1jYXRjaChyKXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25Nb3ZlUGF0aCddKCciK2UrIicsICciK3QrIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIityLm1lc3NhZ2UpfX19LHJtZGlyOmZ1bmN0aW9uKGUpe3ZhciB0PVRlLmxvb2t1cFBhdGgoZSx7cGFyZW50OiEwfSkubm9kZSxyPWdlLmJhc2VuYW1lKGUpLG49VGUubG9va3VwTm9kZSh0LHIpLG89VGUubWF5RGVsZXRlKHQsciwhMCk7aWYobyl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihvKTtpZighdC5ub2RlX29wcy5ybWRpcil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FUEVSTSk7aWYoVGUuaXNNb3VudHBvaW50KG4pKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCVVNZKTt0cnl7VGUudHJhY2tpbmdEZWxlZ2F0ZS53aWxsRGVsZXRlUGF0aCYmVGUudHJhY2tpbmdEZWxlZ2F0ZS53aWxsRGVsZXRlUGF0aChlKX1jYXRjaCh0KXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbERlbGV0ZVBhdGgnXSgnIitlKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrdC5tZXNzYWdlKX10Lm5vZGVfb3BzLnJtZGlyKHQsciksVGUuZGVzdHJveU5vZGUobik7dHJ5e1RlLnRyYWNraW5nRGVsZWdhdGUub25EZWxldGVQYXRoJiZUZS50cmFja2luZ0RlbGVnYXRlLm9uRGVsZXRlUGF0aChlKX1jYXRjaCh0KXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10oJyIrZSsiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK3QubWVzc2FnZSl9fSxyZWFkZGlyOmZ1bmN0aW9uKGUpe3ZhciB0PVRlLmxvb2t1cFBhdGgoZSx7Zm9sbG93OiEwfSkubm9kZTtpZighdC5ub2RlX29wcy5yZWFkZGlyKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT1RESVIpO3JldHVybiB0Lm5vZGVfb3BzLnJlYWRkaXIodCl9LHVubGluazpmdW5jdGlvbihlKXt2YXIgdD1UZS5sb29rdXBQYXRoKGUse3BhcmVudDohMH0pLm5vZGUscj1nZS5iYXNlbmFtZShlKSxuPVRlLmxvb2t1cE5vZGUodCxyKSxvPVRlLm1heURlbGV0ZSh0LHIsITEpO2lmKG8pdGhyb3cgbmV3IFRlLkVycm5vRXJyb3Iobyk7aWYoIXQubm9kZV9vcHMudW5saW5rKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVQRVJNKTtpZihUZS5pc01vdW50cG9pbnQobikpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUJVU1kpO3RyeXtUZS50cmFja2luZ0RlbGVnYXRlLndpbGxEZWxldGVQYXRoJiZUZS50cmFja2luZ0RlbGVnYXRlLndpbGxEZWxldGVQYXRoKGUpfWNhdGNoKHQpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsRGVsZXRlUGF0aCddKCciK2UrIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIit0Lm1lc3NhZ2UpfXQubm9kZV9vcHMudW5saW5rKHQsciksVGUuZGVzdHJveU5vZGUobik7dHJ5e1RlLnRyYWNraW5nRGVsZWdhdGUub25EZWxldGVQYXRoJiZUZS50cmFja2luZ0RlbGVnYXRlLm9uRGVsZXRlUGF0aChlKX1jYXRjaCh0KXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10oJyIrZSsiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK3QubWVzc2FnZSl9fSxyZWFkbGluazpmdW5jdGlvbihlKXt2YXIgdD1UZS5sb29rdXBQYXRoKGUpLm5vZGU7aWYoIXQpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PRU5UKTtpZighdC5ub2RlX29wcy5yZWFkbGluayl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSU5WQUwpO3JldHVybiBnZS5yZXNvbHZlKFRlLmdldFBhdGgodC5wYXJlbnQpLHQubm9kZV9vcHMucmVhZGxpbmsodCkpfSxzdGF0OmZ1bmN0aW9uKGUsdCl7dmFyIHI9VGUubG9va3VwUGF0aChlLHtmb2xsb3c6IXR9KS5ub2RlO2lmKCFyKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT0VOVCk7aWYoIXIubm9kZV9vcHMuZ2V0YXR0cil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FUEVSTSk7cmV0dXJuIHIubm9kZV9vcHMuZ2V0YXR0cihyKX0sbHN0YXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIFRlLnN0YXQoZSwhMCl9LGNobW9kOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbjsic3RyaW5nIj09dHlwZW9mIGU/bj1UZS5sb29rdXBQYXRoKGUse2ZvbGxvdzohcn0pLm5vZGU6bj1lO2lmKCFuLm5vZGVfb3BzLnNldGF0dHIpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRVBFUk0pO24ubm9kZV9vcHMuc2V0YXR0cihuLHttb2RlOjQwOTUmdHwtNDA5NiZuLm1vZGUsdGltZXN0YW1wOkRhdGUubm93KCl9KX0sbGNobW9kOmZ1bmN0aW9uKGUsdCl7VGUuY2htb2QoZSx0LCEwKX0sZmNobW9kOmZ1bmN0aW9uKGUsdCl7dmFyIHI9VGUuZ2V0U3RyZWFtKGUpO2lmKCFyKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCQURGKTtUZS5jaG1vZChyLm5vZGUsdCl9LGNob3duOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvOyJzdHJpbmciPT10eXBlb2YgZT9vPVRlLmxvb2t1cFBhdGgoZSx7Zm9sbG93OiFufSkubm9kZTpvPWU7aWYoIW8ubm9kZV9vcHMuc2V0YXR0cil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FUEVSTSk7by5ub2RlX29wcy5zZXRhdHRyKG8se3RpbWVzdGFtcDpEYXRlLm5vdygpfSl9LGxjaG93bjpmdW5jdGlvbihlLHQscil7VGUuY2hvd24oZSx0LHIsITApfSxmY2hvd246ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPVRlLmdldFN0cmVhbShlKTtpZighbil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQkFERik7VGUuY2hvd24obi5ub2RlLHQscil9LHRydW5jYXRlOmZ1bmN0aW9uKGUsdCl7aWYodDwwKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7dmFyIHI7InN0cmluZyI9PXR5cGVvZiBlP3I9VGUubG9va3VwUGF0aChlLHtmb2xsb3c6ITB9KS5ub2RlOnI9ZTtpZighci5ub2RlX29wcy5zZXRhdHRyKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVQRVJNKTtpZihUZS5pc0RpcihyLm1vZGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJU0RJUik7aWYoIVRlLmlzRmlsZShyLm1vZGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7dmFyIG49VGUubm9kZVBlcm1pc3Npb25zKHIsInciKTtpZihuKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG4pO3Iubm9kZV9vcHMuc2V0YXR0cihyLHtzaXplOnQsdGltZXN0YW1wOkRhdGUubm93KCl9KX0sZnRydW5jYXRlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9VGUuZ2V0U3RyZWFtKGUpO2lmKCFyKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCQURGKTtpZigwPT0oMjA5NzE1NSZyLmZsYWdzKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSU5WQUwpO1RlLnRydW5jYXRlKHIubm9kZSx0KX0sdXRpbWU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPVRlLmxvb2t1cFBhdGgoZSx7Zm9sbG93OiEwfSkubm9kZTtuLm5vZGVfb3BzLnNldGF0dHIobix7dGltZXN0YW1wOk1hdGgubWF4KHQscil9KX0sb3BlbjpmdW5jdGlvbihlLHQscixuLGkpe2lmKCIiPT09ZSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTk9FTlQpO3ZhciBhO2lmKHI9dm9pZCAwPT09cj80Mzg6cixyPTY0Jih0PSJzdHJpbmciPT10eXBlb2YgdD9UZS5tb2RlU3RyaW5nVG9GbGFncyh0KTp0KT80MDk1JnJ8MzI3Njg6MCwib2JqZWN0Ij09dHlwZW9mIGUpYT1lO2Vsc2V7ZT1nZS5ub3JtYWxpemUoZSk7dHJ5e2E9VGUubG9va3VwUGF0aChlLHtmb2xsb3c6ISgxMzEwNzImdCl9KS5ub2RlfWNhdGNoKGUpe319dmFyIHM9ITE7aWYoNjQmdClpZihhKXtpZigxMjgmdCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FRVhJU1QpfWVsc2UgYT1UZS5ta25vZChlLHIsMCkscz0hMDtpZighYSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTk9FTlQpO2lmKFRlLmlzQ2hyZGV2KGEubW9kZSkmJih0Jj0tNTEzKSw2NTUzNiZ0JiYhVGUuaXNEaXIoYS5tb2RlKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTk9URElSKTtpZighcyl7dmFyIHU9VGUubWF5T3BlbihhLHQpO2lmKHUpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IodSl9NTEyJnQmJlRlLnRydW5jYXRlKGEsMCksdCY9LTY0MTt2YXIgYz1UZS5jcmVhdGVTdHJlYW0oe25vZGU6YSxwYXRoOlRlLmdldFBhdGgoYSksZmxhZ3M6dCxzZWVrYWJsZTohMCxwb3NpdGlvbjowLHN0cmVhbV9vcHM6YS5zdHJlYW1fb3BzLHVuZ290dGVuOltdLGVycm9yOiExfSxuLGkpO2Muc3RyZWFtX29wcy5vcGVuJiZjLnN0cmVhbV9vcHMub3BlbihjKSwhby5sb2dSZWFkRmlsZXN8fDEmdHx8KFRlLnJlYWRGaWxlc3x8KFRlLnJlYWRGaWxlcz17fSksZSBpbiBUZS5yZWFkRmlsZXN8fChUZS5yZWFkRmlsZXNbZV09MSxvLnByaW50RXJyKCJyZWFkIGZpbGU6ICIrZSkpKTt0cnl7aWYoVGUudHJhY2tpbmdEZWxlZ2F0ZS5vbk9wZW5GaWxlKXt2YXIgbD0wOzEhPSgyMDk3MTU1JnQpJiYobHw9VGUudHJhY2tpbmcub3BlbkZsYWdzLlJFQUQpLDAhPSgyMDk3MTU1JnQpJiYobHw9VGUudHJhY2tpbmcub3BlbkZsYWdzLldSSVRFKSxUZS50cmFja2luZ0RlbGVnYXRlLm9uT3BlbkZpbGUoZSxsKX19Y2F0Y2godCl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uT3BlbkZpbGUnXSgnIitlKyInLCBmbGFncykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK3QubWVzc2FnZSl9cmV0dXJuIGN9LGNsb3NlOmZ1bmN0aW9uKGUpe2lmKFRlLmlzQ2xvc2VkKGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCQURGKTtlLmdldGRlbnRzJiYoZS5nZXRkZW50cz1udWxsKTt0cnl7ZS5zdHJlYW1fb3BzLmNsb3NlJiZlLnN0cmVhbV9vcHMuY2xvc2UoZSl9Y2F0Y2goZSl7dGhyb3cgZX1maW5hbGx5e1RlLmNsb3NlU3RyZWFtKGUuZmQpfWUuZmQ9bnVsbH0saXNDbG9zZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PT1lLmZkfSxsbHNlZWs6ZnVuY3Rpb24oZSx0LHIpe2lmKFRlLmlzQ2xvc2VkKGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCQURGKTtpZighZS5zZWVrYWJsZXx8IWUuc3RyZWFtX29wcy5sbHNlZWspdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRVNQSVBFKTtyZXR1cm4gZS5wb3NpdGlvbj1lLnN0cmVhbV9vcHMubGxzZWVrKGUsdCxyKSxlLnVuZ290dGVuPVtdLGUucG9zaXRpb259LHJlYWQ6ZnVuY3Rpb24oZSx0LHIsbixvKXtpZihuPDB8fG88MCl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSU5WQUwpO2lmKFRlLmlzQ2xvc2VkKGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCQURGKTtpZigxPT0oMjA5NzE1NSZlLmZsYWdzKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQkFERik7aWYoVGUuaXNEaXIoZS5ub2RlLm1vZGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJU0RJUik7aWYoIWUuc3RyZWFtX29wcy5yZWFkKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVJTlZBTCk7dmFyIGk9dm9pZCAwIT09bztpZihpKXtpZighZS5zZWVrYWJsZSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FU1BJUEUpfWVsc2Ugbz1lLnBvc2l0aW9uO3ZhciBhPWUuc3RyZWFtX29wcy5yZWFkKGUsdCxyLG4sbyk7cmV0dXJuIGl8fChlLnBvc2l0aW9uKz1hKSxhfSx3cml0ZTpmdW5jdGlvbihlLHQscixuLG8saSl7aWYobjwwfHxvPDApdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUlOVkFMKTtpZihUZS5pc0Nsb3NlZChlKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQkFERik7aWYoMD09KDIwOTcxNTUmZS5mbGFncykpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUJBREYpO2lmKFRlLmlzRGlyKGUubm9kZS5tb2RlKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSVNESVIpO2lmKCFlLnN0cmVhbV9vcHMud3JpdGUpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUlOVkFMKTsxMDI0JmUuZmxhZ3MmJlRlLmxsc2VlayhlLDAsMik7dmFyIGE9dm9pZCAwIT09bztpZihhKXtpZighZS5zZWVrYWJsZSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FU1BJUEUpfWVsc2Ugbz1lLnBvc2l0aW9uO3ZhciBzPWUuc3RyZWFtX29wcy53cml0ZShlLHQscixuLG8saSk7YXx8KGUucG9zaXRpb24rPXMpO3RyeXtlLnBhdGgmJlRlLnRyYWNraW5nRGVsZWdhdGUub25Xcml0ZVRvRmlsZSYmVGUudHJhY2tpbmdEZWxlZ2F0ZS5vbldyaXRlVG9GaWxlKGUucGF0aCl9Y2F0Y2goZSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uV3JpdGVUb0ZpbGUnXSgnIitwYXRoKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrZS5tZXNzYWdlKX1yZXR1cm4gc30sYWxsb2NhdGU6ZnVuY3Rpb24oZSx0LHIpe2lmKFRlLmlzQ2xvc2VkKGUpKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVCQURGKTtpZih0PDB8fHI8PTApdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUlOVkFMKTtpZigwPT0oMjA5NzE1NSZlLmZsYWdzKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQkFERik7aWYoIVRlLmlzRmlsZShlLm5vZGUubW9kZSkmJiFUZS5pc0RpcihlLm5vZGUubW9kZSkpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PREVWKTtpZighZS5zdHJlYW1fb3BzLmFsbG9jYXRlKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVPUE5PVFNVUFApO2Uuc3RyZWFtX29wcy5hbGxvY2F0ZShlLHQscil9LG1tYXA6ZnVuY3Rpb24oZSx0LHIsbixvLGksYSl7aWYoMT09KDIwOTcxNTUmZS5mbGFncykpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUFDQ0VTKTtpZighZS5zdHJlYW1fb3BzLm1tYXApdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRU5PREVWKTtyZXR1cm4gZS5zdHJlYW1fb3BzLm1tYXAoZSx0LHIsbixvLGksYSl9LG1zeW5jOmZ1bmN0aW9uKGUsdCxyLG4sbyl7cmV0dXJuIGUmJmUuc3RyZWFtX29wcy5tc3luYz9lLnN0cmVhbV9vcHMubXN5bmMoZSx0LHIsbixvKTowfSxtdW5tYXA6ZnVuY3Rpb24oZSl7cmV0dXJuIDB9LGlvY3RsOmZ1bmN0aW9uKGUsdCxyKXtpZighZS5zdHJlYW1fb3BzLmlvY3RsKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT1RUWSk7cmV0dXJuIGUuc3RyZWFtX29wcy5pb2N0bChlLHQscil9LHJlYWRGaWxlOmZ1bmN0aW9uKGUsdCl7aWYoKHQ9dHx8e30pLmZsYWdzPXQuZmxhZ3N8fCJyIix0LmVuY29kaW5nPXQuZW5jb2Rpbmd8fCJiaW5hcnkiLCJ1dGY4IiE9PXQuZW5jb2RpbmcmJiJiaW5hcnkiIT09dC5lbmNvZGluZyl0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSAiJyt0LmVuY29kaW5nKyciJyk7dmFyIHIsbj1UZS5vcGVuKGUsdC5mbGFncyksbz1UZS5zdGF0KGUpLnNpemUsaT1uZXcgVWludDhBcnJheShvKTtyZXR1cm4gVGUucmVhZChuLGksMCxvLDApLCJ1dGY4Ij09PXQuZW5jb2Rpbmc/cj1fKGksMCk6ImJpbmFyeSI9PT10LmVuY29kaW5nJiYocj1pKSxUZS5jbG9zZShuKSxyfSx3cml0ZUZpbGU6ZnVuY3Rpb24oZSx0LHIpeyhyPXJ8fHt9KS5mbGFncz1yLmZsYWdzfHwidyI7dmFyIG49VGUub3BlbihlLHIuZmxhZ3Msci5tb2RlKTtpZigic3RyaW5nIj09dHlwZW9mIHQpe3ZhciBvPW5ldyBVaW50OEFycmF5KFModCkrMSksaT1BKHQsbywwLG8ubGVuZ3RoKTtUZS53cml0ZShuLG8sMCxpLHZvaWQgMCxyLmNhbk93bil9ZWxzZXtpZighQXJyYXlCdWZmZXIuaXNWaWV3KHQpKXRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIik7VGUud3JpdGUobix0LDAsdC5ieXRlTGVuZ3RoLHZvaWQgMCxyLmNhbk93bil9VGUuY2xvc2Uobil9LGN3ZDpmdW5jdGlvbigpe3JldHVybiBUZS5jdXJyZW50UGF0aH0sY2hkaXI6ZnVuY3Rpb24oZSl7dmFyIHQ9VGUubG9va3VwUGF0aChlLHtmb2xsb3c6ITB9KTtpZihudWxsPT09dC5ub2RlKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG1lLkVOT0VOVCk7aWYoIVRlLmlzRGlyKHQubm9kZS5tb2RlKSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FTk9URElSKTt2YXIgcj1UZS5ub2RlUGVybWlzc2lvbnModC5ub2RlLCJ4Iik7aWYocil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihyKTtUZS5jdXJyZW50UGF0aD10LnBhdGh9LGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczpmdW5jdGlvbigpe1RlLm1rZGlyKCIvdG1wIiksVGUubWtkaXIoIi9ob21lIiksVGUubWtkaXIoIi9ob21lL3dlYl91c2VyIil9LGNyZWF0ZURlZmF1bHREZXZpY2VzOmZ1bmN0aW9uKCl7dmFyIGU7aWYoVGUubWtkaXIoIi9kZXYiKSxUZS5yZWdpc3RlckRldmljZShUZS5tYWtlZGV2KDEsMykse3JlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sd3JpdGU6ZnVuY3Rpb24oZSx0LHIsbixvKXtyZXR1cm4gbn19KSxUZS5ta2RldigiL2Rldi9udWxsIixUZS5tYWtlZGV2KDEsMykpLHZlLnJlZ2lzdGVyKFRlLm1ha2VkZXYoNSwwKSx2ZS5kZWZhdWx0X3R0eV9vcHMpLHZlLnJlZ2lzdGVyKFRlLm1ha2VkZXYoNiwwKSx2ZS5kZWZhdWx0X3R0eTFfb3BzKSxUZS5ta2RldigiL2Rldi90dHkiLFRlLm1ha2VkZXYoNSwwKSksVGUubWtkZXYoIi9kZXYvdHR5MSIsVGUubWFrZWRldig2LDApKSwidW5kZWZpbmVkIiE9dHlwZW9mIGNyeXB0byl7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoMSk7ZT1mdW5jdGlvbigpe3JldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHQpLHRbMF19fWVsc2UgZT1sP2Z1bmN0aW9uKCl7cmV0dXJuIHJlcXVpcmUoImNyeXB0byIpLnJhbmRvbUJ5dGVzKDEpWzBdfTpmdW5jdGlvbigpe3JldHVybiAyNTYqTWF0aC5yYW5kb20oKXwwfTtUZS5jcmVhdGVEZXZpY2UoIi9kZXYiLCJyYW5kb20iLGUpLFRlLmNyZWF0ZURldmljZSgiL2RldiIsInVyYW5kb20iLGUpLFRlLm1rZGlyKCIvZGV2L3NobSIpLFRlLm1rZGlyKCIvZGV2L3NobS90bXAiKX0sY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOmZ1bmN0aW9uKCl7VGUubWtkaXIoIi9wcm9jIiksVGUubWtkaXIoIi9wcm9jL3NlbGYiKSxUZS5ta2RpcigiL3Byb2Mvc2VsZi9mZCIpLFRlLm1vdW50KHttb3VudDpmdW5jdGlvbigpe3ZhciBlPVRlLmNyZWF0ZU5vZGUoIi9wcm9jL3NlbGYiLCJmZCIsMTY4OTUsNzMpO3JldHVybiBlLm5vZGVfb3BzPXtsb29rdXA6ZnVuY3Rpb24oZSx0KXt2YXIgcj0rdCxuPVRlLmdldFN0cmVhbShyKTtpZighbil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQkFERik7dmFyIG89e3BhcmVudDpudWxsLG1vdW50Onttb3VudHBvaW50OiJmYWtlIn0sbm9kZV9vcHM6e3JlYWRsaW5rOmZ1bmN0aW9uKCl7cmV0dXJuIG4ucGF0aH19fTtyZXR1cm4gby5wYXJlbnQ9byxvfX0sZX19LHt9LCIvcHJvYy9zZWxmL2ZkIil9LGNyZWF0ZVN0YW5kYXJkU3RyZWFtczpmdW5jdGlvbigpe28uc3RkaW4/VGUuY3JlYXRlRGV2aWNlKCIvZGV2Iiwic3RkaW4iLG8uc3RkaW4pOlRlLnN5bWxpbmsoIi9kZXYvdHR5IiwiL2Rldi9zdGRpbiIpLG8uc3Rkb3V0P1RlLmNyZWF0ZURldmljZSgiL2RldiIsInN0ZG91dCIsbnVsbCxvLnN0ZG91dCk6VGUuc3ltbGluaygiL2Rldi90dHkiLCIvZGV2L3N0ZG91dCIpLG8uc3RkZXJyP1RlLmNyZWF0ZURldmljZSgiL2RldiIsInN0ZGVyciIsbnVsbCxvLnN0ZGVycik6VGUuc3ltbGluaygiL2Rldi90dHkxIiwiL2Rldi9zdGRlcnIiKTt2YXIgZT1UZS5vcGVuKCIvZGV2L3N0ZGluIiwiciIpO3koMD09PWUuZmQsImludmFsaWQgaGFuZGxlIGZvciBzdGRpbiAoIitlLmZkKyIpIik7dmFyIHQ9VGUub3BlbigiL2Rldi9zdGRvdXQiLCJ3Iik7eSgxPT09dC5mZCwiaW52YWxpZCBoYW5kbGUgZm9yIHN0ZG91dCAoIit0LmZkKyIpIik7dmFyIHI9VGUub3BlbigiL2Rldi9zdGRlcnIiLCJ3Iik7eSgyPT09ci5mZCwiaW52YWxpZCBoYW5kbGUgZm9yIHN0ZGVyciAoIityLmZkKyIpIil9LGVuc3VyZUVycm5vRXJyb3I6ZnVuY3Rpb24oKXtUZS5FcnJub0Vycm9yfHwoVGUuRXJybm9FcnJvcj1mdW5jdGlvbihlLHQpe3RoaXMubm9kZT10LHRoaXMuc2V0RXJybm89ZnVuY3Rpb24oZSl7Zm9yKHZhciB0IGluIHRoaXMuZXJybm89ZSxtZSlpZihtZVt0XT09PWUpe3RoaXMuY29kZT10O2JyZWFrfX0sdGhpcy5zZXRFcnJubyhlKSx0aGlzLm1lc3NhZ2U9RWVbZV0sdGhpcy5zdGFjayYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN0YWNrIix7dmFsdWU6KG5ldyBFcnJvcikuc3RhY2ssd3JpdGFibGU6ITB9KX0sVGUuRXJybm9FcnJvci5wcm90b3R5cGU9bmV3IEVycm9yLFRlLkVycm5vRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPVRlLkVycm5vRXJyb3IsW21lLkVOT0VOVF0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7VGUuZ2VuZXJpY0Vycm9yc1tlXT1uZXcgVGUuRXJybm9FcnJvcihlKSxUZS5nZW5lcmljRXJyb3JzW2VdLnN0YWNrPSI8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+In0pKSl9LHN0YXRpY0luaXQ6ZnVuY3Rpb24oKXtUZS5lbnN1cmVFcnJub0Vycm9yKCksVGUubmFtZVRhYmxlPW5ldyBBcnJheSg0MDk2KSxUZS5tb3VudCh3ZSx7fSwiLyIpLFRlLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpLFRlLmNyZWF0ZURlZmF1bHREZXZpY2VzKCksVGUuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCksVGUuZmlsZXN5c3RlbXM9e01FTUZTOndlLElEQkZTOl9lLE5PREVGUzpiZSxXT1JLRVJGUzpBZX19LGluaXQ6ZnVuY3Rpb24oZSx0LHIpe3koIVRlLmluaXQuaW5pdGlhbGl6ZWQsIkZTLmluaXQgd2FzIHByZXZpb3VzbHkgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byBpbml0aWFsaXplIGxhdGVyIHdpdGggY3VzdG9tIHBhcmFtZXRlcnMsIHJlbW92ZSBhbnkgZWFybGllciBjYWxscyAobm90ZSB0aGF0IG9uZSBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoZSBnZW5lcmF0ZWQgY29kZSkiKSxUZS5pbml0LmluaXRpYWxpemVkPSEwLFRlLmVuc3VyZUVycm5vRXJyb3IoKSxvLnN0ZGluPWV8fG8uc3RkaW4sby5zdGRvdXQ9dHx8by5zdGRvdXQsby5zdGRlcnI9cnx8by5zdGRlcnIsVGUuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCl9LHF1aXQ6ZnVuY3Rpb24oKXtUZS5pbml0LmluaXRpYWxpemVkPSExO3ZhciBlPW8uX2ZmbHVzaDtlJiZlKDApO2Zvcih2YXIgdD0wO3Q8VGUuc3RyZWFtcy5sZW5ndGg7dCsrKXt2YXIgcj1UZS5zdHJlYW1zW3RdO3ImJlRlLmNsb3NlKHIpfX0sZ2V0TW9kZTpmdW5jdGlvbihlLHQpe3ZhciByPTA7cmV0dXJuIGUmJihyfD0zNjUpLHQmJihyfD0xNDYpLHJ9LGpvaW5QYXRoOmZ1bmN0aW9uKGUsdCl7dmFyIHI9Z2Uuam9pbi5hcHBseShudWxsLGUpO3JldHVybiB0JiYiLyI9PXJbMF0mJihyPXIuc3Vic3RyKDEpKSxyfSxhYnNvbHV0ZVBhdGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZ2UucmVzb2x2ZSh0LGUpfSxzdGFuZGFyZGl6ZVBhdGg6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlLm5vcm1hbGl6ZShlKX0sZmluZE9iamVjdDpmdW5jdGlvbihlLHQpe3ZhciByPVRlLmFuYWx5emVQYXRoKGUsdCk7cmV0dXJuIHIuZXhpc3RzP3Iub2JqZWN0Oih5ZShyLmVycm9yKSxudWxsKX0sYW5hbHl6ZVBhdGg6ZnVuY3Rpb24oZSx0KXt0cnl7ZT0obj1UZS5sb29rdXBQYXRoKGUse2ZvbGxvdzohdH0pKS5wYXRofWNhdGNoKGUpe312YXIgcj17aXNSb290OiExLGV4aXN0czohMSxlcnJvcjowLG5hbWU6bnVsbCxwYXRoOm51bGwsb2JqZWN0Om51bGwscGFyZW50RXhpc3RzOiExLHBhcmVudFBhdGg6bnVsbCxwYXJlbnRPYmplY3Q6bnVsbH07dHJ5e3ZhciBuPVRlLmxvb2t1cFBhdGgoZSx7cGFyZW50OiEwfSk7ci5wYXJlbnRFeGlzdHM9ITAsci5wYXJlbnRQYXRoPW4ucGF0aCxyLnBhcmVudE9iamVjdD1uLm5vZGUsci5uYW1lPWdlLmJhc2VuYW1lKGUpLG49VGUubG9va3VwUGF0aChlLHtmb2xsb3c6IXR9KSxyLmV4aXN0cz0hMCxyLnBhdGg9bi5wYXRoLHIub2JqZWN0PW4ubm9kZSxyLm5hbWU9bi5ub2RlLm5hbWUsci5pc1Jvb3Q9Ii8iPT09bi5wYXRofWNhdGNoKGUpe3IuZXJyb3I9ZS5lcnJub31yZXR1cm4gcn0sY3JlYXRlRm9sZGVyOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPWdlLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgZT9lOlRlLmdldFBhdGgoZSksdCksaT1UZS5nZXRNb2RlKHIsbik7cmV0dXJuIFRlLm1rZGlyKG8saSl9LGNyZWF0ZVBhdGg6ZnVuY3Rpb24oZSx0LHIsbil7ZT0ic3RyaW5nIj09dHlwZW9mIGU/ZTpUZS5nZXRQYXRoKGUpO2Zvcih2YXIgbz10LnNwbGl0KCIvIikucmV2ZXJzZSgpO28ubGVuZ3RoOyl7dmFyIGk9by5wb3AoKTtpZihpKXt2YXIgYT1nZS5qb2luMihlLGkpO3RyeXtUZS5ta2RpcihhKX1jYXRjaChlKXt9ZT1hfX1yZXR1cm4gYX0sY3JlYXRlRmlsZTpmdW5jdGlvbihlLHQscixuLG8pe3ZhciBpPWdlLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgZT9lOlRlLmdldFBhdGgoZSksdCksYT1UZS5nZXRNb2RlKG4sbyk7cmV0dXJuIFRlLmNyZWF0ZShpLGEpfSxjcmVhdGVEYXRhRmlsZTpmdW5jdGlvbihlLHQscixuLG8saSl7dmFyIGE9dD9nZS5qb2luMigic3RyaW5nIj09dHlwZW9mIGU/ZTpUZS5nZXRQYXRoKGUpLHQpOmUscz1UZS5nZXRNb2RlKG4sbyksdT1UZS5jcmVhdGUoYSxzKTtpZihyKXtpZigic3RyaW5nIj09dHlwZW9mIHIpe2Zvcih2YXIgYz1uZXcgQXJyYXkoci5sZW5ndGgpLGw9MCxmPXIubGVuZ3RoO2w8ZjsrK2wpY1tsXT1yLmNoYXJDb2RlQXQobCk7cj1jfVRlLmNobW9kKHUsMTQ2fHMpO3ZhciBkPVRlLm9wZW4odSwidyIpO1RlLndyaXRlKGQsciwwLHIubGVuZ3RoLDAsaSksVGUuY2xvc2UoZCksVGUuY2htb2QodSxzKX1yZXR1cm4gdX0sY3JlYXRlRGV2aWNlOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPWdlLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgZT9lOlRlLmdldFBhdGgoZSksdCksaT1UZS5nZXRNb2RlKCEhciwhIW4pO1RlLmNyZWF0ZURldmljZS5tYWpvcnx8KFRlLmNyZWF0ZURldmljZS5tYWpvcj02NCk7dmFyIGE9VGUubWFrZWRldihUZS5jcmVhdGVEZXZpY2UubWFqb3IrKywwKTtyZXR1cm4gVGUucmVnaXN0ZXJEZXZpY2UoYSx7b3BlbjpmdW5jdGlvbihlKXtlLnNlZWthYmxlPSExfSxjbG9zZTpmdW5jdGlvbihlKXtuJiZuLmJ1ZmZlciYmbi5idWZmZXIubGVuZ3RoJiZuKDEwKX0scmVhZDpmdW5jdGlvbihlLHQsbixvLGkpe2Zvcih2YXIgYT0wLHM9MDtzPG87cysrKXt2YXIgdTt0cnl7dT1yKCl9Y2F0Y2goZSl7dGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUlPKX1pZih2b2lkIDA9PT11JiYwPT09YSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQUdBSU4pO2lmKG51bGw9PXUpYnJlYWs7YSsrLHRbbitzXT11fXJldHVybiBhJiYoZS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpKSxhfSx3cml0ZTpmdW5jdGlvbihlLHQscixvLGkpe2Zvcih2YXIgYT0wO2E8bzthKyspdHJ5e24odFtyK2FdKX1jYXRjaChlKXt0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSU8pfXJldHVybiBvJiYoZS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpKSxhfX0pLFRlLm1rZGV2KG8saSxhKX0sY3JlYXRlTGluazpmdW5jdGlvbihlLHQscixuLG8pe3ZhciBpPWdlLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgZT9lOlRlLmdldFBhdGgoZSksdCk7cmV0dXJuIFRlLnN5bWxpbmsocixpKX0sZm9yY2VMb2FkRmlsZTpmdW5jdGlvbihlKXtpZihlLmlzRGV2aWNlfHxlLmlzRm9sZGVyfHxlLmxpbmt8fGUuY29udGVudHMpcmV0dXJuITA7dmFyIHQ9ITA7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBYTUxIdHRwUmVxdWVzdCl0aHJvdyBuZXcgRXJyb3IoIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLiIpO2lmKCFvLnJlYWQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4iKTt0cnl7ZS5jb250ZW50cz0kdChvLnJlYWQoZS51cmwpLCEwKSxlLnVzZWRCeXRlcz1lLmNvbnRlbnRzLmxlbmd0aH1jYXRjaChlKXt0PSExfXJldHVybiB0fHx5ZShtZS5FSU8pLHR9LGNyZWF0ZUxhenlGaWxlOmZ1bmN0aW9uKGUsdCxyLG4sbyl7ZnVuY3Rpb24gaSgpe3RoaXMubGVuZ3RoS25vd249ITEsdGhpcy5jaHVua3M9W119aWYoaS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe2lmKCEoZT50aGlzLmxlbmd0aC0xfHxlPDApKXt2YXIgdD1lJXRoaXMuY2h1bmtTaXplLHI9ZS90aGlzLmNodW5rU2l6ZXwwO3JldHVybiB0aGlzLmdldHRlcihyKVt0XX19LGkucHJvdG90eXBlLnNldERhdGFHZXR0ZXI9ZnVuY3Rpb24oZSl7dGhpcy5nZXR0ZXI9ZX0saS5wcm90b3R5cGUuY2FjaGVMZW5ndGg9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7aWYoZS5vcGVuKCJIRUFEIixyLCExKSxlLnNlbmQobnVsbCksIShlLnN0YXR1cz49MjAwJiZlLnN0YXR1czwzMDB8fDMwND09PWUuc3RhdHVzKSl0aHJvdyBuZXcgRXJyb3IoIkNvdWxkbid0IGxvYWQgIityKyIuIFN0YXR1czogIitlLnN0YXR1cyk7dmFyIHQsbj1OdW1iZXIoZS5nZXRSZXNwb25zZUhlYWRlcigiQ29udGVudC1sZW5ndGgiKSksbz0odD1lLmdldFJlc3BvbnNlSGVhZGVyKCJBY2NlcHQtUmFuZ2VzIikpJiYiYnl0ZXMiPT09dCxpPSh0PWUuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtRW5jb2RpbmciKSkmJiJnemlwIj09PXQsYT0xMDQ4NTc2O298fChhPW4pO3ZhciBzPXRoaXM7cy5zZXREYXRhR2V0dGVyKChmdW5jdGlvbihlKXt2YXIgdD1lKmEsbz0oZSsxKSphLTE7aWYobz1NYXRoLm1pbihvLG4tMSksdm9pZCAwPT09cy5jaHVua3NbZV0mJihzLmNodW5rc1tlXT1mdW5jdGlvbihlLHQpe2lmKGU+dCl0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgcmFuZ2UgKCIrZSsiLCAiK3QrIikgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkISIpO2lmKHQ+bi0xKXRocm93IG5ldyBFcnJvcigib25seSAiK24rIiBieXRlcyBhdmFpbGFibGUhIHByb2dyYW1tZXIgZXJyb3IhIik7dmFyIG89bmV3IFhNTEh0dHBSZXF1ZXN0O2lmKG8ub3BlbigiR0VUIixyLCExKSxuIT09YSYmby5zZXRSZXF1ZXN0SGVhZGVyKCJSYW5nZSIsImJ5dGVzPSIrZSsiLSIrdCksInVuZGVmaW5lZCIhPXR5cGVvZiBVaW50OEFycmF5JiYoby5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIiksby5vdmVycmlkZU1pbWVUeXBlJiZvLm92ZXJyaWRlTWltZVR5cGUoInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQiKSxvLnNlbmQobnVsbCksIShvLnN0YXR1cz49MjAwJiZvLnN0YXR1czwzMDB8fDMwND09PW8uc3RhdHVzKSl0aHJvdyBuZXcgRXJyb3IoIkNvdWxkbid0IGxvYWQgIityKyIuIFN0YXR1czogIitvLnN0YXR1cyk7cmV0dXJuIHZvaWQgMCE9PW8ucmVzcG9uc2U/bmV3IFVpbnQ4QXJyYXkoby5yZXNwb25zZXx8W10pOiR0KG8ucmVzcG9uc2VUZXh0fHwiIiwhMCl9KHQsbykpLHZvaWQgMD09PXMuY2h1bmtzW2VdKXRocm93IG5ldyBFcnJvcigiZG9YSFIgZmFpbGVkISIpO3JldHVybiBzLmNodW5rc1tlXX0pKSwhaSYmbnx8KGE9bj0xLG49dGhpcy5nZXR0ZXIoMCkubGVuZ3RoLGE9bixjb25zb2xlLmxvZygiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkIikpLHRoaXMuX2xlbmd0aD1uLHRoaXMuX2NodW5rU2l6ZT1hLHRoaXMubGVuZ3RoS25vd249ITB9LCJ1bmRlZmluZWQiIT10eXBlb2YgWE1MSHR0cFJlcXVlc3Qpe2lmKCFjKXRocm93IkNhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2MiO3ZhciBhPW5ldyBpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGEse2xlbmd0aDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RoS25vd258fHRoaXMuY2FjaGVMZW5ndGgoKSx0aGlzLl9sZW5ndGh9fSxjaHVua1NpemU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aEtub3dufHx0aGlzLmNhY2hlTGVuZ3RoKCksdGhpcy5fY2h1bmtTaXplfX19KTt2YXIgcz17aXNEZXZpY2U6ITEsY29udGVudHM6YX19ZWxzZSBzPXtpc0RldmljZTohMSx1cmw6cn07dmFyIHU9VGUuY3JlYXRlRmlsZShlLHQscyxuLG8pO3MuY29udGVudHM/dS5jb250ZW50cz1zLmNvbnRlbnRzOnMudXJsJiYodS5jb250ZW50cz1udWxsLHUudXJsPXMudXJsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh1LHt1c2VkQnl0ZXM6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aH19fSk7dmFyIGw9e307cmV0dXJuIE9iamVjdC5rZXlzKHUuc3RyZWFtX29wcykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9dS5zdHJlYW1fb3BzW2VdO2xbZV09ZnVuY3Rpb24oKXtpZighVGUuZm9yY2VMb2FkRmlsZSh1KSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FSU8pO3JldHVybiB0LmFwcGx5KG51bGwsYXJndW1lbnRzKX19KSksbC5yZWFkPWZ1bmN0aW9uKGUsdCxyLG4sbyl7aWYoIVRlLmZvcmNlTG9hZEZpbGUodSkpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUlPKTt2YXIgaT1lLm5vZGUuY29udGVudHM7aWYobz49aS5sZW5ndGgpcmV0dXJuIDA7dmFyIGE9TWF0aC5taW4oaS5sZW5ndGgtbyxuKTtpZih5KGE+PTApLGkuc2xpY2UpZm9yKHZhciBzPTA7czxhO3MrKyl0W3Irc109aVtvK3NdO2Vsc2UgZm9yKHM9MDtzPGE7cysrKXRbcitzXT1pLmdldChvK3MpO3JldHVybiBhfSx1LnN0cmVhbV9vcHM9bCx1fSxjcmVhdGVQcmVsb2FkZWRGaWxlOmZ1bmN0aW9uKGUsdCxyLG4saSxhLHMsdSxjLGwpe0Jyb3dzZXIuaW5pdCgpO3ZhciBmPXQ/Z2UucmVzb2x2ZShnZS5qb2luMihlLHQpKTplO2Z1bmN0aW9uIGQocil7ZnVuY3Rpb24gZChyKXtsJiZsKCksdXx8VGUuY3JlYXRlRGF0YUZpbGUoZSx0LHIsbixpLGMpLGEmJmEoKSxsZSgpfXZhciBoPSExO28ucHJlbG9hZFBsdWdpbnMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aHx8ZS5jYW5IYW5kbGUoZikmJihlLmhhbmRsZShyLGYsZCwoZnVuY3Rpb24oKXtzJiZzKCksbGUoKX0pKSxoPSEwKX0pKSxofHxkKHIpfWNlKCksInN0cmluZyI9PXR5cGVvZiByP0Jyb3dzZXIuYXN5bmNMb2FkKHIsKGZ1bmN0aW9uKGUpe2QoZSl9KSxzKTpkKHIpfSxpbmRleGVkREI6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmluZGV4ZWREQnx8d2luZG93Lm1vekluZGV4ZWREQnx8d2luZG93LndlYmtpdEluZGV4ZWREQnx8d2luZG93Lm1zSW5kZXhlZERCfSxEQl9OQU1FOmZ1bmN0aW9uKCl7cmV0dXJuIkVNX0ZTXyIrd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfSxEQl9WRVJTSU9OOjIwLERCX1NUT1JFX05BTUU6IkZJTEVfREFUQSIsc2F2ZUZpbGVzVG9EQjpmdW5jdGlvbihlLHQscil7dD10fHxmdW5jdGlvbigpe30scj1yfHxmdW5jdGlvbigpe307dmFyIG49VGUuaW5kZXhlZERCKCk7dHJ5e3ZhciBvPW4ub3BlbihUZS5EQl9OQU1FKCksVGUuREJfVkVSU0lPTil9Y2F0Y2goZSl7cmV0dXJuIHIoZSl9by5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZygiY3JlYXRpbmcgZGIiKSxvLnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZShUZS5EQl9TVE9SRV9OQU1FKX0sby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgbj1vLnJlc3VsdC50cmFuc2FjdGlvbihbVGUuREJfU1RPUkVfTkFNRV0sInJlYWR3cml0ZSIpLGk9bi5vYmplY3RTdG9yZShUZS5EQl9TVE9SRV9OQU1FKSxhPTAscz0wLHU9ZS5sZW5ndGg7ZnVuY3Rpb24gYygpezA9PXM/dCgpOnIoKX1lLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PWkucHV0KFRlLmFuYWx5emVQYXRoKGUpLm9iamVjdC5jb250ZW50cyxlKTt0Lm9uc3VjY2Vzcz1mdW5jdGlvbigpeysrYStzPT11JiZjKCl9LHQub25lcnJvcj1mdW5jdGlvbigpe3MrKyxhK3M9PXUmJmMoKX19KSksbi5vbmVycm9yPXJ9LG8ub25lcnJvcj1yfSxsb2FkRmlsZXNGcm9tREI6ZnVuY3Rpb24oZSx0LHIpe3Q9dHx8ZnVuY3Rpb24oKXt9LHI9cnx8ZnVuY3Rpb24oKXt9O3ZhciBuPVRlLmluZGV4ZWREQigpO3RyeXt2YXIgbz1uLm9wZW4oVGUuREJfTkFNRSgpLFRlLkRCX1ZFUlNJT04pfWNhdGNoKGUpe3JldHVybiByKGUpfW8ub251cGdyYWRlbmVlZGVkPXIsby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgbj1vLnJlc3VsdDt0cnl7dmFyIGk9bi50cmFuc2FjdGlvbihbVGUuREJfU1RPUkVfTkFNRV0sInJlYWRvbmx5Iil9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgcihlKX12YXIgYT1pLm9iamVjdFN0b3JlKFRlLkRCX1NUT1JFX05BTUUpLHM9MCx1PTAsYz1lLmxlbmd0aDtmdW5jdGlvbiBsKCl7MD09dT90KCk6cigpfWUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIHQ9YS5nZXQoZSk7dC5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtUZS5hbmFseXplUGF0aChlKS5leGlzdHMmJlRlLnVubGluayhlKSxUZS5jcmVhdGVEYXRhRmlsZShnZS5kaXJuYW1lKGUpLGdlLmJhc2VuYW1lKGUpLHQucmVzdWx0LCEwLCEwLCEwKSwrK3MrdT09YyYmbCgpfSx0Lm9uZXJyb3I9ZnVuY3Rpb24oKXt1Kysscyt1PT1jJiZsKCl9fSkpLGkub25lcnJvcj1yfSxvLm9uZXJyb3I9cn19LFNlPXtERUZBVUxUX1BPTExNQVNLOjUsbWFwcGluZ3M6e30sdW1hc2s6NTExLGNhbGN1bGF0ZUF0OmZ1bmN0aW9uKGUsdCl7aWYoIi8iIT09dFswXSl7dmFyIHI7aWYoLTEwMD09PWUpcj1UZS5jd2QoKTtlbHNle3ZhciBuPVRlLmdldFN0cmVhbShlKTtpZighbil0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQkFERik7cj1uLnBhdGh9dD1nZS5qb2luMihyLHQpfXJldHVybiB0fSxkb1N0YXQ6ZnVuY3Rpb24oZSx0LHIpe3RyeXt2YXIgbj1lKHQpfWNhdGNoKGUpe2lmKGUmJmUubm9kZSYmZ2Uubm9ybWFsaXplKHQpIT09Z2Uubm9ybWFsaXplKFRlLmdldFBhdGgoZS5ub2RlKSkpcmV0dXJuLW1lLkVOT1RESVI7dGhyb3cgZX1yZXR1cm4gRltyPj4yXT1uLmRldixGW3IrND4+Ml09MCxGW3IrOD4+Ml09bi5pbm8sRltyKzEyPj4yXT1uLm1vZGUsRltyKzE2Pj4yXT1uLm5saW5rLEZbcisyMD4+Ml09bi51aWQsRltyKzI0Pj4yXT1uLmdpZCxGW3IrMjg+PjJdPW4ucmRldixGW3IrMzI+PjJdPTAsRltyKzM2Pj4yXT1uLnNpemUsRltyKzQwPj4yXT00MDk2LEZbcis0ND4+Ml09bi5ibG9ja3MsRltyKzQ4Pj4yXT1uLmF0aW1lLmdldFRpbWUoKS8xZTN8MCxGW3IrNTI+PjJdPTAsRltyKzU2Pj4yXT1uLm10aW1lLmdldFRpbWUoKS8xZTN8MCxGW3IrNjA+PjJdPTAsRltyKzY0Pj4yXT1uLmN0aW1lLmdldFRpbWUoKS8xZTN8MCxGW3IrNjg+PjJdPTAsRltyKzcyPj4yXT1uLmlubywwfSxkb01zeW5jOmZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBvPW5ldyBVaW50OEFycmF5KE8uc3ViYXJyYXkoZSxlK3IpKTtUZS5tc3luYyh0LG8sMCxyLG4pfSxkb01rZGlyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIi8iPT09KGU9Z2Uubm9ybWFsaXplKGUpKVtlLmxlbmd0aC0xXSYmKGU9ZS5zdWJzdHIoMCxlLmxlbmd0aC0xKSksVGUubWtkaXIoZSx0LDApLDB9LGRvTWtub2Q6ZnVuY3Rpb24oZSx0LHIpe3N3aXRjaCg2MTQ0MCZ0KXtjYXNlIDMyNzY4OmNhc2UgODE5MjpjYXNlIDI0NTc2OmNhc2UgNDA5NjpjYXNlIDQ5MTUyOmJyZWFrO2RlZmF1bHQ6cmV0dXJuLW1lLkVJTlZBTH1yZXR1cm4gVGUubWtub2QoZSx0LHIpLDB9LGRvUmVhZGxpbms6ZnVuY3Rpb24oZSx0LHIpe2lmKHI8PTApcmV0dXJuLW1lLkVJTlZBTDt2YXIgbj1UZS5yZWFkbGluayhlKSxvPU1hdGgubWluKHIsUyhuKSksaT1SW3Qrb107cmV0dXJuIFQobix0LHIrMSksUlt0K29dPWksb30sZG9BY2Nlc3M6ZnVuY3Rpb24oZSx0KXtpZigtOCZ0KXJldHVybi1tZS5FSU5WQUw7dmFyIHI7cj1UZS5sb29rdXBQYXRoKGUse2ZvbGxvdzohMH0pLm5vZGU7dmFyIG49IiI7cmV0dXJuIDQmdCYmKG4rPSJyIiksMiZ0JiYobis9InciKSwxJnQmJihuKz0ieCIpLG4mJlRlLm5vZGVQZXJtaXNzaW9ucyhyLG4pPy1tZS5FQUNDRVM6MH0sZG9EdXA6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPVRlLmdldFN0cmVhbShyKTtyZXR1cm4gbiYmVGUuY2xvc2UobiksVGUub3BlbihlLHQsMCxyLHIpLmZkfSxkb1JlYWR2OmZ1bmN0aW9uKGUsdCxyLG4pe2Zvcih2YXIgbz0wLGk9MDtpPHI7aSsrKXt2YXIgYT1GW3QrOCppPj4yXSxzPUZbdCsoOCppKzQpPj4yXSx1PVRlLnJlYWQoZSxSLGEscyxuKTtpZih1PDApcmV0dXJuLTE7aWYobys9dSx1PHMpYnJlYWt9cmV0dXJuIG99LGRvV3JpdGV2OmZ1bmN0aW9uKGUsdCxyLG4pe2Zvcih2YXIgbz0wLGk9MDtpPHI7aSsrKXt2YXIgYT1GW3QrOCppPj4yXSxzPUZbdCsoOCppKzQpPj4yXSx1PVRlLndyaXRlKGUsUixhLHMsbik7aWYodTwwKXJldHVybi0xO28rPXV9cmV0dXJuIG99LHZhcmFyZ3M6MCxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIFNlLnZhcmFyZ3MrPTQsRltTZS52YXJhcmdzLTQ+PjJdfSxnZXRTdHI6ZnVuY3Rpb24oKXtyZXR1cm4gdihTZS5nZXQoKSl9LGdldFN0cmVhbUZyb21GRDpmdW5jdGlvbigpe3ZhciBlPVRlLmdldFN0cmVhbShTZS5nZXQoKSk7aWYoIWUpdGhyb3cgbmV3IFRlLkVycm5vRXJyb3IobWUuRUJBREYpO3JldHVybiBlfSxnZXRTb2NrZXRGcm9tRkQ6ZnVuY3Rpb24oKXt2YXIgZT1TT0NLRlMuZ2V0U29ja2V0KFNlLmdldCgpKTtpZighZSl0aHJvdyBuZXcgVGUuRXJybm9FcnJvcihtZS5FQkFERik7cmV0dXJuIGV9LGdldFNvY2tldEFkZHJlc3M6ZnVuY3Rpb24oZSl7dmFyIHQ9U2UuZ2V0KCkscj1TZS5nZXQoKTtpZihlJiYwPT09dClyZXR1cm4gbnVsbDt2YXIgbj1fX3JlYWRfc29ja2FkZHIodCxyKTtpZihuLmVycm5vKXRocm93IG5ldyBUZS5FcnJub0Vycm9yKG4uZXJybm8pO3JldHVybiBuLmFkZHI9RE5TLmxvb2t1cF9hZGRyKG4uYWRkcil8fG4uYWRkcixufSxnZXQ2NDpmdW5jdGlvbigpe3ZhciBlPVNlLmdldCgpLHQ9U2UuZ2V0KCk7cmV0dXJuIHkoZT49MD8wPT09dDotMT09PXQpLGV9LGdldFplcm86ZnVuY3Rpb24oKXt5KDA9PT1TZS5nZXQoKSl9fTt2YXIga2U9NDI7dmFyIFBlPXt9O2Z1bmN0aW9uIERlKGUpe2Zvcig7ZS5sZW5ndGg7KXt2YXIgdD1lLnBvcCgpO2UucG9wKCkodCl9fWZ1bmN0aW9uIFJlKGUpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShNW2U+PjJdKX12YXIgT2U9e30sQ2U9e30sTmU9e307ZnVuY3Rpb24gRmUoZSl7aWYodm9pZCAwPT09ZSlyZXR1cm4iX3Vua25vd24iO3ZhciB0PShlPWUucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCIkIikpLmNoYXJDb2RlQXQoMCk7cmV0dXJuIHQ+PTQ4JiZ0PD01Nz8iXyIrZTplfWZ1bmN0aW9uIE1lKGUsdCl7cmV0dXJuIGU9RmUoZSksbmV3IEZ1bmN0aW9uKCJib2R5IiwicmV0dXJuIGZ1bmN0aW9uICIrZSsnKCkge1xuICAgICJ1c2Ugc3RyaWN0IjsgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4nKSh0KX1mdW5jdGlvbiBJZShlLHQpe3ZhciByPU1lKHQsKGZ1bmN0aW9uKGUpe3RoaXMubmFtZT10LHRoaXMubWVzc2FnZT1lO3ZhciByPW5ldyBFcnJvcihlKS5zdGFjazt2b2lkIDAhPT1yJiYodGhpcy5zdGFjaz10aGlzLnRvU3RyaW5nKCkrIlxuIityLnJlcGxhY2UoL15FcnJvcig6W15cbl0qKT9cbi8sIiIpKX0pKTtyZXR1cm4gci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSksci5wcm90b3R5cGUuY29uc3RydWN0b3I9cixyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10aGlzLm1lc3NhZ2U/dGhpcy5uYW1lOnRoaXMubmFtZSsiOiAiK3RoaXMubWVzc2FnZX0scn12YXIgQmU9dm9pZCAwO2Z1bmN0aW9uIExlKGUpe3Rocm93IG5ldyBCZShlKX1mdW5jdGlvbiB4ZShlLHQscil7ZnVuY3Rpb24gbih0KXt2YXIgbj1yKHQpO24ubGVuZ3RoIT09ZS5sZW5ndGgmJkxlKCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50Iik7Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pWWUoZVtvXSxuW29dKX1lLmZvckVhY2goKGZ1bmN0aW9uKGUpe05lW2VdPXR9KSk7dmFyIG89bmV3IEFycmF5KHQubGVuZ3RoKSxpPVtdLGE9MDt0LmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7Q2UuaGFzT3duUHJvcGVydHkoZSk/b1t0XT1DZVtlXTooaS5wdXNoKGUpLE9lLmhhc093blByb3BlcnR5KGUpfHwoT2VbZV09W10pLE9lW2VdLnB1c2goKGZ1bmN0aW9uKCl7b1t0XT1DZVtlXSwrK2E9PT1pLmxlbmd0aCYmbihvKX0pKSl9KSksMD09PWkubGVuZ3RoJiZuKG8pfWZ1bmN0aW9uIGplKGUpe3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIDA7Y2FzZSAyOnJldHVybiAxO2Nhc2UgNDpyZXR1cm4gMjtjYXNlIDg6cmV0dXJuIDM7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIHR5cGUgc2l6ZTogIitlKX19dmFyIFVlPXZvaWQgMDtmdW5jdGlvbiB6ZShlKXtmb3IodmFyIHQ9IiIscj1lO09bcl07KXQrPVVlW09bcisrXV07cmV0dXJuIHR9dmFyICRlPXZvaWQgMDtmdW5jdGlvbiBXZShlKXt0aHJvdyBuZXcgJGUoZSl9ZnVuY3Rpb24gWWUoZSx0LHIpe2lmKHI9cnx8e30sISgiYXJnUGFja0FkdmFuY2UiaW4gdCkpdGhyb3cgbmV3IFR5cGVFcnJvcigicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZSIpO3ZhciBuPXQubmFtZTtpZihlfHxXZSgndHlwZSAiJytuKyciIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXInKSxDZS5oYXNPd25Qcm9wZXJ0eShlKSl7aWYoci5pZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zKXJldHVybjtXZSgiQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyIrbisiJyB0d2ljZSIpfWlmKENlW2VdPXQsZGVsZXRlIE5lW2VdLE9lLmhhc093blByb3BlcnR5KGUpKXt2YXIgbz1PZVtlXTtkZWxldGUgT2VbZV0sby5mb3JFYWNoKChmdW5jdGlvbihlKXtlKCl9KSl9fWZ1bmN0aW9uIFZlKGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGV0KSlyZXR1cm4hMTtpZighKGUgaW5zdGFuY2VvZiBldCkpcmV0dXJuITE7Zm9yKHZhciB0PXRoaXMuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3Mscj10aGlzLiQkLnB0cixuPWUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3Msbz1lLiQkLnB0cjt0LmJhc2VDbGFzczspcj10LnVwY2FzdChyKSx0PXQuYmFzZUNsYXNzO2Zvcig7bi5iYXNlQ2xhc3M7KW89bi51cGNhc3Qobyksbj1uLmJhc2VDbGFzcztyZXR1cm4gdD09PW4mJnI9PT1vfWZ1bmN0aW9uIEhlKGUpe1dlKGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MubmFtZSsiIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZCIpfWZ1bmN0aW9uIEdlKCl7aWYodGhpcy4kJC5wdHJ8fEhlKHRoaXMpLHRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpcmV0dXJuIHRoaXMuJCQuY291bnQudmFsdWUrPTEsdGhpczt2YXIgZSx0PU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLHskJDp7dmFsdWU6KGU9dGhpcy4kJCx7Y291bnQ6ZS5jb3VudCxkZWxldGVTY2hlZHVsZWQ6ZS5kZWxldGVTY2hlZHVsZWQscHJlc2VydmVQb2ludGVyT25EZWxldGU6ZS5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSxwdHI6ZS5wdHIscHRyVHlwZTplLnB0clR5cGUsc21hcnRQdHI6ZS5zbWFydFB0cixzbWFydFB0clR5cGU6ZS5zbWFydFB0clR5cGV9KX19KTtyZXR1cm4gdC4kJC5jb3VudC52YWx1ZSs9MSx0LiQkLmRlbGV0ZVNjaGVkdWxlZD0hMSx0fWZ1bmN0aW9uIHFlKCl7dmFyIGU7dGhpcy4kJC5wdHJ8fEhlKHRoaXMpLHRoaXMuJCQuZGVsZXRlU2NoZWR1bGVkJiYhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSYmV2UoIk9iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb24iKSx0aGlzLiQkLmNvdW50LnZhbHVlLT0xLDA9PT10aGlzLiQkLmNvdW50LnZhbHVlJiYoKGU9dGhpcy4kJCkuc21hcnRQdHI/ZS5zbWFydFB0clR5cGUucmF3RGVzdHJ1Y3RvcihlLnNtYXJ0UHRyKTplLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLnJhd0Rlc3RydWN0b3IoZS5wdHIpKSx0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlfHwodGhpcy4kJC5zbWFydFB0cj12b2lkIDAsdGhpcy4kJC5wdHI9dm9pZCAwKX1mdW5jdGlvbiBYZSgpe3JldHVybiF0aGlzLiQkLnB0cn12YXIgS2U9dm9pZCAwLEplPVtdO2Z1bmN0aW9uIFplKCl7Zm9yKDtKZS5sZW5ndGg7KXt2YXIgZT1KZS5wb3AoKTtlLiQkLmRlbGV0ZVNjaGVkdWxlZD0hMSxlLmRlbGV0ZSgpfX1mdW5jdGlvbiBRZSgpe3JldHVybiB0aGlzLiQkLnB0cnx8SGUodGhpcyksdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQmJiF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlJiZXZSgiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbiIpLEplLnB1c2godGhpcyksMT09PUplLmxlbmd0aCYmS2UmJktlKFplKSx0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZD0hMCx0aGlzfWZ1bmN0aW9uIGV0KCl7fXZhciB0dD17fTtmdW5jdGlvbiBydChlLHQscil7aWYodm9pZCAwPT09ZVt0XS5vdmVybG9hZFRhYmxlKXt2YXIgbj1lW3RdO2VbdF09ZnVuY3Rpb24oKXtyZXR1cm4gZVt0XS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpfHxXZSgiRnVuY3Rpb24gJyIrcisiJyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCIrYXJndW1lbnRzLmxlbmd0aCsiKSAtIGV4cGVjdHMgb25lIG9mICgiK2VbdF0ub3ZlcmxvYWRUYWJsZSsiKSEiKSxlW3RdLm92ZXJsb2FkVGFibGVbYXJndW1lbnRzLmxlbmd0aF0uYXBwbHkodGhpcyxhcmd1bWVudHMpfSxlW3RdLm92ZXJsb2FkVGFibGU9W10sZVt0XS5vdmVybG9hZFRhYmxlW24uYXJnQ291bnRdPW59fWZ1bmN0aW9uIG50KGUsdCxyLG4sbyxpLGEscyl7dGhpcy5uYW1lPWUsdGhpcy5jb25zdHJ1Y3Rvcj10LHRoaXMuaW5zdGFuY2VQcm90b3R5cGU9cix0aGlzLnJhd0Rlc3RydWN0b3I9bix0aGlzLmJhc2VDbGFzcz1vLHRoaXMuZ2V0QWN0dWFsVHlwZT1pLHRoaXMudXBjYXN0PWEsdGhpcy5kb3duY2FzdD1zLHRoaXMucHVyZVZpcnR1YWxGdW5jdGlvbnM9W119ZnVuY3Rpb24gb3QoZSx0LHIpe2Zvcig7dCE9PXI7KXQudXBjYXN0fHxXZSgiRXhwZWN0ZWQgbnVsbCBvciBpbnN0YW5jZSBvZiAiK3IubmFtZSsiLCBnb3QgYW4gaW5zdGFuY2Ugb2YgIit0Lm5hbWUpLGU9dC51cGNhc3QoZSksdD10LmJhc2VDbGFzcztyZXR1cm4gZX1mdW5jdGlvbiBpdChlLHQpe2lmKG51bGw9PT10KXJldHVybiB0aGlzLmlzUmVmZXJlbmNlJiZXZSgibnVsbCBpcyBub3QgYSB2YWxpZCAiK3RoaXMubmFtZSksMDt0LiQkfHxXZSgnQ2Fubm90IHBhc3MgIicrT3QodCkrJyIgYXMgYSAnK3RoaXMubmFtZSksdC4kJC5wdHJ8fFdlKCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAiK3RoaXMubmFtZSk7dmFyIHI9dC4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcztyZXR1cm4gb3QodC4kJC5wdHIscix0aGlzLnJlZ2lzdGVyZWRDbGFzcyl9ZnVuY3Rpb24gYXQoZSx0KXt2YXIgcjtpZihudWxsPT09dClyZXR1cm4gdGhpcy5pc1JlZmVyZW5jZSYmV2UoIm51bGwgaXMgbm90IGEgdmFsaWQgIit0aGlzLm5hbWUpLHRoaXMuaXNTbWFydFBvaW50ZXI/KHI9dGhpcy5yYXdDb25zdHJ1Y3RvcigpLG51bGwhPT1lJiZlLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLHIpLHIpOjA7dC4kJHx8V2UoJ0Nhbm5vdCBwYXNzICInK090KHQpKyciIGFzIGEgJyt0aGlzLm5hbWUpLHQuJCQucHRyfHxXZSgiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgIit0aGlzLm5hbWUpLCF0aGlzLmlzQ29uc3QmJnQuJCQucHRyVHlwZS5pc0NvbnN0JiZXZSgiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAiKyh0LiQkLnNtYXJ0UHRyVHlwZT90LiQkLnNtYXJ0UHRyVHlwZS5uYW1lOnQuJCQucHRyVHlwZS5uYW1lKSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTt2YXIgbj10LiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO2lmKHI9b3QodC4kJC5wdHIsbix0aGlzLnJlZ2lzdGVyZWRDbGFzcyksdGhpcy5pc1NtYXJ0UG9pbnRlcilzd2l0Y2godm9pZCAwPT09dC4kJC5zbWFydFB0ciYmV2UoIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsIiksdGhpcy5zaGFyaW5nUG9saWN5KXtjYXNlIDA6dC4kJC5zbWFydFB0clR5cGU9PT10aGlzP3I9dC4kJC5zbWFydFB0cjpXZSgiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAiKyh0LiQkLnNtYXJ0UHRyVHlwZT90LiQkLnNtYXJ0UHRyVHlwZS5uYW1lOnQuJCQucHRyVHlwZS5uYW1lKSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTticmVhaztjYXNlIDE6cj10LiQkLnNtYXJ0UHRyO2JyZWFrO2Nhc2UgMjppZih0LiQkLnNtYXJ0UHRyVHlwZT09PXRoaXMpcj10LiQkLnNtYXJ0UHRyO2Vsc2V7dmFyIG89dC5jbG9uZSgpO3I9dGhpcy5yYXdTaGFyZShyLFJ0KChmdW5jdGlvbigpe28uZGVsZXRlKCl9KSkpLG51bGwhPT1lJiZlLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLHIpfWJyZWFrO2RlZmF1bHQ6V2UoIlVuc3VwcG9ydGluZyBzaGFyaW5nIHBvbGljeSIpfXJldHVybiByfWZ1bmN0aW9uIHN0KGUsdCl7aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2UmJldlKCJudWxsIGlzIG5vdCBhIHZhbGlkICIrdGhpcy5uYW1lKSwwO3QuJCR8fFdlKCdDYW5ub3QgcGFzcyAiJytPdCh0KSsnIiBhcyBhICcrdGhpcy5uYW1lKSx0LiQkLnB0cnx8V2UoIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICIrdGhpcy5uYW1lKSx0LiQkLnB0clR5cGUuaXNDb25zdCYmV2UoIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgIit0LiQkLnB0clR5cGUubmFtZSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTt2YXIgcj10LiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3JldHVybiBvdCh0LiQkLnB0cixyLHRoaXMucmVnaXN0ZXJlZENsYXNzKX1mdW5jdGlvbiB1dChlKXtyZXR1cm4gdGhpcy5yYXdHZXRQb2ludGVlJiYoZT10aGlzLnJhd0dldFBvaW50ZWUoZSkpLGV9ZnVuY3Rpb24gY3QoZSl7dGhpcy5yYXdEZXN0cnVjdG9yJiZ0aGlzLnJhd0Rlc3RydWN0b3IoZSl9ZnVuY3Rpb24gbHQoZSl7bnVsbCE9PWUmJmUuZGVsZXRlKCl9ZnVuY3Rpb24gZnQoKXtyZXR1cm4gT2JqZWN0LmtleXMocHQpLmxlbmd0aH1mdW5jdGlvbiBkdCgpe3ZhciBlPVtdO2Zvcih2YXIgdCBpbiBwdClwdC5oYXNPd25Qcm9wZXJ0eSh0KSYmZS5wdXNoKHB0W3RdKTtyZXR1cm4gZX1mdW5jdGlvbiBodChlKXtLZT1lLEplLmxlbmd0aCYmS2UmJktlKFplKX12YXIgcHQ9e307ZnVuY3Rpb24gbXQoZSx0KXtyZXR1cm4gdD1mdW5jdGlvbihlLHQpe2Zvcih2b2lkIDA9PT10JiZXZSgicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkIik7ZS5iYXNlQ2xhc3M7KXQ9ZS51cGNhc3QodCksZT1lLmJhc2VDbGFzcztyZXR1cm4gdH0oZSx0KSxwdFt0XX1mdW5jdGlvbiB5dChlLHQpe3JldHVybiB0LnB0clR5cGUmJnQucHRyfHxMZSgibWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZSIpLCEhdC5zbWFydFB0clR5cGUhPT0hIXQuc21hcnRQdHImJkxlKCJCb3RoIHNtYXJ0UHRyVHlwZSBhbmQgc21hcnRQdHIgbXVzdCBiZSBzcGVjaWZpZWQiKSx0LmNvdW50PXt2YWx1ZToxfSxPYmplY3QuY3JlYXRlKGUseyQkOnt2YWx1ZTp0fX0pfWZ1bmN0aW9uIEV0KGUpe3ZhciB0PXRoaXMuZ2V0UG9pbnRlZShlKTtpZighdClyZXR1cm4gdGhpcy5kZXN0cnVjdG9yKGUpLG51bGw7dmFyIHI9bXQodGhpcy5yZWdpc3RlcmVkQ2xhc3MsdCk7aWYodm9pZCAwIT09cil7aWYoMD09PXIuJCQuY291bnQudmFsdWUpcmV0dXJuIHIuJCQucHRyPXQsci4kJC5zbWFydFB0cj1lLHIuY2xvbmUoKTt2YXIgbj1yLmNsb25lKCk7cmV0dXJuIHRoaXMuZGVzdHJ1Y3RvcihlKSxufWZ1bmN0aW9uIG8oKXtyZXR1cm4gdGhpcy5pc1NtYXJ0UG9pbnRlcj95dCh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTp0aGlzLnBvaW50ZWVUeXBlLHB0cjp0LHNtYXJ0UHRyVHlwZTp0aGlzLHNtYXJ0UHRyOmV9KTp5dCh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTp0aGlzLHB0cjplfSl9dmFyIGksYT10aGlzLnJlZ2lzdGVyZWRDbGFzcy5nZXRBY3R1YWxUeXBlKHQpLHM9dHRbYV07aWYoIXMpcmV0dXJuIG8uY2FsbCh0aGlzKTtpPXRoaXMuaXNDb25zdD9zLmNvbnN0UG9pbnRlclR5cGU6cy5wb2ludGVyVHlwZTt2YXIgdT1mdW5jdGlvbiBlKHQscixuKXtpZihyPT09bilyZXR1cm4gdDtpZih2b2lkIDA9PT1uLmJhc2VDbGFzcylyZXR1cm4gbnVsbDt2YXIgbz1lKHQscixuLmJhc2VDbGFzcyk7cmV0dXJuIG51bGw9PT1vP251bGw6bi5kb3duY2FzdChvKX0odCx0aGlzLnJlZ2lzdGVyZWRDbGFzcyxpLnJlZ2lzdGVyZWRDbGFzcyk7cmV0dXJuIG51bGw9PT11P28uY2FsbCh0aGlzKTp0aGlzLmlzU21hcnRQb2ludGVyP3l0KGkucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLHtwdHJUeXBlOmkscHRyOnUsc21hcnRQdHJUeXBlOnRoaXMsc21hcnRQdHI6ZX0pOnl0KGkucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLHtwdHJUeXBlOmkscHRyOnV9KX1mdW5jdGlvbiBndChlLHQscixuLG8saSxhLHMsdSxjLGwpe3RoaXMubmFtZT1lLHRoaXMucmVnaXN0ZXJlZENsYXNzPXQsdGhpcy5pc1JlZmVyZW5jZT1yLHRoaXMuaXNDb25zdD1uLHRoaXMuaXNTbWFydFBvaW50ZXI9byx0aGlzLnBvaW50ZWVUeXBlPWksdGhpcy5zaGFyaW5nUG9saWN5PWEsdGhpcy5yYXdHZXRQb2ludGVlPXMsdGhpcy5yYXdDb25zdHJ1Y3Rvcj11LHRoaXMucmF3U2hhcmU9Yyx0aGlzLnJhd0Rlc3RydWN0b3I9bCxvfHx2b2lkIDAhPT10LmJhc2VDbGFzcz90aGlzLnRvV2lyZVR5cGU9YXQ6bj8odGhpcy50b1dpcmVUeXBlPWl0LHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uPW51bGwpOih0aGlzLnRvV2lyZVR5cGU9c3QsdGhpcy5kZXN0cnVjdG9yRnVuY3Rpb249bnVsbCl9ZnVuY3Rpb24gdnQoZSx0KXt2YXIgcjtpZihlPXplKGUpLHZvaWQgMCE9PW9bIkZVTkNUSU9OX1RBQkxFXyIrZV0pcj1vWyJGVU5DVElPTl9UQUJMRV8iK2VdW3RdO2Vsc2UgaWYoInVuZGVmaW5lZCIhPXR5cGVvZiBGVU5DVElPTl9UQUJMRSlyPUZVTkNUSU9OX1RBQkxFW3RdO2Vsc2V7dmFyIG49by5hc21bImR5bkNhbGxfIitlXTt2b2lkIDA9PT1uJiZ2b2lkIDA9PT0obj1vLmFzbVsiZHluQ2FsbF8iK2UucmVwbGFjZSgvZi9nLCJkIildKSYmV2UoIk5vIGR5bkNhbGwgaW52b2tlciBmb3Igc2lnbmF0dXJlOiAiK2UpLHI9ZnVuY3Rpb24ocil7Zm9yKHZhciBuPVtdLG89MTtvPGUubGVuZ3RoOysrbyluLnB1c2goImEiK28pO3ZhciBpPSJyZXR1cm4gZnVuY3Rpb24gIisoImR5bkNhbGxfIitlKyJfIit0KSsiKCIrbi5qb2luKCIsICIpKyIpIHtcbiI7cmV0dXJuIGkrPSIgICAgcmV0dXJuIGR5bkNhbGwocmF3RnVuY3Rpb24iKyhuLmxlbmd0aD8iLCAiOiIiKStuLmpvaW4oIiwgIikrIik7XG4iLGkrPSJ9O1xuIixuZXcgRnVuY3Rpb24oImR5bkNhbGwiLCJyYXdGdW5jdGlvbiIsaSkocix0KX0obil9cmV0dXJuImZ1bmN0aW9uIiE9dHlwZW9mIHImJldlKCJ1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgIitlKyI6ICIrdCkscn12YXIgd3Q9dm9pZCAwO2Z1bmN0aW9uIF90KGUpe3ZhciB0PXF0KGUpLHI9emUodCk7cmV0dXJuIEt0KHQpLHJ9ZnVuY3Rpb24gYnQoZSx0KXt2YXIgcj1bXSxuPXt9O3Rocm93IHQuZm9yRWFjaCgoZnVuY3Rpb24gZSh0KXtuW3RdfHxDZVt0XXx8KE5lW3RdP05lW3RdLmZvckVhY2goZSk6KHIucHVzaCh0KSxuW3RdPSEwKSl9KSksbmV3IHd0KGUrIjogIityLm1hcChfdCkuam9pbihbIiwgIl0pKX1mdW5jdGlvbiBBdChlLHQpe2Zvcih2YXIgcj1bXSxuPTA7bjxlO24rKylyLnB1c2goRlsodD4+Mikrbl0pO3JldHVybiByfWZ1bmN0aW9uIFR0KGUsdCxyLG4sbyl7dmFyIGk9dC5sZW5ndGg7aTwyJiZXZSgiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhIik7Zm9yKHZhciBhPW51bGwhPT10WzFdJiZudWxsIT09cixzPSExLHU9MTt1PHQubGVuZ3RoOysrdSlpZihudWxsIT09dFt1XSYmdm9pZCAwPT09dFt1XS5kZXN0cnVjdG9yRnVuY3Rpb24pe3M9ITA7YnJlYWt9dmFyIGM9InZvaWQiIT09dFswXS5uYW1lLGw9IiIsZj0iIjtmb3IodT0wO3U8aS0yOysrdSlsKz0oMCE9PXU/IiwgIjoiIikrImFyZyIrdSxmKz0oMCE9PXU/IiwgIjoiIikrImFyZyIrdSsiV2lyZWQiO3ZhciBkPSJyZXR1cm4gZnVuY3Rpb24gIitGZShlKSsiKCIrbCsiKSB7XG5pZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gIisoaS0yKSsiKSB7XG50aHJvd0JpbmRpbmdFcnJvcignZnVuY3Rpb24gIitlKyIgY2FsbGVkIHdpdGggJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cywgZXhwZWN0ZWQgIisoaS0yKSsiIGFyZ3MhJyk7XG59XG4iO3MmJihkKz0idmFyIGRlc3RydWN0b3JzID0gW107XG4iKTt2YXIgaD1zPyJkZXN0cnVjdG9ycyI6Im51bGwiLHA9WyJ0aHJvd0JpbmRpbmdFcnJvciIsImludm9rZXIiLCJmbiIsInJ1bkRlc3RydWN0b3JzIiwicmV0VHlwZSIsImNsYXNzUGFyYW0iXSxtPVtXZSxuLG8sRGUsdFswXSx0WzFdXTthJiYoZCs9InZhciB0aGlzV2lyZWQgPSBjbGFzc1BhcmFtLnRvV2lyZVR5cGUoIitoKyIsIHRoaXMpO1xuIik7Zm9yKHU9MDt1PGktMjsrK3UpZCs9InZhciBhcmciK3UrIldpcmVkID0gYXJnVHlwZSIrdSsiLnRvV2lyZVR5cGUoIitoKyIsIGFyZyIrdSsiKTsgLy8gIit0W3UrMl0ubmFtZSsiXG4iLHAucHVzaCgiYXJnVHlwZSIrdSksbS5wdXNoKHRbdSsyXSk7aWYoYSYmKGY9InRoaXNXaXJlZCIrKGYubGVuZ3RoPjA/IiwgIjoiIikrZiksZCs9KGM/InZhciBydiA9ICI6IiIpKyJpbnZva2VyKGZuIisoZi5sZW5ndGg+MD8iLCAiOiIiKStmKyIpO1xuIixzKWQrPSJydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7XG4iO2Vsc2UgZm9yKHU9YT8xOjI7dTx0Lmxlbmd0aDsrK3Upe3ZhciB5PTE9PT11PyJ0aGlzV2lyZWQiOiJhcmciKyh1LTIpKyJXaXJlZCI7bnVsbCE9PXRbdV0uZGVzdHJ1Y3RvckZ1bmN0aW9uJiYoZCs9eSsiX2R0b3IoIit5KyIpOyAvLyAiK3RbdV0ubmFtZSsiXG4iLHAucHVzaCh5KyJfZHRvciIpLG0ucHVzaCh0W3VdLmRlc3RydWN0b3JGdW5jdGlvbikpfXJldHVybiBjJiYoZCs9InZhciByZXQgPSByZXRUeXBlLmZyb21XaXJlVHlwZShydik7XG5yZXR1cm4gcmV0O1xuIiksZCs9In1cbiIscC5wdXNoKGQpLGZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IG5ldyBUeXBlRXJyb3IoIm5ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAiK3R5cGVvZiBlKyIgd2hpY2ggaXMgbm90IGEgZnVuY3Rpb24iKTt2YXIgcj1NZShlLm5hbWV8fCJ1bmtub3duRnVuY3Rpb25OYW1lIiwoZnVuY3Rpb24oKXt9KSk7ci5wcm90b3R5cGU9ZS5wcm90b3R5cGU7dmFyIG49bmV3IHIsbz1lLmFwcGx5KG4sdCk7cmV0dXJuIG8gaW5zdGFuY2VvZiBPYmplY3Q/bzpufShGdW5jdGlvbixwKS5hcHBseShudWxsLG0pfXZhciBTdD1bXSxrdD1be30se3ZhbHVlOnZvaWQgMH0se3ZhbHVlOm51bGx9LHt2YWx1ZTohMH0se3ZhbHVlOiExfV07ZnVuY3Rpb24gUHQoKXtmb3IodmFyIGU9MCx0PTU7dDxrdC5sZW5ndGg7Kyt0KXZvaWQgMCE9PWt0W3RdJiYrK2U7cmV0dXJuIGV9ZnVuY3Rpb24gRHQoKXtmb3IodmFyIGU9NTtlPGt0Lmxlbmd0aDsrK2UpaWYodm9pZCAwIT09a3RbZV0pcmV0dXJuIGt0W2VdO3JldHVybiBudWxsfWZ1bmN0aW9uIFJ0KGUpe3N3aXRjaChlKXtjYXNlIHZvaWQgMDpyZXR1cm4gMTtjYXNlIG51bGw6cmV0dXJuIDI7Y2FzZSEwOnJldHVybiAzO2Nhc2UhMTpyZXR1cm4gNDtkZWZhdWx0OnZhciB0PVN0Lmxlbmd0aD9TdC5wb3AoKTprdC5sZW5ndGg7cmV0dXJuIGt0W3RdPXtyZWZjb3VudDoxLHZhbHVlOmV9LHR9fWZ1bmN0aW9uIE90KGUpe2lmKG51bGw9PT1lKXJldHVybiJudWxsIjt2YXIgdD10eXBlb2YgZTtyZXR1cm4ib2JqZWN0Ij09PXR8fCJhcnJheSI9PT10fHwiZnVuY3Rpb24iPT09dD9lLnRvU3RyaW5nKCk6IiIrZX1mdW5jdGlvbiBDdChlLHQpe3N3aXRjaCh0KXtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShJW2U+PjJdKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoQltlPj4zXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBmbG9hdCB0eXBlOiAiK2UpfX1mdW5jdGlvbiBOdChlLHQscil7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gcj9mdW5jdGlvbihlKXtyZXR1cm4gUltlXX06ZnVuY3Rpb24oZSl7cmV0dXJuIE9bZV19O2Nhc2UgMTpyZXR1cm4gcj9mdW5jdGlvbihlKXtyZXR1cm4gQ1tlPj4xXX06ZnVuY3Rpb24oZSl7cmV0dXJuIE5bZT4+MV19O2Nhc2UgMjpyZXR1cm4gcj9mdW5jdGlvbihlKXtyZXR1cm4gRltlPj4yXX06ZnVuY3Rpb24oZSl7cmV0dXJuIE1bZT4+Ml19O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBpbnRlZ2VyIHR5cGU6ICIrZSl9fXZhciBGdD1MKz0xNjt2YXIgTXQ9e307dmFyIEl0PUwrPTE2O0wrPTQ4O2coJHQoIkdNVCIpLCJpOCIsMik7dmFyIEJ0PUwsTHQ9TCs9MTYseHQ9TCs9MTY7ZnVuY3Rpb24ganQoKXtpZighanQuY2FsbGVkKXtqdC5jYWxsZWQ9ITAsRlt4dD4+Ml09NjAqKG5ldyBEYXRlKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBlPW5ldyBEYXRlKDJlMywwLDEpLHQ9bmV3IERhdGUoMmUzLDYsMSk7RltMdD4+Ml09TnVtYmVyKGUuZ2V0VGltZXpvbmVPZmZzZXQoKSE9dC5nZXRUaW1lem9uZU9mZnNldCgpKTt2YXIgcj1hKGUpLG49YSh0KSxvPWcoJHQociksImk4IiwwKSxpPWcoJHQobiksImk4IiwwKTt0LmdldFRpbWV6b25lT2Zmc2V0KCk8ZS5nZXRUaW1lem9uZU9mZnNldCgpPyhGW0J0Pj4yXT1vLEZbQnQrND4+Ml09aSk6KEZbQnQ+PjJdPWksRltCdCs0Pj4yXT1vKX1mdW5jdGlvbiBhKGUpe3ZhciB0PWUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1woKFtBLVphLXogXSspXCkkLyk7cmV0dXJuIHQ/dFsxXToiR01UIn19TCs9MTY7dmFyIFV0PXt9O3ZhciB6dD0xO2Z1bmN0aW9uICR0KGUsdCxyKXt2YXIgbj1yPjA/cjpTKGUpKzEsbz1uZXcgQXJyYXkobiksaT1BKGUsbywwLG8ubGVuZ3RoKTtyZXR1cm4gdCYmKG8ubGVuZ3RoPWkpLG99VGUuc3RhdGljSW5pdCgpLEoudW5zaGlmdCgoZnVuY3Rpb24oKXtvLm5vRlNJbml0fHxUZS5pbml0LmluaXRpYWxpemVkfHxUZS5pbml0KCl9KSksWi5wdXNoKChmdW5jdGlvbigpe1RlLmlnbm9yZVBlcm1pc3Npb25zPSExfSkpLFEucHVzaCgoZnVuY3Rpb24oKXtUZS5xdWl0KCl9KSksSi51bnNoaWZ0KChmdW5jdGlvbigpe3ZlLmluaXQoKX0pKSxRLnB1c2goKGZ1bmN0aW9uKCl7dmUuc2h1dGRvd24oKX0pKSxCZT1vLkludGVybmFsRXJyb3I9SWUoRXJyb3IsIkludGVybmFsRXJyb3IiKSxmdW5jdGlvbigpe2Zvcih2YXIgZT1uZXcgQXJyYXkoMjU2KSx0PTA7dDwyNTY7Kyt0KWVbdF09U3RyaW5nLmZyb21DaGFyQ29kZSh0KTtVZT1lfSgpLCRlPW8uQmluZGluZ0Vycm9yPUllKEVycm9yLCJCaW5kaW5nRXJyb3IiKSxldC5wcm90b3R5cGUuaXNBbGlhc09mPVZlLGV0LnByb3RvdHlwZS5jbG9uZT1HZSxldC5wcm90b3R5cGUuZGVsZXRlPXFlLGV0LnByb3RvdHlwZS5pc0RlbGV0ZWQ9WGUsZXQucHJvdG90eXBlLmRlbGV0ZUxhdGVyPVFlLGd0LnByb3RvdHlwZS5nZXRQb2ludGVlPXV0LGd0LnByb3RvdHlwZS5kZXN0cnVjdG9yPWN0LGd0LnByb3RvdHlwZS5hcmdQYWNrQWR2YW5jZT04LGd0LnByb3RvdHlwZS5yZWFkVmFsdWVGcm9tUG9pbnRlcj1SZSxndC5wcm90b3R5cGUuZGVsZXRlT2JqZWN0PWx0LGd0LnByb3RvdHlwZS5mcm9tV2lyZVR5cGU9RXQsby5nZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50PWZ0LG8uZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcz1kdCxvLmZsdXNoUGVuZGluZ0RlbGV0ZXM9WmUsby5zZXREZWxheUZ1bmN0aW9uPWh0LHd0PW8uVW5ib3VuZFR5cGVFcnJvcj1JZShFcnJvciwiVW5ib3VuZFR5cGVFcnJvciIpLG8uY291bnRfZW12YWxfaGFuZGxlcz1QdCxvLmdldF9maXJzdF9lbXZhbD1EdCxmdW5jdGlvbiBlKHQpe3ZhciByLG47ZS5jYWxsZWQ/KG49RltGdD4+Ml0scj1GW24+PjJdKTooZS5jYWxsZWQ9ITAsTXQuVVNFUj1NdC5MT0dOQU1FPSJ3ZWJfdXNlciIsTXQuUEFUSD0iLyIsTXQuUFdEPSIvIixNdC5IT01FPSIvaG9tZS93ZWJfdXNlciIsTXQuTEFORz0iQy5VVEYtOCIsTXQuXz1vLnRoaXNQcm9ncmFtLHI9ZigxMDI0KSxuPWYoMjU2KSxGW24+PjJdPXIsRltGdD4+Ml09bik7dmFyIGk9W10sYT0wO2Zvcih2YXIgcyBpbiB0KWlmKCJzdHJpbmciPT10eXBlb2YgdFtzXSl7dmFyIHU9cysiPSIrdFtzXTtpLnB1c2godSksYSs9dS5sZW5ndGh9aWYoYT4xMDI0KXRocm93IG5ldyBFcnJvcigiRW52aXJvbm1lbnQgc2l6ZSBleGNlZWRlZCBUT1RBTF9FTlZfU0laRSEiKTtmb3IodmFyIGM9MDtjPGkubGVuZ3RoO2MrKyl7cmUodT1pW2NdLHIpLEZbbis0KmM+PjJdPXIscis9dS5sZW5ndGgrMX1GW24rNCppLmxlbmd0aD4+Ml09MH0oTXQpLCQ9Zig0KSxqPVU9aChMKSx6PWgoaitHKSxGWyQ+PjJdPXoseD0hMCxvLndhc21UYWJsZVNpemU9MzE2LG8ud2FzbU1heFRhYmxlU2l6ZT0zMTYsby5hc21HbG9iYWxBcmc9e30sby5hc21MaWJyYXJ5QXJnPXthYm9ydDpycixlbmxhcmdlTWVtb3J5OkgsZ2V0VG90YWxNZW1vcnk6ZnVuY3Rpb24oKXtyZXR1cm4gcX0sYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnk6ZnVuY3Rpb24oKXtycigiQ2Fubm90IGVubGFyZ2UgbWVtb3J5IGFycmF5cy4gRWl0aGVyICgxKSBjb21waWxlIHdpdGggIC1zIFRPVEFMX01FTU9SWT1YICB3aXRoIFggaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgIitxKyIsICgyKSBjb21waWxlIHdpdGggIC1zIEFMTE9XX01FTU9SWV9HUk9XVEg9MSAgd2hpY2ggYWxsb3dzIGluY3JlYXNpbmcgdGhlIHNpemUgYXQgcnVudGltZSwgb3IgKDMpIGlmIHlvdSB3YW50IG1hbGxvYyB0byByZXR1cm4gTlVMTCAoMCkgaW5zdGVhZCBvZiB0aGlzIGFib3J0LCBjb21waWxlIHdpdGggIC1zIEFCT1JUSU5HX01BTExPQz0wICIpfSxpbnZva2VfaTpmdW5jdGlvbihlKXt0cnl7cmV0dXJuIG8uZHluQ2FsbF9pKGUpfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV9paTpmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gby5keW5DYWxsX2lpKGUsdCl9Y2F0Y2goZSl7aWYoIm51bWJlciIhPXR5cGVvZiBlJiYibG9uZ2ptcCIhPT1lKXRocm93IGU7by5zZXRUaHJldygxLDApfX0saW52b2tlX2lpaTpmdW5jdGlvbihlLHQscil7dHJ5e3JldHVybiBvLmR5bkNhbGxfaWlpKGUsdCxyKX1jYXRjaChlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUmJiJsb25nam1wIiE9PWUpdGhyb3cgZTtvLnNldFRocmV3KDEsMCl9fSxpbnZva2VfaWlpaTpmdW5jdGlvbihlLHQscixuKXt0cnl7cmV0dXJuIG8uZHluQ2FsbF9paWlpKGUsdCxyLG4pfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV9paWlpaTpmdW5jdGlvbihlLHQscixuLGkpe3RyeXtyZXR1cm4gby5keW5DYWxsX2lpaWlpKGUsdCxyLG4saSl9Y2F0Y2goZSl7aWYoIm51bWJlciIhPXR5cGVvZiBlJiYibG9uZ2ptcCIhPT1lKXRocm93IGU7by5zZXRUaHJldygxLDApfX0saW52b2tlX2lpaWlpaWk6ZnVuY3Rpb24oZSx0LHIsbixpLGEscyl7dHJ5e3JldHVybiBvLmR5bkNhbGxfaWlpaWlpaShlLHQscixuLGksYSxzKX1jYXRjaChlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUmJiJsb25nam1wIiE9PWUpdGhyb3cgZTtvLnNldFRocmV3KDEsMCl9fSxpbnZva2VfaWlpaWlpaWlpaTpmdW5jdGlvbihlLHQscixuLGksYSxzLHUsYyxsKXt0cnl7cmV0dXJuIG8uZHluQ2FsbF9paWlpaWlpaWlpKGUsdCxyLG4saSxhLHMsdSxjLGwpfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV9paWlpaWlqaWk6ZnVuY3Rpb24oZSx0LHIsbixpLGEscyx1LGMsbCl7dHJ5e3JldHVybiBvLmR5bkNhbGxfaWlpaWlpamlpKGUsdCxyLG4saSxhLHMsdSxjLGwpfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV9pamo6ZnVuY3Rpb24oZSx0LHIsbixpKXt0cnl7cmV0dXJuIG8uZHluQ2FsbF9pamooZSx0LHIsbixpKX1jYXRjaChlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUmJiJsb25nam1wIiE9PWUpdGhyb3cgZTtvLnNldFRocmV3KDEsMCl9fSxpbnZva2Vfamk6ZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIG8uZHluQ2FsbF9qaShlLHQpfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV92OmZ1bmN0aW9uKGUpe3RyeXtvLmR5bkNhbGxfdihlKX1jYXRjaChlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUmJiJsb25nam1wIiE9PWUpdGhyb3cgZTtvLnNldFRocmV3KDEsMCl9fSxpbnZva2Vfdmk6ZnVuY3Rpb24oZSx0KXt0cnl7by5keW5DYWxsX3ZpKGUsdCl9Y2F0Y2goZSl7aWYoIm51bWJlciIhPXR5cGVvZiBlJiYibG9uZ2ptcCIhPT1lKXRocm93IGU7by5zZXRUaHJldygxLDApfX0saW52b2tlX3ZpaTpmdW5jdGlvbihlLHQscil7dHJ5e28uZHluQ2FsbF92aWkoZSx0LHIpfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV92aWlpOmZ1bmN0aW9uKGUsdCxyLG4pe3RyeXtvLmR5bkNhbGxfdmlpaShlLHQscixuKX1jYXRjaChlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUmJiJsb25nam1wIiE9PWUpdGhyb3cgZTtvLnNldFRocmV3KDEsMCl9fSxpbnZva2VfdmlpaWk6ZnVuY3Rpb24oZSx0LHIsbixpKXt0cnl7by5keW5DYWxsX3ZpaWlpKGUsdCxyLG4saSl9Y2F0Y2goZSl7aWYoIm51bWJlciIhPXR5cGVvZiBlJiYibG9uZ2ptcCIhPT1lKXRocm93IGU7by5zZXRUaHJldygxLDApfX0saW52b2tlX3ZpaWlpaTpmdW5jdGlvbihlLHQscixuLGksYSl7dHJ5e28uZHluQ2FsbF92aWlpaWkoZSx0LHIsbixpLGEpfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV92aWlpaWlpOmZ1bmN0aW9uKGUsdCxyLG4saSxhLHMpe3RyeXtvLmR5bkNhbGxfdmlpaWlpaShlLHQscixuLGksYSxzKX1jYXRjaChlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUmJiJsb25nam1wIiE9PWUpdGhyb3cgZTtvLnNldFRocmV3KDEsMCl9fSxpbnZva2VfdmlpaWlpaWlpaTpmdW5jdGlvbihlLHQscixuLGksYSxzLHUsYyxsKXt0cnl7by5keW5DYWxsX3ZpaWlpaWlpaWkoZSx0LHIsbixpLGEscyx1LGMsbCl9Y2F0Y2goZSl7aWYoIm51bWJlciIhPXR5cGVvZiBlJiYibG9uZ2ptcCIhPT1lKXRocm93IGU7by5zZXRUaHJldygxLDApfX0saW52b2tlX3ZpaWlpaWlpaWlpOmZ1bmN0aW9uKGUsdCxyLG4saSxhLHMsdSxjLGwsZil7dHJ5e28uZHluQ2FsbF92aWlpaWlpaWlpaShlLHQscixuLGksYSxzLHUsYyxsLGYpfWNhdGNoKGUpe2lmKCJudW1iZXIiIT10eXBlb2YgZSYmImxvbmdqbXAiIT09ZSl0aHJvdyBlO28uc2V0VGhyZXcoMSwwKX19LGludm9rZV92aWo6ZnVuY3Rpb24oZSx0LHIsbil7dHJ5e28uZHluQ2FsbF92aWooZSx0LHIsbil9Y2F0Y2goZSl7aWYoIm51bWJlciIhPXR5cGVvZiBlJiYibG9uZ2ptcCIhPT1lKXRocm93IGU7by5zZXRUaHJldygxLDApfX0saW52b2tlX3Zpamk6ZnVuY3Rpb24oZSx0LHIsbixpKXt0cnl7by5keW5DYWxsX3ZpamkoZSx0LHIsbixpKX1jYXRjaChlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUmJiJsb25nam1wIiE9PWUpdGhyb3cgZTtvLnNldFRocmV3KDEsMCl9fSxfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uOmZ1bmN0aW9uKGUpe3JldHVybiBKdChlKX0sX19fY3hhX2JlZ2luX2NhdGNoOmZ1bmN0aW9uKGUpe3ZhciB0PWRlLmluZm9zW2VdO3JldHVybiB0JiYhdC5jYXVnaHQmJih0LmNhdWdodD0hMCksdCYmKHQucmV0aHJvd249ITEpLGRlLmNhdWdodC5wdXNoKGUpLGRlLmFkZFJlZihkZS5kZUFkanVzdChlKSksZX0sX19fY3hhX2VuZF9jYXRjaDpmdW5jdGlvbigpe28uc2V0VGhyZXcoMCk7dmFyIGU9ZGUuY2F1Z2h0LnBvcCgpO2UmJihkZS5kZWNSZWYoZGUuZGVBZGp1c3QoZSkpLGRlLmxhc3Q9MCl9LF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzI6ZnVuY3Rpb24oKXtyZXR1cm4gcGUuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8zOmZ1bmN0aW9uKCl7cmV0dXJuIHBlLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfNDpmdW5jdGlvbigpe3JldHVybiBwZS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9fX2N4YV9mcmVlX2V4Y2VwdGlvbjpoZSxfX19jeGFfdGhyb3c6ZnVuY3Rpb24oZSx0LHIpe3Rocm93IGRlLmluZm9zW2VdPXtwdHI6ZSxhZGp1c3RlZDplLHR5cGU6dCxkZXN0cnVjdG9yOnIscmVmY291bnQ6MCxjYXVnaHQ6ITEscmV0aHJvd246ITF9LGRlLmxhc3Q9ZSxlfSxfX19sb2NrOmZ1bmN0aW9uKCl7fSxfX19tYXBfZmlsZTpmdW5jdGlvbihlLHQpe3JldHVybiB5ZShtZS5FUEVSTSksLTF9LF9fX3Jlc3VtZUV4Y2VwdGlvbjpmdW5jdGlvbihlKXt0aHJvdyBkZS5sYXN0fHwoZGUubGFzdD1lKSxlfSxfX19zZXRFcnJObzp5ZSxfX19zeXNjYWxsMTQwOmZ1bmN0aW9uKGUsdCl7U2UudmFyYXJncz10O3RyeXt2YXIgcj1TZS5nZXRTdHJlYW1Gcm9tRkQoKSxuPShTZS5nZXQoKSxTZS5nZXQoKSksbz1TZS5nZXQoKSxpPVNlLmdldCgpLGE9bjtyZXR1cm4gVGUubGxzZWVrKHIsYSxpKSxGW28+PjJdPXIucG9zaXRpb24sci5nZXRkZW50cyYmMD09PWEmJjA9PT1pJiYoci5nZXRkZW50cz1udWxsKSwwfWNhdGNoKGUpe3JldHVybiB2b2lkIDAhPT1UZSYmZSBpbnN0YW5jZW9mIFRlLkVycm5vRXJyb3J8fHJyKGUpLC1lLmVycm5vfX0sX19fc3lzY2FsbDE0NTpmdW5jdGlvbihlLHQpe1NlLnZhcmFyZ3M9dDt0cnl7dmFyIHI9U2UuZ2V0U3RyZWFtRnJvbUZEKCksbj1TZS5nZXQoKSxvPVNlLmdldCgpO3JldHVybiBTZS5kb1JlYWR2KHIsbixvKX1jYXRjaChlKXtyZXR1cm4gdm9pZCAwIT09VGUmJmUgaW5zdGFuY2VvZiBUZS5FcnJub0Vycm9yfHxycihlKSwtZS5lcnJub319LF9fX3N5c2NhbGwxNDY6ZnVuY3Rpb24oZSx0KXtTZS52YXJhcmdzPXQ7dHJ5e3ZhciByPVNlLmdldFN0cmVhbUZyb21GRCgpLG49U2UuZ2V0KCksbz1TZS5nZXQoKTtyZXR1cm4gU2UuZG9Xcml0ZXYocixuLG8pfWNhdGNoKGUpe3JldHVybiB2b2lkIDAhPT1UZSYmZSBpbnN0YW5jZW9mIFRlLkVycm5vRXJyb3J8fHJyKGUpLC1lLmVycm5vfX0sX19fc3lzY2FsbDE4MzpmdW5jdGlvbihlLHQpe1NlLnZhcmFyZ3M9dDt0cnl7dmFyIHI9U2UuZ2V0KCksbj1TZS5nZXQoKTtpZigwPT09bilyZXR1cm4tbWUuRUlOVkFMO3ZhciBvPVRlLmN3ZCgpO3JldHVybiBuPFMobykrMT8tbWUuRVJBTkdFOihUKG8scixuKSxyKX1jYXRjaChlKXtyZXR1cm4gdm9pZCAwIT09VGUmJmUgaW5zdGFuY2VvZiBUZS5FcnJub0Vycm9yfHxycihlKSwtZS5lcnJub319LF9fX3N5c2NhbGwxOTg6ZnVuY3Rpb24oZSx0KXtTZS52YXJhcmdzPXQ7dHJ5e3ZhciByPVNlLmdldFN0cigpLG49U2UuZ2V0KCksbz1TZS5nZXQoKTtyZXR1cm4gVGUuY2hvd24ocixuLG8pLDB9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgMCE9PVRlJiZlIGluc3RhbmNlb2YgVGUuRXJybm9FcnJvcnx8cnIoZSksLWUuZXJybm99fSxfX19zeXNjYWxsMjA6ZnVuY3Rpb24oZSx0KXtTZS52YXJhcmdzPXQ7dHJ5e3JldHVybiBrZX1jYXRjaChlKXtyZXR1cm4gdm9pZCAwIT09VGUmJmUgaW5zdGFuY2VvZiBUZS5FcnJub0Vycm9yfHxycihlKSwtZS5lcnJub319LF9fX3N5c2NhbGw2OmZ1bmN0aW9uKGUsdCl7U2UudmFyYXJncz10O3RyeXt2YXIgcj1TZS5nZXRTdHJlYW1Gcm9tRkQoKTtyZXR1cm4gVGUuY2xvc2UociksMH1jYXRjaChlKXtyZXR1cm4gdm9pZCAwIT09VGUmJmUgaW5zdGFuY2VvZiBUZS5FcnJub0Vycm9yfHxycihlKSwtZS5lcnJub319LF9fX3N5c2NhbGw2MDpmdW5jdGlvbihlLHQpe1NlLnZhcmFyZ3M9dDt0cnl7dmFyIHI9U2UuZ2V0KCksbj1TZS51bWFzaztyZXR1cm4gU2UudW1hc2s9cixufWNhdGNoKGUpe3JldHVybiB2b2lkIDAhPT1UZSYmZSBpbnN0YW5jZW9mIFRlLkVycm5vRXJyb3J8fHJyKGUpLC1lLmVycm5vfX0sX19fc3lzY2FsbDgzOmZ1bmN0aW9uKGUsdCl7U2UudmFyYXJncz10O3RyeXt2YXIgcj1TZS5nZXRTdHIoKSxuPVNlLmdldFN0cigpO3JldHVybiBUZS5zeW1saW5rKHIsbiksMH1jYXRjaChlKXtyZXR1cm4gdm9pZCAwIT09VGUmJmUgaW5zdGFuY2VvZiBUZS5FcnJub0Vycm9yfHxycihlKSwtZS5lcnJub319LF9fX3N5c2NhbGw5MTpmdW5jdGlvbihlLHQpe1NlLnZhcmFyZ3M9dDt0cnl7dmFyIHI9U2UuZ2V0KCksbj1TZS5nZXQoKSxvPVNlLm1hcHBpbmdzW3JdO2lmKCFvKXJldHVybiAwO2lmKG49PT1vLmxlbil7dmFyIGk9VGUuZ2V0U3RyZWFtKG8uZmQpO1NlLmRvTXN5bmMocixpLG4sby5mbGFncyksVGUubXVubWFwKGkpLFNlLm1hcHBpbmdzW3JdPW51bGwsby5hbGxvY2F0ZWQmJkt0KG8ubWFsbG9jKX1yZXR1cm4gMH1jYXRjaChlKXtyZXR1cm4gdm9pZCAwIT09VGUmJmUgaW5zdGFuY2VvZiBUZS5FcnJub0Vycm9yfHxycihlKSwtZS5lcnJub319LF9fX3VubG9jazpmdW5jdGlvbigpe30sX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0OmZ1bmN0aW9uKGUpe3ZhciB0PVBlW2VdO2RlbGV0ZSBQZVtlXTt2YXIgcj10LnJhd0NvbnN0cnVjdG9yLG49dC5yYXdEZXN0cnVjdG9yLG89dC5maWVsZHM7eGUoW2VdLG8ubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXR0ZXJSZXR1cm5UeXBlfSkpLmNvbmNhdChvLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2V0dGVyQXJndW1lbnRUeXBlfSkpKSwoZnVuY3Rpb24oZSl7dmFyIGk9e307cmV0dXJuIG8uZm9yRWFjaCgoZnVuY3Rpb24odCxyKXt2YXIgbj10LmZpZWxkTmFtZSxhPWVbcl0scz10LmdldHRlcix1PXQuZ2V0dGVyQ29udGV4dCxjPWVbcitvLmxlbmd0aF0sbD10LnNldHRlcixmPXQuc2V0dGVyQ29udGV4dDtpW25dPXtyZWFkOmZ1bmN0aW9uKGUpe3JldHVybiBhLmZyb21XaXJlVHlwZShzKHUsZSkpfSx3cml0ZTpmdW5jdGlvbihlLHQpe3ZhciByPVtdO2woZixlLGMudG9XaXJlVHlwZShyLHQpKSxEZShyKX19fSkpLFt7bmFtZTp0Lm5hbWUsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Zvcih2YXIgciBpbiBpKXRbcl09aVtyXS5yZWFkKGUpO3JldHVybiBuKGUpLHR9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG8gaW4gaSlpZighKG8gaW4gdCkpdGhyb3cgbmV3IFR5cGVFcnJvcigiTWlzc2luZyBmaWVsZCIpO3ZhciBhPXIoKTtmb3IobyBpbiBpKWlbb10ud3JpdGUoYSx0W29dKTtyZXR1cm4gbnVsbCE9PWUmJmUucHVzaChuLGEpLGF9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6UmUsZGVzdHJ1Y3RvckZ1bmN0aW9uOm59XX0pKX0sX19lbWJpbmRfcmVnaXN0ZXJfYm9vbDpmdW5jdGlvbihlLHQscixuLG8pe3ZhciBpPWplKHIpO1llKGUse25hbWU6dD16ZSh0KSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZSl7cmV0dXJuISFlfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ/bjpvfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKGUpe3ZhciBuO2lmKDE9PT1yKW49UjtlbHNlIGlmKDI9PT1yKW49QztlbHNle2lmKDQhPT1yKXRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gYm9vbGVhbiB0eXBlIHNpemU6ICIrdCk7bj1GfXJldHVybiB0aGlzLmZyb21XaXJlVHlwZShuW2U+PmldKX0sZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KX0sX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3M6ZnVuY3Rpb24oZSx0LHIsbixpLGEscyx1LGMsbCxmLGQsaCl7Zj16ZShmKSxhPXZ0KGksYSksdSYmKHU9dnQocyx1KSksbCYmKGw9dnQoYyxsKSksaD12dChkLGgpO3ZhciBwPUZlKGYpOyFmdW5jdGlvbihlLHQscil7by5oYXNPd25Qcm9wZXJ0eShlKT8oKHZvaWQgMD09PXJ8fHZvaWQgMCE9PW9bZV0ub3ZlcmxvYWRUYWJsZSYmdm9pZCAwIT09b1tlXS5vdmVybG9hZFRhYmxlW3JdKSYmV2UoIkNhbm5vdCByZWdpc3RlciBwdWJsaWMgbmFtZSAnIitlKyInIHR3aWNlIikscnQobyxlLGUpLG8uaGFzT3duUHJvcGVydHkocikmJldlKCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgb3ZlcmxvYWRzIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzICgiK3IrIikhIiksb1tlXS5vdmVybG9hZFRhYmxlW3JdPXQpOihvW2VdPXQsdm9pZCAwIT09ciYmKG9bZV0ubnVtQXJndW1lbnRzPXIpKX0ocCwoZnVuY3Rpb24oKXtidCgiQ2Fubm90IGNvbnN0cnVjdCAiK2YrIiBkdWUgdG8gdW5ib3VuZCB0eXBlcyIsW25dKX0pKSx4ZShbZSx0LHJdLG4/W25dOltdLChmdW5jdGlvbih0KXt2YXIgcixpO3Q9dFswXSxpPW4/KHI9dC5yZWdpc3RlcmVkQ2xhc3MpLmluc3RhbmNlUHJvdG90eXBlOmV0LnByb3RvdHlwZTt2YXIgcz1NZShwLChmdW5jdGlvbigpe2lmKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSE9PWMpdGhyb3cgbmV3ICRlKCJVc2UgJ25ldycgdG8gY29uc3RydWN0ICIrZik7aWYodm9pZCAwPT09ZC5jb25zdHJ1Y3Rvcl9ib2R5KXRocm93IG5ldyAkZShmKyIgaGFzIG5vIGFjY2Vzc2libGUgY29uc3RydWN0b3IiKTt2YXIgZT1kLmNvbnN0cnVjdG9yX2JvZHlbYXJndW1lbnRzLmxlbmd0aF07aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgJGUoIlRyaWVkIHRvIGludm9rZSBjdG9yIG9mICIrZisiIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoIithcmd1bWVudHMubGVuZ3RoKyIpIC0gZXhwZWN0ZWQgKCIrT2JqZWN0LmtleXMoZC5jb25zdHJ1Y3Rvcl9ib2R5KS50b1N0cmluZygpKyIpIHBhcmFtZXRlcnMgaW5zdGVhZCEiKTtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSksYz1PYmplY3QuY3JlYXRlKGkse2NvbnN0cnVjdG9yOnt2YWx1ZTpzfX0pO3MucHJvdG90eXBlPWM7dmFyIGQ9bmV3IG50KGYscyxjLGgscixhLHUsbCksbT1uZXcgZ3QoZixkLCEwLCExLCExKSx5PW5ldyBndChmKyIqIixkLCExLCExLCExKSxFPW5ldyBndChmKyIgY29uc3QqIixkLCExLCEwLCExKTtyZXR1cm4gdHRbZV09e3BvaW50ZXJUeXBlOnksY29uc3RQb2ludGVyVHlwZTpFfSxmdW5jdGlvbihlLHQscil7by5oYXNPd25Qcm9wZXJ0eShlKXx8TGUoIlJlcGxhY2luZyBub25leGlzdGFudCBwdWJsaWMgc3ltYm9sIiksdm9pZCAwIT09b1tlXS5vdmVybG9hZFRhYmxlJiZ2b2lkIDAhPT1yP29bZV0ub3ZlcmxvYWRUYWJsZVtyXT10OihvW2VdPXQsb1tlXS5hcmdDb3VudD1yKX0ocCxzKSxbbSx5LEVdfSkpfSxfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcjpmdW5jdGlvbihlLHQscixuLG8saSl7dmFyIGE9QXQodCxyKTtvPXZ0KG4sbykseGUoW10sW2VdLChmdW5jdGlvbihlKXt2YXIgcj0iY29uc3RydWN0b3IgIisoZT1lWzBdKS5uYW1lO2lmKHZvaWQgMD09PWUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkmJihlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5PVtdKSx2b2lkIDAhPT1lLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W3QtMV0pdGhyb3cgbmV3ICRlKCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzICgiKyh0LTEpKyIpIGZvciBjbGFzcyAnIitlLm5hbWUrIichIE92ZXJsb2FkIHJlc29sdXRpb24gaXMgY3VycmVudGx5IG9ubHkgcGVyZm9ybWVkIHVzaW5nIHRoZSBwYXJhbWV0ZXIgY291bnQsIG5vdCBhY3R1YWwgdHlwZSBpbmZvISIpO3JldHVybiBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W3QtMV09ZnVuY3Rpb24oKXtidCgiQ2Fubm90IGNvbnN0cnVjdCAiK2UubmFtZSsiIGR1ZSB0byB1bmJvdW5kIHR5cGVzIixhKX0seGUoW10sYSwoZnVuY3Rpb24obil7cmV0dXJuIGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbdC0xXT1mdW5jdGlvbigpe2FyZ3VtZW50cy5sZW5ndGghPT10LTEmJldlKHIrIiBjYWxsZWQgd2l0aCAiK2FyZ3VtZW50cy5sZW5ndGgrIiBhcmd1bWVudHMsIGV4cGVjdGVkICIrKHQtMSkpO3ZhciBlPVtdLGE9bmV3IEFycmF5KHQpO2FbMF09aTtmb3IodmFyIHM9MTtzPHQ7KytzKWFbc109bltzXS50b1dpcmVUeXBlKGUsYXJndW1lbnRzW3MtMV0pO3ZhciB1PW8uYXBwbHkobnVsbCxhKTtyZXR1cm4gRGUoZSksblswXS5mcm9tV2lyZVR5cGUodSl9LFtdfSkpLFtdfSkpfSxfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbjpmdW5jdGlvbihlLHQscixuLG8saSxhLHMpe3ZhciB1PUF0KHIsbik7dD16ZSh0KSxpPXZ0KG8saSkseGUoW10sW2VdLChmdW5jdGlvbihlKXt2YXIgbj0oZT1lWzBdKS5uYW1lKyIuIit0O2Z1bmN0aW9uIG8oKXtidCgiQ2Fubm90IGNhbGwgIituKyIgZHVlIHRvIHVuYm91bmQgdHlwZXMiLHUpfXMmJmUucmVnaXN0ZXJlZENsYXNzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zLnB1c2godCk7dmFyIGM9ZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsbD1jW3RdO3JldHVybiB2b2lkIDA9PT1sfHx2b2lkIDA9PT1sLm92ZXJsb2FkVGFibGUmJmwuY2xhc3NOYW1lIT09ZS5uYW1lJiZsLmFyZ0NvdW50PT09ci0yPyhvLmFyZ0NvdW50PXItMixvLmNsYXNzTmFtZT1lLm5hbWUsY1t0XT1vKToocnQoYyx0LG4pLGNbdF0ub3ZlcmxvYWRUYWJsZVtyLTJdPW8pLHhlKFtdLHUsKGZ1bmN0aW9uKG8pe3ZhciBzPVR0KG4sbyxlLGksYSk7cmV0dXJuIHZvaWQgMD09PWNbdF0ub3ZlcmxvYWRUYWJsZT8ocy5hcmdDb3VudD1yLTIsY1t0XT1zKTpjW3RdLm92ZXJsb2FkVGFibGVbci0yXT1zLFtdfSkpLFtdfSkpfSxfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbDpmdW5jdGlvbihlLHQpe1llKGUse25hbWU6dD16ZSh0KSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZSl7dmFyIHQ9a3RbZV0udmFsdWU7cmV0dXJuIGZ1bmN0aW9uKGUpe2U+NCYmMD09LS1rdFtlXS5yZWZjb3VudCYmKGt0W2VdPXZvaWQgMCxTdC5wdXNoKGUpKX0oZSksdH0sdG9XaXJlVHlwZTpmdW5jdGlvbihlLHQpe3JldHVybiBSdCh0KX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpSZSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdDpmdW5jdGlvbihlLHQscil7dmFyIG49amUocik7WWUoZSx7bmFtZTp0PXplKHQpLGZyb21XaXJlVHlwZTpmdW5jdGlvbihlKXtyZXR1cm4gZX0sdG9XaXJlVHlwZTpmdW5jdGlvbihlLHQpe2lmKCJudW1iZXIiIT10eXBlb2YgdCYmImJvb2xlYW4iIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCAiJytPdCh0KSsnIiB0byAnK3RoaXMubmFtZSk7cmV0dXJuIHR9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q3QodCxuKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyOmZ1bmN0aW9uKGUsdCxyLG4sbyl7dD16ZSh0KSwtMT09PW8mJihvPTQyOTQ5NjcyOTUpO3ZhciBpPWplKHIpLGE9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9O2lmKDA9PT1uKXt2YXIgcz0zMi04KnI7YT1mdW5jdGlvbihlKXtyZXR1cm4gZTw8cz4+PnN9fXZhciB1PS0xIT10LmluZGV4T2YoInVuc2lnbmVkIik7WWUoZSx7bmFtZTp0LGZyb21XaXJlVHlwZTphLHRvV2lyZVR5cGU6ZnVuY3Rpb24oZSxyKXtpZigibnVtYmVyIiE9dHlwZW9mIHImJiJib29sZWFuIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgIicrT3QocikrJyIgdG8gJyt0aGlzLm5hbWUpO2lmKHI8bnx8cj5vKXRocm93IG5ldyBUeXBlRXJyb3IoJ1Bhc3NpbmcgYSBudW1iZXIgIicrT3QocikrJyIgZnJvbSBKUyBzaWRlIHRvIEMvQysrIHNpZGUgdG8gYW4gYXJndW1lbnQgb2YgdHlwZSAiJyt0KyciLCB3aGljaCBpcyBvdXRzaWRlIHRoZSB2YWxpZCByYW5nZSBbJytuKyIsICIrbysiXSEiKTtyZXR1cm4gdT9yPj4+MDowfHJ9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6TnQodCxpLDAhPT1uKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldzpmdW5jdGlvbihlLHQscil7dmFyIG49W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5XVt0XTtmdW5jdGlvbiBvKGUpe3ZhciB0PU0scj10W2U+Pj0yXSxvPXRbZSsxXTtyZXR1cm4gbmV3IG4odC5idWZmZXIsbyxyKX1ZZShlLHtuYW1lOnI9emUociksZnJvbVdpcmVUeXBlOm8sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpvfSx7aWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczohMH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nOmZ1bmN0aW9uKGUsdCl7WWUoZSx7bmFtZTp0PXplKHQpLGZyb21XaXJlVHlwZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9TVtlPj4yXSxyPW5ldyBBcnJheSh0KSxuPTA7bjx0OysrbilyW25dPVN0cmluZy5mcm9tQ2hhckNvZGUoT1tlKzQrbl0pO3JldHVybiBLdChlKSxyLmpvaW4oIiIpfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcihlLHQpe3JldHVybiBlW3RdfXZhciBuO3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fHx0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQ4QXJyYXk/bj1yOiJzdHJpbmciPT10eXBlb2YgdD9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY2hhckNvZGVBdCh0KX06V2UoIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmciKTt2YXIgbz10Lmxlbmd0aCxpPUp0KDQrbyk7TVtpPj4yXT1vO2Zvcih2YXIgYT0wO2E8bzsrK2Epe3ZhciBzPW4odCxhKTtzPjI1NSYmKEt0KGkpLFdlKCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHMiKSksT1tpKzQrYV09c31yZXR1cm4gbnVsbCE9PWUmJmUucHVzaChLdCxpKSxpfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOlJlLGRlc3RydWN0b3JGdW5jdGlvbjpmdW5jdGlvbihlKXtLdChlKX19KX0sX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmc6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLG87cj16ZShyKSwyPT09dD8obj1mdW5jdGlvbigpe3JldHVybiBOfSxvPTEpOjQ9PT10JiYobj1mdW5jdGlvbigpe3JldHVybiBNfSxvPTIpLFllKGUse25hbWU6cixmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW4oKSxyPU1bZT4+Ml0saT1uZXcgQXJyYXkociksYT1lKzQ+Pm8scz0wO3M8cjsrK3MpaVtzXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbYStzXSk7cmV0dXJuIEt0KGUpLGkuam9pbigiIil9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZSxyKXt2YXIgaT1uKCksYT1yLmxlbmd0aCxzPUp0KDQrYSp0KTtNW3M+PjJdPWE7Zm9yKHZhciB1PXMrND4+byxjPTA7YzxhOysrYylpW3UrY109ci5jaGFyQ29kZUF0KGMpO3JldHVybiBudWxsIT09ZSYmZS5wdXNoKEt0LHMpLHN9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6UmUsZGVzdHJ1Y3RvckZ1bmN0aW9uOmZ1bmN0aW9uKGUpe0t0KGUpfX0pfSxfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3Q6ZnVuY3Rpb24oZSx0LHIsbixvLGkpe1BlW2VdPXtuYW1lOnplKHQpLHJhd0NvbnN0cnVjdG9yOnZ0KHIsbikscmF3RGVzdHJ1Y3Rvcjp2dChvLGkpLGZpZWxkczpbXX19LF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZDpmdW5jdGlvbihlLHQscixuLG8saSxhLHMsdSxjKXtQZVtlXS5maWVsZHMucHVzaCh7ZmllbGROYW1lOnplKHQpLGdldHRlclJldHVyblR5cGU6cixnZXR0ZXI6dnQobixvKSxnZXR0ZXJDb250ZXh0Omksc2V0dGVyQXJndW1lbnRUeXBlOmEsc2V0dGVyOnZ0KHMsdSksc2V0dGVyQ29udGV4dDpjfSl9LF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQ6ZnVuY3Rpb24oZSx0KXtZZShlLHtpc1ZvaWQ6ITAsbmFtZTp0PXplKHQpLGFyZ1BhY2tBZHZhbmNlOjAsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKCl7fSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGUsdCl7fX0pfSxfYWJvcnQ6ZnVuY3Rpb24oKXtvLmFib3J0KCl9LF9lbXNjcmlwdGVuX21lbWNweV9iaWc6ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBPLnNldChPLnN1YmFycmF5KHQsdCtyKSxlKSxlfSxfZ2V0ZW52OmZ1bmN0aW9uIGUodCl7cmV0dXJuIDA9PT10PzA6KHQ9dih0KSxNdC5oYXNPd25Qcm9wZXJ0eSh0KT8oZS5yZXQmJkt0KGUucmV0KSxlLnJldD0ocj1NdFt0XSxuPVMocikrMSwobz1KdChuKSkmJkEocixSLG8sbiksbykpOjApO3ZhciByLG4sb30sX2dldGdybmFtOmZ1bmN0aW9uKCl7by5wcmludEVycigibWlzc2luZyBmdW5jdGlvbjogZ2V0Z3JuYW0iKSxycigtMSl9LF9nZXRwd25hbTpmdW5jdGlvbigpe3Rocm93ImdldHB3bmFtOiBUT0RPIn0sX2pzQ2xvc2U6ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9qc0NyZWF0ZTpmdW5jdGlvbihlKXtyZXR1cm4gYS5jcmVhdGUuY2FsbChudWxsLGsoZSkpfSxfanNPcGVuOmZ1bmN0aW9uKGUpe3JldHVybiBhLm9wZW4uY2FsbChudWxsLGsoZSkpfSxfanNSZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIGEucmVhZC5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9qc1NlZWs6ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBhLnNlZWsuY2FsbChudWxsLGUsdCxiKHIpKX0sX2pzVGVsbDpmdW5jdGlvbigpe3JldHVybiBhLnRlbGwuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfanNXcml0ZTpmdW5jdGlvbigpe3JldHVybiBhLndyaXRlLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX2xsdm1fZWhfdHlwZWlkX2ZvcjpmdW5jdGlvbihlKXtyZXR1cm4gZX0sX2xvY2FsdGltZTpmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtqdCgpO3ZhciByPW5ldyBEYXRlKDFlMypGW2U+PjJdKTtGW3Q+PjJdPXIuZ2V0U2Vjb25kcygpLEZbdCs0Pj4yXT1yLmdldE1pbnV0ZXMoKSxGW3QrOD4+Ml09ci5nZXRIb3VycygpLEZbdCsxMj4+Ml09ci5nZXREYXRlKCksRlt0KzE2Pj4yXT1yLmdldE1vbnRoKCksRlt0KzIwPj4yXT1yLmdldEZ1bGxZZWFyKCktMTkwMCxGW3QrMjQ+PjJdPXIuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUoci5nZXRGdWxsWWVhcigpLDAsMSksbz0oci5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDA7Rlt0KzI4Pj4yXT1vLEZbdCszNj4+Ml09LTYwKnIuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgaT1uZXcgRGF0ZSgyZTMsNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGE9bi5nZXRUaW1lem9uZU9mZnNldCgpLHM9MHwoaSE9YSYmci5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihhLGkpKTtGW3QrMzI+PjJdPXM7dmFyIHU9RltCdCsocz80OjApPj4yXTtyZXR1cm4gRlt0KzQwPj4yXT11LHR9KGUsSXQpfSxfbWt0aW1lOmZ1bmN0aW9uKGUpe2p0KCk7dmFyIHQ9bmV3IERhdGUoRltlKzIwPj4yXSsxOTAwLEZbZSsxNj4+Ml0sRltlKzEyPj4yXSxGW2UrOD4+Ml0sRltlKzQ+PjJdLEZbZT4+Ml0sMCkscj1GW2UrMzI+PjJdLG49dC5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSksaT1uZXcgRGF0ZSgyZTMsNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGE9by5nZXRUaW1lem9uZU9mZnNldCgpLHM9TWF0aC5taW4oYSxpKTtpZihyPDApRltlKzMyPj4yXT1OdW1iZXIoaSE9YSYmcz09bik7ZWxzZSBpZihyPjAhPShzPT1uKSl7dmFyIHU9TWF0aC5tYXgoYSxpKSxjPXI+MD9zOnU7dC5zZXRUaW1lKHQuZ2V0VGltZSgpKzZlNCooYy1uKSl9RltlKzI0Pj4yXT10LmdldERheSgpO3ZhciBsPSh0LmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MDtyZXR1cm4gRltlKzI4Pj4yXT1sLHQuZ2V0VGltZSgpLzFlM3wwfSxfcHRocmVhZF9nZXRzcGVjaWZpYzpmdW5jdGlvbihlKXtyZXR1cm4gVXRbZV18fDB9LF9wdGhyZWFkX2tleV9jcmVhdGU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09ZT9tZS5FSU5WQUw6KEZbZT4+Ml09enQsVXRbenRdPTAsenQrKywwKX0sX3B0aHJlYWRfb25jZTpmdW5jdGlvbiBlKHQscil7ZS5zZWVufHwoZS5zZWVuPXt9KSx0IGluIGUuc2Vlbnx8KG8uZHluQ2FsbF92KHIpLGUuc2Vlblt0XT0xKX0sX3B0aHJlYWRfc2V0c3BlY2lmaWM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSBpbiBVdD8oVXRbZV09dCwwKTptZS5FSU5WQUx9LF90aW1lOmZ1bmN0aW9uKGUpe3ZhciB0PURhdGUubm93KCkvMWUzfDA7cmV0dXJuIGUmJihGW2U+PjJdPXQpLHR9LERZTkFNSUNUT1BfUFRSOiQsU1RBQ0tUT1A6VX07dmFyIFd0PW8uYXNtKG8uYXNtR2xvYmFsQXJnLG8uYXNtTGlicmFyeUFyZyxEKTtvLmFzbT1XdDt2YXIgWXQ9by5fX0dMT0JBTF9fc3ViX0lfYmluZF9jcHA9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVnQ9by5fX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcD1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5fX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcC5hcHBseShudWxsLGFyZ3VtZW50cyl9LEh0PW8uX19HTE9CQUxfX3N1Yl9JX2NyY19jcHA9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uX19HTE9CQUxfX3N1Yl9JX2NyY19jcHAuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxHdD1vLl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scXQ9KG8uX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5fX19jeGFfY2FuX2NhdGNoLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sby5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLl9fX2N4YV9pc19wb2ludGVyX3R5cGUuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLl9fX2Vycm5vX2xvY2F0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLl9fX2Vycm5vX2xvY2F0aW9uLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sby5fX19nZXRUeXBlTmFtZT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5fX19nZXRUeXBlTmFtZS5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxYdD1vLl9lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLl9lbXNjcmlwdGVuX3JlcGxhY2VfbWVtb3J5LmFwcGx5KG51bGwsYXJndW1lbnRzKX0sS3Q9by5fZnJlZT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5fZnJlZS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEp0PW8uX21hbGxvYz1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5fbWFsbG9jLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWnQ9by5zZXRUZW1wUmV0MD1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5zZXRUZW1wUmV0MC5hcHBseShudWxsLGFyZ3VtZW50cyl9LFF0PShvLnNldFRocmV3PWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLnNldFRocmV3LmFwcGx5KG51bGwsYXJndW1lbnRzKX0sby5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLnN0YWNrQWxsb2MuYXBwbHkobnVsbCxhcmd1bWVudHMpfSk7by5keW5DYWxsX2RpaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX2RpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF9pPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLmR5bkNhbGxfaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF9paT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX2lpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sby5keW5DYWxsX2lpaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX2lpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF9paWlpPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLmR5bkNhbGxfaWlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF9paWlpaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX2lpaWlpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sby5keW5DYWxsX2lpaWlpaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX2lpaWlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF9paWlpaWlpPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLmR5bkNhbGxfaWlpaWlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF9paWlpaWlpaWlpPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLmR5bkNhbGxfaWlpaWlpaWlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF9paWlpaWlqaWk9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uZHluQ2FsbF9paWlpaWlqaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfaWpqPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLmR5bkNhbGxfaWpqLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sby5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXNtLmR5bkNhbGxfamkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdj1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX3YuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmk9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uZHluQ2FsbF92aS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF92aWk9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uZHluQ2FsbF92aWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmlpZD1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX3ZpaWQuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmlpaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX3ZpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uZHluQ2FsbF92aWlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF92aWlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uZHluQ2FsbF92aWlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmlpaWlpaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX3ZpaWlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmlpaWlpaWlpaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX3ZpaWlpaWlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmlpaWlpaWlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uZHluQ2FsbF92aWlpaWlpaWlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG8uZHluQ2FsbF92aWo9ZnVuY3Rpb24oKXtyZXR1cm4gby5hc20uZHluQ2FsbF92aWouYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvLmR5bkNhbGxfdmlqaT1mdW5jdGlvbigpe3JldHVybiBvLmFzbS5keW5DYWxsX3ZpamkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBlcihlKXt0aGlzLm5hbWU9IkV4aXRTdGF0dXMiLHRoaXMubWVzc2FnZT0iUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgiK2UrIikiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gdHIoZSl7ZnVuY3Rpb24gdCgpe28uY2FsbGVkUnVufHwoby5jYWxsZWRSdW49ITAsbXx8KHRlfHwodGU9ITAsWChKKSksWChaKSxvLm9uUnVudGltZUluaXRpYWxpemVkJiZvLm9uUnVudGltZUluaXRpYWxpemVkKCksZnVuY3Rpb24oKXtpZihvLnBvc3RSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBvLnBvc3RSdW4mJihvLnBvc3RSdW49W28ucG9zdFJ1bl0pO28ucG9zdFJ1bi5sZW5ndGg7KWU9by5wb3N0UnVuLnNoaWZ0KCksZWUudW5zaGlmdChlKTt2YXIgZTtYKGVlKX0oKSkpfXNlPjB8fCghZnVuY3Rpb24oKXtpZihvLnByZVJ1bilmb3IoImZ1bmN0aW9uIj09dHlwZW9mIG8ucHJlUnVuJiYoby5wcmVSdW49W28ucHJlUnVuXSk7by5wcmVSdW4ubGVuZ3RoOyllPW8ucHJlUnVuLnNoaWZ0KCksSy51bnNoaWZ0KGUpO3ZhciBlO1goSyl9KCksc2U+MHx8by5jYWxsZWRSdW58fChvLnNldFN0YXR1cz8oby5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7by5zZXRTdGF0dXMoIiIpfSksMSksdCgpfSksMSkpOnQoKSkpfWZ1bmN0aW9uIHJyKGUpe3Rocm93IG8ub25BYm9ydCYmby5vbkFib3J0KGUpLHZvaWQgMCE9PWU/KG8ucHJpbnQoZSksby5wcmludEVycihlKSxlPUpTT04uc3RyaW5naWZ5KGUpKTplPSIiLG09ITAsImFib3J0KCIrZSsiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby4ifWlmKG8uYXNtPVd0LGVyLnByb3RvdHlwZT1uZXcgRXJyb3IsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPWVyLHVlPWZ1bmN0aW9uIGUoKXtvLmNhbGxlZFJ1bnx8dHIoKSxvLmNhbGxlZFJ1bnx8KHVlPWUpfSxvLnJ1bj10cixvLmV4aXQ9ZnVuY3Rpb24oZSx0KXt0JiZvLm5vRXhpdFJ1bnRpbWUmJjA9PT1lfHwoby5ub0V4aXRSdW50aW1lfHwobT0hMCxVPXZvaWQgMCxYKFEpLG8ub25FeGl0JiZvLm9uRXhpdChlKSksbCYmcHJvY2Vzcy5leGl0KGUpLG8ucXVpdChlLG5ldyBlcihlKSkpfSxvLmFib3J0PXJyLG8ucHJlSW5pdClmb3IoImZ1bmN0aW9uIj09dHlwZW9mIG8ucHJlSW5pdCYmKG8ucHJlSW5pdD1bby5wcmVJbml0XSk7by5wcmVJbml0Lmxlbmd0aD4wOylvLnByZUluaXQucG9wKCkoKTtyZXR1cm4gby5ub0V4aXRSdW50aW1lPSEwLHRyKCksdH07ZnVuY3Rpb24gaSh7cmVzb3VyY2VJZDplLHVybDp0fSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlLG8pe2lmKCFyKXRocm93IG5ldyBFcnJvcigidW5wYWNrQnJpZGdlIG5vdCBkZXRlY3RlZCIpO2lmKCFuKXRocm93IG5ldyBFcnJvcigidW5wYWNrIG5vdCBkZXRlY3RlZCIpOyhmdW5jdGlvbihlKXtyZXR1cm4gZmV0Y2gobmV3IFJlcXVlc3QoZSkpLnRoZW4oZT0+e2lmKGUub2spcmV0dXJuIGUuYXJyYXlCdWZmZXIoKTt0aHJvdyBuZXcgRXJyb3IoIjQwNCBFcnJvcjogRmlsZSBub3QgZm91bmQuIil9KS50aGVuKGU9PnIuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGEoZSkpfSkodCkudGhlbih0PT57ZSh0LmV4dHJhY3RBbGwoKSl9LGU9PntvKGUpfSl9KSl9ZnVuY3Rpb24gYShlLHQpe2NvbnN0W3Isbl09dDtpZigiRkFJTCI9PXIuc3RhdGUpe2NvbnN0IHQ9e3R5cGU6IkVSUk9SIixyZWFzb246ci5yZWFzb24sbXNnOnIubXNnLHJlc291cmNlSWQ6ZS5kYXRhLnJlc291cmNlSWQsdXJsOmUuZGF0YS51cmx9O3JldHVybiB2b2lkIHNlbGYucG9zdE1lc3NhZ2UodCl9Y29uc3Qgbz17dHlwZToiRklOSVNIRUQiLHJlc291cmNlSWQ6ZS5kYXRhLnJlc291cmNlSWQsZW50cmllczp7fX0saT1bXTtpZihuJiZuLmZpbGVzKWZvcihjb25zdCBlIG9mIG4uZmlsZXMpby5lbnRyaWVzW2UuZmlsZUhlYWRlci5uYW1lXT1lLmV4dHJhY3RbMV0saS5wdXNoKGUuZXh0cmFjdFsxXS5idWZmZXIpO3NlbGYucG9zdE1lc3NhZ2UobyxpKX1vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7aWYoImluaXQiPT1lLmRhdGEudHlwZSluPW8oZS5kYXRhLndhc21VcmwpLG4ub25SdW50aW1lSW5pdGlhbGl6ZWQ9KCk9PnBvc3RNZXNzYWdlKHt0eXBlOiJXQVNNX0xPQURFRCJ9KTtlbHNlIGlmKCJmZXRjaCI9PWUuZGF0YS50eXBlKWkoZS5kYXRhKS50aGVuKHQ9PnthKGUsdCl9LHQ9Pntjb25zdCByPXt0eXBlOiJFUlJPUiIscmVzb3VyY2VJZDplLmRhdGEucmVzb3VyY2VJZCx1cmw6ZS5kYXRhLnVybH07c2VsZi5wb3N0TWVzc2FnZShyKX0pO2Vsc2UgaWYoInVucGFjayI9PWUuZGF0YS50eXBlKXtjb25zdHtidWZmZXI6dH09ZS5kYXRhO2lmKCFyKXRocm93IG5ldyBFcnJvcigidW5wYWNrQnJpZGdlIG5vdCBkZXRlY3RlZCIpO2lmKCFuKXRocm93IG5ldyBFcnJvcigidW5wYWNrIG5vdCBkZXRlY3RlZCIpO2NvbnN0IG89ci5jcmVhdGVFeHRyYWN0b3JGcm9tRGF0YSh0KS5leHRyYWN0QWxsKCk7YShlLG8pfX07Cgo=",null,!1);function ne(e){return e&&"object"==typeof e&&!Array.isArray(e)}function le(e,...t){if(!t.length)return e;const a=t.shift();if(ne(e)&&ne(a))for(const t in a)ne(a[t])?(e[t]||Object.assign(e,{[t]:{}}),le(e[t],a[t])):Object.assign(e,{[t]:a[t]});return le(e,...t)}const re=new class{constructor(){let e;this.loaded=new S,this.progressIncremented=new S,this.allResourcesLoaded=new S,this.fileUpdated=new S,this.__totalWork=0,this.__totalWorkByCategory={},this.__doneWork=0,this.__doneWorkByCategory={},this.__resourceRegisterCallbacks={},this.__callbacks={},this.__resources={},this.__resourcesTreeEntities={},this.__resourcesTree={children:{}},this.__workers=[],this.__nextWorker=0;const t=document.getElementsByTagName("script");for(let a=0;a<t.length;a++){const i=t[a];if(i.src.includes("zea-engine")){const t=i.src.split("/");t.pop(),t.pop(),e=t.join("/");break}}e||(e="https://unpkg.com/@zeainc/zea-engine@0.1.3"),this.wasmUrl=e+"/public-resources/unpack.wasm",this.addResourceURL("ZeaEngine/Vive.vla",e+"/public-resources/Vive.vla"),this.addResourceURL("ZeaEngine/Oculus.vla",e+"/public-resources/Oculus.vla");}getRootFolder(){return this.__resourcesTree}registerResourceCallback(e,t){this.__resourceRegisterCallbacks[e]=t;for(const a in this.__resources){const i=this.__resources[a];i.name.includes(e)&&t(i);}}__applyCallbacks(e){const t=e=>{for(const t in this.__resourceRegisterCallbacks)e.name.includes(t)&&this.__resourceRegisterCallbacks[t](e);};for(const a in e){const i=e[a];i.url&&t(i);}}__buildTree(e){const t=a=>{if(this.__resourcesTreeEntities[a])return;const i=e[a];i.id=a,"folder"!==i.type&&"dependency"!==i.type||(i.children={}),i.parent&&(this.__resourcesTreeEntities[i.parent]||t(i.parent)),(i.parent?this.__resourcesTreeEntities[i.parent]:this.__resourcesTree).children[i.name]=i,this.__resourcesTreeEntities[a]=i;};for(const a in e)t(a);}setResources(e){this.__resources=Object.assign(this.__resources,e),this.__buildTree(e),this.__applyCallbacks(e);}addResourceURL(e,t){const a=e.split("/"),i=a.pop();if(!t){let i=window.location.href.split("#")[0];i=i.split("?")[0],(i.endsWith(".html")||i.endsWith(".html"))&&(i=i.substring(0,i.lastIndexOf("/"))+"/");const s=i;if("."==a[0])a.shift();else if(".."==a[0]){item=item.substring(3);const e=s.split("/");e.pop(),e.pop(),s=e.join("/")+"/";}t=s+e;}let n;const l={};for(const e of a){const t=s(e);t in this.__resources||(this.__resources[t]={name:e,type:"folder",parent:n},l[t]=this.__resources[t]),n=t;}const r=s(i),o={name:i,url:t,parent:n,id:r};this.__resources[r]=o,l[r]=o,this.__buildTree(l),this.__applyCallbacks(l);}updateFile(e){const t=!(e.id in this.__resources);if(this.__resources[e.id]=e,t){console.log("New file added");const t={};t[e.id]=e,this.__buildTree(t);}this.fileUpdated.emit(e.id);}freeData(e){}__getWorker(){return this.__nextWorker=(this.__nextWorker+1)%3,null==this.__workers[this.__nextWorker]&&(this.__workers[this.__nextWorker]=(()=>new Promise(e=>{const t=new se;t.postMessage({type:"init",wasmUrl:this.wasmUrl}),t.onmessage=a=>{if("WASM_LOADED"===a.data.type)e(t);else if("FINISHED"===a.data.type){this.addWorkDone(a.data.resourceId,1),this.__onFinishedReceiveFileData(a.data);}else if("ERROR"===a.data.type){const e=a.data,t=this.__resources[e.resourceId];console.error("Unable to load Resource:",t?t.name:e.resourceId," With url:",e.url);}};}))()),this.__workers[this.__nextWorker]}__terminateWorkers(){for(const e of this.__workers)e.terminate();this.__workers=[];}getFilepath(e){let t=this.__resources[e];const a=[t.name];for(;t.parent;)t=this.__resources[t.parent],a.splice(0,0,t.name);return a.join("/")}resourceAvailable(e){return e.indexOf(".")>0?(console.warn("Deprecation warning for resourceAvailable. Value should be a file id, not a path."),null!=this.resolveFilepath(e)):e in this.__resources}getFile(e){return this.__resources[e]}resolveFilePathToId(e){if(!e)return void console.warn("Invalid file path:",e);const t=this.resolveFilepath(e);return t?t.id:void 0}resolveFilepath(e){const t=e.split("/");"."!=t[0]&&""!=t[0]||t.shift();let a=this.__resourcesTree;for(const i of t){if(!(i in a.children))return console.warn("Unable to resolve key:"+i+" of path:"+e),null;a=a.children[i];}return a}resolveFile(e){return console.warn("Deprecation warning for resolveFile. Use resolveFilepath."),this.resolveFilepath(e)}resolveURL(e){console.warn("Deprecation warning for resolveURL. Use resolveFilepath.");const t=this.resolveFilepath(e);if(t)return t.url}addWork(e,t){this.__totalWork+=t,this.progressIncremented.emit(this.__doneWork/this.__totalWork*100);}addWorkDone(e,t){if(this.__doneWork+=t,this.progressIncremented.emit(this.__doneWork/this.__totalWork*100),this.__doneWork>this.__totalWork)throw new Error("Mismatch between work loaded and work done.");this.__doneWork==this.__totalWork&&this.allResourcesLoaded.emit();}loadResource(e,t,a=!0){const i=this.getFile(e);if(!i)throw new Error("Invalid resource Id:'"+e+"' not found in Resources:"+JSON.stringify(this.__resources,null,2));this.loadUrl(e,i.url,t,a);}loadURL(e,t,a,i=!0){return console.warn("Please call loadUrl instead,"),this.loadUrl(e,t,a,i)}loadUrl(e,t,a,i=!0){i&&this.addWork(e,3),e in this.__callbacks||(this.__callbacks[e]=[]),this.__callbacks[e].push(a),fetch(t).then(e=>function(e){if(!e.ok)throw new Error(`HTTP ${e.status} - ${e.statusText}`);return e}(e)&&e.arrayBuffer()).then(t=>{this.__getWorker().then(a=>{a.postMessage({type:"unpack",resourceId:e,buffer:t});});});}unpackBuffer(e,t,a,i=!0){return new Promise((s,n)=>{i&&this.addWork(e,3),e in this.__callbacks||(this.__callbacks[e]=[]),a&&this.__callbacks[e].push(a),this.__callbacks[e].push(e=>{s(e);}),this.__getWorker().then(a=>{a.postMessage({type:"unpack",resourceId:e,buffer:t},[t]);});})}__onFinishedReceiveFileData(e){const t=e.resourceId;this.addWorkDone(t,1);const a=this.__callbacks[t];if(a){for(const t of a)t(e.entries);delete this.__callbacks[t];}this.loaded.emit(t),this.addWorkDone(t,1);}suspend(){this.__terminateWorkers();}traverse(e){const t=e=>{for(const t in e.children)a(e.children[t]);},a=a=>{if(0==e(a))return !1;a.children&&t(a);};t(this.__resourcesTree);}};class oe{constructor(e){if(e){const t=e.split("-"),a=t[0].split(".");this.major=parseInt(a[0]),this.minor=parseInt(a[1]),this.patch=parseInt(a[2]),2==t.length&&(this.branch=t[1]);}else this.major=0,this.minor=0,this.patch=0;}equals(e){return !(this.patch==e[2]&&this.minor==e[1]&&this.major==e[0])}lessThan(e){return !(this.major>=e[0]||this.minor>=e[1]||this.patch>=e[2])}greaterThan(e){return this.major>e[0]||this.minor>e[1]||this.patch>e[2]}greaterOrEqualThan(e){return !(this.major<e[0])&&(this.major>e[0]||!(this.minor<e[1])&&(this.minor>e[1]||!(this.patch<e[2])))}}class de{constructor(e,t=0,a=!0){this.__data=e,this.__byteOffset=t,this.__dataView=new DataView(this.__data),this.__isMobileDevice=a,this.utf8decoder=new TextDecoder;}get isMobileDevice(){return this.__isMobileDevice}get data(){return this.__data}get byteLength(){return this.__dataView.byteLength}get remainingByteLength(){return this.__dataView.byteLength-this.__byteOffset}pos(){return this.__byteOffset}seek(e){this.__byteOffset=e;}advance(e){this.__byteOffset+=e;}loadUInt8(){const e=this.__dataView.getUint8(this.__byteOffset);return this.__byteOffset+=1,e}loadUInt16(){const e=this.__dataView.getUint16(this.__byteOffset,!0);return this.__byteOffset+=2,e}loadUInt32(){const e=this.__dataView.getUint32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadSInt32(){const e=this.__dataView.getInt32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadFloat16(){const e=this.loadUInt16();return Math.decode16BitFloat(e)}loadUFloat16(){const e=this.loadFloat16();return e<0?2048-e:e}loadFloat16From2xUInt8(){const e=this.__dataView.getFloat16(this.__byteOffset,!0);return this.__byteOffset+=2,e}loadUInt32From2xUFloat16(){return this.loadUFloat16()+4096*this.loadUFloat16()}loadSInt32From2xFloat16(){return this.loadFloat16()+2048*this.loadFloat16()}loadFloat32(){const e=this.__dataView.getFloat32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadUInt8Array(e,t=!1){null==e&&(e=this.loadUInt32());const a=new Uint8Array(this.__data,this.__byteOffset,e);this.__byteOffset+=e;return a}loadUInt16Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Uint16Array;let a;if(this.readPadd(2),this.__isMobileDevice){a=new Uint16Array(e);for(let t=0;t<e;t++)a[t]=this.__dataView.getUint16(this.__byteOffset,!0),this.__byteOffset+=2;}else a=new Uint16Array(this.__data,this.__byteOffset,e),this.__byteOffset+=2*e;return a}loadUInt32Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Uint32Array;let a;if(this.readPadd(4),this.__isMobileDevice){a=new Uint32Array(e);for(let t=0;t<e;t++)a[t]=this.__dataView.getUint32(this.__byteOffset,!0),this.__byteOffset+=4;}else a=new Uint32Array(this.__data,this.__byteOffset,e),this.__byteOffset+=4*e;return a}loadFloat32Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Float32Array;let a;if(this.readPadd(4),this.__isMobileDevice){a=new Float32Array(e);for(let t=0;t<e;t++)a[t]=this.__dataView.getFloat32(this.__byteOffset,!0),this.__byteOffset+=4;}else a=new Float32Array(this.__data,this.__byteOffset,e),this.__byteOffset+=4*e;return a}loadStr(){const e=this.loadUInt32(),t=new Uint8Array(this.__data,this.__byteOffset,e);return this.__byteOffset+=e,this.utf8decoder.decode(t)}loadStrArray(){const e=this.loadUInt32(),t=[];for(let a=0;a<e;a++)t[a]=this.loadStr();return t}loadSInt32Vec2(){const e=this.loadSInt32(),t=this.loadSInt32();return new o(e,t)}loadUInt32Vec2(){const e=this.loadUInt32(),t=this.loadUInt32();return new o(e,t)}loadFloat16Vec2(){const e=this.loadFloat16(),t=this.loadFloat16();return new o(e,t)}loadFloat32Vec2(){const e=this.loadFloat32(),t=this.loadFloat32();return new o(e,t)}loadFloat16Vec3(){const e=this.loadFloat16(),t=this.loadFloat16(),a=this.loadFloat16();return new d(e,t,a)}loadFloat32Vec3(){const e=this.loadFloat32(),t=this.loadFloat32(),a=this.loadFloat32();return new d(e,t,a)}loadFloat16Quat(){const e=this.loadFloat16(),t=this.loadFloat16(),a=this.loadFloat16(),i=this.loadFloat16();return new Z(e,t,a,i)}loadFloat32Quat(){const e=this.loadFloat32(),t=this.loadFloat32(),a=this.loadFloat32(),i=this.loadFloat32();return new Z(e,t,a,i)}loadRGBFloat32Color(){const e=this.loadFloat32(),t=this.loadFloat32(),a=this.loadFloat32();return new u(e,t,a)}loadRGBAFloat32Color(){const e=this.loadFloat32(),t=this.loadFloat32(),a=this.loadFloat32(),i=this.loadFloat32();return new u(e,t,a,i)}loadRGBUInt8Color(){const e=this.loadUInt8(),t=this.loadUInt8(),a=this.loadUInt8();return new u(e/255,t/255,a/255)}loadRGBAUInt8Color(){const e=this.loadUInt8(),t=this.loadUInt8(),a=this.loadUInt8(),i=this.loadUInt8();return new u(e/255,t/255,a/255,i/255)}loadBox2(){return new y(this.loadFloat32Vec2(),this.loadFloat32Vec2())}loadBox3(){return new V(this.loadFloat32Vec3(),this.loadFloat32Vec3())}readPadd(e){const t=this.__byteOffset%e;0!=t&&(this.__byteOffset+=e-t);}}class he{constructor(e=0){this.__data=new ArrayBuffer(e),this.__byteOffset=0,this.__reserved=e,this.__dataView=new DataView(this.__data);}pos(){return this.__byteOffset}seek(e){this.__byteOffset=e;}seekEnd(){this.__byteOffset=this.__reserved;}getBuffer(){if(this.__data.byteLength==this.__byteOffset)return this.__data;return new Uint8Array(this.__data).slice(0,this.__byteOffset).buffer}__grow(){const e=2*(this.__reserved>0?this.__reserved:1),t=new ArrayBuffer(e),a=new Uint8Array(t),i=new Uint8Array(this.__data);a.set(i),this.__data=t,this.__dataView=new DataView(this.__data),this.__reserved=e;}__reserve(e){this.__byteOffset+e>this.__reserved&&this.__grow();}__offset(e){this.__byteOffset+=e,this.__byteOffset>this.__reserved&&this.__grow();}writeUInt8(e){this.__reserve(1),this.__dataView.setUint8(this.__byteOffset,e),this.__offset(1);}writeUInt16(e){this.__reserve(2),this.__dataView.setUint16(this.__byteOffset,e,!0),this.__offset(2);}writeUInt32(e){this.__reserve(4),this.__dataView.setUint32(this.__byteOffset,e,!0),this.__offset(4);}writeSInt32(e){this.__reserve(4),this.__dataView.setInt32(this.__byteOffset,e,!0),this.__offset(4);}writeFloat16(e){const t=Math.encode16BitFloat(e);this.writeUInt16(t);}writeFloat32(e){this.__reserve(4),this.__dataView.setFloat32(this.__byteOffset,e,!0),this.__offset(4);}writeUInt8Array(e,t=!0){const a=e.size?e.size:e.length;this.__reserve(a+(t?4:0)),t&&this.writeUInt32(a);for(let t=0;t<a;t++)this.writeUInt8(e[t]);}writeUInt16Array(e,t=!0){const a=e.size?e.size:e.length;this.__reserve(2*a+(t?4:0)),t&&this.writeUInt32(a);for(let t=0;t<a;t++)this.writeUInt16(e[t]);}writeUInt32Array(e,t=!0){const a=e.size?e.size:e.length;this.__reserve(4*a+(t?4:0)),t&&this.writeUInt32(a);for(let t=0;t<a;t++)this.writeUInt32(e[t]);}writeFloat32Array(e,t=!0){const a=e.size?e.size:e.length;this.__reserve(4*a+(t?4:0)),t&&this.writeUInt32(a);for(let t=0;t<a;t++)this.writeFloat32(e[t]);}writeStr(e,t=!0){const a=value.length;this.__reserve(4*a+(t?4:0)),t&&this.writeUInt32(a);for(let e=0;e<a;e++)this.writeFloat32(value.charCodeAt(e));}writeSInt32Vec2(e){this.writeSInt32(e.x),this.writeSInt32(e.y);}writeUInt32Vec2(e){this.writeUInt32(e.x),this.writeUInt32(e.y);}writeFloat16Vec2(e){this.writeFloat16(e.x),this.writeFloat16(e.y);}writeFloat32Vec2(e){this.writeFloat32(e.x),this.writeFloat32(e.y);}writeFloat16Vec3(e){this.writeFloat16(e.x),this.writeFloat16(e.y),this.writeFloat16(e.z);}writeFloat32Vec3(e){this.writeFloat32(e.x),this.writeFloat32(e.y),this.writeFloat32(e.z);}writeFloat16Quat(e){this.writeFloat16(e.x),this.writeFloat16(e.y),this.writeFloat16(e.z),this.writeFloat16(e.w);}writeFloat32Quat(e){this.writeFloat32(e.x),this.writeFloat32(e.y),this.writeFloat32(e.z),this.writeFloat32(e.w);}writeRGBFloat32Color(e){this.writeFloat32(e.r),this.writeFloat32(e.g),this.writeFloat32(e.b);}writeRGBAFloat32Color(e){this.writeFloat32(e.r),this.writeFloat32(e.g),this.writeFloat32(e.b),this.writeFloat32(e.a);}writeRGBUInt8Color(e){this.writeUInt8(e.r),this.writeUInt8(e.g),this.writeUInt8(e.b);}writeRGBAUInt8Color(e){this.writeUInt8(e.r),this.writeUInt8(e.g),this.writeUInt8(e.b),this.writeUInt8(e.a);}writeBox2(e){this.writeFloat32Vec2(e.p0),this.writeFloat32Vec2(e.p1);}writeBox3(e){this.writeFloat32Vec3(e.p0),this.writeFloat32Vec3(e.p1);}writePadd(e){const t=e-this.__byteOffset;this.__reserve(t),this.__offset(t);}writeAlignment(e){const t=this.__byteOffset%e;0!=t&&(this.__reserve(e-t),this.__offset(e-t));}}const ce=4;class me{constructor(e,t){this.__name=e,this.__cb=t,this.__flags=0;}getName(){return this.__name}getOwner(){return this.__ownerItem}setOwner(e){this.__ownerItem!==e&&(this.__ownerItem=e);}getPath(){if(this.__ownerItem){if(this.__ownerItem.getPath){const e=this.__ownerItem.getPath().slice();return e.push(this.__name),e}return [this.__ownerItem.getName(),this.__name]}return [this.__name]}setEnabled(e){e?this.__flags&=~ce:this.__flags|=~ce;}isEnabled(){}invoke(){this.__cb();}}class ue extends P{constructor(e,t=0,a,i){super(e,t,"Number"),a&&!Array.isArray(a)&&console.error("Range value must be an array of 2 numbers."),this.__range=a,this.__step=i;}setValue(e,t){t==N.USER_SETVALUE&&(this.__range&&(e=Math.clamp(e,this.__range[0],this.__range[1])),this.__step&&(e=Math.round(e/this.__step)*this.__step)),super.setValue(e,t);}getValue(e){return super.getValue(e)}getRange(){return this.__range}setRange(e){return this.__range=e,this}getStep(){return this.__step}setStep(e){return this.__step=e,this}toJSON(e,t){const a=super.toJSON(e,t);return this.__range&&(a.range=this.__range),this.__step&&(a.step=this.__step),a}fromJSON(e,t,a){super.fromJSON(e,t,a),e.range&&(this.__range=e.range),e.step&&(this.__step=e.step);}readBinary(e,t){const a=e.loadFloat32();this.setValue(a,N.DATA_LOAD);}clone(e){const t=new ue(this.__name,this.__value);return t.__range=this.__range,t.__step=this.__step,t}}C.registerClass("NumberParameter",ue),C.registerClass("Property_SInt32",ue),C.registerClass("Property_UInt32",ue),C.registerClass("Property_Float32",ue);class be extends ue{constructor(e,t,a){super(e,t,[0,a.length],1),this.choices=a;}getChoices(){return this.choices}setValue(e,t){"string"==typeof e?super.setValue(this.choices.indexOf(e),t):super.setValue(e,t);}}class pe extends P{constructor(e,t){super(e,t,"Boolean");}clone(e){return new pe(this.__name,this.__value)}}C.registerClass("BooleanParameter",pe);class ge extends P{constructor(e,t,a){super(e,t||new o,"Vec2"),this.__range=a;}getRange(){return this.__range}__setRange(e){this.__range=e,this.rangeChanged.emit();}clone(e){return new ge(this.__name,this.__value.clone())}}class _e extends P{constructor(e,t,a){super(e,t||new d,"Vec3");}clone(e){return new _e(this.__name,this.__value.clone())}}class Ze extends P{constructor(e,t){super(e,t||new h,"Vec4");}clone(e){return new Ze(this.__name,this.__value.clone())}}class Ge extends P{constructor(e,t){super(e,t||new u,"Color");}readBinary(e,t){const a=e.loadRGBAFloat32Color();a.applyGamma(2.2),this.setValue(a,N.DATA_LOAD);}clone(e){return new Ge(this.__name,this.__value.clone())}}C.registerClass("ColorParameter",Ge);class Xe extends P{constructor(e,t){super(e,t||new g,"Mat3");}clone(e){return new Xe(this.__name,this.__value.clone())}}class ye extends P{constructor(e,t){super(e,t||new _,"Mat4");}clone(e){return new ye(this.__name,this.__value.clone())}}class fe extends P{constructor(e,t){super(e,t||new X,"Xfo");}clone(e){return new fe(this.__name,this.__value.clone())}}class Ve extends P{constructor(e,t){super(e,t,"BaseImage"),this.valueParameterValueChanged=new S;}toJSON(e,t){const a=super.toJSON(e,t);return this.__value&&(a.imageType=this.__value.constructor.name),a}fromJSON(e,t,a){return e.imageType&&(this.__value=C.constructClass(e.imageType)),super.fromJSON(e,t,a)}clone(e){return new Ve(this.__name,this.__value)}}class xe extends P{constructor(e,t=""){super(e,t,"String"),this.multiLine=!1;}setMultiLine(e){this.multiLine=e;}getMultiLine(){return this.multiLine}readBinary(e,t){const a=e.loadStr();this.setValue(a,N.DATA_LOAD);}clone(e){return new xe(this.__name,this.__value)}}C.registerClass("StringParameter",xe),C.registerClass("Property_String",xe);class Ie extends xe{constructor(e,t=""){super(e,t,"String"),this.lang="js";}setLanguage(e){this.lang=e;}getLanguage(){return this.lang}clone(e){return new Ie(this.__name,this.__value)}}C.registerClass("CodeParameter",Ie);class Re extends P{constructor(e,t){super(e,"","FilePath"),this.fileUpdated=new S,t&&this.setSupportedExts(t);}setSupportedExts(e){this.__reextensions=new RegExp("\\.("+e+")$","i");}getFilepath(){return this.__file?re.getFilepath(this.__file.id):""}setFilepath(e,t){const a=re.resolveFilePathToId(e);a?this.setValue(a,t):console.warn("Resource unavailable:"+e);}getFilename(){if(this.__file)return this.__file.name}getExt(){const e=this.getFilename(),t=e.lastIndexOf(".");if(-1!=t)return e.substring(t).toLowerCase()}getStem(){const e=this.getFilename();if(e){const t=e.split(".");return 2==t.length?t[0]:e}}getFileFolder(){if(this.__file)return this.__file.parent?re.getFile(this.__file.parent):re.getRootFolder()}getFileFolderPath(){const e=this.getFilepath();if(e)return e.substring(0,e.lastIndexOf("/"))+"/"}getFile(){return this.__file}getFileDesc(){return this.__file}setUrl(e,t,a=N.USER_SETVALUE){const i=e.split("/");t||(t=i[i.length-1]),this.__value=t,this.__file={id:e,name:t,url:e},a!=N.USER_SETVALUE&&a!=N.REMOTEUSER_SETVALUE||(this.__flags|=K.USER_EDITED),this.valueChanged.emit(a);}getUrl(){return this.__file?this.__file.url:void 0}setDirty(e){throw new Error("Cannot drive a filepath param from an oporator")}setValue(e,t=N.USER_SETVALUE){if(null==e)throw new Error("Invalid value for setValue.");if(e.indexOf(".")>0)return console.warn("Deprecation warning for setValue. setValue should now only take a file id, not a path."),this.setFilepath(e,t);if(e==this.__value)return;const a=e;if(!re.resourceAvailable(a))return void console.warn("Resource unavailable:"+a);const i=re.getFile(a);if(this.__reextensions&&!this.__reextensions.test(i.name))return console.warn("Unsupported file type:"+i.name),!1;this.__value=e,this.__file=i,re.fileUpdated.connect(e=>{e==this.__value&&(this.__file=re.getFile(this.__value),this.fileUpdated.emit());}),t==N.USER_SETVALUE&&(this.__flags|=K.USER_EDITED),this.valueChanged.emit(t);}toJSON(e,t){if(0==(this.__flags&K.USER_EDITED))return;const a={};return this.__file&&(a.value=this.__file.id,a.filepath=re.getFilepath(this.__file.id)),a}fromJSON(e,t,a){if(e.value){if(e.value.indexOf(".")>0)return void this.setFilepath(e.value,N.DATA_LOAD);if(re.resourceAvailable(e.value))return this.setValue(e.value,N.DATA_LOAD),void(this.__flags|=K.USER_EDITED)}if(e.filepath){const t=re.resolveFilePathToId(e.filepath);if(t)return void this.setValue(t,N.DATA_LOAD);console.warn("Resource unavailable:"+e.filepath);}}clone(e){const t=new Re(this.__name);return t.__file=this.__file,t}destroy(){super.destroy();}}class Se extends P{constructor(e,t){super(e,[]),this.__dataType=t,this.elementAdded=new S,this.elementRemoved=new S;}__filter(e){return !0}getCount(){return this.__value.length}getElement(e){return this.__value[e]}setElement(e,t){this.__value[e]=t,this.valueChanged.emit(N.USER_SETVALUE);}addElement(e){if(null==e)e=new this.__dataType;else if(!this.__filter(e))return;return this.__value.push(e),this.__flags|=K.USER_EDITED,this.elementAdded.emit(e,this.__value.length-1),this.valueChanged.emit(N.USER_SETVALUE),e}removeElement(e){const t=this.__value[e];this.__value.splice(e,1),this.__flags|=K.USER_EDITED,this.elementRemoved.emit(t,e),this.valueChanged.emit(N.USER_SETVALUE);}insertElement(e,t){this.__filter(t)&&(this.__value.splice(e,0,t),this.__flags|=K.USER_EDITED,this.elementAdded.emit(t,e),this.valueChanged.emit(N.USER_SETVALUE));}toJSON(e,t){if(0==(this.__flags&K.USER_EDITED))return;const a=[];for(const i of this.__value)"string"==typeof this.__dataType?a.push(i):a.push(i.toJSON(e,t));return {items:a}}fromJSON(e,t,a){if(null!=e.items){this.__flags|=K.USER_EDITED,this.__value=[];for(let a=0;a<e.items.length;a++){let i;"string"==typeof this.__dataType?i=e.items[a]:(i=new this.__dataType,i.fromJSON(e.items[a],t)),this.__value.push(i),this.elementAdded.emit(i,this.__value.length-1);}this.valueChanged.emit(N.DATA_LOAD);}else console.warn("Invalid Parameter JSON");}clone(e){const t=this.__value.slice(0),a=new Se(this.__name,this.__dataType);return a.setValue(t),a}destroy(){for(let e=0;e<this.__value.length;e++)this.__value[e]instanceof P&&this.__value[e].destroy(),this.removeElement(e);}}class We extends P{constructor(e){super(e,{},"Struct"),this.__members=[];}_addMember(e){return this.__value[e.getName()]=e.getValue(),e.valueChanged.connect(()=>{this.__value[e.getName()]=e.getValue();}),this.__members.push(e),this.__flags|=K.USER_EDITED,this.valueChanged.emit(),e}getParameter(e){for(const t of this.__members)if(t.getName()==e)return t}getMember(e){return this.getParameter(e)}getMemberNames(){const e=[];for(let t=0;t<this.__members.length;t++){const a=this.__members[t];null!=a&&(e[t]=a.getName());}return e}toJSON(e,t){if(0==(this.__flags&K.USER_EDITED))return;const a=[];for(const i of this.__members)a.push(i.toJSON(e,t));return {members:a}}fromJSON(e,t,a){if(null!=e.members){this.__flags|=K.USER_EDITED;for(let a=0;a<e.members.length;a++)e.members[a]&&this.__members[a].fromJSON(e.members[a],t);}else console.warn("Invalid Parameter JSON");}destroy(){super.destroy();for(const e of this.__members)e.destroy();}}class Le extends P{constructor(e,t){super(e,void 0,"TreeItem"),this.__filterFn=t,this.treeItemGlobalXfoChanged=new S;}setOwner(e){this.__owner=e;}getOwner(){return this.__owner}setFilterFn(){this.__filterFn=filterFn;}getFilterFn(){return this.__filterFn}setValue(e,t=N.USER_SETVALUE){if(this.__filterFn&&!this.__filterFn(e))return !1;this.__value!==e&&(this.__value&&this.__value.globalXfoChanged.disconnect(this.treeItemGlobalXfoChanged.emit),this.__value=e,this.__value&&this.__value.globalXfoChanged.connect(this.treeItemGlobalXfoChanged.emit),t!=N.USER_SETVALUE&&t!=N.REMOTEUSER_SETVALUE||(this.__flags|=K.USER_EDITED),this.valueChanged.emit(t));}toJSON(e,t){if(0!=(this.__flags&K.USER_EDITED))return {value:e.makeRelative(this.__value.getPath())}}fromJSON(e,t,a){null!=e.value?(t.resolvePath(e.value,e=>{this.setValue(e);},()=>{console.warn("Unable to resolve tree item parameter value:"+pj.paramPath);}),this.__flags|=K.USER_EDITED):console.warn("Invalid Parameter JSON");}clone(e){return new Le(this.__name,this.__filterFn)}destroy(){this.__value&&this.__value.parameterValueChanged.disconnect(this.valueParameterValueChanged.emit);}}class ve extends P{constructor(e,t){super(e,void 0,"BaseItem"),this.__items=new Set,this.__filterFn=t,this.itemAdded=new S,this.itemRemoved=new S;}setFilterFn(e){this.__filterFn=e;}getFilterFn(){return this.__filterFn}getItem(e){return Array.from(this.__items)[e]}addItem(e,t=!0){if(this.__filterFn&&!this.__filterFn(e))return console.warn("ItemSet __filterFn rejecting item:",e.getPath()),!1;this.__items.add(e);const a=Array.from(this.__items).indexOf(e);return this.itemAdded.emit(e,a),t&&this.valueChanged.emit(),a}addItems(e,t=!0){e.forEach(e=>this.addItem(e,!1)),t&&this.valueChanged.emit();}removeItem(e,t=!0){const a=Array.from(this.__items)[e];return this.__items.delete(a),this.itemRemoved.emit(a,e),t&&this.valueChanged.emit(),a}setItems(e,t=!0){for(let t=this.__items.length-1;t>=0;t--){const a=this.__items[t];e.has(a)||this.removeItem(a,!1);}for(const t of e)this.__items.has(t)||this.addItem(t,!1);t&&this.valueChanged.emit();}clearItems(e=!0){this.__items.clear(),e&&this.valueChanged.emit();}getNumItems(){return Array.from(this.__items).length}getValue(){return this.__items}toJSON(e,t){return {}}fromJSON(e,t,a){}clone(e){return new ve(this.__name,this.__filterFn)}}class Me extends P{constructor(e,t){super(e,void 0,t.getDataType()),this.setSourceParameter(t);}setSourceParameter(e){this.sourceParameter=e,this.sourceParameter.valueChanged.connect(this.__proxyValueChanged.bind(this));}__proxyValueChanged(e){this.valueChanged.emit(e);}getDataType(){return this.sourceParameter.getDataType()}setValue(e,t){}getValue(e){return this.sourceParameter.getValue(e)}toJSON(e,t){const a=super.toJSON(e,t);return this.sourceParameter&&(a.sourceParameter=this.sourceParameter.getPath()),a}fromJSON(e,t,a){super.fromJSON(e,t,a),e.sourceParameter&&t.resolvePath(e.sourceParameter,e=>{this.setSourceParameter(e);},t=>{console.warn("Error loading Proxy Param: '"+this.getName()+"'. Unable to connect to:"+e.sourceParameter);}),e.range&&(this.sourceParameter=e.range),e.step&&(this.__step=e.step);}clone(e,t){const a=new Me(this.__name,this.__value);return this.sourceParameter&&this.connectToClonedSourceParam(t),a}connectToClonedSourceParam(e){e.resolveClonedItem(this.sourceParameter,e=>{clonedParam.setSourceParameter(e);},e=>{console.warn("Error cloning Proxy Param: '"+this.getName()+"'. Unable to connect to:"+j.sourceParameter);});}}C.registerClass("ProxyParameter",Me);class Fe extends P{constructor(e,t){super(e,void 0,"Geometry"),this.boundingBoxDirtied=new S,this.setValue(t);}setValue(e,t=N.USER_SETVALUE){this.__value!==e&&(this.__value&&this.__value.boundingBoxDirtied.disconnect(this.boundingBoxDirtied.emit),this.__value=e,this.__value&&this.__value.boundingBoxDirtied.connect(this.boundingBoxDirtied.emit),t!=N.USER_SETVALUE&&t!=N.REMOTEUSER_SETVALUE||(this.__flags|=K.USER_EDITED),t!=N.OPERATOR_SETVALUE&&this.valueChanged.emit(t));}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,a){return super.fromJSON(e,t,a)}clone(e){return new Fe(this.__name,this.__value)}destroy(){this.__value&&this.__value.boundingBoxDirtied.disconnect(this.boundingBoxDirtied.emit);}}class Te extends D{constructor(e){super(e),this.width=0,this.height=0,this.format="RGB",this.type="UNSIGNED_BYTE",this.addParameter(new pe("AlphaFromLuminance",!1)),this.addParameter(new pe("Invert",!1)),this.addParameter(new pe("FlipY",!1)),this.updated=this.parameterValueChanged,this.loaded=new S(!0);}isLoaded(){return !0}getMapping(){return this.__mapping}setMapping(e){this.__mapping=e;}isStream(){return !1}isStreamAtlas(){return this.__streamAtlas}getParams(){return {type:this.type,format:this.format,width:this.width,height:this.height,flipY:this.getParameter("FlipY").getValue(),invert:this.getParameter("Invert").getValue(),alphaFromLuminance:this.getParameter("AlphaFromLuminance").getValue()}}}class Ce extends ue{constructor(e,t,a){super(e,t,a),this.textureConnected=new S,this.textureDisconnected=new S;}getImage(){return this.__image}setImage(e,t=0){const a=()=>{this.textureDisconnected.emit();};e?(null!=this.__image&&this.__image!==e&&a(),this.__image=e,this.textureConnected.emit(),this.valueChanged.emit(t)):null!=this.__image&&(a(),this.__image=void 0,this.textureDisconnected.emit());}setValue(e){e instanceof Te?this.setImage(e):(null!=this.__image&&this.setImage(void 0),super.setValue(e));}readBinary(e,t){super.readBinary(e,t);const a=e.loadStr();""!=a&&(console.log("Load Texture"),this.setImage(t.materialLibrary.getImage(a)));}clone(e){return new Ce(this.__name,this.__value.clone())}}C.registerClass("MaterialFloatParam",Ce);class Ye extends Ge{constructor(e,t){super(e,t),this.textureConnected=new S,this.textureDisconnected=new S,this.__imageUpdated=this.__imageUpdated.bind(this);}getImage(){return this.__image}__imageUpdated(){this.valueChanged.emit();}setImage(e,t=0){const a=()=>{this.__image.loaded.disconnect(this.__imageUpdated),this.__image.updated.disconnect(this.__imageUpdated),this.__image=null,this.textureDisconnected.emit();};e?(null!=this.__image&&this.__image!==e&&a(),this.__image=e,this.__image.updated.connect(this.__imageUpdated),this.textureConnected.emit(),this.valueChanged.emit(t)):null!=this.__image&&(a(),this.__image=void 0,this.textureDisconnected.emit());}setValue(e){e instanceof Te?this.setImage(e):(null!=this.__image&&this.setImage(void 0),super.setValue(e));}readBinary(e,t){super.readBinary(e,t);const a=e.loadStr();""!=a&&this.setImage(t.materialLibrary.getImage(a));}clone(e){return new Ye(this.__name,this.__value.clone())}}C.registerClass("MaterialColorParam",Ye);const Ne=(e,t,a,i)=>"boolean"==typeof t||!1===t||!0===t?new P(e,t,"Boolean"):"string"==typeof t?new P(e,t,"String"):Number.isNumeric(t)?i?new Ce(e,t,a):new ue(e,t,a):t instanceof o?new ge(e,t):t instanceof d?new _e(e,t):t instanceof u?i?new Ye(e,t):new Ge(e,t):new P(e,t);class Ke extends D{constructor(e,t){super(e),this.shaderNameChanged=new S,this.visibleInGeomDataBuffer=!0,t&&this.setShaderName(t);}getShaderName(){return this.__shaderName}setShaderName(e){if(this.__shaderName==e)return;const t=C.getClass(e);if(!t)throw new Error("Error setting Shader. Shader not found:"+e);const a=t.getParamDeclarations(),i={};for(const e of a){let t=this.getParameter(e.name);t||(t=this.addParameter(Ne(e.name,e.defaultValue,e.range,0!=e.texturable))),i[e.name]=!0;}for(const e of this.__params)i[e.getName()]||this.removeParameter(e.getName());this.__shaderName=e,this.shaderNameChanged.emit(this.__shaderName);}removeAllTextures(){for(const e of this.__params)e.getImage&&e.getImage()&&e.setImage(void 0);}getParamTextures(){const e={};for(const t of this.__params)t.getImage&&t.getImage()&&(e[t.getName()]=t.getImage());return e}__makeParameterTexturable(e){makeParameterTexturable(e);}isTransparent(){const e=this.getParameter("Opacity");if(e&&(e.getValue()<.99||e.getImage()))return !0;const t=this.getParameter("BaseColor");return !(!t||!t.getImage()||"RGBA"!=t.getImage().format)}getShaderClass(){return C.getClass(this.getShaderName())}modifyParams(e,t){t&&this.setShaderName(t);for(const t in e){const a=this.getParameter(t);a&&(e[t]instanceof P?this.replaceParameter(e[t]):a.setValue(e[t]));}}toJSON(e,t=0){return super.toJSON(e,t)}fromJSON(e,t={},a=0){e.shader?(this.setShaderName(e.shader),super.fromJSON(e,t,a)):console.warn("Invalid Material JSON");}readBinary(e,t){let a=e.loadStr();if("StandardMaterial"==a&&(a="StandardSurfaceShader"),"TransparentMaterial"==a&&(a="TransparentSurfaceShader"),this.setShaderName(a),t.versions["zea-engine"].lessThan([0,0,3])){this.setName(e.loadStr());const a=e.loadUInt32();for(let s=0;s<a;s++){const a=(i=e.loadStr()).charAt(0).toUpperCase()+i.slice(1);let s;"MaterialColorParam"==e.loadStr()?(s=e.loadRGBAFloat32Color(),s.applyGamma(2.2)):s=e.loadFloat32();const n=e.loadStr();let l=this.getParameter(a);l?l.setValue(s):l=this.addParameter(Ne(a,s)),""!=n&&l.setImage&&(t.materialLibrary.hasImage(n)?l.setImage(t.materialLibrary.getImage(n)):console.warn("Missing Texture:"+n));}}else super.readBinary(e,t);var i;}clone(e){const t=new Ke;return t.copyFrom(this,e),t}copyFrom(e,t){super.copyFrom(e,t),this.setShaderName(e.getShaderName());for(const t of e.getParameters()){const a=e.getParameter(t.getName());t.getImage||this.__makeParameterTexturable(a);}}destroy(){this.removeAllTextures(),super.destroy();}}class we extends Te{constructor(e){super(),null==e&&(e=this.constructor.name),this.__name=e,this.format="RGBA",this.type="UNSIGNED_BYTE",this.__loaded=!1,this.width=1,this.height=1;}isLoaded(){return this.__loaded}getName(){return this.__name}isStream(){return !1}setData(e,t,a){this.width=e,this.height=t,this.__data=a,this.__loaded?this.updated.emit():(this.__loaded=!0,this.loaded.emit());}getParams(){const e=super.getParams();return e.data=this.__data,e}}function ze(e){this.data=e,this.pos=0;}function Ue(e){this.stream=new ze(e),this.output={};}C.registerClass("DataImage2D",we),C.registerClass("DataImage",we),ze.prototype.readByte=function(){return this.data[this.pos++]},ze.prototype.peekByte=function(){return this.data[this.pos]},ze.prototype.readBytes=function(e){for(var t=new Array(e),a=0;a<e;a++)t[a]=this.readByte();return t},ze.prototype.peekBytes=function(e){for(var t=new Array(e),a=0;a<e;a++)t[a]=this.data[this.pos+a];return t},ze.prototype.readString=function(e){for(var t="",a=0;a<e;a++)t+=String.fromCharCode(this.readByte());return t},ze.prototype.readBitArray=function(){for(var e=[],t=this.readByte(),a=7;a>=0;a--)e.push(!!(t&1<<a));return e},ze.prototype.readUnsigned=function(e){var t=this.readBytes(2);return e?(t[1]<<8)+t[0]:(t[0]<<8)+t[1]},Ue.prototype.parse=function(e){return this.parseParts(this.output,e),this.output},Ue.prototype.parseParts=function(e,t){for(var a=0;a<t.length;a++){var i=t[a];this.parsePart(e,i);}},Ue.prototype.parsePart=function(e,t){var a,i=t.label;if(!t.requires||t.requires(this.stream,this.output,e))if(t.loop){for(var s=[];t.loop(this.stream);){var n={};this.parseParts(n,t.parts),s.push(n);}e[i]=s;}else t.parts?(a={},this.parseParts(a,t.parts),e[i]=a):t.parser?(a=t.parser(this.stream,this.output,e),t.skip||(e[i]=a)):t.bits&&(e[i]=this.parseBits(t.bits));},Ue.prototype.parseBits=function(e){var t={},a=this.stream.readBitArray();for(var i in e){var s=e[i];s.length?t[i]=a.slice(s.index,s.index+s.length).reduce((function(e,t){return 2*e+t}),0):t[i]=a[s.index];}return t};var Je=function(){return function(e){return e.readByte()}},Pe=function(e){return function(t){return t.readBytes(e)}},Ee=function(e){return function(t){return t.readString(e)}},He=function(e){return function(t){return t.readUnsigned(e)}},ke=function(e,t){return function(a,i,s){for(var n=t(a,i,s),l=new Array(n),r=0;r<n;r++)l[r]=a.readBytes(e);return l}},Be={label:"blocks",parser:function(e){for(var t=[],a=e.readByte();0!==a;a=e.readByte())t=t.concat(e.readBytes(a));return t}},De={label:"gce",requires:function(e){var t=e.peekBytes(2);return 33===t[0]&&249===t[1]},parts:[{label:"codes",parser:Pe(2),skip:!0},{label:"byteSize",parser:Je()},{label:"extras",bits:{future:{index:0,length:3},disposal:{index:3,length:3},userInput:{index:6},transparentColorGiven:{index:7}}},{label:"delay",parser:He(!0)},{label:"transparentColorIndex",parser:Je()},{label:"terminator",parser:Je(),skip:!0}]},Oe={label:"image",requires:function(e){return 44===e.peekByte()},parts:[{label:"code",parser:Je(),skip:!0},{label:"descriptor",parts:[{label:"left",parser:He(!0)},{label:"top",parser:He(!0)},{label:"width",parser:He(!0)},{label:"height",parser:He(!0)},{label:"lct",bits:{exists:{index:0},interlaced:{index:1},sort:{index:2},future:{index:3,length:2},size:{index:5,length:3}}}]},{label:"lct",requires:function(e,t,a){return a.descriptor.lct.exists},parser:ke(3,(function(e,t,a){return Math.pow(2,a.descriptor.lct.size+1)}))},{label:"data",parts:[{label:"minCodeSize",parser:Je()},Be]}]},Qe={label:"text",requires:function(e){var t=e.peekBytes(2);return 33===t[0]&&1===t[1]},parts:[{label:"codes",parser:Pe(2),skip:!0},{label:"blockSize",parser:Je()},{label:"preData",parser:function(e,t,a){return e.readBytes(a.text.blockSize)}},Be]},Ae={label:"frames",parts:[De,{label:"application",requires:function(e,t,a){var i=e.peekBytes(2);return 33===i[0]&&255===i[1]},parts:[{label:"codes",parser:Pe(2),skip:!0},{label:"blockSize",parser:Je()},{label:"id",parser:function(e,t,a){return e.readString(a.blockSize)}},Be]},{label:"comment",requires:function(e,t,a){var i=e.peekBytes(2);return 33===i[0]&&254===i[1]},parts:[{label:"codes",parser:Pe(2),skip:!0},Be]},Oe,Qe],loop:function(e){var t=e.peekByte();return 33===t||44===t}},je=[{label:"header",parts:[{label:"signature",parser:Ee(3)},{label:"version",parser:Ee(3)}]},{label:"lsd",parts:[{label:"width",parser:He(!0)},{label:"height",parser:He(!0)},{label:"gct",bits:{exists:{index:0},resolution:{index:1,length:3},sort:{index:4},size:{index:5,length:3}}},{label:"backgroundColorIndex",parser:Je()},{label:"pixelAspectRatio",parser:Je()}]},{label:"gct",requires:function(e,t){return t.lsd.gct.exists},parser:ke(3,(function(e,t){return Math.pow(2,t.lsd.gct.size+1)}))},Ae];function qe(e){var t=new Ue(new Uint8Array(e));this.raw=t.parse(je),this.raw.hasImages=!1;for(var a=0;a<this.raw.frames.length;a++)if(this.raw.frames[a].image){this.raw.hasImages=!0;break}}qe.prototype.decompressFrame=function(e,t){if(e>=this.raw.frames.length)return null;var a=this.raw.frames[e];if(a.image){var i=a.image.descriptor.width*a.image.descriptor.height,s=function(e,t,a){var i,s,n,l,r,o,d,h,c,m,u,b,p,g,_,Z,G=a,X=new Array(a),y=new Array(4096),f=new Array(4096),V=new Array(4097);for(r=(s=1<<(b=e))+1,i=s+2,d=-1,n=(1<<(l=b+1))-1,c=0;c<s;c++)y[c]=0,f[c]=c;for(u=h=p=g=Z=_=0,m=0;m<G;){if(0===g){if(h<l){u+=t[_]<<h,h+=8,_++;continue}if(c=u&n,u>>=l,h-=l,c>i||c==r)break;if(c==s){n=(1<<(l=b+1))-1,i=s+2,d=-1;continue}if(-1==d){V[g++]=f[c],d=c,p=c;continue}for(o=c,c==i&&(V[g++]=p,c=d);c>s;)V[g++]=f[c],c=y[c];p=255&f[c],V[g++]=p,i<4096&&(y[i]=d,f[i]=p,0==(++i&n)&&i<4096&&(l++,n+=i)),d=o;}g--,X[Z++]=V[g],m++;}for(m=Z;m<G;m++)X[m]=0;return X}(a.image.data.minCodeSize,a.image.data.blocks,i);a.image.descriptor.lct.interlaced&&(s=function(e,t){for(var a=new Array(e.length),i=e.length/t,s=function(i,s){var n=e.slice(s*t,(s+1)*t);a.splice.apply(a,[i*t,t].concat(n));},n=[0,4,2,1],l=[8,8,4,2],r=0,o=0;o<4;o++)for(var d=n[o];d<i;d+=l[o])s(d,r),r++;return a}(s,a.image.descriptor.width));var n={pixels:s,dims:{top:a.image.descriptor.top,left:a.image.descriptor.left,width:a.image.descriptor.width,height:a.image.descriptor.height}};return a.image.descriptor.lct&&a.image.descriptor.lct.exists?n.colorTable=a.image.lct:n.colorTable=this.raw.gct,a.gce&&(n.delay=10*(a.gce.delay||10),n.disposalType=a.gce.extras.disposal,a.gce.extras.transparentColorGiven&&(n.transparentIndex=a.gce.transparentColorIndex)),t&&(n.patch=function(e){for(var t=e.pixels.length,a=new Uint8ClampedArray(4*t),i=0;i<t;i++){var s=4*i,n=e.pixels[i],l=e.colorTable[n];a[s]=l[0],a[s+1]=l[1],a[s+2]=l[2],a[s+3]=n!==e.transparentIndex?255:0;}return a}(n)),n}return null},qe.prototype.decompressFrames=function(e){for(var t=[],a=0;a<this.raw.frames.length;a++){this.raw.frames[a].image&&t.push(this.decompressFrame(a,e));}return t};const $e={},et={},tt=-1!==navigator.userAgent.indexOf("Chrome");class it extends Te{constructor(e,t="",a={}){t.constructor==Object&&(a=t),null!=e&&-1!=e.lastIndexOf(".")&&(console.warn("Deprecated signature. Please provide a name and filepath to the image constructor"),e=e.substring(e.lastIndexOf("/")+1,e.lastIndexOf("."))),super(e,a),this.__loaded=!1;const i=this.addParameter(new Re("FilePath"));i.valueChanged.connect(()=>{if(this.loaded.untoggle(),this.getName()==C.getClassName(this)){const e=i.getStem(),t=e.substring(e.length-1);isNaN(t)?this.setName(e):this.setName(e.substring(0,e.length-1));}const e=i.getFileDesc();e&&this.__loadData(e);}),t&&""!=t&&i.setFilepath(t);}static __imageDataLibrary(){return $e}static registerLoader(e,t){et[e]=t;}static constructLoader(e,t){for(const a of et)if(new RegExp("\\.("+a+")$","i").test(e.name)){const i=new et[a](t);if(i)return i.getParameter("FilePath").setValue(e.id),i}}__loadData(e){const t=this.getParameter("FilePath").getExt();if(".jpg"==t||".png"==t||".webp"==t)this.__loadLDRImage(e,t);else if(".mp4"==t||".ogg"==t)this.__loadLDRVideo(e);else if(".vlh"==t)this.__loadVLH(e);else if(".gif"==t)this.__loadGIF(e);else {if(".svg"!=t)throw new Error("Unsupported file type. Check the ext:"+e);console.warn("SVG Image not yet supported");}}__loadLDRImage(e,a){let i;".jpg"==a?this.format="RGB":".png"==a&&(this.format="RGBA"),this.type="UNSIGNED_BYTE";const s=()=>{this.getDOMElement=()=>i,this.width=i.width,this.height=i.height,this.__data=i,this.__loaded=!0,this.loaded.emit();};if(e.id in $e)i=$e[e.id],i.complete?s():i.addEventListener("load",s);else {re.addWork(e.id,1);const a=this.addParameter(new ue("PreferredSize",-1));let n=e.url;if(e.assets&&Object.keys(e.assets).length>0){const i={maxSize:t.gpuDesc.maxTextureSize},s=a.getValue();-1==s?e.assets.reduce&&(i.prefSize=e.assets.reduce.w):i.prefSize=s;const l=function(e,t){if(t=t.filter(e=>null!==e),tt){const e=t.filter(e=>"webp"===e.format);e.length>1&&(t=e);}else t=t.filter(e=>"webp"!==e.format);if(e.maxSize&&(t=t.filter(t=>t.w<=e.maxSize)),e.filter){const a=t.filter(t=>-1!==t.url.indexOf(e.filter));a.length>1&&(t=a);}if(e.prefSize&&(t=t.map(t=>Object.assign({score:Math.abs(e.prefSize-t.w)},t))).sort((e,t)=>e.score>t.score?1:e.score<t.score?-1:0),t.length>0)return t[0]}(i,Object.values(e.assets));l&&(console.log("Selected image:"+e.name+" format:"+l.format+" :"+l.w+"x"+l.h+" url:"+l.url),n=l.url);}else console.warn("Images not processed for this file:"+e.name);i=new Image,i.crossOrigin="anonymous",i.src=n,i.addEventListener("load",s),i.addEventListener("load",()=>{re.addWorkDone(e.id,1);}),$e[e.id]=i;}}__removeVideoParams(){this.getParameterIndex("spatializeAudio")&&(this.removeParameter(this.getParameterIndex("Loop")),this.removeParameter(this.getParameterIndex("spatializeAudio")),this.removeParameter(this.getParameterIndex("Gain")),this.removeParameter(this.getParameterIndex("refDistance")),this.removeParameter(this.getParameterIndex("maxDistance")),this.removeParameter(this.getParameterIndex("rolloffFactor")),this.removeParameter(this.getParameterIndex("coneInnerAngle")),this.removeParameter(this.getParameterIndex("coneOuterAngle")),this.removeParameter(this.getParameterIndex("coneOuterGain")));}__loadLDRVideo(e){this.format="RGB",this.type="UNSIGNED_BYTE",re.addWork(e.id,1);const t=this.addParameter(new pe("Mute",!0)),a=this.addParameter(new pe("Loop",!0)),i=document.createElement("video");i.style.display="none",i.preload="auto",i.crossOrigin="anonymous",this.getAudioSource=()=>i,document.body.appendChild(i),i.addEventListener("loadedmetadata",()=>{i.muted=t.getValue(),t.valueChanged.connect(()=>{i.muted=t.getValue();}),i.loop=a.getValue(),a.valueChanged.connect(()=>{i.loop=a.getValue();}),this.width=i.videoHeight,this.height=i.videoWidth,this.__data=i,this.__loaded=!0,re.addWorkDone(e.id,1),this.loaded.emit(i),i.play().then(()=>{let e=0;const t=()=>{if(i.paused||i.ended)return;const a=Math.floor(29.97*i.currentTime);e!=a&&(this.updated.emit(),e=a),setTimeout(t,20);};t();},e=>{console.log("Autoplay was prevented.",e,e.message);});},!1),i.src=e.url;}__loadVLH(e){this.type="FLOAT";let t=new u(1,1,1,1);this.setHDRTint=e=>{t=e;},this.getHDRTint=()=>t,re.loadUrl(e.id,e.url,e=>{let t,a;for(const i in e)i.endsWith(".jpg")?t=e[i]:i.endsWith(".bin")&&(a=e[i]);const i=new Blob([t.buffer]),s=new Image;s.onload=()=>{this.width=s.width,this.height=s.height,this.__data={ldr:s,cdm:a},this.__loaded?this.updated.emit():(this.__loaded=!0,this.loaded.emit());},s.src=URL.createObjectURL(i);});}__loadGIF(e){let t,a,i;this.format="RGBA",this.type="UNSIGNED_BYTE",this.__streamAtlas=!0,this.addParameter(new Ze("StreamAtlasDesc",new h)),this.addParameter(new ue("StreamAtlasIndex",0)),this.getParameter("StreamAtlasIndex").setRange([0,1]),this.getFrameDelay=()=>20,this.play=()=>{i.then(()=>{t=!0,a&&a();});},this.stop=()=>{t=!1;},e.id in $e?i=$e[e.id]:(i=new Promise((t,a)=>{if(re.addWork(e.id,1),e.assets&&e.assets.atlas){const a=new Image;return a.crossOrigin="anonymous",a.src=e.assets.atlas.url,void a.addEventListener("load",()=>{t({width:e.assets.atlas.width,height:e.assets.atlas.height,atlasSize:e.assets.atlas.atlasSize,frameDelays:e.assets.atlas.frameDelays,frameRange:[0,e.assets.atlas.frameDelays.length],imageData:a}),re.addWorkDone(e.id,1);})}ee(e.url,a=>{console.warn("Unpacking Gif client side:"+e.name);const i=performance.now(),s=new qe(a).decompressFrames(!0),n=Math.sqrt(s.length),l=[n,n];Math.fract(n)>0&&(l[0]=Math.floor(l[0]+1),Math.fract(n)>.5?l[1]=Math.floor(l[1]+1):l[1]=Math.floor(l[1]));const r=s[0].dims.width,o=s[0].dims.height,d=document.createElement("canvas"),h=d.getContext("2d"),c=document.createElement("canvas"),m=c.getContext("2d");c.width=r,c.height=o;const u=document.createElement("canvas"),b=u.getContext("2d");let p;u.width=l[0]*r,u.height=l[1]*o;const g=[],_=(e,t)=>{const a=e.dims;g.push(e.delay/10),p&&a.width==p.width&&a.height==p.height||(d.width=a.width,d.height=a.height,p=h.createImageData(a.width,a.height)),p.data.set(e.patch),h.putImageData(p,0,0),2==e.disposalType&&m.clearRect(0,0,c.width,c.height),m.drawImage(d,a.left,a.top),b.drawImage(c,t%l[0]*r,Math.floor(t/l[0])*o);};for(let e=0;e<s.length;e++)_(s[e],e);re.addWorkDone(e.id,1);const Z=b.getImageData(0,0,u.width,u.height),G=performance.now()-i;console.log(`Decode GIF '${e.name}' time:`+G),t({width:u.width,height:u.height,atlasSize:l,frameRange:[0,s.length],frameDelays:g,imageData:Z});},t=>{console.warn("Unable to Load URL:"+t+":"+e.url),a();});}),$e[e.id]=i),i.then(e=>{this.width=e.width,this.height=e.height,this.getParameter("StreamAtlasDesc").setValue(new h(e.atlasSize[0],e.atlasSize[1],0,0)),this.getParameter("StreamAtlasIndex").setRange(e.frameRange),this.__data=e.imageData,this.getFrameDelay=t=>10*e.frameDelays[t];const i=this.getParameter("StreamAtlasIndex"),s=i.getRange()[1];let n=0;a=()=>{i.setValue(n),t&&setTimeout(a,this.getFrameDelay(n)),n=(n+1)%s;},t&&a(),this.__loaded=!0,this.loaded.emit();});}getFilepath(){return this.getParameter("FilePath").getValue()}isStream(){return !1}isLoaded(){return this.__loaded}getParams(){const e=super.getParams();return this.__loaded&&(e.data=this.__data),e}toJSON(e,t){}fromJSON(e,t,a){}readBinary(e,t){this.setName(e.loadStr());let a=e.loadStr();if("string"==typeof a&&""!=a){if(t.lod>=0){const e=a.lastIndexOf(".");if(-1!=e){const i=a.substring(0,e)+t.lod+a.substring(e);re.resolveFilepath(i)&&(a=i);}}this.getParameter("FilePath").setFilepath(a);}}}class st extends it{constructor(e,t={}){console.warn("FileImage2D is becoming deprecated in favor of simple FileImage"),super(e,t);}}C.registerClass("FileImage2D",it),C.registerClass("FileImage",it);const nt=-1!==navigator.userAgent.indexOf("Chrome");class lt extends it{constructor(e,t,a){super(e,t,a),this.type="UNSIGNED_BYTE",this.addParameter(new ue("PreferredSize",-1)),this.__crossOrigin="anonymous";}setCrossOrigin(e){this.__crossOrigin=e;}__loadData(e){".png"==this.getParameter("FilePath").getExt()&&(this.format="RGBA");let a=e.url;if(e.assets&&Object.keys(e.assets).length>0){const i={maxSize:t.gpuDesc.maxTextureSize},s=this.getParameter("PreferredSize").getValue();-1==s?e.assets.reduce&&(i.prefSize=e.assets.reduce.w):i.prefSize=s;const n=function(e,t){if(t=t.filter(e=>null!==e),nt){const e=t.filter(e=>"webp"===e.format);e.length>1&&(t=e);}else t=t.filter(e=>"webp"!==e.format);if(e.maxSize&&(t=t.filter(t=>t.w<=e.maxSize)),e.filter){const a=t.filter(t=>-1!==t.url.indexOf(e.filter));a.length>1&&(t=a);}if(e.prefSize&&(t=t.map(t=>Object.assign({score:Math.abs(e.prefSize-t.w)},t))).sort((e,t)=>e.score>t.score?1:e.score<t.score?-1:0),t.length>0)return t[0]}(i,Object.values(e.assets));n&&(console.log("Selected image:"+e.name+" format:"+n.format+" :"+n.w+"x"+n.h+" url:"+n.url),a=n.url);}else console.warn("Images not processed for this file:"+e.name);this.setImageURL(a,"RGB");}setImageURL(e,t="RGB"){if(!t){const a=e.lastIndexOf(".");if(-1!=a){".png"==e.substring(a).toLowerCase()&&(t="RGBA");}}let a;this.format=t,this.__loaded=!1;const i=()=>{this.getDOMElement=()=>a,this.width=a.width,this.height=a.height,this.__data=a,this.__loaded=!0,this.loaded.emit();},s=it.__imageDataLibrary();e in s?(a=s[e],a.complete?i():a.addEventListener("load",i)):(a=new Image,a.crossOrigin=this.__crossOrigin,a.src=e,a.addEventListener("load",i),s[e]=a);}}it.registerLoader("jpg|jpeg|png",lt),C.registerClass("LDRImage",lt);class rt extends it{constructor(e,t,a){super(e,t,a),this.format="RGB",this.type="UNSIGNED_BYTE",this.addParameter(new pe("Mute",!1)),this.addParameter(new pe("Loop",!0)),this.addParameter(new ue("Gain",2)).setRange([0,5]),this.addParameter(new pe("SpatializeAudio",!0)),this.addParameter(new ue("refDistance",2)),this.addParameter(new ue("maxDistance",1e4)),this.addParameter(new ue("rolloffFactor",1)),this.addParameter(new ue("coneInnerAngle",360)),this.addParameter(new ue("coneOuterAngle",0)),this.addParameter(new ue("coneOuterGain",1));}__loadData(e){re.addWork(e.id,1);const t=document.createElement("video");t.style.display="none",t.preload="auto",t.crossOrigin="anonymous",this.getAudioSource=()=>t,document.body.appendChild(t),t.addEventListener("loadedmetadata",()=>{const a=this.getParameter("Mute");t.muted=a.getValue(),a.valueChanged.connect(()=>{t.muted=a.getValue();});const i=this.getParameter("Loop");t.loop=i.getValue(),i.valueChanged.connect(()=>{t.loop=i.getValue();}),this.width=t.videoHeight,this.height=t.videoWidth,this.__data=t,this.__loaded=!0,re.addWorkDone(e.id,1),this.loaded.emit(t);let s=0;const n=()=>{if(t.paused||t.ended)return;const e=Math.floor(29.97*t.currentTime);s!=e&&(this.updated.emit(),s=e),setTimeout(n,20);};n();},!1),t.src=e.url;const a=t.play();void 0!==a&&a.then(e=>{console.log("Autoplay started!");}).catch(()=>{console.log("Autoplay was prevented.");});}}it.registerLoader("mp4|ogg",rt),C.registerClass("LDRVideo",rt);class ot extends it{constructor(e,t="",a={}){super(e,t,a),this.format="RGBA",this.type="UNSIGNED_BYTE",this.__streamAtlas=!0,this.getParameter("FilePath").setSupportedExts("gif"),this.addParameter(new Ze("StreamAtlasDesc")),this.addParameter(new ue("StreamAtlasIndex",0));const i=this.getParameter("StreamAtlasIndex");let s;i.setRange([0,1]);let n=0;const l=e=>{i.setValue(n),s&&setTimeout(()=>l(e),this.getFrameDelay(n)),n=(n+1)%e;};this.play=()=>{this.__resourcePromise.then(()=>{s=!0;const e=i.getRange()[1];l(e);});},this.stop=()=>{s=!1;};}getFrameDelay(e){return 10*this.__unpackedData.frameDelays[e]}__loadData(e){const t=it.__imageDataLibrary();e.id in t?this.__resourcePromise=t[e.id]:(this.__resourcePromise=new Promise((t,a)=>{if(re.addWork(e.id,1),e.assets&&e.assets.atlas){const a=new Image;return a.crossOrigin="anonymous",a.src=e.assets.atlas.url,void a.addEventListener("load",()=>{t({width:e.assets.atlas.width,height:e.assets.atlas.height,atlasSize:e.assets.atlas.atlasSize,frameDelays:e.assets.atlas.frameDelays,frameRange:[0,e.assets.atlas.frameDelays.length],imageData:a}),re.addWorkDone(e.id,1);})}ee(e.url,a=>{console.warn("Unpacking Gif client side:"+e.name);const i=performance.now(),s=new qe(a).decompressFrames(!0),n=Math.sqrt(s.length),l=[n,n];Math.fract(n)>0&&(l[0]=Math.floor(l[0]+1),Math.fract(n)>.5?l[1]=Math.floor(l[1]+1):l[1]=Math.floor(l[1]));const r=s[0].dims.width,o=s[0].dims.height,d=document.createElement("canvas"),h=d.getContext("2d"),c=document.createElement("canvas"),m=c.getContext("2d");c.width=r,c.height=o;const u=document.createElement("canvas"),b=u.getContext("2d");let p;u.width=l[0]*r,u.height=l[1]*o;const g=[],_=(e,t)=>{const a=e.dims;g.push(e.delay/10),p&&a.width==p.width&&a.height==p.height||(d.width=a.width,d.height=a.height,p=h.createImageData(a.width,a.height)),p.data.set(e.patch),h.putImageData(p,0,0),2==e.disposalType&&m.clearRect(0,0,c.width,c.height),m.drawImage(d,a.left,a.top),b.drawImage(c,t%l[0]*r,Math.floor(t/l[0])*o);};for(let e=0;e<s.length;e++)_(s[e],e);re.addWorkDone(e.id,1);const Z=b.getImageData(0,0,u.width,u.height),G=performance.now()-i;console.log(`Decode GIF '${e.name}' time:`+G),t({width:u.width,height:u.height,atlasSize:l,frameRange:[0,s.length],frameDelays:g,imageData:Z});},t=>{console.warn("Unable to Load URL:"+t+":"+e.url),a();});}),t[e.id]=this.__resourcePromise),this.__resourcePromise.then(e=>{this.width=e.width,this.height=e.height,this.getParameter("StreamAtlasDesc").setValue(new h(e.atlasSize[0],e.atlasSize[1],0,0)),this.getParameter("StreamAtlasIndex").setRange(e.frameRange),this.__unpackedData=e,this.__data=e.imageData,this.__loaded=!0,this.loaded.emit();});}}it.registerLoader("gif",ot),C.registerClass("GIFImage",ot);class dt extends Te{constructor(e,t={}){let a;null!=e&&-1!=e.lastIndexOf(".")&&(a=e,e=e.substring(e.lastIndexOf("/")+1,e.lastIndexOf("."))),super(e,t),this.__loaded=!1,this.__exposure=1,this.__ambientLightFactor=0,this.__hdrtint=new u(1,1,1,1),this.__stream="stream"in t&&t.stream,this.type="FLOAT";const i=this.addParameter(new Re("FilePath"));i.valueChanged.connect(()=>{if(this.loaded.untoggle(),this.getName()==C.getClassName(this)){const e=i.getStem(),t=e.substring(e.length-1);isNaN(t)?this.setName(e):this.setName(e.substring(0,e.length-1));}const e=i.getValue(),t=i.getFile();this.__loadVLH(e,t);}),a&&this.getParameter("FilePath").setFilepath(a);}getDOMElement(){return this.__domElement}getResourcePath(){return this.getParameter("FilePath").getValue()}__decodeData(e){const t=e.ldr,a=e.cdm,i=new Blob([t.buffer]),s=new Image;s.onload=()=>{this.width=s.width,this.height=s.height,this.__data={ldr:s,cdm:a},this.__loaded?this.updated.emit():(this.__loaded=!0,this.loaded.emit());},s.src=URL.createObjectURL(i);}__loadVLH(e,t){this.type="FLOAT",re.loadUrl(e,t.url,e=>{if(!e.ldr||!e.cdm)for(const t in e)t.endsWith(".jpg")?(e.ldr=e[t],delete e[t]):t.endsWith(".bin")&&(e.cdm=e[t],delete e[t]);this.__decodeData(e);});}isStream(){return !1}isLoaded(){return this.__loaded}getParams(){const e=super.getParams();return this.__loaded&&(e.data=this.__data,e.exposure=this.__exposure),e}setHDRTint(e){this.__hdrtint=e;}getHDRTint(){return this.__hdrtint}toJSON(e,t){}fromJSON(e,t,a){}readBinary(e,t){this.setName(e.loadStr());const a=e.loadStr();if("string"==typeof a&&""!=a){if(t.lod>=0){const e=a.lastIndexOf(".");if(-1!=e){const i=a.substring(0,e)+t.lod+a.substring(e);re.resourceAvailable(i)&&(a=i);}}this.getParameter("FilePath").setValue(a);}}}C.registerClass("VLHImage",dt);const ht=1,ct=2,mt=(e,t)=>t<e?0:1;function ut(e){return e.dot(new o(1,1))}function bt(e){return new o(Math.abs(e.x),Math.abs(e.y))}function pt(e,t){return new o(Math.max(e.x,t),Math.max(e.y,t))}function gt(e){const t=function(e){return new d(Math.abs(e.x),Math.abs(e.y),Math.abs(e.z))}(e),a=function(e){return new d(2*mt(0,e.x)-1,2*mt(0,e.y)-1,2*mt(0,e.z)-1)}(e),i=new o(t.x,t.y);let s=pt(i,1e-20);const n=Math.atan2(s.x,s.y)/Math.HALF_PI;s=pt(new o(t.z,i.length()),1e-20);const l=Math.atan2(s.y,s.x)/Math.HALF_PI;let r=new o(a.x*n,a.y*(1-n));if(r.scaleInPlace(l),e.z<0){const e=new o(r.y,r.x),t=new o(a.x,a.y);r=t.subtract(bt(e).multiply(t));}return r.scale(.5).add(new o(.5,.5))}function _t(e){const t=function(e){return new o(2*mt(0,e.x)-1,2*mt(0,e.y)-1)}(e=e.scale(2).subtract(new o(1,1))),a=ut(bt(e)),i=a*Math.PI*.5;if(i<=0)return new d(0,0,1);if(Math.abs(i-Math.PI)<1e-6)return new d(0,0,-1);if(a>1){e=bt(o(e.y,e.x)).negate().add(new o(1,1)).multiply(t),a=ut(bt(e));}const s=Math.abs(e.x)/a*Math.HALF_PI,n=Math.sin(s),l=Math.cos(s),r=Math.sin(i),h=Math.cos(i);return new d(n*t.x*r,l*t.y*r,h)}class Zt extends dt{constructor(e,t={}){super(e,t),this.mapping=ct;}__decodeData(e){super.__decodeData(e);const t=e.samples;t&&(window.TextDecoder?this.__sampleSets=JSON.parse(new TextDecoder("utf-8").decode(t)):this.__sampleSets=JSON.parse(v(t)),this.__sampleSets.luminanceThumbnail&&(this.__thumbSize=Math.sqrt(this.__sampleSets.luminanceThumbnail.length)));}getSampleSets(){return this.__sampleSets}uvToDir(e){switch(this.mapping){case ht:return function(e,t){const a=Math.PI*(2*e-1),i=Math.PI*t;return new d(sin(i)*sin(a),-sin(i)*cos(a),cos(i))}(e);case ct:return _t(e)}}dirToUv(e){switch(this.mapping){case ht:return function(e){const t=Math.acos(e.z),a=Math.atan2(e.x,-e.y);return new o((1+a/Math.PI)/2,t/Math.PI)}(e);case ct:return gt(e)}}uvToLuminance(e){const t=Math.floor(e.y*this.__thumbSize)*this.__thumbSize+Math.floor(e.x*this.__thumbSize);return this.__sampleSets.luminanceThumbnail[t]}dirToLuminance(e){return this.uvToLuminance(this.dirToUv(e))}}C.registerClass("EnvMap",Zt);class Gt extends T{constructor(e,t,a,i){super(),this.atlasSize=a,this.image=new dt("Lightmap",{stream:i}),this.image.getParameter("FilePath").setFilepath(e),this.image.setHDRTint(t.getParameter("LightmapTint").getValue()),this.__stream=i;}get width(){return this.atlasSize[0]}get height(){return this.atlasSize[1]}isStream(){return this.__stream}loadResource(e){this.image.loadResource(e);}fromJSON(e){this.__atlasSize=e.atlasSize;}}class Xt extends T{constructor(e){super(),this.atlasSize=e,this.__images=[],this.__weights=[],this.__stream=!1,this.lightmapAdded=new S,this.lightmapResourceChanged=new S,this.lightmapWeightChanged=new S;}get width(){return this.atlasSize[0]}get height(){return this.atlasSize[1]}isStream(){return this.__stream}loadResource(e,t,a,i=!1){this.__images[e]?(this.__images[e].loadResource(t),this.lightmapResourceChanged.emit(e,a),a&&(this.__weights[e]=a,this.lightmapWeightChanged.emit(e,a))):(this.__images[e]=new FileImage(t,{stream:i}),this.__weights[e]=a||1,this.lightmapAdded.emit(e)),this.__stream|=i;}setWeight(e,t){this.__weights[e]=t,this.lightmapWeightChanged.emit(e,t);}numSubImages(){return this.__images.length}getSubImage(e){return this.__images[e]}getSubImageWeight(e){return this.__weights[e]}fromJSON(e){this.__atlasSize=e.atlasSize;}}const yt=new class{constructor(){this.__labelLibraries={},this.labelLibraryLoaded=new S;const e=function(){const e=window.navigator,t=["language","browserLanguage","systemLanguage","userLanguage"];let a,i;if(Array.isArray(e.languages))for(a=0;a<e.languages.length;a++)if(i=e.languages[a],i&&i.length)return i;for(a=0;a<t.length;a++)if(i=e[t[a]],i&&i.length)return i;return null}();e.startsWith("en")?this.__language="En":e.startsWith("es")?this.__language="Es":e.startsWith("fr")?this.__language="Fr":(e.startsWith("gb")||e.startsWith("de"))&&(this.__language="Gb"),this.__foundLabelLibraries={},re.registerResourceCallback(".labels",e=>{const t=e.name.split(".")[0];this.__foundLabelLibraries[t]=e,A(e.url,e=>{this.__labelLibraries[t]=JSON.parse(e),this.labelLibraryLoaded.emit(t);});}),window.XLSX&&re.registerResourceCallback(".xlsx",e=>{const t=e.name.split(".")[0];this.__foundLabelLibraries[t]=e,ee(e.url,e=>{const a=new Uint8Array(e),i=XLSX.read(a,{type:"array"}),s={};i.SheetNames.forEach((function(e){XLSX.utils.sheet_to_row_object_array(i.Sheets[e]).forEach((function(e){const t=e.Identifier;delete e.Identifier,s[t]=e;}));})),this.__labelLibraries[t]=s,this.labelLibraryLoaded.emit(t);});});}isLibraryFound(e){return e in this.__foundLabelLibraries}isLibraryLoaded(e){return e in this.__labelLibraries}getLabelText(e,t){const a=this.__labelLibraries[e];if(!a)throw new Error("LabelLibrary: '"+e+"' not found in LabelManager. Found: ["+Object.keys(this.__labelLibraries)+"]");const i=a[t];if(!i)throw new Error("Label: '"+t+"' not found in LabelLibrary: '"+e+"'. Found: ["+Object.keys(a)+"]");const s=i[this.__language];if(!s){if(i.En)return i.En;throw new Error("labelText: '"+language+"' not found in Label. Found: ["+Object.keys(i)+"]")}return s}setLabelText(e,t,a){let i=this.__labelLibraries[e];i||(i={},this.__labelLibraries[e]=i);let s=i[t];s||(s={},i[t]=s),s[this.__language]=a;}setLanguage(e){this.__language=e;}};class ft extends we{constructor(e,t){super(e),this.__canvasElem=document.createElement("canvas");const a=this.addParameter(new xe("library"));this.addParameter(new xe("text","")),this.addParameter(new Ge("fontColor",new u(0,0,0))),this.addParameter(new ue("margin",11)),this.addParameter(new ue("borderWidth",2)),this.addParameter(new ue("borderRadius",11)),this.addParameter(new pe("outline",!1)),this.addParameter(new pe("outlineColor",new u(0,0,0))),this.addParameter(new pe("background",!0)),this.addParameter(new Ge("backgroundColor",new u("#FBC02D"))),this.addParameter(new pe("fillBackground",!0)),this.addParameter(new pe("strokeBackgroundOutline",!0)),this.addParameter(new ue("fontSize",22)),this.addParameter(new xe("font","Helvetica"));this.nameChanged.connect(()=>{this.loadLabelData();}),t&&a.setValue(t),this.__requestedRerender=!1,this.__needsRender=!1,this.labelRendered=new S,this.loadLabelData();}__parameterValueChanged(e,t){this.__requestedRerender||(this.__requestedRerender=!0,this.loadLabelData());}loadLabelData(){Promise.all([(()=>new Promise(e=>{const t=this.getParameter("library").getValue();if(""==t)return void e();if(!yt.isLibraryFound(t))return console.warn("Label Libary not found:",t),void e();const a=()=>{try{const e=this.getName(),a=yt.getLabelText(t,e);this.getParameter("text").setValue(a);}catch(e){console.warn(e);}e();};yt.isLibraryLoaded(t)?a():yt.labelLibraryLoaded.connect(e=>{e==t&&a();});}))(),(()=>new Promise(e=>{if(null!=document.fonts){const t=this.getParameter("font").getValue(),a=this.getParameter("fontSize").getValue();document.fonts.load(a+'px "'+t+'"').then(()=>{e();});}else e();}))()]).then(()=>{this.__requestedRerender=!1,this.__needsRender=!0,this.__loaded?this.updated.emit():(this.__loaded=!0,this.loaded.emit());});}renderLabelToImage(){const e=this.__canvasElem.getContext("2d",{alpha:!0});let t=this.getParameter("text").getValue();""==t&&(t=this.getName());const a=this.getParameter("font").getValue(),i=this.getParameter("fontColor").getValue(),s=this.getParameter("fontSize").getValue(),n=this.getParameter("margin").getValue(),l=this.getParameter("borderWidth").getValue(),r=this.getParameter("borderRadius").getValue(),o=this.getParameter("outline").getValue(),d=this.getParameter("outlineColor").getValue(),h=this.getParameter("background").getValue(),c=this.getParameter("backgroundColor").getValue(),m=this.getParameter("fillBackground").getValue(),u=this.getParameter("strokeBackgroundOutline").getValue(),b=n+l,p=t.split("\n");e.font=s+'px "'+a+'"';let g=0;p.forEach(t=>{g=Math.max(e.measureText(t).width,g);});const _=s;this.width=Math.ceil(g+2*b),this.height=Math.ceil(_*p.length+2*b),e.canvas.width=this.width,e.canvas.height=this.height,this.__canvasElem.width=this.width,this.__canvasElem.height=this.height,e.fillStyle="rgba(0, 0, 0, 0.0)",e.fillRect(0,0,this.width,this.height),h&&(e.fillStyle=c.toHex(),e.strokeStyle=d.toHex(),function(e,t,a,i,s,n,l,r,o){if(void 0===r&&(r=!0),void 0===n&&(n=5),"number"==typeof n)n={tl:n,tr:n,br:n,bl:n};else {const e={tl:0,tr:0,br:0,bl:0};for(const t in e)n[t]=n[t]||e[t];}e.beginPath(),e.moveTo(t+n.tl,a),e.lineTo(t+i-n.tr,a),e.quadraticCurveTo(t+i,a,t+i,a+n.tr),e.lineTo(t+i,a+s-n.br),e.quadraticCurveTo(t+i,a+s,t+i-n.br,a+s),e.lineTo(t+n.bl,a+s),e.quadraticCurveTo(t,a+s,t,a+s-n.bl),e.lineTo(t,a+n.tl),e.quadraticCurveTo(t,a,t+n.tl,a),e.closePath(),l&&e.fill(),r&&(e.lineWidth=o,e.stroke());}(e,l,l,this.width-2*l,this.height-2*l,r,m,u,l)),e.font=s+'px "'+a+'"',e.textAlign="left",e.fillStyle=i.toHex(),e.textBaseline="hanging",p.forEach((t,a)=>{e.fillText(t,b,b+a*_);}),o&&(e.strokeStyle=d.toHex(),e.lineWidth=1.5,e.strokeText(t,b,b)),this.__data=e.getImageData(0,0,this.width,this.height),this.__needsRender=!1,this.labelRendered.emit({width:this.width,height:this.height,data:this.__data});}getParams(){return this.__needsRender&&this.renderLabelToImage(),super.getParams()}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,a){super.fromJSON(e,t,a),this.__getLabelText();}}C.registerClass("Label",ft);class Vt extends Te{constructor(){super(),this.__loaded=!1;}connectWebcam(e,t,a=!1){const i={width:e,height:t,frameRate:{ideal:60,max:60}};i.facingMode=a?{exact:"environment"}:{facingMode:"user"};const s=document.createElement("video");s.style.display="none",s.preload="auto",s.crossOrigin="anonymous",document.body.appendChild(s),navigator.mediaDevices.getUserMedia({audio:!1,video:i}).then(e=>{s.srcObject=e,s.onloadedmetadata=e=>{s.play(),this.width=s.videoWidth,this.height=s.videoHeight,console.log("Webcam:["+this.width+", "+this.height+"]"),this.__data=s,this.__loaded=!0,this.loaded.emit(s);let t=0;const a=()=>{if(s.paused||s.ended)return;const e=Math.floor(60*s.currentTime);t!=e&&(this.updated.emit(),t=e),setTimeout(a,20);};a();};}).catch((function(e){}));}setVideoStream(e){this.__loaded=!1,this.width=e.videoWidth,this.height=e.videoHeight,this.start(),this.__data=e,this.__loaded=!0,this.loaded.emit(e);}stop(){clearInterval(this.__intervalId);}start(){this.__intervalId=setInterval(()=>{this.updated.emit();},20);}isLoaded(){return this.__loaded}getParams(){return {type:this.type,format:this.format,width:this.width,height:this.height,data:this.__data,flipY:this.getParameter("FlipY").getValue()}}}C.registerClass("VideoStreamImage2D",Vt);class xt{constructor(e="MaterialLibrary"){this.__name=e,this.lod=0,t.isMobileDevice&&(this.lod=1),this.loaded=new S,this.clear();}clear(){this.__images={},this.__materials={Default:new Ke("Default","SimpleSurfaceShader")};}getPath(){return [this.__name]}getNumMaterials(){return Object.keys(this.__materials).length}getMaterials(){return Object.values(this.__materials)}getMaterialNames(){const e=[];for(const t in this.__materials)e.push(t);return e}hasMaterial(e){return e in this.__materials}addMaterial(e){e.setOwner(this),this.__materials[e.getName()]=e;}getMaterial(e,t=!0){const a=this.__materials[e];if(!a&&t)throw new Error("Material:"+e+" not found in library:"+this.getMaterialNames());return a}hasImage(e){return e in this.__images}addImage(e){e.setOwner(this),this.__images[e.getName()]=e;}getImage(e,t=!0){const a=this.__images[e];if(!a&&t)throw new Error("Image:"+e+" not found in library:"+this.getImageNames());return a}getImageNames(){const e=[];for(const t in this.__images)e.push(t);return e}load(e){const t=new XMLHttpRequest;t.open("GET",e,!0),t.ontimeout=()=>{throw new Error("The request for "+e+" timed out.")},t.onload=()=>{4===t.readyState&&(200===t.status?this.fromJSON(JSON.parse(t.responseText)):console.warn(t.statusText));},t.send(null);}toJSON(e={},t=0){return {numMaterials:this.geoms.length()}}fromJSON(e,t={},a=0){t.lod=this.lod;for(const t in e.textures){new it(t).fromJSON(e.textures[t]),this.__images[t]=texture;}for(const t in e.materials){const a=new Ke(t);a.fromJSON(e.materials[t]),this.addMaterial(a);}}readBinary(e,t={}){this.name=e.loadStr(),t.lod=this.lod,t.materialLibrary=this;const a=e.loadUInt32();for(let i=0;i<a;i++){const a=e.loadStr(),i=C.constructClass(a,void 0);i.readBinary(e,t),this.__images[i.getName()]=i;}const i=e.loadUInt32();if(i>0){const a=e.loadUInt32Array(i);for(let s=0;s<i;s++){const i=new Ke("");e.seek(a[s]),i.readBinary(e,t,this.__images),this.addMaterial(i);}}this.loaded.emit();}toString(){return JSON.stringify(this.toJSON(),null,2)}}const It=new class{constructor(){this.__materialLibraries={},this.materialLibraryLoaded=new S,re.registerResourceCallback(".matlib",e=>{A(e.url,t=>{const a=e.name.split(".")[0],i=JSON.parse(t),s=new xt(a);s.fromJSON(i),this.__materialLibraries[a]=s,this.materialLibraryLoaded.emit(s);});});}getMaterialLibraryNames(){const e=[];for(const t in this.__materialLibraries)e.push(t);return e}hasMaterialLibrary(e){return e in this.__materialLibraries}getMaterialLibrary(e){const t=this.__materialLibraries[e];return t||console.warn("MaterialLibrary:"+e+" not found in MaterialLibraryManager. Found: ["+this.getMaterialLibraryNames()+"]"),t}resolveMaterialFromPath(e){const t=this.getMaterialLibrary(e[0]);if(t)return t.getMaterial(e[1])}};class Rt extends P{constructor(e,t){super(e,t,"Material"),this.valueParameterValueChanged=new S;}setValue(e,t=N.USER_SETVALUE){this.__value!==e&&(this.__value&&this.__value.parameterValueChanged.disconnect(this.valueParameterValueChanged.emit),this.__value=e,this.__value&&this.__value.parameterValueChanged.connect(this.valueParameterValueChanged.emit),t!=N.USER_SETVALUE&&t!=N.REMOTEUSER_SETVALUE||(this.__flags|=K.USER_EDITED),t!=N.OPERATOR_SETVALUE&&this.valueChanged.emit(t));}toJSON(e,t){if(0!=(this.__flags&K.USER_EDITED))return {value:this.__value.getPath()}}fromJSON(e,t,a){if(null==e.value)return void console.warn("Invalid Parameter JSON");const i=e.value,s=It.resolveMaterialFromPath(i);s&&this.setValue(s),this.__flags|=K.USER_EDITED;}clone(e){return new Rt(this.__name,this.__value)}destroy(){this.__value&&this.__value.parameterValueChanged.disconnect(this.valueParameterValueChanged.emit);}}class St{constructor(e,t,a){if(this.__dataType=e,this.normalized=!1,null!=e.numElements)this.__dimension=this.__dataType.numElements();else switch(e){case 6:case 4:case 5:this.__dimension=1;break;default:throw new Error("Invalid data type for attribute:"+e)}var i;this.__defaultElementValue=null!=a?a:Number.MAX_VALUE,(i=t)&&void 0!==i.byteLength?this.__data=t:(this.__data=new Float32Array(t*this.__dimension),this.initRange(0));}resize(e){const t=this.__data.length,a=e*this.__dimension,i=new Float32Array(a);for(let e=0;e<Math.min(this.__data.length,a);e++)i[e]=this.__data[e];this.__data.length<a&&(this.__data=i),this.initRange(t);}initRange(e){for(let t=e;t<this.__data.length;t++)this.__data[t]=this.__defaultElementValue;}getCount(){return this.__data.length/this.__dimension}get length(){return this.__data.length/this.__dimension}get dataType(){return this.__dataType}get data(){return this.__data}set data(e){this.__data=e;}get numElements(){return this.__dimension}getFloat32Value(e){return this.__data[e]}setFloat32Value(e,t){this.__data[e]=t;}getValueRef(e){const t=this.__dimension;if(e>=this.__data.length/t)throw new Error("Invalid vertex index:"+e+". Num Vertices:"+this.__data.length/3);return this.__dataType.createFromFloat32Buffer(this.__data.buffer,e*t)}setValue(e,t){const a=this.__dimension;if(e>=this.__data.length/a)throw new Error("Invalid vertex index:"+e+". Num Vertices:"+this.__data.length/3);this.__dataType.createFromFloat32Buffer(this.__data.buffer,e*a).setFromOther(t);}toJSON(e,t){return {data:Array.from(this.__data),dataType:r.getTypeName(this.__dataType),defaultValue:this.__defaultElementValue,length:this.__data.length/this.__dimension}}fromJSON(e){this.__data=Float32Array.from(e.data);}toString(){return JSON.stringify(this.toJSON(),null,2)}}class Wt extends H{constructor(){super(),this.__boundingBox=new V,this.__boundingBoxDirty=!0,this.__vertexAttributes=new Map,this.__metaData=new Map,this.addVertexAttribute("positions",d,0),this.boundingBoxDirtied=new S,this.geomDataChanged=new S,this.geomDataTopologyChanged=new S;}setDebugName(e){this.__name=e;}addVertexAttribute(e,t,a){let i;var s;return i=(s=a)&&void 0!==s.byteLength?new St(t,a):new St(t,null!=this.vertices?this.vertices.length:0,a),this.__vertexAttributes.set(e,i),i}hasVertexAttribute(e){return this.__vertexAttributes.has(e)}getVertexAttribute(e){return this.__vertexAttributes.get(e)}getVertexAttributes(e){const t={};for(const[e,a]of this.__vertexAttributes.entries())t[e]=a;return t}get vertices(){return this.__vertexAttributes.get("positions")}numVertices(){return this.vertices.length}getNumVertices(){return this.vertices.length}setNumVertices(e){this.__vertexAttributes.forEach(t=>t.resize(e));}getVertex(e){return d.createFromFloat32Buffer(this.vertices.data.buffer,3*e)}setVertex(e,t){return d.createFromFloat32Buffer(this.vertices.data.buffer,3*e).setFromOther(t)}moveVertices(e){const t=this.vertices;for(let a=0;a<t.length;a++)t.getValueRef(a).addInPlace(e);this.setBoundingBoxDirty();}transformVertices(e){const t=this.vertices;for(let a=0;a<t.length;a++){const i=t.getValueRef(a),s=e.transformVec3(i);i.set(s.x,s.y,s.z);}this.setBoundingBoxDirty();}get boundingBox(){return this.__boundingBoxDirty&&this.updateBoundingBox(),this.__boundingBox}setBoundingBoxDirty(){this.__boundingBoxDirty=!0,this.boundingBoxDirtied.emit();}updateBoundingBox(){const e=this.vertices,t=new V,a=e.length;for(let i=0;i<a;i++)t.addPoint(e.getValueRef(i));this.__boundingBox=t,this.__boundingBoxDirty=!1;}getMetadata(e){return this.__metaData.get(e)}hasMetadata(e){return this.__metaData.has(e)}setMetadata(e,t){this.__metaData.set(e,t);}deleteMetadata(e){this.__metaData.delete(e);}genBuffers(e){const t={};for(const[e,a]of this.__vertexAttributes)t[e]={values:a.data,count:a.size,dataType:a.dataType,normalized:a.normalized};return {numVertices:this.numVertices(),attrBuffers:t}}freeBuffers(){}loadBaseGeomBinary(e){this.name=e.loadStr();const t=e.loadUInt8();this.debugColor=e.loadRGBFloat32Color();const a=e.loadUInt32();this.__boundingBox.set(e.loadFloat32Vec3(),e.loadFloat32Vec3()),this.setNumVertices(a);const i=this.vertices;let s,n;2&t&&(s=this.getVertexAttribute("normals"),s||(s=this.addVertexAttribute("normals",d,0))),4&t&&(n=this.getVertexAttribute("texCoords"),n||(n=this.addVertexAttribute("texCoords",o,0)));const l=(e,t,a,s)=>{for(let n=e[0];n<e[1];n++){const e=new d(s[3*n+0]/255,s[3*n+1]/255,s[3*n+2]/255);e.multiplyInPlace(a),e.addInPlace(t),i.setValue(n,e);}},r=(e,t,a,i)=>{a.isNull()&&a.set(1,1,1);for(let n=e[0];n<e[1];n++){const e=new d(i[3*n+0]/255,i[3*n+1]/255,i[3*n+2]/255);e.multiplyInPlace(a),e.addInPlace(t),e.normalizeInPlace(),s.setValue(n,e);}},h=(e,t,a,i)=>{for(let s=e[0];s<e[1];s++){const e=new o(i[2*s+0]/255,i[2*s+1]/255);e.multiplyInPlace(a),e.addInPlace(t),n.setValue(s,e);}},c=e.loadUInt32();if(1==c){{const t=this.__boundingBox,i=e.loadUInt8Array(3*a);l([0,a],t.p0,t.diagonal(),i);}if(s){const t=new V(e.loadFloat32Vec3(),e.loadFloat32Vec3()),i=e.loadUInt8Array(3*a);r([0,a],t.p0,t.diagonal(),i),s.loadSplitValues(e);}if(n){const t=new y(e.loadFloat32Vec2(),e.loadFloat32Vec2()),i=e.loadUInt8Array(2*a);h([0,a],t.p0,t.diagonal(),i),n.loadSplitValues(e);}}else {const t=[];let i=0;for(let a=0;a<c;a++){const a=e.loadUInt32(),l={range:[i,i+a],bbox:new V(e.loadFloat32Vec3(),e.loadFloat32Vec3())};s&&(l.normalsRange=new V(e.loadFloat32Vec3(),e.loadFloat32Vec3())),n&&(l.texCoordsRange=new y(e.loadFloat32Vec2(),e.loadFloat32Vec2())),t.push(l),i+=a;}const o=e.loadUInt8Array(3*a);let d,m;s&&(d=e.loadUInt8Array(3*a)),n&&(m=e.loadUInt8Array(2*a));for(let e=0;e<c;e++){{const a=t[e].bbox;l(t[e].range,a.p0,a.diagonal(),o);}if(s){const a=t[e].normalsRange;r(t[e].range,a.p0,a.diagonal(),d);}if(n){const a=t[e].texCoordsRange;h(t[e].range,a.p0,a.diagonal(),m);}}s&&s.loadSplitValues(e),n&&n.loadSplitValues(e);}}toJSON(e,t){let a=super.toJSON(e,t);if(a||(a={}),a.type=C.getClassName(this),!(1024&t)){const i={};for(const[a,s]of this.__vertexAttributes.entries())i[a]=s.toJSON(e,t);a.vertexAttributes=i;}return a}fromJSON(e,t,a){super.fromJSON(e,t,a);for(const t in e.vertexAttributes){let a=this.__vertexAttributes.get(t);const i=e.vertexAttributes[t];if(!a){const e=r.getType(i.dataType);a=new VertexAttribute(this,e,0,i.defaultScalarValue),this.__vertexAttributes.set(t,a);}a.fromJSON(i);}}toString(){return JSON.stringify(this.toJSON(),null,2)}}class Lt extends St{constructor(e,t,a,i){super(t,a,i),this.__geom=e,this.__splits={},this.__splitValues=[];}getFaceVertexValueRef(e,t){const a=this.__geom.getFaceVertexIndex(e,t);return a in this.__splits&&e in this.__splits[a]?this.__splitValues[this.__splits[a][e]]:this.getValueRef(a)}setFaceVertexValue(e,t,a){const i=this.__geom.getFaceVertexIndex(e,t);this.setFaceVertexValue_ByVertexIndex(e,i,a);}setFaceVertexValue_ByVertexIndex(e,t,a){const i=this.getValueRef(t);if(i.isValid())if(i.approxEqual(a));else {if(t in this.__splits){const i=this.__splits[t];for(const t in i){const s=i[t];if(this.__splitValues[s].approxEqual(a))return void(i[e]=s)}if(e in this.__splits[t]){return void this.__splitValues[this.__splits[t][e]].setFromOther(a)}}else this.__splits[t]={};this.__splits[t][e]=this.__splitValues.length,this.__splitValues.push(a);}else i.setFromOther(a);}setSplitVertexValue(e,t,a){if(e in this.__splits||(this.__splits[e]={}),t in this.__splits[e]){if(this.__splitValues[this.__splits[e][t]].approxEqual(a))return;console.warn("Face Vertex Already Split with different value");}this.__splits[e][t]=this.__splitValues.length,this.__splitValues.push(a);}setSplitVertexValues(e,t,a){e in this.__splits||(this.__splits[e]={});const i=this.__splitValues.length;this.__splitValues.push(a);for(const a of t)this.__splits[e][a]=i;}getSplits(){return this.__splits}getSplitCount(){let e=0;for(const t in this.__splits)e+=Object.keys(this.__splits[t]).length;return e}generateSplitValues(e,t){if(0==t)return this.__data;const a=this.length,i=this.length+t,s=this.__dataType.numElements?this.__dataType.numElements():1,n=new Float32Array(i*s);for(let e=0;e<this.__data.length;e++)n[e]=this.__data[e];for(const t in e){const i=e[t];for(const e in i){const l=a+i[e];if(t in this.__splits&&e in this.__splits[t]){const a=this.__splits[t][e];6==this.__dataType?n[l*s]=this.__splitValues[a]:this.__dataType.createFromFloat32Buffer(n.buffer,l*s).setFromOther(this.__splitValues[a]);}else {const e=parseInt(t);for(let t=0;t<s;t++)e*s+t>this.__data.length&&console.log("Error remapping src:"+e*s+t),l*s+t>n.length&&console.log("Error remapping tgt:"+l*s+t),n[l*s+t]=this.__data[e*s+t];}}}return n}toJSON(e,t){const a=super.toJSON(e,t);return a.splits=this.__splits,a.splitValues=this.__splitValues,a}fromJSON(e,t,a){super.fromJSON(e,t,a),this.__splits=e.splits,this.__splitValues=[];for(const t of e.splitValues)this.__splitValues.push(this.__dataType.createFromJSON(t));}loadSplitValues(e){const t=e.loadUInt32Array();if(0==t.length)return;let a=0,i=0;for(;;){const e=t[a++],s=t[a++],n={};for(let e=0;e<s;e++){const e=t[a++],s=t[a++];n[e]=s,s>=i&&(i=s+1);}if(this.__splits[e]=n,a>=t.length)break}const s=this.__numFloat32Elements,n=e.loadFloat32Array(i*s);this.__splitValues=[];for(let e=0;e<i;e++){const t=this.__dataType.createFromFloat32Array(n.slice(e*s,e*s+s));this.__splitValues.push(t);}}}class vt extends Wt{constructor(){super();}loadBin(e){this.name=e.loadStr();const t=e.loadUInt32();this.__boundingBox.set(e.loadFloat32Vec3(),e.loadFloat32Vec3()),this.setNumVertices(t);const a=this.vertices;if(t<256){const i=this.__boundingBox.toMat4(),s=e.loadUInt8Array(3*t);for(let e=0;e<t;e++){const t=new Vec3(s[3*e+0]/255,s[3*e+1]/255,s[3*e+2]/255);a.setValue(e,i.transformVec3(t));}}else {const i=e.loadUInt32(),s=[];for(let t=0;t<i;t++){const t=e.loadUInt32Vec2(),a=e.loadFloat32Vec3(),i=e.loadFloat32Vec3();s.push({range:t,bbox:new Box3(a,i)});}const n=e.loadUInt8Array(3*t);for(let e=0;e<i;e++){const t=s[e].bbox.toMat4();for(let i=s[e].range.x;i<s[e].range.y;i++){const e=new Vec3(n[3*i+0]/255,n[3*i+1]/255,n[3*i+2]/255);a.setValue(i,t.transformVec3(e));}}}}readBinary(e,t){super.loadBaseGeomBinary(e),this.geomDataChanged.emit();}}class Mt extends Wt{constructor(){super(),this.__indices=new Uint32Array,this.__segmentAttributes=new Map,this.lineThickness=0;}getIndices(){return this.__indices}getNumSegments(){return this.__indices.length/2}setNumSegments(e){const t=new Uint32Array(2*e);this.__indices=t;}setSegment(e,t,a){if(e>=this.__indices.length/2)throw new Error("Invalid line index:"+e+". Num Segments:"+this.__indices.length/2);this.__indices[2*e+0]=t,this.__indices[2*e+1]=a;}getSegmentVertexIndex(e,t){if(e<this.numLines)return this.__indices[2*e+t]}addSegmentAttribute(e,t,a){const i=new Attribute(t,null!=a?a:this.polygonCount);return this.__segmentAttributes.set(e,i),i}hasSegmentAttribute(e){return this.__segmentAttributes.has(e)}getSegmentAttribute(e){return this.__segmentAttributes.get(e)}genBuffers(){const e=super.genBuffers();let t;return e.numVertices<Math.pow(2,8)?(t=new Uint8Array(this.__indices.length),this.__indices.forEach((e,a)=>{t[a]=e;})):e.numVertices<Math.pow(2,16)?(t=new Uint16Array(this.__indices.length),this.__indices.forEach((e,a)=>{t[a]=e;})):t=this.__indices,e.indices=t,e}readBinary(e,t){super.loadBaseGeomBinary(e),this.setNumSegments(e.loadUInt32());const a=e.loadUInt8();1==a?this.__indices=e.loadUInt8Array():2==a?this.__indices=e.loadUInt16Array():4==a&&(this.__indices=e.loadUInt32Array()),this.geomDataChanged.emit();}toJSON(e,t){const a=super.toJSON(e,t);return 1024&t||(a.indices=Array.from(this.__indices)),a}fromJSON(e,t,a){super.fromJSON(e,t,a),this.__indices=Uint32Array.from(e.indices);}}class Ft extends Wt{constructor(){super(),this.init();}init(){this.__faceCounts=[],this.__faceVertexCounts=new Uint8Array,this.__faceOffsets=new Uint32Array,this.__faceVertexIndices=new Uint32Array,this.__numPopulatedFaceVertexIndices=0,this.__faceAttributes=new Map,this.__edgeAttributes=new Map,this.__logTopologyWarnings=!1,this.edgeVerts=void 0,this.vertexEdges=void 0,this.numEdges=0,this.edgeFlags=new Uint32Array,this.edgeAngles=new Float32Array;}getFaceVertexIndices(){return this.__faceVertexIndices}getFaceCounts(){return this.__faceCounts}clear(){this.__faceVertexIndices=void 0,this.__faceCounts=[],this.__numPopulatedFaceVertexIndices=0;}setFaceCounts(e){if(this.__numPopulatedFaceVertexIndices)throw new Error("Cannot set face counts on a mesh that is already populated. Please call 'clear' before re-building the mesh.");this.__faceCounts=e;let t=0,a=0,i=3;for(const e of this.__faceCounts)t+=e,a+=e*i,i++;this.__faceVertexCounts=new Uint8Array(t),this.__faceOffsets=new Uint32Array(t),this.__faceVertexIndices=new Uint32Array(a);for(const e of this.__faceAttributes)e.resize(t);}setFaceVertexIndices(e){const t=Array.prototype.slice.call(arguments,1),a=this.__numPopulatedFaceVertexIndices;for(let e=0;e<t.length;e++)this.__faceVertexIndices[a+e]=t[e];this.__faceVertexCounts[e]=t.length-3,this.__faceOffsets[e]=a,this.__numPopulatedFaceVertexIndices+=t.length;}getFaceVertexIndices(e){const t=[],a=this.__faceOffsets[e],i=this.__faceVertexCounts[e]+3;for(let e=0;e<i;e++)t.push(this.__faceVertexIndices[a+e]);return t}getFaceVertexIndex(e,t){const a=this.__faceOffsets[e];return this.__faceVertexIndices[a+t]}getNumFaces(){return this.__faceVertexCounts.length}addVertexAttribute(e,t,a){const i=new Lt(this,t,null!=this.vertices?this.vertices.length:0,a);return this.__vertexAttributes.set(e,i),i}addFaceAttribute(e,t,a){const i=new St(t,null!=a?a:this.getNumFaces());return this.__faceAttributes.set(e,i),i}hasFaceAttribute(e){return this.__faceAttributes.has(e)}getFaceAttribute(e){return this.__faceAttributes.get(e)}addEdgeAttribute(e,t,a){const i=new St(t,null!=a?a:this.getNumEdges());return this.__edgeAttributes.set(e,i),i}hasEdgeAttribute(e){return this.__edgeAttributes.has(e)}getEdgeAttribute(e){return this.__edgeAttributes.get(e)}genTopologyInfo(){const e={};this.vertexEdges=[],this.edgeFaces=[],this.edgeVerts=[],this.faceEdges=[],this.numEdges=0;const t=(t,a)=>{let i=t,s=a;if(s<i){const e=i;i=s,s=e;}const n=i+">"+s;if(n in e)return e[n];const l=this.vertices.getValueRef(i),r=this.vertices.getValueRef(s).subtract(l),o={edgeIndex:this.edgeFaces.length/2,edgeVec:r};return e[n]=o,this.edgeFaces.push(-1),this.edgeFaces.push(-1),this.edgeVerts.push(i),this.edgeVerts.push(s),this.numEdges++,o},a=(e,a,i)=>{const s=t(e,a).edgeIndex;if(a<e){const e=2*s+0;this.__logTopologyWarnings&&-1!=this.edgeFaces[e]&&console.warn("Edge poly 0 already set. Mesh is non-manifold."),this.edgeFaces[e]=i;}else {const e=2*s+1;this.__logTopologyWarnings&&-1!=this.edgeFaces[e]&&console.warn("Edge poly 1 already set. Mesh is non-manifold."),this.edgeFaces[e]=i;}i in this.faceEdges||(this.faceEdges[i]=[]),this.faceEdges[i].push(s),null==this.vertexEdges[e]&&(this.vertexEdges[e]=new Set),null==this.vertexEdges[a]&&(this.vertexEdges[a]=new Set),this.vertexEdges[e].add(s),this.vertexEdges[a].add(s);},i=this.getNumFaces();for(let e=0;e<i;e++){const t=this.getFaceVertexIndices(e);for(let i=0;i<t.length;i++){a(t[i],t[(i+1)%t.length],e);}}}computeFaceNormals(){const e=this.vertices,t=this.addFaceAttribute("normals",d),a=this.getNumFaces();for(let i=0;i<a;i++){const a=this.getFaceVertexIndices(i),s=e.getValueRef(a[0]);let n=e.getValueRef(a[1]);const l=new d;for(let t=2;t<a.length;t++){const i=e.getValueRef(a[t]),r=n.subtract(s),o=i.subtract(s);l.addInPlace(r.cross(o).normalize()),n=i;}l.lengthSquared(),t.setValue(i,l.normalize());}}generateEdgeFlags(){null==this.vertexEdges&&this.genTopologyInfo(),this.hasFaceAttribute("normals")||this.computeFaceNormals();const e=this.vertices,t=this.getFaceAttribute("normals");this.edgeVecs=[],this.edgeAngles=new Float32Array(this.numEdges);for(let a=0;a<this.edgeFaces.length;a+=2){const i=this.edgeVerts[a],s=this.edgeVerts[a+1],n=e.getValueRef(s).subtract(e.getValueRef(i));n.normalizeInPlace(),this.edgeVecs.push(n);const l=this.edgeFaces[a],r=this.edgeFaces[a+1];if(-1==l||-1==r){this.edgeAngles[a/2]=2*Math.PI;continue}const o=t.getValueRef(l),d=t.getValueRef(r);this.edgeAngles[a/2]=o.angleTo(d);}}computeVertexNormals(e=1){this.generateEdgeFlags();const t=this.getFaceAttribute("normals"),a=this.addVertexAttribute("normals",d),i=t.data.buffer,s=e=>new d(i,12*e),n=a.data,l=(e,t)=>{n[3*e+0]=t.x,n[3*e+1]=t.y,n[3*e+2]=t.z;},r=(e,t)=>{let a,i;const s=this.faceEdges[e];for(const e of s)(this.edgeVerts[2*e]==t||this.edgeVerts[2*e+1]==t)&&(a?i=this.edgeVecs[e]:a=this.edgeVecs[e]);return [a,i]};for(let t=0;t<this.vertexEdges.length;t++){if(null==this.vertexEdges[t])continue;const i=this.vertexEdges[t],n=[],o=e=>{let t=!1;for(const a of n)if(t=-1!=a.indexOf(e),t)break;t||n.push([e]);};for(const t of i){const a=this.edgeFaces[2*t],i=this.edgeFaces[2*t+1];if(-1!=a&&-1==i&&this.edgeAngles[t]<e){let e=-1,t=-1;for(let s=0;s<n.length;s++)-1==e&&-1!=n[s].indexOf(a)&&(e=s),-1==t&&-1!=n[s].indexOf(i)&&(t=s);-1==e&&-1==t?n.push([a,i]):-1!=e&&-1!=t?e!=t&&(n[e]=n[e].concat(n[t]),n.splice(t,1)):(-1==e&&n[t].push(a),-1==t&&n[e].push(i));}else -1!=a&&o(a),-1!=i&&o(i);}n.sort((e,t)=>e.length<t.length?1:e.length>t.length?-1:0);let h=!0;for(const e of n){const i=new d;for(const a of e){const e=r(a,t),n=e[0].angleTo(e[1]);i.addInPlace(s(a).scale(n));}i.normalizeInPlace(),h?(l(t,i),h=!1):a.setSplitVertexValues(t,e,i);}}return a}computeNumTriangles(){let e=3,t=0;for(const a of this.__faceCounts)t+=a*(e-2),e++;return t}generateTriangulatedIndices(e,t,a){const i=this.computeNumTriangles();let s;s=e<Math.pow(2,8)?new Uint8Array(3*i):e<Math.pow(2,16)?new Uint16Array(3*i):new Uint32Array(3*i);let n=0;const l=function(e,i){e in a&&i in a[e]&&(e=t+a[e][i]),s[n]=e,n++;},r=this.getNumFaces();for(let e=0;e<r;e++){const t=this.getFaceVertexIndices(e);for(let a=0;a<t.length;a++)a>=3&&(l(t[0],e),l(t[a-1],e)),l(t[a],e);}return s}computeHardEdgesIndices(e=1){const t=[],a=e=>{t.push(this.edgeVerts[e]),t.push(this.edgeVerts[e+1]);};for(let t=0;t<this.edgeFlags.length;t+=2)this.edgeAngles[t/2]>e&&a(t);return t}getWireframeIndices(){return indices}genBuffers(e){const t={};let a=0;for(const[,e]of this.__vertexAttributes){const i=e.getSplits();for(const e in i){e in t||(t[e]={});const s=i[e];for(const i in s){const s=parseInt(i);s in t[e]||(t[e][s]=a,a++);}}}const i=this.vertices.length,s=i+a;let n;e&&0==e.includeIndices||(n=this.generateTriangulatedIndices(s,i,t));const l={};for(const[e,i]of this.__vertexAttributes){let s;s=0==a?i.data:i.generateSplitValues(t,a);const n=i.numElements,r=s.length/n;l[e]={values:s,count:r,dimension:n,normalized:"normals"==e,dataType:i.dataType};}const r={numVertices:this.numVertices(),numRenderVerts:s,indices:n,attrBuffers:l};if(e&&e.includeVertexNeighbors){null==this.vertexEdges&&this.genTopologyInfo();let e=0;for(let t=0;t<this.vertexEdges.length;t++)this.vertexEdges[t]&&(e+=this.vertexEdges[t].size);const t=new Uint32Array(2*this.vertexEdges.length+e),a=e=>{for(let t=0;t<e.length;t++){const a=e[t];for(let i=0;i<t;i++){const s=e[i];if(-1!=a[0]&&a[0]==s[1]){t!=i+1&&(e.splice(t,1),e.splice(i+1,0,a));break}if(-1!=a[1]&&a[1]==s[0]){e.splice(t,1),e.splice(i,0,a);break}}}},i=e=>{if(!(-1!=e[0][0]&&-1!=e[e.length-1][1]||-1==e[0][0]&&-1==e[e.length-1][1]))throw new Error("If fan starts with -1, it must also end with -1");for(let t=0;t<e.length;t++){const a=e[t];if((-1==a[0]||-1==a[1])&&0!=t&&t!=e.length-1)throw new Error("-1 only allowed at the beginning and end of a fan.");if(-1!=a[0]){let i=t-1;if(i<0&&(i+=e.length),a[0]!=e[i][1])throw new Error("Faces are not sequential")}if(-1!=a[1]){const i=(t+1)%e.length;if(a[1]!=e[i][0])throw new Error("Faces are not sequential")}}};let s=2*this.vertexEdges.length;for(let e=0;e<this.vertexEdges.length;e++){if(null==this.vertexEdges[e])continue;const n=this.vertexEdges[e],l=[];for(const t of n){const a=this.edgeVerts[2*t],i=this.edgeVerts[2*t+1];let s,n=this.edgeFaces[2*t],r=this.edgeFaces[2*t+1];if(a==e)s=i;else {if(i!=e)throw new Error("Invalid topology");{s=a;const e=n;n=r,r=e;}}l.push([n,r,s]);}a(l),i(l);let r=0;(-1!=l[0][0]||-1!=l[l.length-1][1])&&(r+=1),t[2*e]=s,t[2*e+1]=n.size+(r<<8);for(const e of l)t[s]=e[2],s++;}r.vertexNeighbors=t;}return r}freeBuffers(){super.freeBuffers(),this.init();}readBinary(e,t){super.loadBaseGeomBinary(e),this.setFaceCounts(e.loadUInt32Array()),this.__faceVertexCounts=e.loadUInt8Array(this.__faceVertexCounts.length);const a=e.loadSInt32Vec2(),i=e.loadUInt8();let s;1==i?s=e.loadUInt8Array():2==i?s=e.loadUInt16Array():4==i&&(s=e.loadUInt32Array());const n=this.getNumFaces();let l=0,r=0;for(let e=0;e<n;e++){const t=this.__faceVertexCounts[e]+3;this.__faceOffsets[e]=l;for(let i=0;i<t;i++){const t=l+i,n=s[t]+a.x;if(0==e)this.__faceVertexIndices[t]=n;else {let a=this.__faceOffsets[e-1];a+=i<r?i:r-1,this.__faceVertexIndices[t]=this.__faceVertexIndices[a]+n;}}l+=t,r=t;}this.__numPopulatedFaceVertexIndices=l;const d=e.loadUInt32();if(d>0){const t=this.vertices,a=this.addVertexAttribute("lightmapCoords",o);for(let i=0;i<d;i++){const i=new X(e.loadFloat32Vec3(),e.loadFloat32Quat()),s=e.loadFloat32(),n=e.loadFloat32Vec2(),l=e.loadSInt32Vec2(),r=e.loadUInt8();let d;d=1==r?e.loadUInt8Array():2==r?e.loadUInt16Array():e.loadUInt32Array();let h=0;for(const e of d){let r=e+l.x;r+=h,h=r;const d=this.getFaceVertexIndices(r);for(const e of d){const l=t.getValueRef(e),d=i.transformVec3(l),h=new o(d.x,d.z);h.scaleInPlace(s),h.addInPlace(n),a.setFaceVertexValue_ByVertexIndex(r,e,h);}}}}this.hasVertexAttribute("normals")||this.computeVertexNormals(),this.geomDataChanged.emit();}toJSON(e,t){const a=super.toJSON(e,t);return 1024&t||(a.faceCounts=Array.from(this.__faceCounts),a.faceVertexIndices=Array.from(this.__faceVertexIndices)),a}fromJSON(e,t,a){super.fromJSON(e,t,a),e.faceCounts&&(this.__faceCounts=Uint32Array.from(e.faceCounts)),e.faceVertexIndices&&(this.__faceVertexIndices=Uint32Array.from(e.faceVertexIndices));}}class Tt extends T{constructor(e){if(super(),this.name=e.name,this.__buffers=e.geomBuffers,this.__buffers.attrBuffers)for(const e in this.__buffers.attrBuffers){const t=this.__buffers.attrBuffers[e],a=r.getType(t.dataType);t.dataType=a;}this.boundingBox=new V,this.boundingBox.p0.__data=e.bbox.p0.__data,this.boundingBox.p1.__data=e.bbox.p1.__data,this.__metaData=new Map,this.boundingBoxDirtied=new S,this.geomDataChanged=new S,this.geomDataTopologyChanged=new S;}genBuffers(){return this.__buffers}freeBuffers(){if(this.__buffers.indices&&(delete this.__buffers.indices),this.__buffers.attrBuffers){for(const a in this.__buffers.attrBuffers){delete this.__buffers.attrBuffers[a];}delete this.__buffers.attrBuffers;}}getMetadata(e){return this.__metaData.get(e)}hasMetadata(e){return this.__metaData.has(e)}setMetadata(e,t){this.__metaData.set(e,t);}}class Ct extends Tt{constructor(e){super(e);}}class Yt extends Tt{constructor(e){super(e);}}class Nt extends Tt{constructor(e){super(e);}}class Kt extends vt{constructor(e=1,t=1,a=1,i=1,s=!1){if(super(),isNaN(e)||isNaN(t)||isNaN(a)||isNaN(i))throw new Error("Invalid geom args");this.__x=e,this.__y=t,this.__xDivisions=a,this.__yDivisions=i,s&&this.addVertexAttribute("texCoords",o),this.__rebuild();}get x(){return console.warn("getter is deprectated. Please use 'getX'"),this.getX()}set x(e){console.warn("getter is deprectated. Please use 'setX'"),this.setX(e);}get y(){return console.warn("getter is deprectated. Please use 'getY'"),this.getY()}set y(e){console.warn("getter is deprectated. Please use 'setY'"),this.setY(e);}getX(){return this.__x}setX(e){this.__x=e,this.__resize();}getY(){return this.__y}setY(e){this.__y=e,this.__resize();}setSize(e,t){this.__x=e,this.__y=t,this.__resize();}__rebuild(){this.setNumVertices(this.__xDivisions*this.__yDivisions);const e=this.getVertexAttribute("texCoords");if(e)for(let t=0;t<this.__yDivisions;t++){const a=t/(this.__yDivisions-1);for(let i=0;i<this.__xDivisions;i++){const s=i/(this.__xDivisions-1);e.getValueRef(t*this.__xDivisions+i).set(s,a);}}this.__resize();}__resize(){for(let e=0;e<this.__yDivisions;e++){const t=(e/(this.__yDivisions-1)-.5)*this.__y;for(let a=0;a<this.__xDivisions;a++){const i=(a/(this.__xDivisions-1)-.5)*this.__x;this.getVertex(e*this.__xDivisions+a).set(i,t,0);}}this.setBoundingBoxDirty();}toJSON(){const e=super.toJSON();return e.x=this.__x,e.y=this.__y,e.xDivisions=this.__xDivisions,e.yDivisions=this.__yDivisions,e}}class wt extends Mt{constructor(e=1,t=1){if(super(),isNaN(e)||isNaN(t))throw new Error("Invalid geom args");this.__x=this.addParameter(new ue("x",e)),this.__x.valueChanged.connect(this.__resize.bind(this)),this.__y=this.addParameter(new ue("y",t)),this.__y.valueChanged.connect(this.__resize.bind(this)),this.__rebuild();}get x(){return this.__x.getValue()}set x(e){this.__x.setValue(e);}get y(){return this.__y.getValue()}set y(e){this.__y.setValue(e);}setSize(e,t){this.__x.setValue(e,-1),this.__y.setValue(t,-1),this.__resize();}__rebuild(){this.setNumVertices(4),this.setNumSegments(4),this.setSegment(0,0,1),this.setSegment(1,1,2),this.setSegment(2,2,3),this.setSegment(3,3,0),this.__resize(-1),this.geomDataTopologyChanged.emit();}__resize(e){const t=this.__x.getValue(),a=this.__y.getValue();this.getVertex(0).set(-.5*t,-.5*a,0),this.getVertex(1).set(.5*t,-.5*a,0),this.getVertex(2).set(.5*t,.5*a,0),this.getVertex(3).set(-.5*t,.5*a,0),this.setBoundingBoxDirty(),-1!=e&&this.geomDataChanged.emit();}toJSON(){const e=super.toJSON();return e.x=this.__x,e.y=this.__y,e}}C.registerClass("Rect",wt);class zt extends Mt{constructor(e=1,t=2*Math.PI,a=32){if(super(),isNaN(e)||isNaN(a))throw new Error("Invalid geom args");this.__radius=this.addParameter(new ue("Radius",e)),this.__angle=this.addParameter(new ue("Angle",t)),this.__numSegments=this.addParameter(new ue("NumSegments",a>=3?a:3,[3,200],1)),this.__radius.valueChanged.connect(this.__resize.bind(this)),this.__angle.valueChanged.connect(this.__rebuild.bind(this)),this.__numSegments.valueChanged.connect(this.__rebuild.bind(this)),this.__rebuild();}__rebuild(){const e=this.__numSegments.getValue();this.setNumVertices(e);const t=this.__angle.getValue()<2*Math.PI;t?this.setNumSegments(e-1):this.setNumSegments(e);for(let a=0;a<(t?e-1:e);a++)this.setSegment(a,a,(a+1)%e);this.__resize(-1),this.geomDataTopologyChanged.emit();}__resize(e){const t=this.__radius.getValue(),a=this.__numSegments.getValue(),i=this.__angle.getValue()/a;for(let e=0;e<a;e++)this.getVertex(e).set(Math.cos(i*e)*t,Math.sin(i*e)*t,0);this.setBoundingBoxDirty(),-1!=e&&this.geomDataChanged.emit();}}C.registerClass("Circle",zt);class Ut extends Mt{constructor(e=1){if(super(),isNaN(e))throw new Error("Invalid geom args");this.__sizeParam=this.addParameter(new ue("size",e)),this.__rebuild();this.__sizeParam.valueChanged.connect(()=>{this.__resize();});}get size(){return this.__size}set size(e){this.__size=e,this.__resize();}__rebuild(){this.setNumVertices(6),this.setNumSegments(3),this.setSegment(0,0,1),this.setSegment(1,2,3),this.setSegment(2,4,5),this.__resize();}__resize(){const e=this.__sizeParam.getValue();this.getVertex(0).set(-.5*e,0,0),this.getVertex(1).set(.5*e,0,0),this.getVertex(2).set(0,.5*e,0),this.getVertex(3).set(0,-.5*e,0),this.getVertex(4).set(0,0,.5*e),this.getVertex(5).set(0,0,-.5*e),this.setBoundingBoxDirty();}}C.registerClass("Cross",Ut);class Jt extends Mt{constructor(e=1,t=1,a=1,i=!1){super(),this.__x=this.addParameter(new ue("x",e)),this.__x.valueChanged.connect(this.__resize.bind(this)),this.__y=this.addParameter(new ue("y",t)),this.__y.valueChanged.connect(this.__resize.bind(this)),this.__z=this.addParameter(new ue("z",a)),this.__z.valueChanged.connect(this.__resize.bind(this)),this.__baseZAtZero=this.addParameter(new ue("BaseZAtZero",i)),this.__baseZAtZero.valueChanged.connect(this.__rebuild.bind(this)),this.__rebuild();}__rebuild(){this.setNumVertices(8),this.setNumSegments(12),this.setSegment(0,0,1),this.setSegment(1,1,2),this.setSegment(2,2,3),this.setSegment(3,3,0),this.setSegment(4,4,5),this.setSegment(5,5,6),this.setSegment(6,6,7),this.setSegment(7,7,4),this.setSegment(8,0,4),this.setSegment(9,1,5),this.setSegment(10,2,6),this.setSegment(11,3,7),this.__resize(-1),this.geomDataTopologyChanged.emit();}__resize(e){const t=this.__x.getValue(),a=this.__y.getValue(),i=this.__z.getValue(),s=this.__baseZAtZero.getValue();let n=.5;s&&(n=1),this.getVertex(0).set(.5*t,-.5*a,n*i),this.getVertex(1).set(.5*t,.5*a,n*i),this.getVertex(2).set(-.5*t,.5*a,n*i),this.getVertex(3).set(-.5*t,-.5*a,n*i),n=-.5,s&&(n=0),this.getVertex(4).set(.5*t,-.5*a,n*i),this.getVertex(5).set(.5*t,.5*a,n*i),this.getVertex(6).set(-.5*t,.5*a,n*i),this.getVertex(7).set(-.5*t,-.5*a,n*i),this.setBoundingBoxDirty(),-1!=e&&this.geomDataChanged.emit();}toJSON(){const e=super.toJSON();return e.size=this.__size,e}}C.registerClass("LinesCuboid",Jt);class Pt extends Mt{constructor(e=1,t=1,a=10,i=10,s=!1){if(super(),isNaN(e)||isNaN(t)||isNaN(a)||isNaN(i))throw new Error("Invalid geom args");this.__xParam=this.addParameter(new ue("x",e)),this.__yParam=this.addParameter(new ue("y",t)),this.__xDivisionsParam=this.addParameter(new ue("xDivisions",a)),this.__yDivisionsParam=this.addParameter(new ue("yDivisions",i)),this.__skipCenterLinesParam=this.addParameter(new pe("skipCenterLines",s)),this.__rebuild();}get sizeX(){return this.__x}set sizeX(e){this.__x=e,this.__resize();}get sizeY(){return this.__y}set sizeY(e){this.__y=e,this.__resize();}get divisionsX(){return this.__xDivisions}set divisionsX(e){this.__xDivisions=e,this.__rebuild();}get divisionsY(){return this.__yDivisions}set divisionsY(e){this.__yDivisions=e,this.__rebuild();}setSize(e,t){this.__x=e,this.__y=t,this.__resize();}__rebuild(){const e=this.__xDivisionsParam.getValue(),t=this.__yDivisionsParam.getValue(),a=this.__skipCenterLinesParam.getValue()&&e%2==0&&t%2==0;this.setNumVertices(2*(e+t+2-(a?1:0))),this.setNumSegments(e+t+2-(a?1:0));let i=0;for(let t=0;t<=e;t++){if(a&&t==e/2)continue;const s=2*i,n=2*i+1;this.setSegment(i,s,n),i++;}for(let s=0;s<=t;s++){if(a&&s==e/2)continue;const t=2*i,n=2*i+1;this.setSegment(i,t,n),i++;}this.__resize();}__resize(){const e=this.__xDivisionsParam.getValue(),t=this.__yDivisionsParam.getValue(),a=this.__xParam.getValue(),i=this.__yParam.getValue(),s=this.__skipCenterLinesParam.getValue()&&e%2==0&&t%2==0;let n=0;for(let t=0;t<=e;t++){if(s&&t==e/2)continue;const l=2*n,r=2*n+1,o=(t/e-.5)*a;this.getVertex(l).set(o,-.5*i,0),this.getVertex(r).set(o,.5*i,0),n++;}for(let l=0;l<=t;l++){if(s&&l==e/2)continue;const r=2*n,o=2*n+1,d=(l/t-.5)*i;this.getVertex(r).set(-.5*a,d,0),this.getVertex(o).set(.5*a,d,0),n++;}this.setBoundingBoxDirty();}toJSON(){const e=super.toJSON();return e.x=this.__x,e.z=this.__y,e.xDivisions=this.__xDivisions,e.yDivisions=this.__yDivisions,e}}C.registerClass("Grid",Pt);class Et extends Ft{constructor(e=.5,t=1,a=32,i=!0){if(super(),isNaN(e)||isNaN(t)||isNaN(a))throw new Error("Invalid geom args");this.__radiusParam=this.addParameter(new ue("radius",e)),this.__heightParam=this.addParameter(new ue("height",t)),this.__detailParam=this.addParameter(new ue("detail",a>=3?a:3,[3,200],1)),this.__capParam=this.addParameter(new pe("cap",i)),this.addVertexAttribute("texCoords",o),this.addVertexAttribute("normals",d),this.__rebuild();const s=()=>{this.__resize();},n=()=>{this.__rebuild();};this.__radiusParam.valueChanged.connect(s),this.__heightParam.valueChanged.connect(s),this.__detailParam.valueChanged.connect(n),this.__capParam.valueChanged.connect(n);}get radius(){return this.__radiusParam.getValue()}set radius(e){this.__radiusParam.setValue(e),this.__resize();}get height(){return this.__heightParam.getValue()}set height(e){this.__heightParam.setValue(e),this.__resize();}get detail(){return this.__detailParam.getValue()}set detail(e){this.__detailParam.setValue(e),this.__rebuild();}get cap(){return this.__capParam.getValue()}set cap(e){this.__capParam.setValue(e),this.__rebuild();}__rebuild(){this.clear();const e=this.__detailParam.getValue(),t=this.__radiusParam.getValue(),a=this.__heightParam.getValue(),i=this.__capParam.getValue();let s=e+1;i&&(s+=1),this.setNumVertices(s);const n=e,l=e+1;this.getVertex(n).set(0,0,a);for(let a=0;a<e;a++){const i=a/e*2*Math.PI;this.getVertex(a).set(t*Math.cos(i),t*Math.sin(i),0);}i&&this.getVertex(l).set(0,0,0),this.setFaceCounts([e+(i?e:0)]);for(let t=0;t<e;t++){const a=(t+1)%e;this.setFaceVertexIndices(t,a,t,n);}if(i)for(let t=0;t<e;t++){const a=(t+1)%e;this.setFaceVertexIndices(e+t,t,a,l);}const r=this.getVertexAttribute("normals");let h;const c=a;Math.abs(a)<1e-12&&(h=a<0?-1e-12:1e-12),h=t/c;let m=0;for(let t=0;t<e;t++){const a=(t+1)/e*2*Math.PI,i=t/e*2*Math.PI,s=.5*(a+i);r.setFaceVertexValue(m,0,new d(Math.cos(a),h,Math.sin(a)).normalize()),r.setFaceVertexValue(m,1,new d(Math.cos(i),h,Math.sin(i)).normalize()),r.setFaceVertexValue(m,2,new d(Math.cos(s),h,Math.sin(s)).normalize()),m++;}if(i){const t=new d(0,-1,0);for(let a=0;a<e;a++)r.setFaceVertexValue(m,0,t),r.setFaceVertexValue(m,1,t),r.setFaceVertexValue(m,2,t),m++;}const u=this.getVertexAttribute("texCoords");m=0;for(let t=0;t<e;t++)u.setFaceVertexValue(m,0,new o((t+1)/e,0)),u.setFaceVertexValue(m,1,new o(t/e,0)),u.setFaceVertexValue(m,2,new o((t+.5)/e,1));if(i)for(let t=0;t<e;t++)u.setFaceVertexValue(m,0,new o(t/e,0)),u.setFaceVertexValue(m,1,new o((t+1)/e,0)),u.setFaceVertexValue(m,2,new o((t+.5)/e,1)),m++;this.setBoundingBoxDirty();}__resize(){const e=this.__detailParam.getValue(),t=this.__radiusParam.getValue(),a=this.__heightParam.getValue(),i=(this.__capParam.getValue(),e),s=e+1;this.getVertex(i).set(0,0,a);for(let a=0;a<e;a++){const i=a/e*2*Math.PI;this.getVertex(a).set(t*Math.cos(i),t*Math.sin(i),0);}this.__cap&&this.getVertex(s).set(0,0,0),this.setBoundingBoxDirty();}}C.registerClass("Cone",Et);class Ht extends Ft{constructor(e=1,t=1,a=1,i=!1){if(super(),isNaN(e)||isNaN(t)||isNaN(a))throw new Error("Invalid geom args");this.__xParam=this.addParameter(new ue("x",e)),this.__yParam=this.addParameter(new ue("y",t)),this.__zParam=this.addParameter(new ue("z",a)),this.__baseZAtZeroParam=this.addParameter(new pe("baseZAtZero",i)),this.setFaceCounts([0,6]),this.setFaceVertexIndices(0,0,1,2,3),this.setFaceVertexIndices(1,7,6,5,4),this.setFaceVertexIndices(2,1,0,4,5),this.setFaceVertexIndices(3,3,2,6,7),this.setFaceVertexIndices(4,0,3,7,4),this.setFaceVertexIndices(5,2,1,5,6),this.setNumVertices(8),this.addVertexAttribute("texCoords",o),this.addVertexAttribute("normals",d),this.__rebuild();const s=()=>{this.__resize();};this.__xParam.valueChanged.connect(s),this.__yParam.valueChanged.connect(s),this.__zParam.valueChanged.connect(s),this.__baseZAtZeroParam.valueChanged.connect(s);}setSize(e,t,a){this.__xParam.setValue(e),this.__yParam.setValue(t),this.__zParam.setValue(a);}setBaseSize(e,t){this.__xParam.setValue(e),this.__yParam.setValue(t);}__rebuild(){const e=this.getVertexAttribute("normals");for(let t=0;t<6;t++){let a;switch(t){case 0:a=new d(0,0,1);break;case 1:a=new d(0,0,-1);break;case 2:a=new d(1,0,0);break;case 3:a=new d(-1,0,0);break;case 4:a=new d(0,1,0);break;case 5:a=new d(0,-1,0);}e.setFaceVertexValue(t,0,a),e.setFaceVertexValue(t,1,a),e.setFaceVertexValue(t,2,a),e.setFaceVertexValue(t,3,a);}const t=this.getVertexAttribute("texCoords");for(let e=0;e<6;e++)t.setFaceVertexValue(e,0,new o(0,0)),t.setFaceVertexValue(e,1,new o(1,0)),t.setFaceVertexValue(e,2,new o(1,1)),t.setFaceVertexValue(e,3,new o(0,1));this.__resize();}__resize(e){const t=this.__xParam.getValue(),a=this.__yParam.getValue(),i=this.__zParam.getValue(),s=this.__baseZAtZeroParam.getValue();let n=.5;s&&(n=1),this.getVertex(0).set(.5*t,-.5*a,n*i),this.getVertex(1).set(.5*t,.5*a,n*i),this.getVertex(2).set(-.5*t,.5*a,n*i),this.getVertex(3).set(-.5*t,-.5*a,n*i),n=-.5,s&&(n=0),this.getVertex(4).set(.5*t,-.5*a,n*i),this.getVertex(5).set(.5*t,.5*a,n*i),this.getVertex(6).set(-.5*t,.5*a,n*i),this.getVertex(7).set(-.5*t,-.5*a,n*i),this.setBoundingBoxDirty(),this.geomDataChanged.emit();}toJSON(){const e=super.toJSON();return e.x=this.__x,e.y=this.__y,e.z=this.__z,e}}C.registerClass("Cuboid",Ht);class kt extends Ft{constructor(e=.5,t=1,a=32,i=2,s=!0,n=!1){if(super(),isNaN(e)||isNaN(t)||isNaN(a)||isNaN(i))throw new Error("Invalid geom args");this.__radiusParam=this.addParameter(new ue("radius",e)),this.__heightParam=this.addParameter(new ue("height",t)),this.__sidesParam=this.addParameter(new ue("sides",a>=3?a:3,[3,200],1)),this.__loopsParam=this.addParameter(new ue("loops",i>=2?i:2,[1,200],1)),this.__capsParam=this.addParameter(new pe("caps",s)),this.__baseZAtZeroParam=this.addParameter(new pe("baseZAtZero",n)),this.addVertexAttribute("texCoords",o),this.addVertexAttribute("normals",d),this.__rebuild();const l=()=>{this.__resize();},r=()=>{this.__rebuild();};this.__radiusParam.valueChanged.connect(l),this.__heightParam.valueChanged.connect(l),this.__sidesParam.valueChanged.connect(r),this.__loopsParam.valueChanged.connect(r),this.__capsParam.valueChanged.connect(r),this.__baseZAtZeroParam.valueChanged.connect(l);}__rebuild(){this.clear();this.__radiusParam.getValue();const e=this.__sidesParam.getValue(),t=this.__loopsParam.getValue(),a=(this.__heightParam.getValue(),this.__capsParam.getValue());this.__baseZAtZeroParam.getValue();let i=e*t;a&&(i+=2),this.setNumVertices(i),a?this.setFaceCounts([2*e,e]):this.setFaceCounts([0,e]);let s=0;for(let a=0;a<t-1;a++)for(let t=0;t<e;t++){const i=e*a+(t+1)%e,n=e*a+t,l=e*(a+1)+t,r=e*(a+1)+(t+1)%e;this.setFaceVertexIndices(s++,i,n,l,r);}if(a){for(let t=0;t<e;t++){const a=i-1,n=t,l=(t+1)%e;this.setFaceVertexIndices(s++,a,n,l);}for(let a=0;a<e;a++){const n=e*(t-1)+a,l=i-2,r=e*(t-1)+(a+1)%e;this.setFaceVertexIndices(s++,n,l,r);}}const n=this.getVertexAttribute("normals");s=0;for(let a=0;a<t-1;a++)for(let t=0;t<e;t++){let a=t/e*2*Math.PI;const i=new d(Math.sin(a),Math.cos(a),0);n.setFaceVertexValue(s,0,i),n.setFaceVertexValue(s,1,i),a=(t+1)/e*2*Math.PI;const l=new d(Math.sin(a),Math.cos(a),0);n.setFaceVertexValue(s,2,l),n.setFaceVertexValue(s,3,l),s++;}if(a){const t=new d(0,0,-1);for(let a=0;a<e;a++)n.setFaceVertexValue(s,0,t),n.setFaceVertexValue(s,1,t),n.setFaceVertexValue(s,2,t),s++;t.set(0,0,1);for(let a=0;a<e;a++)n.setFaceVertexValue(s,0,t),n.setFaceVertexValue(s,1,t),n.setFaceVertexValue(s,2,t),s++;}const l=this.getVertexAttribute("texCoords");s=0;for(let t=0;t<e;t++)l.setFaceVertexValue(s,0,new o((t+1)/e,0)),l.setFaceVertexValue(s,2,new o((t+1)/e,1)),l.setFaceVertexValue(s,1,new o(t/e,0)),l.setFaceVertexValue(s,3,new o(t/e,1)),s++;if(a){for(let t=0;t<e;t++)l.setFaceVertexValue(s,0,new o(t/e,0)),l.setFaceVertexValue(s,1,new o((t+1)/e,0)),l.setFaceVertexValue(s,2,new o((t+.5)/e,1)),s++;for(let t=0;t<e;t++)l.setFaceVertexValue(s,0,new o(t/e,0)),l.setFaceVertexValue(s,1,new o((t+1)/e,0)),l.setFaceVertexValue(s,2,new o((t+.5)/e,1)),s++;}this.geomDataTopologyChanged.emit(),this.__resize();}__resize(){const e=this.__sidesParam.getValue(),t=this.__loopsParam.getValue(),a=this.__radiusParam.getValue(),i=this.__heightParam.getValue(),s=this.__capsParam.getValue(),n=this.__baseZAtZeroParam.getValue();let l=e*t;s&&(l+=2);let r=0,o=.5;n&&(o=0);for(let s=0;s<t;s++){const n=s/(t-1)*i-i*o;for(let t=0;t<e;t++){const i=t/e*2*Math.PI;this.getVertex(r).set(Math.sin(i)*a,Math.cos(i)*a,n),r++;}}s&&(this.getVertex(l-1).set(0,0,i*(n?0:-.5)),this.getVertex(l-2).set(0,0,i*(n?1:.5))),this.setBoundingBoxDirty(),this.geomDataChanged.emit();}}C.registerClass("Cylinder",kt);class Bt extends Ft{constructor(e=.5,t=32){if(super(),isNaN(e)||isNaN(t))throw new Error("Invalid geom args");this.__radiusParam=this.addParameter(new ue("radius",e)),this.__sidesParam=this.addParameter(new ue("sides",t>=3?t:3,[3,200],1)),this.addVertexAttribute("texCoords",o),this.addVertexAttribute("normals",d),this.__rebuild();}get radius(){return this.__radius}set radius(e){this.__radius=e,this.__resize();}set sides(e){this.__sides=e>=3?e:3,this.__rebuild();}__rebuild(){const e=this.__sidesParam.getValue();this.setNumVertices(e+1),this.setFaceCounts([e]),this.getVertex(0).set(0,0,0);for(let t=0;t<e;t++){const a=t%e+1,i=(t+1)%e+1;this.setFaceVertexIndices(t,0,a,i);}const t=this.getVertexAttribute("normals"),a=new d(0,0,1);t.setValue(0,a);for(let i=0;i<e;i++)t.setValue(i+1,a);const i=this.getVertexAttribute("texCoords");i.getValueRef(0).set(.5,.5);for(let t=0;t<e;t++){const a=t/e*2*Math.PI;i.getValueRef(t+1).set(.5*Math.sin(a)+.5,.5*Math.cos(a)+.5);}this.setBoundingBoxDirty(),this.__resize();}__resize(){const e=this.__sidesParam.getValue(),t=this.__radiusParam.getValue();for(let a=0;a<e;a++){const i=a/e*2*Math.PI;this.getVertex(a+1).set(Math.sin(i)*t,Math.cos(i)*t,0);}this.setBoundingBoxDirty();}toJSON(){const e=super.toJSON();return e.radius=this.__radius,e}}C.registerClass("Disc",Bt);class Dt extends Ft{constructor(e=1,t=1,a=1,i=1,s=!0,n=!0){if(super(),isNaN(e)||isNaN(t)||isNaN(a)||isNaN(i))throw new Error("Invalid geom args");this.__sizeXParam=this.addParameter(new ue("SizeX",e)),this.__sizeYParam=this.addParameter(new ue("SizeY",t)),this.__detailXParam=this.addParameter(new ue("DetailX",a)),this.__detailYParam=this.addParameter(new ue("DetailY",i)),s&&this.addVertexAttribute("normals",d),n&&this.addVertexAttribute("texCoords",o),this.__rebuild(),this.__sizeXParam.valueChanged.connect(this.__resize.bind(this)),this.__sizeYParam.valueChanged.connect(this.__resize.bind(this)),this.__detailXParam.valueChanged.connect(this.__rebuild.bind(this)),this.__detailYParam.valueChanged.connect(this.__rebuild.bind(this));}__rebuild(){const e=this.__detailXParam.getValue(),t=this.__detailYParam.getValue();this.setNumVertices((e+1)*(t+1)),this.setFaceCounts([0,e*t]);let a=0;for(let i=0;i<t;i++)for(let t=0;t<e;t++){const s=(e+1)*(i+1)+t,n=(e+1)*(i+1)+(t+1),l=(e+1)*i+(t+1),r=(e+1)*i+t;this.setFaceVertexIndices(a,s,n,l,r),a+=1;}let i=0;const s=this.getVertexAttribute("normals");if(s)for(let a=0;a<=t;a++)for(let t=0;t<=e;t++)s.getValueRef(i).set(0,0,1),i++;i=0;const n=this.getVertexAttribute("texCoords");if(n)for(let a=0;a<=t;a++){const s=a/t;for(let t=0;t<=e;t++){const a=t/e;n.getValueRef(i).set(a,s),i++;}}this.__resize(!1),this.geomDataTopologyChanged.emit();}__resize(e=!0){const t=this.__sizeXParam.getValue(),a=this.__sizeYParam.getValue(),i=this.__detailXParam.getValue(),s=this.__detailYParam.getValue();let n=0;for(let e=0;e<=s;e++){const l=(e/s-.5)*a;for(let e=0;e<=i;e++){const a=(e/i-.5)*t;this.getVertex(n).set(a,l,0),n++;}}this.setBoundingBoxDirty(),e&&this.geomDataChanged.emit();}}class Ot extends Ft{constructor(e=1,t=12,a=12){if(super(),isNaN(e)||isNaN(t)||isNaN(a))throw new Error("Invalid geom args");this.__radiusParam=this.addParameter(new ue("radius",e)),this.__sidesParam=this.addParameter(new ue("sides",t>=3?t:3,[3,200],1)),this.__loopsParam=this.addParameter(new ue("loops",a>=3?a:3,[3,200],1)),this.addVertexAttribute("texCoords",o),this.addVertexAttribute("normals",d),this.__rebuild();const i=()=>{this.__rebuild();};this.__radiusParam.valueChanged.connect(()=>{this.__resize();}),this.__sidesParam.valueChanged.connect(i),this.__loopsParam.valueChanged.connect(i);}__rebuild(){const e=this.__radiusParam.getValue(),t=this.__sidesParam.getValue(),a=this.__loopsParam.getValue(),i=2+t*a,s=2*t,n=t*a;this.setNumVertices(i),this.setFaceCounts([s,n]);const l=this.getVertexAttribute("normals"),r=new d(0,0,1);let h=0;this.getVertex(h).set(0,0,e),l.getValueRef(h).set(0,0,1),h++;for(let i=0;i<a;i++){const s=(i+1)/(a+1)*Math.PI;for(let a=0;a<t;a++){const i=a/t*2*Math.PI;r.set(Math.sin(s)*Math.cos(i),Math.sin(s)*Math.sin(i),Math.cos(s)),this.getVertex(h).setFromOther(r.scale(e)),l.getValueRef(h).setFromOther(r),h++;}}this.getVertex(h).set(0,0,-e),l.getValueRef(h).set(0,0,-1),h++;const c=this.getVertexAttribute("texCoords");let m=0;for(let e=0;e<t;e++){const i=0,s=(e+1)%t+1,n=e+1;this.setFaceVertexIndices(m,i,s,n);const l=new o(.5,0),r=new o(1-(e+1)/t,0),d=new o(1-e/t,1/(a+1));c.setFaceVertexValue(m,0,l),c.setFaceVertexValue(m,1,r),c.setFaceVertexValue(m,2,d),m++;}for(let e=0;e<t;e++){const s=i-1,n=t*(a-1)+e+1,l=t*(a-1)+(e+1)%t+1;this.setFaceVertexIndices(m,s,n,l);const r=new o(1-e/t,a/(a+1)),d=new o(1-(e+1)/t,a/(a+1)),h=new o(.5,1);c.setFaceVertexValue(m,0,r),c.setFaceVertexValue(m,1,d),c.setFaceVertexValue(m,2,h),m++;}for(let e=0;e<a-1;e++)for(let i=0;i<t;i++){const s=t*e+i+1,n=t*e+(i+1)%t+1,l=t*(e+1)+(i+1)%t+1,r=t*(e+1)+i+1;this.setFaceVertexIndices(m,s,n,l,r),c.setFaceVertexValue(m,0,new o(e/a,i/a)),c.setFaceVertexValue(m,1,new o(e/a,(i+1)/a)),c.setFaceVertexValue(m,2,new o((e+1)/a,(i+1)/a)),c.setFaceVertexValue(m,3,new o((e+1)/a,i/a)),m++;}this.setBoundingBoxDirty(),this.geomDataTopologyChanged.emit();}__resize(){const e=this.__radiusParam.getValue(),t=this.__sidesParam.getValue(),a=this.__loopsParam.getValue();let i=0;const s=new d(0,0,1);this.getVertex(i).set(0,0,e),i++;for(let n=0;n<a;n++){const l=(n+1)/(a+1)*Math.PI;for(let a=0;a<t;a++){const n=a/t*2*Math.PI;s.set(Math.sin(l)*Math.cos(n),Math.sin(l)*Math.sin(n),Math.cos(l)),this.getVertex(i).setFromOther(s.scale(e)),i++;}}this.getVertex(i).set(0,0,-e),i++,this.setBoundingBoxDirty(),this.geomDataChanged.emit();}}C.registerClass("Sphere",Ot);class Qt extends Ft{constructor(e=.5,t=1,a=32){if(super(),isNaN(e)||isNaN(t)||isNaN(a))throw new Error("Invalid geom args");this.__innerRadius=e,this.__outerRadius=t,this.__detail=a>=3?a:3,this.addVertexAttribute("texCoords",o),this.addVertexAttribute("normals",d),this.__rebuild();}get innerRadius(){return this.__innerRadius}set innerRadius(e){this.__innerRadius=e,this.__resize();}get outerRadius(){return this.__outerRadius}set outerRadius(e){this.__outerRadius=e,this.__resize();}get detail(){return this.__detail}set detail(e){this.__detail=e>=3?e:3,this.__rebuild();}__rebuild(){const e=this.__detail,t=2*this.__detail,a=e*t;this.setNumVertices(a),this.setFaceCounts([0,e*t]);const i=this.getVertexAttribute("normals");let s=0;for(let a=0;a<t;a++){const n=a/t*2*Math.PI,l=Math.cos(n),r=Math.sin(n);for(let t=0;t<e;t++){const a=t/e*2*Math.PI,n=Math.sin(a),o=Math.cos(a),d=this.__outerRadius+o*this.__innerRadius;this.getVertex(s).set(l*d,r*d,this.__innerRadius*n),i.getValueRef(s).set(l*o,r*o,n),s++;}}const n=this.getVertexAttribute("texCoords");let l=0;for(let a=0;a<t;a++)for(let i=0;i<e;i++){const s=(a+1)%t,r=(i+1)%e,d=e*a+i,h=e*a+r,c=e*s+r,m=e*s+i;this.setFaceVertexIndices(l,d,h,c,m),n.setFaceVertexValue(l,0,new o(a/t,i/t)),n.setFaceVertexValue(l,1,new o(a/t,(i+1)/t)),n.setFaceVertexValue(l,2,new o((a+1)/t,(i+1)/t)),n.setFaceVertexValue(l,3,new o((a+1)/t,i/t)),l++;}this.setBoundingBoxDirty();}__resize(){const e=this.__detail,t=2*this.__detail;for(let a=0;a<t;a++){const i=a/t*2*Math.PI,s=Math.cos(i),n=Math.sin(i);for(let t=0;t<e;t++){const a=t/e*2*Math.PI,i=Math.sin(a),l=Math.cos(a),r=this.__outerRadius+l*this.__innerRadius;this.getVertex(0).set(s*r,n*r,this.__innerRadius*i),index++;}}this.setBoundingBoxDirty();}toJSON(){const e=super.toJSON();return e.x=this.__x,e.y=this.__y,e.z=this.__z,e}}const At={SAVE_FLAG_SKIP_CHILDREN:1},jt={LOAD_FLAG_LOADING_BIN_TREE_VALUES:16},qt={CLONE_FLAG_INSTANCED_TREE:1};class $t extends D{constructor(e){super(e),this.__visibleCounter=1,this.__visible=!0,this.__highlightMapping={},this.__highlights=[],this.__childItems=[],this.__childItemsSignalIds=[],this.__childItemsMapping={},this.__components=[],this.__componentMapping={},this.mouseDown=new S,this.mouseUp=new S,this.mouseMove=new S,this.mouseEnter=new S,this.mouseLeave=new S,this.__visibleParam=this.addParameter(new pe("Visible",!0)),this.__localXfoParam=this.addParameter(new fe("LocalXfo",new X)),this.__globalXfoParam=this.addParameter(new fe("GlobalXfo",new X)),this.__boundingBoxParam=this.addParameter(new P("BoundingBox",new V)),this.parentChanged=this.ownerChanged,this.childAdded=new S,this.childRemoved=new S,this.highlightChanged=new S,this.visibilityChanged=new S,this.localXfoChanged=this.__localXfoParam.valueChanged,this.globalXfoChanged=this.__globalXfoParam.valueChanged,this.boundingChanged=this.__boundingBoxParam.valueChanged,this._cleanGlobalXfo=this._cleanGlobalXfo.bind(this),this._setGlobalXfoDirty=this._setGlobalXfoDirty.bind(this),this._setBoundingBoxDirty=this._setBoundingBoxDirty.bind(this),this._cleanBoundingBox=this._cleanBoundingBox.bind(this),this.__localXfoParam.valueChanged.connect(this._setGlobalXfoDirty);const t=e=>{const t=this.__globalXfoParam.getValue();return void 0!==this.__ownerItem?this.__ownerItem.getGlobalXfo().inverse().multiply(t):t};this.__globalXfoParam.valueChanged.connect(e=>{e!=N.OPERATOR_DIRTIED&&this.__localXfoParam.setDirty(t),this._setBoundingBoxDirty();}),this.__visibleParam.valueChanged.connect(e=>{this.__visibleCounter+=this.__visibleParam.getValue()?1:-1,this.__updateVisiblity();});}static get SaveFlags(){return At}static get LoadFlags(){return jt}static get CloneFlags(){return qt}static getSelectionOutlineColor(){return selectionOutlineColor}static setSelectionOutlineColor(e){selectionOutlineColor=e;}static getBranchSelectionOutlineColor(){return branchSelectionOutlineColor}static setBranchSelectionOutlineColor(e){branchSelectionOutlineColor=e;}_childFlagsChanged(e){0!=(e&K.USER_EDITED)&&this.setFlag(k.USER_EDITED);}setFlag(e){super.setFlag(e),this.__ownerItem&&this.__ownerItem._childFlagsChanged(e);}setOwner(e){if(this.__ownerItem){this.__ownerItem.globalXfoChanged.disconnect(this._setGlobalXfoDirty),this.__ownerItem.getVisible()||this.__visibleCounter++;const e=this.__ownerItem.getChildIndex(this);e>=0&&this.__ownerItem.__unbindChild(e,this);}super.setOwner(e),this._setGlobalXfoDirty(),this.__ownerItem&&(this.setSelectable(this.__ownerItem.getSelectable(),!0),this.__ownerItem.getVisible()||this.__visibleCounter--,this.__ownerItem.globalXfoChanged.connect(this._setGlobalXfoDirty)),this.__updateVisiblity();}__updatePath(){super.__updatePath();for(const e of this.__childItems)e&&e.__updatePath();for(const e of this.__components)e&&e.__updatePath();}getParentItem(){return this.getOwner()}setParentItem(e){this.setOwner(e);}getLocalXfo(){return this.__localXfoParam.getValue()}setLocalXfo(e,t){this.__localXfoParam.setValue(e,t);}getGlobalXfo(e){return this.__globalXfoParam.getValue(e)}setGlobalXfo(e,t){const a=this.getOwner();if(a){const i=a.getGlobalXfo().inverse().multiply(e);this.__localXfoParam.setValue(i,t);}else this.__globalXfoParam.setValue(e,t);}_cleanGlobalXfo(e){const t=this.getParentItem(),a=this.__localXfoParam.getValue();if(void 0!==t){return t.getGlobalXfo().multiply(a)}return a}_setGlobalXfoDirty(){this.__globalXfoParam.setDirty(this._cleanGlobalXfo);}getVisible(){return this.__visibleCounter>0}setVisible(e){this.__visibleParam.setValue(e);}propagateVisiblity(e){this.__visibleCounter+=e,this.__updateVisiblity();}__updateVisiblity(){const e=this.__visibleCounter>0;if(e!=this.__visible){this.__visible=e;for(const e of this.__childItems)e instanceof $t&&e.propagateVisiblity(this.__visible?1:-1);return this.visibilityChanged.emit(e),!0}return !1}addHighlight(e,t,a=!1){if(e in this.__highlightMapping){const t=this.__highlights.indexOf(e);this.__highlights.splice(t,1);}this.__highlights.push(e),this.__highlightMapping[e]=t,this.highlightChanged.emit(),a&&this.__childItems.forEach(i=>{i instanceof $t&&i.addHighlight(e,t,a);});}removeHighlight(e,t=!1){if(e in this.__highlightMapping){const t=this.__highlights.indexOf(e);this.__highlights.splice(t,1),delete this.__highlightMapping[e],this.highlightChanged.emit();}t&&this.__childItems.forEach(a=>{a instanceof $t&&a.removeHighlight(e,t);});}getHighlight(){if(this.__highlights.length>0)return this.__highlightMapping[this.__highlights[this.__highlights.length-1]]}isHighlighted(){return this.__highlights.length>0}get boundingBox(){return console.warn("getter is deprectated. Please use 'getBoundingBox'"),this.getBoundingBox()}getBoundingBox(){return this.__boundingBoxParam.getValue()}_cleanBoundingBox(e){return e.reset(),this.__childItems.forEach(t=>{t instanceof $t&&t.getVisible()&&!t.testFlag(k.IGNORE_BBOX)&&e.addBox3(t.getBoundingBox());}),e}_childBBoxChanged(){this._setBoundingBoxDirty();}_setBoundingBoxDirty(){this.__boundingBoxParam&&this.__boundingBoxParam.setDirty(this._cleanBoundingBox);}getChildren(){return this.__childItems}numChildren(){return console.warn("Deprecated method. Please use getNumChildren"),this.__childItems.length}getNumChildren(){return this.__childItems.length}generateUniqueName(e){if(!(e in this.__childItemsMapping))return e;let t=1;e.length>4&&!Number.isNaN(parseInt(e.substring(e.length-4)))?t=parseInt(e.substr(e.length-4)):e.length>3&&!Number.isNaN(parseInt(e.substring(e.length-3)))?t=parseInt(e.substr(e.length-3)):e.length>2&&!Number.isNaN(parseInt(e.substring(e.length-2)))&&(t=parseInt(e.substr(e.length-2)));const a=[];for(const e of this.__childItems)e&&a.push(e.getName());let i=e;for(;;){let s=""+t;for(;s.length<2;)s="0"+s;if(i=e+s,-1==a.indexOf(i))break;t++;}return i}__updateMapping(e){for(let t=e;t<this.__childItems.length;t++)this.__childItemsMapping[this.__childItems[t].getName()]=t;}insertChild(e,t,a=!1,i=!0){if(e.getName()in this.__childItemsMapping){if(!i)throw new Error("Item '"+e.getName()+"' is already a child of :"+this.getPath());e.setName(this.generateUniqueName(e.getName()));}if(!(e instanceof D))throw new Error("Object is is not a tree item :"+e.constructor.name);const s={};let n;return s.nameChangedId=e.nameChanged.connect((e,t)=>{const a=this.__childItemsMapping[t];delete this.__childItemsMapping[t],this.__childItemsMapping[e]=a;}),e instanceof $t&&(a&&(n=this.getGlobalXfo().inverse().multiply(e.getGlobalXfo())),s.bboxChangedId=e.boundingChanged.connect(()=>{this._setBoundingBoxDirty();}),s.visChangedId=e.visibilityChanged.connect(this._setBoundingBoxDirty)),this.__childItems.splice(t,0,e),this.__childItemsSignalIds.splice(t,0,s),this.__childItemsMapping[e.getName()]=t,this.__updateMapping(t),e.setOwner(this),e instanceof $t&&(a&&e.setLocalXfo(n),this._setBoundingBoxDirty()),e.testFlag(k.USER_EDITED)&&this.setFlag(k.USER_EDITED),this.childAdded.emit(e,t),e}addChild(e,t=!0,a=!0){const i=this.__childItems.length;return this.insertChild(e,i,t,a),i}getChild(e){return this.__childItems[e]}getChildByName(e){const t=this.__childItemsMapping[e];return null!=t?this.__childItems[t]:null}getChildNames(){const e=[];for(let t=0;t<this.__childItems.length;t++){const a=this.__childItems[t];null!=a&&(e[t]=a.getName());}return e}__unbindChild(e,t){const a=this.__childItemsSignalIds[e];t.nameChanged.disconnectId(a.nameChangedId),t instanceof $t&&(t.boundingChanged.disconnectId(a.bboxChangedId),t.visibilityChanged.disconnectId(a.visChangedId)),this.__childItems.splice(e,1),this.__childItemsSignalIds.splice(e,1),delete this.__childItemsMapping[t.getName()],this.__updateMapping(e),t instanceof $t&&this._setBoundingBoxDirty(),this.childRemoved.emit(t,e);}removeChild(e){const t=this.__childItems[e];t&&(this.__unbindChild(e,t),t.setOwner(void 0));}removeChildByName(e){const t=this.__childItemsMapping[e];return null!=t?this.removeChild(t):null}removeChildByHandle(e){console.warn("Deprecated method. Please use removeChild");const t=this.__childItems.indexOf(e);if(-1==t)throw new Error("Error in removeChildByHandle. Child not found:"+e.getName());this.removeChild(t);}removeAllChildren(){let e=this.__childItems.length;for(;e--;)this.removeChild(e);this._setBoundingBoxDirty();}getChildIndex(e){return this.__childItems.indexOf(e)}indexOfChild(e){return console.warn("Deprecated method. Please use getChildIndex"),this.getChildIndex(e)}addComponent(e){this.__components.push(e),this.__componentMapping[e.getName()]=this.__components.length-1,e.setOwner(this);}removeComponent(e){const t=this.__componentMapping[e];if(null==t)throw new Error("Component not found:"+e);const a=this.__components[t];a.setOwner(void 0),this.__components.splice(t,1);const i={};for(let e=0;e<this.__components.length;e++)i[this.__components[e].getName()]=e;return this.__componentMapping=i,a}hasComponent(e){return e in this.__componentMapping}getComponent(e){if(e in this.__componentMapping)return this.__components[this.__componentMapping[e]];console.log("No component named '"+e+"' found.");}resolvePath(e,t=0){if("string"==typeof e&&(e=e.split("/")),0==t)if("."==e[0]||e[0]==this.__name)t++;else if(".."==e[0])return this.__ownerItem.resolvePath(e,t+1);if(t==e.length)return this;if(">"==e[t]&&t==e.length-2&&this.hasComponent(e[t+1])){return this.getComponent(e[t+1]).resolvePath(e,t+2)}const a=e[t],i=this.getChildByName(a);if(null==i){if(this.hasComponent(e[t])){const a=this.getComponent(e[t]);return t==e.length?a:a.resolvePath(e,t+1)}const a=this.getParameter(e[t]);return a||null}return i.resolvePath(e,t+1)}traverse(e,t=!0){const a=(e,t)=>{const a=e.getChildren();for(const e of a)e&&i(e,t+1);},i=(t,i)=>{if(0==e(t,i))return !1;a(t,i);};t?i(this,1):a(this,0);}onMouseDown(e){this.mouseDown.emit(e),e.propagating&&this.__ownerItem&&this.__ownerItem.onMouseDown(e);}onMouseUp(e){this.mouseUp.emit(e),e.propagating&&this.__ownerItem&&this.__ownerItem.onMouseUp(e);}onMouseMove(e){this.mouseMove.emit(e),e.propagating&&this.__ownerItem&&this.__ownerItem.onMouseMove(e);}onMouseEnter(e){this.mouseEnter.emit(e),e.propagating&&this.__ownerItem&&this.__ownerItem.onMouseEnter(e);}onMouseLeave(e){this.mouseLeave.emit(e),e.propagating&&this.__ownerItem&&this.__ownerItem.onMouseLeave(e);}onWheel(e){e.propagating&&this.__ownerItem&&this.__ownerItem.onWheel(e);}toJSON(e,t){if(!this.testFlag(k.USER_EDITED))return;const a=super.toJSON(e,t),i=[];for(const a of this.__components)i.push(a.toJSON(e,t));if(i.length>0&&(a.components=i),!(t&At.SAVE_FLAG_SKIP_CHILDREN)){const i={};for(const a of this.__childItems)if(a){const s=a.toJSON(e,t);s&&(i[a.getName()]=s);}Object.keys(i).length>0&&(a?a.children=i:a={name:this.__name,children:i});}return a}fromJSON(e,t,a){if(super.fromJSON(e,t,a),t.numTreeItems++,this.setFlag(k.USER_EDITED),null!=e.children){const i=e.children;if(Array.isArray(i))for(const e of i){let i=this.getChildByName(e.name);i?i.fromJSON(e,t,a):e.type&&(i=C.constructClass(e.type),i&&(i.fromJSON(e,t,a),this.addChild(i,!1,!1)));}else for(const e in i){const s=i[e];let n=this.getChildByName(e);n?n.fromJSON(s,t,a):s.type&&(n=C.constructClass(s.type),n&&(n.fromJSON(s,t,a),this.addChild(n,!1,!1)));}}if(e.components)for(const a of e.components){const e=C.constructClass(a.type?a.type:a.name);e&&(e.fromJSON(a,t),this.addComponent(e));}}readBinary(e,t){super.readBinary(e,t),t.numTreeItems++;const a=e.loadUInt8();if(4&a){const t=new X;t.tr=e.loadFloat32Vec3(),t.ori=e.loadFloat32Quat(),t.sc.set(e.loadFloat32()),this.__localXfoParam.setValue(t,N.DATA_LOAD);}8&a&&this.__boundingBoxParam.setValue(new V(e.loadFloat32Vec3(),e.loadFloat32Vec3()),N.DATA_LOAD);const i=e.loadUInt32();if(i>0){const a=e.loadUInt32Array(i);for(let s=0;s<i;s++){e.seek(a[s]);let i=e.loadStr();if(i.startsWith("N")&&i.endsWith("E")){const e=i.indexOf("podium");-1!=e&&(i=parseInt(i[e+7])?i.substring(e+8,i.length-1):i.substring(e+7,i.length-1)),-1!=i.indexOf("livenurbs")&&(i=i.substring(i.indexOf("CAD"),i.length-1));}const n=C.constructClass(i);if(n)e.seek(a[s]),n.readBinary(e,t),n.setFlag(k.BIN_NODE),this.addChild(n,!1,!1);else {const t=e.loadStr();console.warn("Unable to construct child:"+t+" of type:"+i);}}}}clone(e){const t=new $t;return t.copyFrom(this,e),t}copyFrom(e,t){super.copyFrom(e,t),e.getChildren().forEach(e=>{e&&this.addChild(e.clone(t),!1,!1);});}destroy(){this.removeAllChildren(),super.destroy();}}C.registerClass("TreeItem",$t);class ea extends $t{constructor(e){super(e);}setSrcTree(e,t){if(this.__srcTree=e,0==this.__srcTree.getNumChildren()){const e=this.__srcTree.clone(t);e.setLocalXfo(new X,N.DATA_LOAD),this.addChild(e,!1);}else {this.__srcTree.getChildren().forEach(e=>{const a=e.clone(t);this.addChild(a,!1);});}}getSrcTree(){return this.__srcTree}readBinary(e,t={}){super.readBinary(e,t);const a=e.loadStrArray();t.resolvePath(a,e=>{this.setSrcTree(e,t);});}toJSON(e={},t=0){return super.toJSON(e,t)}fromJSON(e,t={},a=0,i){}}C.registerClass("InstanceItem",ea);class ta extends $t{constructor(e){super(e),this.__loaded=!1,this.audioSourceCreated=new S;const t=this.addParameter(new Re("FilePath"));let a,i;const s=()=>{a=window.ZeaAudioaudioCtx.createBufferSource(),a.buffer=i,a.loop=o.getValue(),a.muted=r.getValue(),a.start(0),this.audioSourceCreated.emit(a);};t.valueChanged.connect(()=>{const e=new XMLHttpRequest;e.open("GET",t.getURL(),!0),e.responseType="arraybuffer",e.onload=()=>{const t=e.response;window.ZeaAudioaudioCtx.decodeAudioData(t,e=>{i=e,this.__loaded=!0,this.loaded.emit(!0),n.getValue()&&s();},e=>{console.log("Error with decoding audio data"+e.err);});},e.send();});const n=this.addParameter(new pe("Autoplay",!1)),l=this.addParameter(new ue("PlayState",0));l.valueChanged.connect(e=>{if(e!=N.CUSTOM)switch(l.getValue()){case 0:this.__loaded&&a&&(a.stop(0),a=void 0);break;case 1:this.__loaded&&s();}}),this.isPlaying=()=>0!=l.getValue(),this.play=()=>{l.setValue(1,N.CUSTOM);},this.stop=()=>{l.setValue(0,N.CUSTOM);},this.pause=()=>{l.setValue(0,N.CUSTOM);},this.getAudioSource=()=>a;const r=this.addParameter(new pe("Mute",!1));this.addParameter(new ue("Gain",1)).setRange([0,5]);const o=this.addParameter(new pe("Loop",!1));this.addParameter(new pe("SpatializeAudio",!0)),this.addParameter(new ue("refDistance",2)),this.addParameter(new ue("maxDistance",1e4)),this.addParameter(new ue("rolloffFactor",1)),this.addParameter(new ue("coneInnerAngle",360)),this.addParameter(new ue("coneOuterAngle",0)),this.addParameter(new ue("coneOuterGain",1)),r.valueChanged.connect(()=>{a&&(a.muted=r.getValue());}),o.valueChanged.connect(()=>{a&&(a.loop=o.getValue());}),this.mute=e=>{r.setValue(e,N.CUSTOM);},this.loaded=new S(!0),this.loaded.setToggled(!1);}isLoaded(){return this.__loaded}setAudioStream(){this.__loaded=!0,this.loaded.emit(),this.audioSourceCreated.emit(audioSource);}}class aa extends ta{constructor(e){}}class ia extends $t{constructor(e){super(e),this.overlay=!1,this.__cutAway=!1,this.__cutAwayVector=!1,this.__cutAwayDist=!1,this.cutAwayChanged=new S,this.__layers=[];}setOverlay(e){this.overlay=e;}isOverlay(){return this.overlay}addLayer(e){this.__layers.push(e);}getLayers(){return this.__layers}isCutawayEnabled(){return this.__cutAway}setCutawayEnabled(e){this.__cutAway=e,this.cutAwayChanged.emit();}getCutVector(){return this.__cutAwayVector}setCutVector(e){this.__cutAwayVector=e,this.cutAwayChanged.emit();}getCutDist(){return this.__cutAwayDist}setCutDist(e){this.__cutAwayDist=e,this.cutAwayChanged.emit();}readBinary(e,t){if(super.readBinary(e,t),t.versions["zea-engine"].greaterOrEqualThan([0,0,4])){const a=e.loadStr();let i=t.assetItem.getMaterialLibrary().getMaterial(a,!1);if(i||(i=new Ke(a,"SimpleSurfaceShader"),i.getParameter("BaseColor").setValue(u.random(.25),N.DATA_LOAD),t.assetItem.getMaterialLibrary().addMaterial(i)),this.setMaterial(i,N.DATA_LOAD),this.__layers=e.loadStrArray(),this.__layers.length>0)for(const e of this.__layers)t.addGeomToLayer(this,e);}}}class sa extends ia{constructor(e,t,a){super(e),this.__geomParam=this.insertParameter(new Fe("geometry"),0),this.__geomParam.valueChanged.connect(this._setBoundingBoxDirty.bind(this)),this.__geomParam.boundingBoxDirtied.connect(this._setBoundingBoxDirty.bind(this)),this.__materialParam=this.insertParameter(new Rt("Material"),1),this.__paramMapping.material=this.getParameterIndex(this.__materialParam),this.__lightmapCoordOffset=new o,this.__geomOffsetXfoParam=this.addParameter(new fe("GeomOffsetXfo")),this.__geomMatParam=this.addParameter(new ye("GeomMat")),this.__cleanGeomMat=this.__cleanGeomMat.bind(this),this.__globalXfoParam.valueChanged.connect(e=>{this.__geomMatParam.setDirty(this.__cleanGeomMat);}),this.__geomOffsetXfoParam.valueChanged.connect(e=>{this.__geomMatParam.setDirty(this.__cleanGeomMat);}),this.geomXfoChanged=this.__geomMatParam.valueChanged,this.materialAssigned=this.__materialParam.valueChanged,this.geomAssigned=this.__geomParam.valueChanged,t&&this.setGeometry(t,N.DATA_LOAD),a&&this.setMaterial(a,N.DATA_LOAD);}__cleanGeomMat(){const e=this.__globalXfoParam.getValue().toMat4(),t=this.__geomOffsetXfoParam.getValue().toMat4();return e.multiply(t)}getGeometry(){return this.__geomParam.getValue()}setGeometry(e,t){this.__geomParam.setValue(e,t);}getGeom(){return console.warn("getGeom is deprectated. Please use 'getGeometry'"),this.getGeometry()}setGeom(e){return console.warn("setGeom is deprectated. Please use 'setGeometry'"),this.setGeometry(e)}getMaterial(){return this.__materialParam.getValue()}setMaterial(e,t){this.__materialParam.setValue(e,t);}_cleanBoundingBox(e){e=super._cleanBoundingBox(e);const t=this.getGeometry();return t&&e.addBox3(t.boundingBox,this.getGeomMat4()),e}getGeomOffsetXfo(){return this.__geomOffsetXfoParam.getValue()}setGeomOffsetXfo(e){this.__geomOffsetXfoParam.setValue(e);}getGeomMat4(){return this.__geomMatParam.getValue()}getLightmapName(){return this.__lightmapName}getLightmapCoordsOffset(){return this.__lightmapCoordOffset}applyAssetLightmapSettings(e,t){this.__lightmap=e,this.__lightmapCoordOffset.addInPlace(t);}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t){super.fromJSON(e,t),t.numGeomItems++;}readBinary(e,t){super.readBinary(e,t),t.numGeomItems++,this.__lightmapName=t.assetItem.getName();const a=e.loadUInt8(),i=e.loadUInt32(),s=t.assetItem.getGeometryLibrary(),n=s.getGeom(i);if(n)this.setGeometry(n,N.DATA_LOAD);else {this.geomIndex=i;const e=e=>{if(i>=e[0]&&i<e[1]){const e=s.getGeom(i);e?this.setGeometry(e,N.DATA_LOAD):console.warn("Geom not loaded:",this.getName()),s.rangeLoaded.disconnectId(t);}},t=s.rangeLoaded.connect(e);}if(4&a&&this.__geomOffsetXfoParam.setValue(new X(e.loadFloat32Vec3(),e.loadFloat32Quat(),e.loadFloat32Vec3())),t.versions["zea-engine"].lessThan([0,0,4])){if(a&8){const a=t.assetItem.getMaterialLibrary(),i=e.loadStr();let s=a.getMaterial(i);s||(console.warn("Geom :'"+this.name+"' Material not found:"+i),s=a.getMaterial("Default")),this.setMaterial(s,N.DATA_LOAD);}else this.setMaterial(t.assetItem.getMaterialLibrary().getMaterial("Default"),N.DATA_LOAD);}this.__lightmapCoordOffset=e.loadFloat32Vec2();}toString(){return JSON.stringify(this.toJSON(),null,2)}clone(e){const t=new sa;return t.copyFrom(this,e),t}copyFrom(e,t){if(super.copyFrom(e,t),this.__lightmapCoordOffset=e.__lightmapCoordOffset,!e.getGeometry()&&-1!=e.geomIndex){const a=t.assetItem.getGeometryLibrary(),i=e.geomIndex,s=e=>{if(i>=e[0]&&i<e[1]){const e=a.getGeom(i);e?this.setGeometry(e,N.DATA_LOAD):console.warn("Geom not loaded:",this.getName()),a.rangeLoaded.disconnectId(n);}},n=a.rangeLoaded.connect(s);}this.__geomMatParam.setDirty(this.__cleanGeomMat);}destroy(){super.destroy();}}C.registerClass("GeomItem",sa);const na={manual:0,first:1,average:2,globalOri:3};class la extends $t{constructor(e){super(e),this.setFlag(k.USER_EDITED),this.calculatingGroupXfo=!1,this.dirty=!1,this.invGroupXfo=void 0,this.__initialXfos=[],this.__signalIndices=[];let t=0;this.__itemsParam=this.insertParameter(new ve("Items",e=>e instanceof $t),t++),this.__itemsParam.itemAdded.connect((e,t)=>{this.__bindItem(e,t);}),this.__itemsParam.itemRemoved.connect((e,t)=>{this.__unbindItem(e,t);}),this.__itemsParam.valueChanged.connect(()=>{this.calcGroupXfo(),this._setBoundingBoxDirty();}),this.__initialXfoModeParam=this.insertParameter(new be("InitialXfoMode",na.average,["manual","first","average","global"]),t++),this.__initialXfoModeParam.valueChanged.connect(()=>{this.calcGroupXfo();}),this.__highlightedParam=this.insertParameter(new pe("Highlighted",!1),t++),this.__highlightedParam.valueChanged.connect(()=>{this.__updateHighlight();}),this.__updateHighlight=this.__updateHighlight.bind(this),this.insertParameter(new Ge("HighlightColor",new u(.5,.5,1)),t++).valueChanged.connect(this.__updateHighlight),this.insertParameter(new ue("HighlightFill",0,[0,1]),t++).valueChanged.connect(this.__updateHighlight),this.__materialParam=this.insertParameter(new Rt("Material"),t++),this.__materialParam.valueChanged.connect(()=>{this.__updateMaterial();}),this.__updateCutaway=this.__updateCutaway.bind(this),this.insertParameter(new pe("CutAwayEnabled",!1),t++).valueChanged.connect(this.__updateCutaway),this.insertParameter(new _e("CutVector",new d(1,0,0)),t++).valueChanged.connect(this.__updateCutaway),this.insertParameter(new ue("CutDist",0),t++).valueChanged.connect(this.__updateCutaway),this.__globalXfoParam.valueChanged.connect(e=>{this.calculatingGroupXfo||this._propagateDirtyXfoToItems();});}static get INITIAL_XFO_MODES(){return na}__updateVisiblity(){if(super.__updateVisiblity()){const e=this.getVisible();return Array.from(this.__itemsParam.getValue()).forEach(t=>{t instanceof $t&&t.propagateVisiblity(e?1:-1);}),!0}return !1}__updateHighlight(){let e,t=!1;(this.getParameter("Highlighted").getValue()||this.isSelected())&&(t=!0,e=this.getParameter("HighlightColor").getValue(),e.a=this.getParameter("HighlightFill").getValue());const a="groupItemHighlight"+this.getId();Array.from(this.__itemsParam.getValue()).forEach(i=>{i instanceof $t&&(t?i.addHighlight(a,e,!0):i.removeHighlight(a,!0));});}setSelected(e){super.setSelected(e),this.__updateHighlight();}_setGlobalXfoDirty(){super._setGlobalXfoDirty();}calcGroupXfo(){const e=Array.from(this.__itemsParam.getValue());if(0==e.length)return new X;this.calculatingGroupXfo=!0;const t=this.__initialXfoModeParam.getValue();let a;if(t==na.manual)return this.invGroupXfo=this.getGlobalXfo().inverse(),void(this.calculatingGroupXfo=!1);if(t==na.first)a=this.__initialXfos[0];else if(t==na.average){a=new X,a.ori.set(0,0,0,0);let t=0;e.forEach((e,i)=>{e instanceof $t&&(a.tr.addInPlace(this.__initialXfos[i].tr),a.ori.addInPlace(this.__initialXfos[i].ori),t++);}),a.tr.scaleInPlace(1/t),a.ori.normalizeInPlace();}else {if(t!=na.globalOri)throw new Error("Invalid mode.");{a=new X;let t=0;e.forEach((e,i)=>{e instanceof $t&&(a.tr.addInPlace(this.__initialXfos[i].tr),t++);}),a.tr.scaleInPlace(1/t);}}this.setGlobalXfo(a,N.GENERATED_VALUE);const i=this.getGlobalXfo();this.invGroupXfo=i.inverse(),this.calculatingGroupXfo=!1;}_propagateDirtyXfoToItems(){if(this.calculatingGroupXfo)return;const e=Array.from(this.__itemsParam.getValue());if(!this.calculatingGroupXfo&&e.length>0&&this.invGroupXfo&&!this.dirty){let t;this.dirty=!0,this.propagatingXfoToItems=!0;const a=(e,a)=>{const i=e.getParameter("GlobalXfo");i.setDirty(()=>{if(!t){const e=this.__globalXfoParam.getValue();t=e.multiply(this.invGroupXfo),this.dirty=!1;}const e=t.multiply(a);i.setClean(e);});};e.forEach((e,t)=>{e instanceof $t&&a(e,this.__initialXfos[t]);}),this.propagatingXfoToItems=!1;}}__updateMaterial(){const e=this.getParameter("Material").getValue();Array.from(this.__itemsParam.getValue()).forEach(t=>{t.traverse(t=>{if(t instanceof $t&&t.hasParameter("Material")){const a=t.getParameter("Material");if(e){const t=a.getValue();t!=e&&(a.__backupMaterial=t,a.setValue(e,N.GENERATED_VALUE));}else a.__backupMaterial&&a.setValue(a.__backupMaterial,N.GENERATED_VALUE);}},!1);});}__updateCutaway(){const e=this.getParameter("CutAwayEnabled").getValue(),t=this.getParameter("CutVector").getValue(),a=this.getParameter("CutDist").getValue();Array.from(this.__itemsParam.getValue()).forEach(i=>{i.traverse(i=>{i instanceof ia&&(i.setCutawayEnabled(e),i.setCutVector(t),i.setCutDist(a));},!0);});}setPaths(e){this.clearItems(!1);const t=this.getOwner();if(null==t)return void console.warn("Group does not have an owner and so cannot resolve paths:",this.getName());const a=[];e.forEach(e=>{const i=t.resolvePath(e);i?a.push(i):console.warn("Path does not resolve to an Item:",e," group:",this.getName());}),this.setItems(a);}resolveItems(e){this.setPaths(e);}__bindItem(e,t){if(!(e instanceof $t))return;const a={};a.mouseDownIndex=e.mouseDown.connect(e=>{this.onMouseDown(e);}),a.mouseUpIndex=e.mouseUp.connect(e=>{this.onMouseUp(e);}),a.mouseMoveIndex=e.mouseMove.connect(e=>{this.onMouseMove(e);}),a.mouseEnterIndex=e.mouseEnter.connect(e=>{this.onMouseEnter(e);}),a.mouseLeaveIndex=e.mouseLeave.connect(e=>{this.onMouseLeave(e);});const i=this.getParameter("Material").getValue();if(i&&e.traverse(e=>{if(e instanceof $t&&e.hasParameter("Material")){const t=e.getParameter("Material");if(i){const e=t.getValue();e!=i&&(t.__backupMaterial=e,t.setValue(i,N.GENERATED_VALUE));}}},!0),e instanceof $t&&this.getParameter("Highlighted").getValue()){const t=this.getParameter("HighlightColor").getValue();t.a=this.getParameter("HighlightFill").getValue(),e.addHighlight("groupItemHighlight"+this.getId(),t,!0);}const s=this.getParameter("CutAwayEnabled").getValue();if(s){const t=this.getParameter("CutVector").getValue(),a=this.getParameter("CutDist").getValue();e.traverse(e=>{e instanceof ia&&(e.setCutawayEnabled(s),e.setCutVector(t),e.setCutDist(a));},!0);}this.getVisible()||e.propagateVisiblity(-1);const n=()=>{const e=this.__initialXfoModeParam.getValue();e==na.first&&0==t?this.calcGroupXfo():e!=na.average&&e!=na.globalOri||this.calcGroupXfo();};a.globalXfoChangedIndex=e.globalXfoChanged.connect(a=>{this.propagatingXfoToItems||(this.__initialXfos[t]=e.getGlobalXfo(),n());}),this.__initialXfos[t]=e.getGlobalXfo(),a.bboxChangedIndex=e.boundingChanged.connect(this._setBoundingBoxDirty),this.__signalIndices[t]=a,n();}__unbindItem(e,t){if(!(e instanceof $t))return;e.removeHighlight("branchselected"+this.getId(),!0),this.getParameter("Highlighted").getValue()&&e.removeHighlight("groupItemHighlight"+this.getId(),!0),this.getVisible()||e.propagateVisiblity(1),e.traverse(e=>{e instanceof ia&&e.setCutawayEnabled(!1);},!0);const a=this.__signalIndices[t];e.mouseDown.disconnectId(a.mouseDownIndex),e.mouseUp.disconnectId(a.mouseUpIndex),e.mouseMove.disconnectId(a.mouseMoveIndex),e.mouseEnter.disconnectId(a.mouseEnterIndex),e.mouseLeave.disconnectId(a.mouseLeaveIndex),e.globalXfoChanged.disconnectId(a.globalXfoChangedIndex),e.boundingChanged.disconnectId(a.bboxChangedIndex),this.__signalIndices.splice(t,1),this.__initialXfos.splice(t,1);}addItem(e,t=!0){e?this.__itemsParam.addItem(e,t):console.warn("Error adding item to group. Item is null");}removeItem(e,t=!0){this.__itemsParam.removeItem(e,t);}clearItems(e=!0){const t=Array.from(this.__itemsParam.getValue());for(let e=t.length-1;e>=0;e--)this.__unbindItem(t[e],e);this.__signalIndices=[],this.__initialXfos=[],this.__itemsParam.clearItems(e);}getItems(){return this.__itemsParam.getValue()}setItems(e){this.clearItems(!1),this.__itemsParam.setItems(e);}_cleanBoundingBox(e){const t=super._cleanBoundingBox(e);return Array.from(this.__itemsParam.getValue()).forEach(e=>{e instanceof $t&&e.getVisible()&&!e.testFlag(k.IGNORE_BBOX)&&t.addBox3(e.getBoundingBox());}),t}onMouseDown(e){super.onMouseDown(e);}onMouseUp(e){super.onMouseUp(e);}onMouseMove(e){super.onMouseMove(e);}toJSON(e,t){const a=super.toJSON(e,t),i=Array.from(this.__itemsParam.getValue()),s=[];return i.forEach(t=>{const a=t.getPath();s.push(e?e.makeRelative(a):a);}),a.treeItems=s,a}fromJSON(e,t,a){if(super.fromJSON(e,t,a),this.setFlag(k.USER_EDITED),!e.treeItems)return void console.warn("Invalid Parameter JSON");let i=e.treeItems.length;const s=e=>{t.resolvePath(e,e=>{this.addItem(e),i--,0==i&&(this.calculatingGroupXfo=!0,this.calcGroupXfo(),this.calculatingGroupXfo=!1);},t=>{console.warn("Group: '"+this.getName()+"'. Unable to load item:"+e);});};for(const t of e.treeItems)s(t);}clone(e){const t=new la;return t.copyFrom(this,e),t}copyFrom(e,t){super.copyFrom(e,t);}destroy(){super.destroy();}}C.registerClass("Group",la);const ra=ie("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwpjb25zdCB0PU1hdGguUEkvMTgwO01hdGguSEFMRl9QST0uNSpNYXRoLlBJLE1hdGguVFdPX1BJPTIqTWF0aC5QSTtNYXRoLnJhZFRvRGVnPWZ1bmN0aW9uKGUpe3JldHVybiBlL3R9LE1hdGguZGVnVG9SYWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUqdH0sTnVtYmVyLmlzTnVtZXJpYz10PT4haXNOYU4ocGFyc2VGbG9hdCh0KSkmJmlzRmluaXRlKHQpLFN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnJlcGxhY2UobmV3IFJlZ0V4cCh0LCJnIiksZSl9O2Z1bmN0aW9uIGUodCxlPTAscz01KXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodCwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZSYmZS50b0ZpeGVkP051bWJlcihlLnRvRml4ZWQocykpOmV9KSxlKX1TdHJpbmcucHJvdG90eXBlLmhhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7bGV0IGUscyxhLGk9MDtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGk7Zm9yKGU9MCxhPXQubGVuZ3RoO2U8YTtlKyspcz10LmNoYXJDb2RlQXQoZSksaT0oaTw8NSktaStzLGl8PTA7cmV0dXJuIE1hdGguYWJzKGkpfSh0aGlzKX0sU3RyaW5nLnByb3RvdHlwZS50cmltPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVwbGFjZSgvXlxzK3xccyskL2csIiIpfSxTdHJpbmcucHJvdG90eXBlLmx0cmltPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVwbGFjZSgvXlxzKy8sIiIpfSxTdHJpbmcucHJvdG90eXBlLnJ0cmltPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVwbGFjZSgvXHMrJC8sIiIpfSxTdHJpbmcucHJvdG90eXBlLmxwYWQ9ZnVuY3Rpb24odCxlKXtsZXQgcz10aGlzO2Zvcig7cy5sZW5ndGg8ZTspcz10K3M7cmV0dXJuIHN9LFN0cmluZy5wcm90b3R5cGUucnBhZD1mdW5jdGlvbih0LGUpe2xldCBzPXRoaXM7Zm9yKDtzLmxlbmd0aDxlOylzKz10O3JldHVybiBzfSxNYXRoLnJhbmRvbUludD1mdW5jdGlvbih0LGUpe3JldHVybiB0PU1hdGguY2VpbCh0KSxlPU1hdGguZmxvb3IoZSksTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihlLXQpKSt0fSxNYXRoLmxlcnA9KHQsZSxzKT0+dCtzKihlLXQpLE1hdGguY2xhbXA9ZnVuY3Rpb24odCxlLHMpe3JldHVybiBNYXRoLm1pbihNYXRoLm1heCh0LGUpLHMpfSxNYXRoLm5lYXJlc3RQb3cyPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLE1hdGgucm91bmQoTWF0aC5sb2codCkvTWF0aC5sb2coMikpKX0sTWF0aC5uZWFyZXN0UG93MTA9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDEwLE1hdGgucm91bmQoTWF0aC5sb2cxMCh0KS9NYXRoLmxvZzEwKDEwKSkpfSxNYXRoLm5leHRQb3cyPWZ1bmN0aW9uKHQpe2xldCBlPTA7Zm9yKDt0PjA7KWUrKyx0Pj49MTtyZXR1cm4gMTw8ZX0sTWF0aC5mcmFjdD1mdW5jdGlvbih0KXtyZXR1cm4gMD09dD8wOnQ8MD90Pi0xPy10Oi10JU1hdGguZmxvb3IoLXQpOnQ8MT90OnQlTWF0aC5mbG9vcih0KX0sTWF0aC5yZW1hcD1mdW5jdGlvbih0LGUscyxhLGkpe3JldHVybiBhKyh0LWUpLyhzLWUpKihpLWEpfSxNYXRoLmNvbnZlcnRGbG9hdDMyQXJyYXlUb1VJbnQxNkFycmF5PWZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IFVpbnQxNkFycmF5KHQubGVuZ3RoKSxzPW5ldyBJbnQzMkFycmF5KHQuYnVmZmVyKSxhPXQ9PntsZXQgZT10Pj4xNiYzMjc2OCxzPXQ+PjEyJjIwNDc7Y29uc3QgYT10Pj4yMyYyNTU7cmV0dXJuIGE8MTAzP2U6YT4xNDI/KGV8PTMxNzQ0LGV8PSgyNTU9PWE/MDoxKSYmODM4ODYwNyZ0LGUpOmE8MTEzPyhzfD0yMDQ4LGV8PShzPj4xMTQtYSkrKHM+PjExMy1hJjEpLGUpOihlfD1hLTExMjw8MTB8cz4+MSxlKz0xJnMsZSl9O2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKWVbaV09YShzW2ldKTtyZXR1cm4gZX0sTWF0aC5kZWNvZGUxNkJpdEZsb2F0RnJvbTJ4VUludDg9dD0+e2NvbnN0IGU9dFswXSxzPSgxMjAmZSk+PjM7bGV0IGE9MD09cz8wOjIwNDg7Y29uc3QgaT1hKygoNyZlKTw8OCkrdFsxXTtyZXR1cm4gYT0wPT1zPzE6MCwoMTI4JmU/MTotMSkqaSpNYXRoLnBvdygyLHMrYS0xNil9LE1hdGguZW5jb2RlMTZCaXRGbG9hdEludG8yeFVJbnQ4PXQ9PntjfHwoYz1uZXcgVWludDhBcnJheSgyKSk7Y29uc3QgZT10Pj0wPzEyODowO3Q9TWF0aC5hYnModCk7bGV0IHMsYT0xNSxpPTEwMjQ7Zm9yKGxldCBlPTE1O2U+MDtlLS0pdDxpJiYoaS89MixhLS0pO3M9MD09YT90L2kvMjoodC1pKS9pO2NvbnN0IHI9TWF0aC5yb3VuZCgyMDQ4KnMpLG49ci8yNTYsaD1yLTI1NipuO3JldHVybiBjWzBdPWUrOCphK24sY1sxXT1oLHQ+PTIwNDgmJihjWzBdPTI1NSksY30sTWF0aC5lbmNvZGUxNkJpdEZsb2F0PXQ9Pntjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkoMSk7ZVswXT10O3JldHVybih0PT57bGV0IGU9dD4+MTYmMzI3Njgscz10Pj4xMiYyMDQ3O2NvbnN0IGE9dD4+MjMmMjU1O3JldHVybiBhPDEwMz9lOmE+MTQyPyhlfD0zMTc0NCxlfD0oMjU1PT1hPzA6MSkmJjgzODg2MDcmdCxlKTphPDExMz8oc3w9MjA0OCxlfD0ocz4+MTE0LWEpKyhzPj4xMTMtYSYxKSxlKTooZXw9YS0xMTI8PDEwfHM+PjEsZSs9MSZzLGUpfSkobmV3IEludDMyQXJyYXkoZS5idWZmZXIpWzBdKX0sTWF0aC5kZWNvZGUxNkJpdEZsb2F0PXQ9Pntjb25zdCBlPSgzMjc2OCZ0KT4+MTUscz0oMzE3NDQmdCk+PjEwLGE9MTAyMyZ0O3JldHVybiAwPT1zPyhlPy0xOjEpKk1hdGgucG93KDIsLTE0KSooYS9NYXRoLnBvdygyLDEwKSk6MzE9PXM/YT9OYU46MS8wKihlPy0xOjEpOihlPy0xOjEpKk1hdGgucG93KDIscy0xNSkqKDErYS9NYXRoLnBvdygyLDEwKSl9LE1hdGguc21vb3RoU3RlcD0odCxlLHMpPT57Y29uc3QgYT1NYXRoLmNsYW1wKChzLXQpLyhlLXQpLDAsMSk7cmV0dXJuIGEqYSooMy0yKmEpfSxNYXRoLmxpblN0ZXA9KHQsZSxzKT0+TWF0aC5jbGFtcCgocy10KS8oZS10KSwwLDEpO2NsYXNzIHN7aXNWYWxpZCgpe2Zvcihjb25zdCB0IG9mIHRoaXMuX19kYXRhKWlmKHQ9PTEvMHx8aXNOYU4odCkpcmV0dXJuITE7cmV0dXJuITB9c3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHQsZSl7dGhyb3cgbmV3IEVycm9yKCJOb3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIHR5cGU6Iit0aGlzLmNvbnN0cnVjdG9yLm5hbWUpfXN0YXRpYyBudW1FbGVtZW50cygpe3Rocm93IG5ldyBFcnJvcigiTm90IHlldCBpbXBsZW1lbnRlZCBmb3IgdGhpcyB0eXBlOiIrdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKX1hc0FycmF5KCl7cmV0dXJuIHRoaXMuX19kYXRhfXRvU3RyaW5nKCl7cmV0dXJuIGUodGhpcy50b0pTT04oKSl9fWNvbnN0IGE9bmV3IGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fX3R5cGVzPXt9LHRoaXMuX19uYW1lcz17fSx0aGlzLnJlZ2lzdGVyVHlwZSgiU0ludDMyIiw1KSx0aGlzLnJlZ2lzdGVyVHlwZSgiVUludDMyIiw0KSx0aGlzLnJlZ2lzdGVyVHlwZSgiRmxvYXQzMiIsNil9cmVnaXN0ZXJUeXBlKHQsZSl7dGhpcy5fX3R5cGVzW3RdPWUsZS5uYW1lP3RoaXMuX19uYW1lc1tlLm5hbWVdPXQ6dGhpcy5fX25hbWVzW2VdPXR9Z2V0VHlwZSh0KXtyZXR1cm4gdGhpcy5fX3R5cGVzW3RdfWdldFR5cGVOYW1lKHQpe2lmKHRoaXMuX19uYW1lc1t0XSlyZXR1cm4gdGhpcy5fX25hbWVzW3RdO2lmKHRoaXMuX19uYW1lc1t0Lm5hbWVdKXJldHVybiB0aGlzLl9fbmFtZXNbdC5uYW1lXTt0aHJvdyB0fX07Y2xhc3MgaSBleHRlbmRzIHN7Y29uc3RydWN0b3IodD0wLGU9MCl7aWYoc3VwZXIoKSx0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5KXRoaXMuX19kYXRhPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnN0IHM9dCxhPWU7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheShzLGEsMil9ZWxzZSBudWxsIT10JiYib2JqZWN0Ij09dHlwZW9mIHQ/KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMiksdGhpcy5mcm9tSlNPTih0KSk6KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMiksdGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lKX1nZXQgeCgpe3JldHVybiB0aGlzLl9fZGF0YVswXX1zZXQgeCh0KXt0aGlzLl9fZGF0YVswXT10fWdldCB5KCl7cmV0dXJuIHRoaXMuX19kYXRhWzFdfXNldCB5KHQpe3RoaXMuX19kYXRhWzFdPXR9c2V0KHQsZSl7dGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lfXNldEZyb21PdGhlcih0KXt0aGlzLng9dC54LHRoaXMueT10Lnl9ZXF1YWwodCl7cmV0dXJuIHRoaXMueD09dC54JiZ0aGlzLnk9PXQueX1ub3RFcXVhbHModCl7cmV0dXJuIHRoaXMueCE9dC54JiZ0aGlzLnkhPXQueX1hcHByb3hFcXVhbCh0LGU9TnVtYmVyLkVQU0lMT04pe3JldHVybiBNYXRoLmFicyh0aGlzLngtdC54KTxlJiZNYXRoLmFicyh0aGlzLnktdC55KTxlfWFkZCh0KXtyZXR1cm4gbmV3IGkodGhpcy54K3QueCx0aGlzLnkrdC55KX1hZGRJblBsYWNlKHQpe3RoaXMueCs9dC54LHRoaXMueSs9dC55fXN1YnRyYWN0KHQpe3JldHVybiBuZXcgaSh0aGlzLngtdC54LHRoaXMueS10LnkpfXN1YnRyYWN0SW5QbGFjZSh0KXtyZXR1cm4gdGhpcy54LT10LngsdGhpcy55LT10LnksdGhpc31zY2FsZSh0KXtyZXR1cm4gbmV3IGkodGhpcy54KnQsdGhpcy55KnQpfXNjYWxlSW5QbGFjZSh0KXt0aGlzLngqPXQsdGhpcy55Kj10fWludmVydCgpe3JldHVybiBuZXcgaSgxL3RoaXMueCwxL3RoaXMueSl9aW52ZXJ0SW5QbGFjZSgpe3JldHVybiB0aGlzLng9MS90aGlzLngsdGhpcy55PTEvdGhpcy55LHRoaXN9bXVsdGlwbHkodCl7cmV0dXJuIG5ldyBpKHRoaXMueCp0LngsdGhpcy55KnQueSl9bXVsdGlwbHlJblBsYWNlKHQpe3RoaXMueCo9dC54LHRoaXMueSo9dC55fWxlbmd0aFNxdWFyZWQoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV07cmV0dXJuIHQqdCtlKmV9bGVuZ3RoKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxdWFyZWQoKSl9ZGlzdGFuY2VUbyh0KXtjb25zdCBlPXRoaXMuX19kYXRhWzBdLXQueCxzPXRoaXMuX19kYXRhWzFdLXQueTtyZXR1cm4gTWF0aC5zcXJ0KGUqZStzKnMpfW5vcm1hbGl6ZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXTtsZXQgcz10KnQrZSplO3JldHVybiBzPE51bWJlci5FUFNJTE9OP25ldyBpOihzPTEvTWF0aC5zcXJ0KHMpLG5ldyBpKHQqcyxlKnMpKX1ub3JtYWxpemVJblBsYWNlKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdO2xldCBzPXQqdCtlKmU7czxOdW1iZXIuRVBTSUxPTnx8KHM9MS9NYXRoLnNxcnQocyksdGhpcy5zZXQodCpzLGUqcykpfWRvdCh0KXtyZXR1cm4gdGhpcy54KnQueCt0aGlzLnkqdC55fWNyb3NzKHQpe3JldHVybiB0aGlzLngqdC55LXRoaXMueSp0Lnh9YW5nbGVUbyh0KXtjb25zdCBlPXRoaXMubm9ybWFsaXplKCkuZG90KHQubm9ybWFsaXplKCkpO3JldHVybiBlPjE/MDplPC0xP01hdGguUEk6TWF0aC5hY29zKGUpfXNpZ25lZEFuZ2xlVG8odCl7Y29uc3QgZT10aGlzLmFuZ2xlVG8odCk7cmV0dXJuIHRoaXMuY3Jvc3ModCk8MD8tZTplfXJvdGF0ZSh0KXtjb25zdCBlPU1hdGguY29zKHQpLHM9TWF0aC5zaW4odCk7cmV0dXJuIG5ldyBpKHRoaXMueCplLXRoaXMueSpzLHRoaXMueCpzK3RoaXMueSplKX1sZXJwKHQsZSl7Y29uc3Qgcz10aGlzLngsYT10aGlzLnk7cmV0dXJuIG5ldyBpKHMrZSoodC54LXMpLGErZSoodC55LWEpKX1zZXRSYW5kb21EaXIodD0xKXtjb25zdCBlPTIqTWF0aC5yYW5kb20oKSpNYXRoLlBJO3JldHVybiB0aGlzLl9fZGF0YVswXT1NYXRoLmNvcyhlKSp6U2NhbGUsdGhpcy5fX2RhdGFbMV09TWF0aC5zaW4oZSkqelNjYWxlLHRoaXN9c2V0UmFuZG9tKHQ9MSl7cmV0dXJuIHRoaXMuX19kYXRhWzBdPU1hdGgucmFuZG9tKCkqdCx0aGlzLl9fZGF0YVsxXT1NYXRoLnJhbmRvbSgpKnQsdGhpc31jbG9uZSgpe3JldHVybiBuZXcgaSh0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSl9YXNBcnJheSgpe3JldHVybiB0aGlzLl9fZGF0YX1zdGF0aWMgY3JlYXRlKC4uLnQpe3JldHVybiBuZXcgaSguLi50KX1zdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIodCxlPTApe3JldHVybiBuZXcgaSh0LDQqZSl9c3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQXJyYXkodCl7cmV0dXJuIG5ldyBpKHQpfXN0YXRpYyBudW1FbGVtZW50cygpe3JldHVybiAyfXRvSlNPTigpe3JldHVybnt4OnRoaXMueCx5OnRoaXMueX19ZnJvbUpTT04odCl7dGhpcy54PXQueCx0aGlzLnk9dC55fX1hLnJlZ2lzdGVyVHlwZSgiVmVjMiIsaSk7Y2xhc3MgciBleHRlbmRzIHN7Y29uc3RydWN0b3IodD0wLGU9MCxzPTApe2lmKHN1cGVyKCksdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KXRoaXMuX19kYXRhPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnN0IHM9dCxhPWU7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheShzLGEsMyl9ZWxzZSBudWxsIT10JiYib2JqZWN0Ij09dHlwZW9mIHQ/KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMyksdGhpcy5mcm9tSlNPTih0KSk6KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMyksdGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lLHRoaXMuX19kYXRhWzJdPXMpfWdldCB4KCl7cmV0dXJuIHRoaXMuX19kYXRhWzBdfXNldCB4KHQpe3RoaXMuX19kYXRhWzBdPXR9Z2V0IHkoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMV19c2V0IHkodCl7dGhpcy5fX2RhdGFbMV09dH1nZXQgeigpe3JldHVybiB0aGlzLl9fZGF0YVsyXX1zZXQgeih0KXt0aGlzLl9fZGF0YVsyXT10fWdldCB4eSgpe3JldHVybiBuZXcgaSh0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSl9Z2V0IHl6KCl7cmV0dXJuIG5ldyBpKHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdKX1zZXQodCxlLHMpe3RoaXMueD10LHRoaXMueT12b2lkIDAhPT1lP2U6dCx0aGlzLno9dm9pZCAwIT09cz9zOnR9c2V0RGF0YUFycmF5KHQpe3RoaXMuX19kYXRhPXR9c2V0RnJvbU90aGVyKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56fWlzTnVsbCgpe3JldHVybiBNYXRoLmFicyh0aGlzLngpPE51bWJlci5FUFNJTE9OJiZNYXRoLmFicyh0aGlzLnkpPE51bWJlci5FUFNJTE9OJiZNYXRoLmFicyh0aGlzLnopPE51bWJlci5FUFNJTE9OfWlzMTExKCl7cmV0dXJuIE1hdGguYWJzKDEtdGhpcy54KTxOdW1iZXIuRVBTSUxPTiYmTWF0aC5hYnMoMS10aGlzLnkpPE51bWJlci5FUFNJTE9OJiZNYXRoLmFicygxLXRoaXMueik8TnVtYmVyLkVQU0lMT059ZXF1YWwodCl7cmV0dXJuIHRoaXMueD09dC54JiZ0aGlzLnk9PXQueSYmdGhpcy56PT10Lnp9bm90RXF1YWxzKHQpe3JldHVybiB0aGlzLnghPXQueCYmdGhpcy55IT10LnkmJnRoaXMueiE9dC56fWFwcHJveEVxdWFsKHQsZT1OdW1iZXIuRVBTSUxPTil7cmV0dXJuIE1hdGguYWJzKHRoaXMueC10LngpPGUmJk1hdGguYWJzKHRoaXMueS10LnkpPGUmJk1hdGguYWJzKHRoaXMuei10LnopPGV9YWRkKHQpe3JldHVybiBuZXcgcih0aGlzLngrdC54LHRoaXMueSt0LnksdGhpcy56K3Queil9YWRkSW5QbGFjZSh0KXt0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzLnorPXQuen1zdWJ0cmFjdCh0KXtyZXR1cm4gbmV3IHIodGhpcy54LXQueCx0aGlzLnktdC55LHRoaXMuei10LnopfXN1YnRyYWN0SW5QbGFjZSh0KXt0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzLnotPXQuen1tdWx0aXBseSh0KXtyZXR1cm4gbmV3IHIodGhpcy54KnQueCx0aGlzLnkqdC55LHRoaXMueip0LnopfW11bHRpcGx5SW5QbGFjZSh0KXt0aGlzLngqPXQueCx0aGlzLnkqPXQueSx0aGlzLnoqPXQuen1kaXZpZGUodCl7cmV0dXJuIG5ldyByKHRoaXMueC90LngsdGhpcy55L3QueSx0aGlzLnovdC56KX1kaXZpZGVJblBsYWNlKHQpe3RoaXMueC89dC54LHRoaXMueS89dC55LHRoaXMuei89dC56fXNjYWxlKHQpe3JldHVybiBuZXcgcih0aGlzLngqdCx0aGlzLnkqdCx0aGlzLnoqdCl9c2NhbGVJblBsYWNlKHQpe3RoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10fW5lZ2F0ZSgpe3JldHVybiBuZXcgcigtdGhpcy54LC10aGlzLnksLXRoaXMueil9aW52ZXJzZSgpe3JldHVybiBuZXcgcigxL3RoaXMueCwxL3RoaXMueSwxL3RoaXMueil9bGVuZ3RoU3F1YXJlZCgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdO3JldHVybiB0KnQrZSplK3Mqc31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3F1YXJlZCgpKX1kaXN0YW5jZVRvKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGFbMF0tdC54LHM9dGhpcy5fX2RhdGFbMV0tdC55LGE9dGhpcy5fX2RhdGFbMl0tdC56O3JldHVybiBNYXRoLnNxcnQoZSplK3MqcythKmEpfW5vcm1hbGl6ZSgpe2xldCB0PXRoaXMuX19kYXRhWzBdKnRoaXMuX19kYXRhWzBdK3RoaXMuX19kYXRhWzFdKnRoaXMuX19kYXRhWzFdK3RoaXMuX19kYXRhWzJdKnRoaXMuX19kYXRhWzJdO3JldHVybiB0PE51bWJlci5FUFNJTE9OP25ldyByOih0PTEvTWF0aC5zcXJ0KHQpLG5ldyByKHRoaXMuX19kYXRhWzBdKnQsdGhpcy5fX2RhdGFbMV0qdCx0aGlzLl9fZGF0YVsyXSp0KSl9bm9ybWFsaXplSW5QbGFjZSgpe2xldCB0PXRoaXMuX19kYXRhWzBdKnRoaXMuX19kYXRhWzBdK3RoaXMuX19kYXRhWzFdKnRoaXMuX19kYXRhWzFdK3RoaXMuX19kYXRhWzJdKnRoaXMuX19kYXRhWzJdO2lmKHQ8TnVtYmVyLkVQU0lMT04pcmV0dXJuO3Q9TWF0aC5zcXJ0KHQpO2NvbnN0IGU9MS90O3JldHVybiB0aGlzLl9fZGF0YVswXSo9ZSx0aGlzLl9fZGF0YVsxXSo9ZSx0aGlzLl9fZGF0YVsyXSo9ZSx0fXJlc2l6ZSh0KXtjb25zdCBlPXRoaXMuX19kYXRhWzBdKnRoaXMuX19kYXRhWzBdK3RoaXMuX19kYXRhWzFdKnRoaXMuX19kYXRhWzFdK3RoaXMuX19kYXRhWzJdKnRoaXMuX19kYXRhWzJdO2lmKGU8TnVtYmVyLkVQU0lMT04pcmV0dXJuO2NvbnN0IHM9dC9NYXRoLnNxcnQoZSk7cmV0dXJuIG5ldyByKHRoaXMuX19kYXRhWzBdKnMsdGhpcy5fX2RhdGFbMV0qcyx0aGlzLl9fZGF0YVsyXSpzKX1yZXNpemVJblBsYWNlKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGFbMF0qdGhpcy5fX2RhdGFbMF0rdGhpcy5fX2RhdGFbMV0qdGhpcy5fX2RhdGFbMV0rdGhpcy5fX2RhdGFbMl0qdGhpcy5fX2RhdGFbMl07aWYoZTxOdW1iZXIuRVBTSUxPTilyZXR1cm47Y29uc3Qgcz10L01hdGguc3FydChlKTt0aGlzLl9fZGF0YVswXSo9cyx0aGlzLl9fZGF0YVsxXSo9cyx0aGlzLl9fZGF0YVsyXSo9c31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56fWNyb3NzKHQpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGE9dGhpcy56LGk9dC54LG49dC55LGg9dC56O3JldHVybiBuZXcgcihzKmgtYSpuLGEqaS1lKmgsZSpuLXMqaSl9YW5nbGVUbyh0KXtjb25zdCBlPXRoaXMuZG90KHQpO3JldHVybiBlPjE/MDpNYXRoLmFjb3MoZSl9bGVycCh0LGUpe2NvbnN0IHM9dGhpcy54LGE9dGhpcy55LGk9dGhpcy56O3JldHVybiBuZXcgcihzK2UqKHQueC1zKSxhK2UqKHQueS1hKSxpK2UqKHQuei1pKSl9YWJzKCl7cmV0dXJuIG5ldyByKE1hdGguYWJzKHRoaXMueCksTWF0aC5hYnModGhpcy55KSxNYXRoLmFicyh0aGlzLnopKX1zZXRSYW5kb21EaXIodD0xKXtjb25zdCBlPTIqTWF0aC5yYW5kb20oKSpNYXRoLlBJLHM9MipNYXRoLnJhbmRvbSgpLTEsYT1NYXRoLnNxcnQoMS1zKnMpKnQ7cmV0dXJuIHRoaXMuX19kYXRhWzBdPU1hdGguY29zKGUpKmEsdGhpcy5fX2RhdGFbMV09TWF0aC5zaW4oZSkqYSx0aGlzLl9fZGF0YVsyXT1zKnQsdGhpc31zZXRSYW5kb20odD0xKXtyZXR1cm4gdGhpcy5fX2RhdGFbMF09KE1hdGgucmFuZG9tKCktLjUpKnQsdGhpcy5fX2RhdGFbMV09KE1hdGgucmFuZG9tKCktLjUpKnQsdGhpcy5fX2RhdGFbMl09KE1hdGgucmFuZG9tKCktLjUpKnQsdGhpc31jbG9uZSgpe3JldHVybiBuZXcgcih0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVsyXSl9YXNBcnJheSgpe3JldHVybiB0aGlzLl9fZGF0YX1zdGF0aWMgY3JlYXRlKC4uLnQpe3JldHVybiBuZXcgciguLi50KX1zdGF0aWMgY3JlYXRlRnJvbUpTT04odCl7Y29uc3QgZT1uZXcgcjtyZXR1cm4gZS5mcm9tSlNPTih0KSxlfXN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcih0LGU9MCl7cmV0dXJuIG5ldyByKHQsNCplKX1zdGF0aWMgY3JlYXRlRnJvbUZsb2F0MzJBcnJheSh0KXtyZXR1cm4gbmV3IHIodCl9c3RhdGljIG51bUVsZW1lbnRzKCl7cmV0dXJuIDN9dG9KU09OKCl7cmV0dXJue3g6dGhpcy54LHk6dGhpcy55LHo6dGhpcy56fX1mcm9tSlNPTih0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuen19YS5yZWdpc3RlclR5cGUoIlZlYzMiLHIpO2NsYXNzIG4gZXh0ZW5kcyBze2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wLGE9MCl7aWYoc3VwZXIoKSx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnN0IHM9dCxhPWU7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheShzLGEsNCl9ZWxzZSBudWxsIT10JiYib2JqZWN0Ij09dHlwZW9mIHQ/KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoNCksdGhpcy5mcm9tSlNPTih0KSk6KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoNCksdGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lLHRoaXMuX19kYXRhWzJdPXMsdGhpcy5fX2RhdGFbM109YSl9Z2V0IHgoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMF19c2V0IHgodCl7dGhpcy5fX2RhdGFbMF09dH1nZXQgeSgpe3JldHVybiB0aGlzLl9fZGF0YVsxXX1zZXQgeSh0KXt0aGlzLl9fZGF0YVsxXT10fWdldCB6KCl7cmV0dXJuIHRoaXMuX19kYXRhWzJdfXNldCB6KHQpe3RoaXMuX19kYXRhWzJdPXR9Z2V0IHQoKXtyZXR1cm4gdGhpcy5fX2RhdGFbM119c2V0IHQodCl7dGhpcy5fX2RhdGFbM109dH1nZXQgeHl6KCl7cmV0dXJuIG5ldyByKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdKX1zZXQodCxlLHMsYSl7dGhpcy54PXQsdGhpcy55PWUsdGhpcy56PXMsdGhpcy50PWF9c2V0RnJvbU90aGVyKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56LHRoaXMudD10LnR9ZXF1YWwodCl7cmV0dXJuIHRoaXMueD09dC54JiZ0aGlzLnk9PXQueSYmdGhpcy56PT10LnomJnRoaXMudD09dC50fW5vdEVxdWFscyh0KXtyZXR1cm4gdGhpcy54IT10LngmJnRoaXMueSE9dC55JiZ0aGlzLnohPXQueiYmdGhpcy50IT10LnR9YXBwcm94RXF1YWwodCxlPU51bWJlci5FUFNJTE9OKXtyZXR1cm4gTWF0aC5hYnModGhpcy54LXQueCk8ZSYmTWF0aC5hYnModGhpcy55LXQueSk8ZSYmTWF0aC5hYnModGhpcy56LXQueik8ZSYmTWF0aC5hYnModGhpcy50LXQudCk8ZX1hZGQodCl7cmV0dXJuIG5ldyBuKHRoaXMueCt0LngsdGhpcy55K3QueSx0aGlzLnordC56LHRoaXMudCt0LnQpfWFkZEluUGxhY2UodCl7dGhpcy54Kz10LngsdGhpcy55Kz10LnksdGhpcy56Kz10LnosdGhpcy50Kz10LnR9c3VidHJhY3QodCl7cmV0dXJuIG5ldyBuKHRoaXMueC10LngsdGhpcy55LXQueSx0aGlzLnotdC56LHRoaXMudC10LnQpfXN1YnRyYWN0SW5QbGFjZSh0KXt0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzLnotPXQueix0aGlzLnQtPXQudH1tdWx0aXBseSh0KXtyZXR1cm4gbmV3IG4odGhpcy54KnQueCx0aGlzLnkqdC55LHRoaXMueip0LnosdGhpcy50KnQudCl9bXVsdGlwbHlJblBsYWNlKHQpe3RoaXMueCo9dC54LHRoaXMueSo9dC55LHRoaXMueio9dC56LHRoaXMudCo9dC50fWRpdmlkZSh0KXtyZXR1cm4gbmV3IG4odGhpcy54L3QueCx0aGlzLnkvdC55LHRoaXMuei90LnosdGhpcy50L3QudCl9ZGl2aWRlSW5QbGFjZSh0KXt0aGlzLngvPXQueCx0aGlzLnkvPXQueSx0aGlzLnovPXQueix0aGlzLnQvPXQudH1zY2FsZSh0KXtyZXR1cm4gbmV3IG4odGhpcy54KnQsdGhpcy55KnQsdGhpcy56KnQsdGhpcy50KnQpfXNjYWxlSW5QbGFjZSh0KXt0aGlzLnNldCh0aGlzLngqdCx0aGlzLnkqdCx0aGlzLnoqdCx0aGlzLnQqdCl9bGVuZ3RoKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0sYT10aGlzLl9fZGF0YVsyXTtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtlKmUrcypzK2EqYSl9bGVuZ3RoU3F1YXJlZCgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM107cmV0dXJuIHQqdCtlKmUrcypzK2EqYX1ub3JtYWxpemUoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV0scz10aGlzLl9fZGF0YVsyXSxhPXRoaXMuX19kYXRhWzNdO2xldCBpPXQqdCtlKmUrcypzK2EqYTtyZXR1cm4gaTxOdW1iZXIuRVBTSUxPTj9uZXcgbjooaT0xL01hdGguc3FydChpKSxuZXcgbih0KmksZSppLHMqaSkpfW5vcm1hbGl6ZUluUGxhY2UoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV0scz10aGlzLl9fZGF0YVsyXSxhPXRoaXMuX19kYXRhWzNdO2xldCBpPXQqdCtlKmUrcypzK2EqYTtpPE51bWJlci5FUFNJTE9OfHwoaT0xL01hdGguc3FydChpKSx0aGlzLnNldCh0KmksZSppLHMqaSxhKmkpKX1kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56K3RoaXMudCpiLnR9Y3Jvc3ModCl7Y29uc3QgZT10aGlzLngscz10aGlzLnksYT10aGlzLnosaT10aGlzLnQscj10LngsaD10Lnksbz10LnosXz10LnQ7cmV0dXJuIG5ldyBuKHMqby1hKmgsYSpfLWkqbyxpKnItZSpfLGUqaC1zKnIpfWFuZ2xlVG8odCl7Y29uc3QgZT10aGlzLm5vcm1hbGl6ZSgpLHM9dC5ub3JtYWxpemUoKSxhPWUuZG90KHMpO3JldHVybiBhPjE/MDpNYXRoLmFjb3MoYSl9bGVycCh0LGUpe2NvbnN0IHM9dGhpcy54LGE9dGhpcy55LGk9dGhpcy56O3JldHVybiBhdD10aGlzLnQsbmV3IG4ocytlKih0LngtcyksYStlKih0LnktYSksaStlKih0LnotaSksYXQrZSoodC50LWF0KSl9cmFuZG9tKHQ9MSl7Y29uc3QgZT0yKmdsTWF0cml4LlJBTkRPTSgpKk1hdGguUEkscz0yKmdsTWF0cml4LlJBTkRPTSgpLTEsYT1NYXRoLnNxcnQoMS1zKnMpKnQ7cmV0dXJuIG91dFswXT1NYXRoLmNvcyhlKSphLG91dFsxXT1NYXRoLnNpbihlKSphLG91dFsyXT1zKnQsb3V0fWNsb25lKCl7cmV0dXJuIG5ldyBuKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdLHRoaXMuX19kYXRhWzNdKX10b1ZlYzMoKXtyZXR1cm4gbmV3IHIodGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl0pfWFzQXJyYXkoKXtyZXR1cm4gdGhpcy5fX2RhdGF9c3RhdGljIGNyZWF0ZSguLi50KXtyZXR1cm4gbmV3IHIoLi4udCl9c3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHQsZT0wKXtyZXR1cm4gbmV3IG4odCw0KmUpfXN0YXRpYyBudW1FbGVtZW50cygpe3JldHVybiA0fXRvSlNPTigpe3JldHVybnt4OnRoaXMueCx5OnRoaXMueSx6OnRoaXMueix0OnRoaXMudH19fWEucmVnaXN0ZXJUeXBlKCJWZWM0IixuKTtjbGFzcyBoIGV4dGVuZHMgc3tjb25zdHJ1Y3Rvcih0PTAsZT0wLHM9MCxhPTI1NSl7aWYoc3VwZXIoKSx0IGluc3RhbmNlb2YgVWludDhBcnJheSl0aGlzLl9fZGF0YT10O2Vsc2UgaWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtjb25zdCBzPXQsYT1lO3RoaXMuX19kYXRhPW5ldyBVaW50OEFycmF5KHMsYSw0KX1lbHNlIHRoaXMuX19kYXRhPW5ldyBVaW50OEFycmF5KDQpLCJzdHJpbmciPT10eXBlb2YgdD90LnN0YXJ0c1dpdGgoIiMiKT90aGlzLnNldEZyb21IZXgodCk6dGhpcy5zZXRGcm9tQ1NTQ29sb3JOYW1lKHQpOih0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyx0aGlzLl9fZGF0YVszXT1hKX1nZXQgcigpe3JldHVybiB0aGlzLl9fZGF0YVswXX1zZXQgcih0KXt0aGlzLl9fZGF0YVswXT10fWdldCBnKCl7cmV0dXJuIHRoaXMuX19kYXRhWzFdfXNldCBnKHQpe3RoaXMuX19kYXRhWzFdPXR9Z2V0IGIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMl19c2V0IGIodCl7dGhpcy5fX2RhdGFbMl09dH1nZXQgYSgpe3JldHVybiB0aGlzLl9fZGF0YVszXX1zZXQgYSh0KXt0aGlzLl9fZGF0YVszXT10fXNldCh0LGUscyxhPTI1NSl7dGhpcy5yPXQsdGhpcy5nPWUsdGhpcy5iPXMsdGhpcy5hPWF9c2V0RnJvbU90aGVyKHQpe3RoaXMucj10LnIsdGhpcy5nPXQuZyx0aGlzLmI9dC5iLHRoaXMuYT10LmF9c2V0RnJvbUFycmF5KHQpe3RoaXMucj10WzBdLHRoaXMuZz10WzFdLHRoaXMuYj10WzJdLHRoaXMuYT00PT10Lmxlbmd0aD90WzNdOjF9c2V0RnJvbUhleCh0KXtjb25zdCBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9L14jPyhbYS1mXGRdezJ9KShbYS1mXGRdezJ9KShbYS1mXGRdezJ9KSQvaS5leGVjKHQpO3JldHVybiBlP3tyOnBhcnNlSW50KGVbMV0sMTYpLGc6cGFyc2VJbnQoZVsyXSwxNiksYjpwYXJzZUludChlWzNdLDE2KX06bnVsbH0odCk7ZT90aGlzLnNldChlLnIsZS5nLGUuYik6Y29uc29sZS53YXJuKCJJbnZhbGlkIGhleCBjb2RlOiIrdCl9c2V0RnJvbUNTU0NvbG9yTmFtZSh0KXt0LnN0YXJ0c1dpdGgoIiMiKT90aGlzLnNldEZyb21IZXgodCk6dGhpcy5zZXRGcm9tSGV4KCh0PT57Y29uc3QgZT17YWxpY2VibHVlOiIjZjBmOGZmIixhbnRpcXVld2hpdGU6IiNmYWViZDciLGFxdWE6IiMwMGZmZmYiLGFxdWFtYXJpbmU6IiM3ZmZmZDQiLGF6dXJlOiIjZjBmZmZmIixiZWlnZToiI2Y1ZjVkYyIsYmlzcXVlOiIjZmZlNGM0IixibGFjazoiIzAwMDAwMCIsYmxhbmNoZWRhbG1vbmQ6IiNmZmViY2QiLGJsdWU6IiMwMDAwZmYiLGJsdWV2aW9sZXQ6IiM4YTJiZTIiLGJyb3duOiIjYTUyYTJhIixidXJseXdvb2Q6IiNkZWI4ODciLGNhZGV0Ymx1ZToiIzVmOWVhMCIsY2hhcnRyZXVzZToiIzdmZmYwMCIsY2hvY29sYXRlOiIjZDI2OTFlIixjb3JhbDoiI2ZmN2Y1MCIsY29ybmZsb3dlcmJsdWU6IiM2NDk1ZWQiLGNvcm5zaWxrOiIjZmZmOGRjIixjcmltc29uOiIjZGMxNDNjIixjeWFuOiIjMDBmZmZmIixkYXJrYmx1ZToiIzAwMDA4YiIsZGFya2N5YW46IiMwMDhiOGIiLGRhcmtnb2xkZW5yb2Q6IiNiODg2MGIiLGRhcmtncmF5OiIjYTlhOWE5IixkYXJrZ3JlZW46IiMwMDY0MDAiLGRhcmtraGFraToiI2JkYjc2YiIsZGFya21hZ2VudGE6IiM4YjAwOGIiLGRhcmtvbGl2ZWdyZWVuOiIjNTU2YjJmIixkYXJrb3JhbmdlOiIjZmY4YzAwIixkYXJrb3JjaGlkOiIjOTkzMmNjIixkYXJrcmVkOiIjOGIwMDAwIixkYXJrc2FsbW9uOiIjZTk5NjdhIixkYXJrc2VhZ3JlZW46IiM4ZmJjOGYiLGRhcmtzbGF0ZWJsdWU6IiM0ODNkOGIiLGRhcmtzbGF0ZWdyYXk6IiMyZjRmNGYiLGRhcmt0dXJxdW9pc2U6IiMwMGNlZDEiLGRhcmt2aW9sZXQ6IiM5NDAwZDMiLGRlZXBwaW5rOiIjZmYxNDkzIixkZWVwc2t5Ymx1ZToiIzAwYmZmZiIsZGltZ3JheToiIzY5Njk2OSIsZG9kZ2VyYmx1ZToiIzFlOTBmZiIsZmlyZWJyaWNrOiIjYjIyMjIyIixmbG9yYWx3aGl0ZToiI2ZmZmFmMCIsZm9yZXN0Z3JlZW46IiMyMjhiMjIiLGZ1Y2hzaWE6IiNmZjAwZmYiLGdhaW5zYm9ybzoiI2RjZGNkYyIsZ2hvc3R3aGl0ZToiI2Y4ZjhmZiIsZ29sZDoiI2ZmZDcwMCIsZ29sZGVucm9kOiIjZGFhNTIwIixncmF5OiIjODA4MDgwIixncmVlbjoiIzAwODAwMCIsZ3JlZW55ZWxsb3c6IiNhZGZmMmYiLGhvbmV5ZGV3OiIjZjBmZmYwIixob3RwaW5rOiIjZmY2OWI0IiwiaW5kaWFucmVkICI6IiNjZDVjNWMiLGluZGlnbzoiIzRiMDA4MiIsaXZvcnk6IiNmZmZmZjAiLGtoYWtpOiIjZjBlNjhjIixsYXZlbmRlcjoiI2U2ZTZmYSIsbGF2ZW5kZXJibHVzaDoiI2ZmZjBmNSIsbGF3bmdyZWVuOiIjN2NmYzAwIixsZW1vbmNoaWZmb246IiNmZmZhY2QiLGxpZ2h0Ymx1ZToiI2FkZDhlNiIsbGlnaHRjb3JhbDoiI2YwODA4MCIsbGlnaHRjeWFuOiIjZTBmZmZmIixsaWdodGdvbGRlbnJvZHllbGxvdzoiI2ZhZmFkMiIsbGlnaHRncmV5OiIjZDNkM2QzIixsaWdodGdyZWVuOiIjOTBlZTkwIixsaWdodHBpbms6IiNmZmI2YzEiLGxpZ2h0c2FsbW9uOiIjZmZhMDdhIixsaWdodHNlYWdyZWVuOiIjMjBiMmFhIixsaWdodHNreWJsdWU6IiM4N2NlZmEiLGxpZ2h0c2xhdGVncmF5OiIjNzc4ODk5IixsaWdodHN0ZWVsYmx1ZToiI2IwYzRkZSIsbGlnaHR5ZWxsb3c6IiNmZmZmZTAiLGxpbWU6IiMwMGZmMDAiLGxpbWVncmVlbjoiIzMyY2QzMiIsbGluZW46IiNmYWYwZTYiLG1hZ2VudGE6IiNmZjAwZmYiLG1hcm9vbjoiIzgwMDAwMCIsbWVkaXVtYXF1YW1hcmluZToiIzY2Y2RhYSIsbWVkaXVtYmx1ZToiIzAwMDBjZCIsbWVkaXVtb3JjaGlkOiIjYmE1NWQzIixtZWRpdW1wdXJwbGU6IiM5MzcwZDgiLG1lZGl1bXNlYWdyZWVuOiIjM2NiMzcxIixtZWRpdW1zbGF0ZWJsdWU6IiM3YjY4ZWUiLG1lZGl1bXNwcmluZ2dyZWVuOiIjMDBmYTlhIixtZWRpdW10dXJxdW9pc2U6IiM0OGQxY2MiLG1lZGl1bXZpb2xldHJlZDoiI2M3MTU4NSIsbWlkbmlnaHRibHVlOiIjMTkxOTcwIixtaW50Y3JlYW06IiNmNWZmZmEiLG1pc3R5cm9zZToiI2ZmZTRlMSIsbW9jY2FzaW46IiNmZmU0YjUiLG5hdmFqb3doaXRlOiIjZmZkZWFkIixuYXZ5OiIjMDAwMDgwIixvbGRsYWNlOiIjZmRmNWU2IixvbGl2ZToiIzgwODAwMCIsb2xpdmVkcmFiOiIjNmI4ZTIzIixvcmFuZ2U6IiNmZmE1MDAiLG9yYW5nZXJlZDoiI2ZmNDUwMCIsb3JjaGlkOiIjZGE3MGQ2IixwYWxlZ29sZGVucm9kOiIjZWVlOGFhIixwYWxlZ3JlZW46IiM5OGZiOTgiLHBhbGV0dXJxdW9pc2U6IiNhZmVlZWUiLHBhbGV2aW9sZXRyZWQ6IiNkODcwOTMiLHBhcGF5YXdoaXA6IiNmZmVmZDUiLHBlYWNocHVmZjoiI2ZmZGFiOSIscGVydToiI2NkODUzZiIscGluazoiI2ZmYzBjYiIscGx1bToiI2RkYTBkZCIscG93ZGVyYmx1ZToiI2IwZTBlNiIscHVycGxlOiIjODAwMDgwIixyZWJlY2NhcHVycGxlOiIjNjYzMzk5IixyZWQ6IiNmZjAwMDAiLHJvc3licm93bjoiI2JjOGY4ZiIscm95YWxibHVlOiIjNDE2OWUxIixzYWRkbGVicm93bjoiIzhiNDUxMyIsc2FsbW9uOiIjZmE4MDcyIixzYW5keWJyb3duOiIjZjRhNDYwIixzZWFncmVlbjoiIzJlOGI1NyIsc2Vhc2hlbGw6IiNmZmY1ZWUiLHNpZW5uYToiI2EwNTIyZCIsc2lsdmVyOiIjYzBjMGMwIixza3libHVlOiIjODdjZWViIixzbGF0ZWJsdWU6IiM2YTVhY2QiLHNsYXRlZ3JheToiIzcwODA5MCIsc25vdzoiI2ZmZmFmYSIsc3ByaW5nZ3JlZW46IiMwMGZmN2YiLHN0ZWVsYmx1ZToiIzQ2ODJiNCIsdGFuOiIjZDJiNDhjIix0ZWFsOiIjMDA4MDgwIix0aGlzdGxlOiIjZDhiZmQ4Iix0b21hdG86IiNmZjYzNDciLHR1cnF1b2lzZToiIzQwZTBkMCIsdmlvbGV0OiIjZWU4MmVlIix3aGVhdDoiI2Y1ZGViMyIsd2hpdGU6IiNmZmZmZmYiLHdoaXRlc21va2U6IiNmNWY1ZjUiLHllbGxvdzoiI2ZmZmYwMCIseWVsbG93Z3JlZW46IiM5YWNkMzIifTtyZXR1cm4gdm9pZCAwIT09ZVt0LnRvTG93ZXJDYXNlKCldJiZlW3QudG9Mb3dlckNhc2UoKV19KSh0KSl9dG9IZXgoKXtmdW5jdGlvbiB0KHQpe2NvbnN0IGU9dC50b1N0cmluZygxNik7cmV0dXJuIDE9PWUubGVuZ3RoPyIwIitlOmV9cmV0dXJuIiMiK3QodGhpcy5yKSt0KHRoaXMuZykrdCh0aGlzLmIpfWVxdWFsKHQpe3JldHVybiB0aGlzLnI9PXQuciYmdGhpcy5nPT10LmcmJnRoaXMuYj09dC5iJiZ0aGlzLmE9PXQuYX1ub3RlcXVhbHModCl7cmV0dXJuIHRoaXMuciE9dC5yJiZ0aGlzLmchPXQuZyYmdGhpcy5iIT10LmImJnRoaXMuYSE9dC5hfWFwcHJveEVxdWFsKHQsZT1OdW1iZXIuRVBTSUxPTil7cmV0dXJuIE1hdGguYWJzKHRoaXMuci10LnIpPGUmJk1hdGguYWJzKHRoaXMuZy10LmcpPGUmJk1hdGguYWJzKHRoaXMuYi10LmIpPGUmJk1hdGguYWJzKHRoaXMuYS10LmEpPGV9YWRkKHQpe3JldHVybiBuZXcgaCh0aGlzLnIrdC5yLHRoaXMuZyt0LmcsdGhpcy5iK3QuYix0aGlzLmErdC5hKX1zdWJ0cmFjdCh0KXtyZXR1cm4gbmV3IGgodGhpcy5yLXQucix0aGlzLmctdC5nLHRoaXMuYi10LmIsdGhpcy5hLXQuYSl9c2NhbGUodCl7cmV0dXJuIG5ldyBoKHRoaXMucip0LHRoaXMuZyp0LHRoaXMuYip0LHRoaXMuYSp0KX1zY2FsZUluUGxhY2UodCl7dGhpcy5yKj10LHRoaXMuZyo9dCx0aGlzLmIqPXQsdGhpcy5hKj10fWFwcGx5R2FtbWEodCl7dGhpcy5zZXQoTWF0aC5wb3codGhpcy5yLHQpLE1hdGgucG93KHRoaXMuZyx0KSxNYXRoLnBvdyh0aGlzLmIsdCksdGhpcy5hKX10b0xpbmVhcih0PTIuMil7cmV0dXJuIG5ldyBoKE1hdGgucG93KHRoaXMucix0KSxNYXRoLnBvdyh0aGlzLmcsdCksTWF0aC5wb3codGhpcy5iLHQpLHRoaXMuYSl9dG9HYW1tYSh0PTIuMil7cmV0dXJuIG5ldyBoKE1hdGgucG93KHRoaXMuciwxL3QpLE1hdGgucG93KHRoaXMuZywxL3QpLE1hdGgucG93KHRoaXMuYiwxL3QpLHRoaXMuYSl9bHVtaW5hbmNlKCl7cmV0dXJuLjIxMjYqdGhpcy5yKy43MTUyKnRoaXMuZysuMDcyMip0aGlzLmJ9bGVycCh0LGUpe2NvbnN0IHM9dGhpcy5yLGE9dGhpcy5nLGk9dGhpcy5iLHI9dGhpcy5hO3JldHVybiBuZXcgaChzK2UqKHQuci1zKSxhK2UqKHQuZy1hKSxpK2UqKHQuYi1pKSxyK2UqKHQuYS1yKSl9c3RhdGljIHJhbmRvbSh0PTAsZT0hMSl7cmV0dXJuIHQ+MD9uZXcgaCh0K01hdGgucmFuZG9tKCkqKDEtdCksdCtNYXRoLnJhbmRvbSgpKigxLXQpLHQrTWF0aC5yYW5kb20oKSooMS10KSxlP3QrTWF0aC5yYW5kb20oKSooMS10KToxKTp0PDA/bmV3IGgoTWF0aC5yYW5kb20oKSooMSt0KSxNYXRoLnJhbmRvbSgpKigxK3QpLE1hdGgucmFuZG9tKCkqKDErdCksZT9NYXRoLnJhbmRvbSgpKigxK3QpOjEpOm5ldyBoKE1hdGgucmFuZG9tKCksTWF0aC5yYW5kb20oKSxNYXRoLnJhbmRvbSgpLGU/TWF0aC5yYW5kb20oKToxKX1jbG9uZSgpe3JldHVybiBuZXcgaCh0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVsyXSx0aGlzLl9fZGF0YVszXSl9YXNBcnJheSgpe3JldHVybiB0aGlzLl9fZGF0YX1hczNDb21wb25lbnRBcnJheSgpe3JldHVyblt0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVsyXV19c3RhdGljIGNyZWF0ZSguLi50KXtyZXR1cm4gbmV3IGgoLi4udCl9c3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHQsZT0wKXtyZXR1cm4gbmV3IGgodCw0KmUpfXN0YXRpYyBudW1FbGVtZW50cygpe3JldHVybiA0fXRvSlNPTigpe3JldHVybntyOnRoaXMucixnOnRoaXMuZyxiOnRoaXMuYixhOnRoaXMuYX19ZnJvbUpTT04odCl7dGhpcy5yPXQucix0aGlzLmc9dC5nLHRoaXMuYj10LmIsdGhpcy5hPXQuYX10b0NTU1N0cmluZygpe3JldHVybiJyZ2JhKCIrTWF0aC5yb3VuZCgyNTUqdGhpcy5yKSsiLCAiK01hdGgucm91bmQoMjU1KnRoaXMuZykrIiwgIitNYXRoLnJvdW5kKDI1NSp0aGlzLmIpKyIsICIrdGhpcy5hKyIpIn19YS5yZWdpc3RlclR5cGUoIlJHQkEiLGgpO2NsYXNzIG8gZXh0ZW5kcyBze2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wLGE9MSl7aWYoc3VwZXIoKSx0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXRoaXMuX19kYXRhPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnN0IHM9dCxhPWU7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheShzLGEsNCl9ZWxzZSB0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KDQpLCJzdHJpbmciPT10eXBlb2YgdD90LnN0YXJ0c1dpdGgoIiMiKT90aGlzLnNldEZyb21IZXgodCk6dGhpcy5zZXRGcm9tQ1NTQ29sb3JOYW1lKHQpOih0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyx0aGlzLl9fZGF0YVszXT1hKX1nZXQgcigpe3JldHVybiB0aGlzLl9fZGF0YVswXX1zZXQgcih0KXt0aGlzLl9fZGF0YVswXT10fWdldCBnKCl7cmV0dXJuIHRoaXMuX19kYXRhWzFdfXNldCBnKHQpe3RoaXMuX19kYXRhWzFdPXR9Z2V0IGIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMl19c2V0IGIodCl7dGhpcy5fX2RhdGFbMl09dH1nZXQgYSgpe3JldHVybiB0aGlzLl9fZGF0YVszXX1zZXQgYSh0KXt0aGlzLl9fZGF0YVszXT10fXNldCh0LGUscyxhPTEpe3RoaXMucj10LHRoaXMuZz1lLHRoaXMuYj1zLHRoaXMuYT1hfXNldEZyb21PdGhlcih0KXt0aGlzLnI9dC5yLHRoaXMuZz10LmcsdGhpcy5iPXQuYix0aGlzLmE9dC5hfXNldEZyb21TY2FsYXJBcnJheSh0KXt0aGlzLnI9dFswXSx0aGlzLmc9dFsxXSx0aGlzLmI9dFsyXSx0aGlzLmE9ND09dC5sZW5ndGg/dFszXToxfWdldEFzUkdCQXJyYXkoKXtyZXR1cm5bMjU1KnRoaXMuciwyNTUqdGhpcy5nLDI1NSp0aGlzLmJdfWdldEFzUkdCRGljdCgpe3JldHVybntyOjI1NSp0aGlzLnIsZzoyNTUqdGhpcy5nLGI6MjU1KnRoaXMuYn19c2V0RnJvbVJHQih0LGUscyxhKXt0aGlzLnI9dC8yNTUsdGhpcy5nPWUvMjU1LHRoaXMuYj1zLzI1NSx0aGlzLmE9YT9hLzI1NToxfXNldEZyb21SR0JBcnJheSh0KXt0aGlzLnI9dFswXS8yNTUsdGhpcy5nPXRbMV0vMjU1LHRoaXMuYj10WzJdLzI1NSx0aGlzLmE9ND09dC5sZW5ndGg/dFszXS8yNTU6MX1zZXRGcm9tUkdCRGljdCh0KXt0aGlzLnI9dC5yLzI1NSx0aGlzLmc9dC5nLzI1NSx0aGlzLmI9dC5iLzI1NSx0aGlzLmE9ND09dC5hP3QuYS8yNTU6MX1zZXRGcm9tSGV4KHQpe2NvbnN0IGU9ZnVuY3Rpb24odCl7Y29uc3QgZT0vXiM/KFthLWZcZF17Mn0pKFthLWZcZF17Mn0pKFthLWZcZF17Mn0pJC9pLmV4ZWModCk7cmV0dXJuIGU/e3I6cGFyc2VJbnQoZVsxXSwxNiksZzpwYXJzZUludChlWzJdLDE2KSxiOnBhcnNlSW50KGVbM10sMTYpfTpudWxsfSh0KTtlP3RoaXMuc2V0RnJvbVJHQihlLnIsZS5nLGUuYik6Y29uc29sZS53YXJuKCJJbnZhbGlkIGhleCBjb2RlOiIrdCl9c2V0RnJvbUNTU0NvbG9yTmFtZSh0KXt0LnN0YXJ0c1dpdGgoIiMiKT90aGlzLnNldEZyb21IZXgodCk6dGhpcy5zZXRGcm9tSGV4KCh0PT57Y29uc3QgZT17YWxpY2VibHVlOiIjZjBmOGZmIixhbnRpcXVld2hpdGU6IiNmYWViZDciLGFxdWE6IiMwMGZmZmYiLGFxdWFtYXJpbmU6IiM3ZmZmZDQiLGF6dXJlOiIjZjBmZmZmIixiZWlnZToiI2Y1ZjVkYyIsYmlzcXVlOiIjZmZlNGM0IixibGFjazoiIzAwMDAwMCIsYmxhbmNoZWRhbG1vbmQ6IiNmZmViY2QiLGJsdWU6IiMwMDAwZmYiLGJsdWV2aW9sZXQ6IiM4YTJiZTIiLGJyb3duOiIjYTUyYTJhIixidXJseXdvb2Q6IiNkZWI4ODciLGNhZGV0Ymx1ZToiIzVmOWVhMCIsY2hhcnRyZXVzZToiIzdmZmYwMCIsY2hvY29sYXRlOiIjZDI2OTFlIixjb3JhbDoiI2ZmN2Y1MCIsY29ybmZsb3dlcmJsdWU6IiM2NDk1ZWQiLGNvcm5zaWxrOiIjZmZmOGRjIixjcmltc29uOiIjZGMxNDNjIixjeWFuOiIjMDBmZmZmIixkYXJrYmx1ZToiIzAwMDA4YiIsZGFya2N5YW46IiMwMDhiOGIiLGRhcmtnb2xkZW5yb2Q6IiNiODg2MGIiLGRhcmtncmF5OiIjYTlhOWE5IixkYXJrZ3JlZW46IiMwMDY0MDAiLGRhcmtraGFraToiI2JkYjc2YiIsZGFya21hZ2VudGE6IiM4YjAwOGIiLGRhcmtvbGl2ZWdyZWVuOiIjNTU2YjJmIixkYXJrb3JhbmdlOiIjZmY4YzAwIixkYXJrb3JjaGlkOiIjOTkzMmNjIixkYXJrcmVkOiIjOGIwMDAwIixkYXJrc2FsbW9uOiIjZTk5NjdhIixkYXJrc2VhZ3JlZW46IiM4ZmJjOGYiLGRhcmtzbGF0ZWJsdWU6IiM0ODNkOGIiLGRhcmtzbGF0ZWdyYXk6IiMyZjRmNGYiLGRhcmt0dXJxdW9pc2U6IiMwMGNlZDEiLGRhcmt2aW9sZXQ6IiM5NDAwZDMiLGRlZXBwaW5rOiIjZmYxNDkzIixkZWVwc2t5Ymx1ZToiIzAwYmZmZiIsZGltZ3JheToiIzY5Njk2OSIsZG9kZ2VyYmx1ZToiIzFlOTBmZiIsZmlyZWJyaWNrOiIjYjIyMjIyIixmbG9yYWx3aGl0ZToiI2ZmZmFmMCIsZm9yZXN0Z3JlZW46IiMyMjhiMjIiLGZ1Y2hzaWE6IiNmZjAwZmYiLGdhaW5zYm9ybzoiI2RjZGNkYyIsZ2hvc3R3aGl0ZToiI2Y4ZjhmZiIsZ29sZDoiI2ZmZDcwMCIsZ29sZGVucm9kOiIjZGFhNTIwIixncmF5OiIjODA4MDgwIixncmVlbjoiIzAwODAwMCIsZ3JlZW55ZWxsb3c6IiNhZGZmMmYiLGhvbmV5ZGV3OiIjZjBmZmYwIixob3RwaW5rOiIjZmY2OWI0IiwiaW5kaWFucmVkICI6IiNjZDVjNWMiLGluZGlnbzoiIzRiMDA4MiIsaXZvcnk6IiNmZmZmZjAiLGtoYWtpOiIjZjBlNjhjIixsYXZlbmRlcjoiI2U2ZTZmYSIsbGF2ZW5kZXJibHVzaDoiI2ZmZjBmNSIsbGF3bmdyZWVuOiIjN2NmYzAwIixsZW1vbmNoaWZmb246IiNmZmZhY2QiLGxpZ2h0Ymx1ZToiI2FkZDhlNiIsbGlnaHRjb3JhbDoiI2YwODA4MCIsbGlnaHRjeWFuOiIjZTBmZmZmIixsaWdodGdvbGRlbnJvZHllbGxvdzoiI2ZhZmFkMiIsbGlnaHRncmV5OiIjZDNkM2QzIixsaWdodGdyZWVuOiIjOTBlZTkwIixsaWdodHBpbms6IiNmZmI2YzEiLGxpZ2h0c2FsbW9uOiIjZmZhMDdhIixsaWdodHNlYWdyZWVuOiIjMjBiMmFhIixsaWdodHNreWJsdWU6IiM4N2NlZmEiLGxpZ2h0c2xhdGVncmF5OiIjNzc4ODk5IixsaWdodHN0ZWVsYmx1ZToiI2IwYzRkZSIsbGlnaHR5ZWxsb3c6IiNmZmZmZTAiLGxpbWU6IiMwMGZmMDAiLGxpbWVncmVlbjoiIzMyY2QzMiIsbGluZW46IiNmYWYwZTYiLG1hZ2VudGE6IiNmZjAwZmYiLG1hcm9vbjoiIzgwMDAwMCIsbWVkaXVtYXF1YW1hcmluZToiIzY2Y2RhYSIsbWVkaXVtYmx1ZToiIzAwMDBjZCIsbWVkaXVtb3JjaGlkOiIjYmE1NWQzIixtZWRpdW1wdXJwbGU6IiM5MzcwZDgiLG1lZGl1bXNlYWdyZWVuOiIjM2NiMzcxIixtZWRpdW1zbGF0ZWJsdWU6IiM3YjY4ZWUiLG1lZGl1bXNwcmluZ2dyZWVuOiIjMDBmYTlhIixtZWRpdW10dXJxdW9pc2U6IiM0OGQxY2MiLG1lZGl1bXZpb2xldHJlZDoiI2M3MTU4NSIsbWlkbmlnaHRibHVlOiIjMTkxOTcwIixtaW50Y3JlYW06IiNmNWZmZmEiLG1pc3R5cm9zZToiI2ZmZTRlMSIsbW9jY2FzaW46IiNmZmU0YjUiLG5hdmFqb3doaXRlOiIjZmZkZWFkIixuYXZ5OiIjMDAwMDgwIixvbGRsYWNlOiIjZmRmNWU2IixvbGl2ZToiIzgwODAwMCIsb2xpdmVkcmFiOiIjNmI4ZTIzIixvcmFuZ2U6IiNmZmE1MDAiLG9yYW5nZXJlZDoiI2ZmNDUwMCIsb3JjaGlkOiIjZGE3MGQ2IixwYWxlZ29sZGVucm9kOiIjZWVlOGFhIixwYWxlZ3JlZW46IiM5OGZiOTgiLHBhbGV0dXJxdW9pc2U6IiNhZmVlZWUiLHBhbGV2aW9sZXRyZWQ6IiNkODcwOTMiLHBhcGF5YXdoaXA6IiNmZmVmZDUiLHBlYWNocHVmZjoiI2ZmZGFiOSIscGVydToiI2NkODUzZiIscGluazoiI2ZmYzBjYiIscGx1bToiI2RkYTBkZCIscG93ZGVyYmx1ZToiI2IwZTBlNiIscHVycGxlOiIjODAwMDgwIixyZWJlY2NhcHVycGxlOiIjNjYzMzk5IixyZWQ6IiNmZjAwMDAiLHJvc3licm93bjoiI2JjOGY4ZiIscm95YWxibHVlOiIjNDE2OWUxIixzYWRkbGVicm93bjoiIzhiNDUxMyIsc2FsbW9uOiIjZmE4MDcyIixzYW5keWJyb3duOiIjZjRhNDYwIixzZWFncmVlbjoiIzJlOGI1NyIsc2Vhc2hlbGw6IiNmZmY1ZWUiLHNpZW5uYToiI2EwNTIyZCIsc2lsdmVyOiIjYzBjMGMwIixza3libHVlOiIjODdjZWViIixzbGF0ZWJsdWU6IiM2YTVhY2QiLHNsYXRlZ3JheToiIzcwODA5MCIsc25vdzoiI2ZmZmFmYSIsc3ByaW5nZ3JlZW46IiMwMGZmN2YiLHN0ZWVsYmx1ZToiIzQ2ODJiNCIsdGFuOiIjZDJiNDhjIix0ZWFsOiIjMDA4MDgwIix0aGlzdGxlOiIjZDhiZmQ4Iix0b21hdG86IiNmZjYzNDciLHR1cnF1b2lzZToiIzQwZTBkMCIsdmlvbGV0OiIjZWU4MmVlIix3aGVhdDoiI2Y1ZGViMyIsd2hpdGU6IiNmZmZmZmYiLHdoaXRlc21va2U6IiNmNWY1ZjUiLHllbGxvdzoiI2ZmZmYwMCIseWVsbG93Z3JlZW46IiM5YWNkMzIifTtyZXR1cm4gdm9pZCAwIT09ZVt0LnRvTG93ZXJDYXNlKCldJiZlW3QudG9Mb3dlckNhc2UoKV19KSh0KSl9dG9IZXgoKXtmdW5jdGlvbiB0KHQpe2NvbnN0IGU9TWF0aC5yb3VuZCgyNTUqdCkudG9TdHJpbmcoMTYpO3JldHVybiAxPT1lLmxlbmd0aD8iMCIrZTplfXJldHVybiIjIit0KHRoaXMucikrdCh0aGlzLmcpK3QodGhpcy5iKX1lcXVhbCh0KXtyZXR1cm4gdGhpcy5yPT10LnImJnRoaXMuZz09dC5nJiZ0aGlzLmI9PXQuYiYmdGhpcy5hPT10LmF9bm90ZXF1YWxzKHQpe3JldHVybiB0aGlzLnIhPXQuciYmdGhpcy5nIT10LmcmJnRoaXMuYiE9dC5iJiZ0aGlzLmEhPXQuYX1hcHByb3hFcXVhbCh0LGU9TnVtYmVyLkVQU0lMT04pe3JldHVybiBNYXRoLmFicyh0aGlzLnItdC5yKTxlJiZNYXRoLmFicyh0aGlzLmctdC5nKTxlJiZNYXRoLmFicyh0aGlzLmItdC5iKTxlJiZNYXRoLmFicyh0aGlzLmEtdC5hKTxlfWFkZCh0KXtyZXR1cm4gbmV3IG8odGhpcy5yK3Qucix0aGlzLmcrdC5nLHRoaXMuYit0LmIsdGhpcy5hK3QuYSl9c3VidHJhY3QodCl7cmV0dXJuIG5ldyBvKHRoaXMuci10LnIsdGhpcy5nLXQuZyx0aGlzLmItdC5iLHRoaXMuYS10LmEpfXNjYWxlKHQpe3JldHVybiBuZXcgbyh0aGlzLnIqdCx0aGlzLmcqdCx0aGlzLmIqdCx0aGlzLmEqdCl9c2NhbGVJblBsYWNlKHQpe3RoaXMucio9dCx0aGlzLmcqPXQsdGhpcy5iKj10LHRoaXMuYSo9dH1hcHBseUdhbW1hKHQpe3RoaXMuc2V0KE1hdGgucG93KHRoaXMucix0KSxNYXRoLnBvdyh0aGlzLmcsdCksTWF0aC5wb3codGhpcy5iLHQpLHRoaXMuYSl9dG9MaW5lYXIodD0yLjIpe3JldHVybiBuZXcgbyhNYXRoLnBvdyh0aGlzLnIsdCksTWF0aC5wb3codGhpcy5nLHQpLE1hdGgucG93KHRoaXMuYix0KSx0aGlzLmEpfXRvR2FtbWEodD0yLjIpe3JldHVybiBuZXcgbyhNYXRoLnBvdyh0aGlzLnIsMS90KSxNYXRoLnBvdyh0aGlzLmcsMS90KSxNYXRoLnBvdyh0aGlzLmIsMS90KSx0aGlzLmEpfWx1bWluYW5jZSgpe3JldHVybi4yMTI2KnRoaXMucisuNzE1Mip0aGlzLmcrLjA3MjIqdGhpcy5ifWxlcnAodCxlKXtjb25zdCBzPXRoaXMucixhPXRoaXMuZyxpPXRoaXMuYixyPXRoaXMuYTtyZXR1cm4gbmV3IG8ocytlKih0LnItcyksYStlKih0LmctYSksaStlKih0LmItaSkscitlKih0LmEtcikpfXN0YXRpYyByYW5kb20odD0wLGU9ITEpe3JldHVybiB0PjA/bmV3IG8odCtNYXRoLnJhbmRvbSgpKigxLXQpLHQrTWF0aC5yYW5kb20oKSooMS10KSx0K01hdGgucmFuZG9tKCkqKDEtdCksZT90K01hdGgucmFuZG9tKCkqKDEtdCk6MSk6dDwwP25ldyBvKE1hdGgucmFuZG9tKCkqKDErdCksTWF0aC5yYW5kb20oKSooMSt0KSxNYXRoLnJhbmRvbSgpKigxK3QpLGU/TWF0aC5yYW5kb20oKSooMSt0KToxKTpuZXcgbyhNYXRoLnJhbmRvbSgpLE1hdGgucmFuZG9tKCksTWF0aC5yYW5kb20oKSxlP01hdGgucmFuZG9tKCk6MSl9Y2xvbmUoKXtyZXR1cm4gbmV3IG8odGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl0sdGhpcy5fX2RhdGFbM10pfWFzQXJyYXkoKXtyZXR1cm4gdGhpcy5fX2RhdGF9YXMzQ29tcG9uZW50QXJyYXkoKXtyZXR1cm5bdGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl1dfXN0YXRpYyBjcmVhdGUoLi4udCl7cmV0dXJuIG5ldyBvKC4uLnQpfXN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcih0LGU9MCl7cmV0dXJuIG5ldyBvKHQsNCplKX1zdGF0aWMgbnVtRWxlbWVudHMoKXtyZXR1cm4gNH10b0pTT04oKXtyZXR1cm57cjp0aGlzLnIsZzp0aGlzLmcsYjp0aGlzLmIsYTp0aGlzLmF9fWZyb21KU09OKHQpe3RoaXMucj10LnIsdGhpcy5nPXQuZyx0aGlzLmI9dC5iLHRoaXMuYT10LmF9dG9DU1NTdHJpbmcoKXtyZXR1cm4icmdiYSgiK01hdGgucm91bmQoMjU1KnRoaXMucikrIiwgIitNYXRoLnJvdW5kKDI1NSp0aGlzLmcpKyIsICIrTWF0aC5yb3VuZCgyNTUqdGhpcy5iKSsiLCAiK3RoaXMuYSsiKSJ9fWEucmVnaXN0ZXJUeXBlKCJDb2xvciIsbyk7Y2xhc3MgXyBleHRlbmRzIHN7Y29uc3RydWN0b3IodD0wLGU9MCxzPTAsYT0wKXtpZihzdXBlcigpLGlzTmFOKGEpKXN3aXRjaChhKXtjYXNlIlhZWiI6dGhpcy5vcmRlcj0wO2JyZWFrO2Nhc2UiWVpYIjp0aGlzLm9yZGVyPTE7YnJlYWs7Y2FzZSJaWFkiOnRoaXMub3JkZXI9MjticmVhaztjYXNlIlhaWSI6dGhpcy5vcmRlcj0zO2JyZWFrO2Nhc2UiWllYIjp0aGlzLm9yZGVyPTQ7YnJlYWs7Y2FzZSJZWFoiOnRoaXMub3JkZXI9NTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiSW52YWxpZCBFdWxlciBBbmdsZXMgT3JkZXI6IithKX1lbHNlIHRoaXMub3JkZXI9YTtpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnN0IHM9dCxhPWU7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheShzLGEsNCl9ZWxzZSB0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KDMpLHRoaXMuX19kYXRhWzBdPXQsdGhpcy5fX2RhdGFbMV09ZSx0aGlzLl9fZGF0YVsyXT1zfWdldCB4KCl7cmV0dXJuIHRoaXMuX19kYXRhWzBdfXNldCB4KHQpe3RoaXMuX19kYXRhWzBdPXR9Z2V0IHkoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMV19c2V0IHkodCl7dGhpcy5fX2RhdGFbMV09dH1nZXQgeigpe3JldHVybiB0aGlzLl9fZGF0YVsyXX1zZXQgeih0KXt0aGlzLl9fZGF0YVsyXT10fXNldCh0LGUscyl7dGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lLHRoaXMuX19kYXRhWzJdPXN9fWEucmVnaXN0ZXJUeXBlKCJFdWxlckFuZ2xlcyIsXyk7Y2xhc3MgZCBleHRlbmRzIHN7Y29uc3RydWN0b3IodD0xLGU9MCxzPTAsYT0wLGk9MSxyPTAsbj0wLGg9MCxvPTEpe2lmKHN1cGVyKCksdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtjb25zdCBzPXQsYT1lO3RoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkocyxhLDkpfWVsc2UgdGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheSg5KSx0aGlzLnNldCh0LGUscyxhLGkscixuLGgsbyl9Z2V0IG0wMCgpe3JldHVybiB0aGlzLl9fZGF0YVswXX1zZXQgbTAwKHQpe3RoaXMuX19kYXRhWzBdPXR9Z2V0IG0wMSgpe3JldHVybiB0aGlzLl9fZGF0YVsxXX1zZXQgbTAxKHQpe3RoaXMuX19kYXRhWzFdPXR9Z2V0IG0wMigpe3JldHVybiB0aGlzLl9fZGF0YVsyXX1zZXQgbTAyKHQpe3RoaXMuX19kYXRhWzJdPXR9Z2V0IG0xMCgpe3JldHVybiB0aGlzLl9fZGF0YVszXX1zZXQgbTEwKHQpe3RoaXMuX19kYXRhWzNdPXR9Z2V0IG0xMSgpe3JldHVybiB0aGlzLl9fZGF0YVs0XX1zZXQgbTExKHQpe3RoaXMuX19kYXRhWzRdPXR9Z2V0IG0xMigpe3JldHVybiB0aGlzLl9fZGF0YVs1XX1zZXQgbTEyKHQpe3RoaXMuX19kYXRhWzVdPXR9Z2V0IG0yMCgpe3JldHVybiB0aGlzLl9fZGF0YVs2XX1zZXQgbTIwKHQpe3RoaXMuX19kYXRhWzZdPXR9Z2V0IG0yMSgpe3JldHVybiB0aGlzLl9fZGF0YVs3XX1zZXQgbTIxKHQpe3RoaXMuX19kYXRhWzddPXR9Z2V0IG0yMigpe3JldHVybiB0aGlzLl9fZGF0YVs4XX1zZXQgbTIyKHQpe3RoaXMuX19kYXRhWzhdPXR9Z2V0IHhBeGlzKCl7cmV0dXJuIHIuY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLDApfXNldCB4QXhpcyh0KXt0aGlzLnhBeGlzLnNldCh0LngsdC55LHQueil9Z2V0IHlBeGlzKCl7cmV0dXJuIHIuY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLDMpfXNldCB5QXhpcyh0KXt0aGlzLnlBeGlzLnNldCh0LngsdC55LHQueil9Z2V0IHpBeGlzKCl7cmV0dXJuIHIuY3JlYXRlRnJvbUZsb2F0MzJCdWZmZXIodGhpcy5fX2RhdGEuYnVmZmVyLDYpfXNldCB6QXhpcyh0KXt0aGlzLnpBeGlzLnNldCh0LngsdC55LHQueil9c2V0KHQ9MSxlPTAscz0wLGE9MCxpPTEscj0wLG49MCxoPTAsbz0xKXt0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyx0aGlzLl9fZGF0YVszXT1hLHRoaXMuX19kYXRhWzRdPWksdGhpcy5fX2RhdGFbNV09cix0aGlzLl9fZGF0YVs2XT1uLHRoaXMuX19kYXRhWzddPWgsdGhpcy5fX2RhdGFbOF09b31zZXRJZGVudGl0eSgpe3RoaXMuc2V0KCl9c2V0RnJvbU1hdCh0KXt0aGlzLl9fZGF0YVswXT10Lm0wMCx0aGlzLl9fZGF0YVsxXT10Lm0wMSx0aGlzLl9fZGF0YVsyXT10Lm0wMix0aGlzLl9fZGF0YVszXT10Lm0xMCx0aGlzLl9fZGF0YVs0XT10Lm0xMSx0aGlzLl9fZGF0YVs1XT10Lm0xMix0aGlzLl9fZGF0YVs2XT10Lm0yMCx0aGlzLl9fZGF0YVs3XT10Lm0yMSx0aGlzLl9fZGF0YVs4XT10Lm0yMn1zZXRGcm9tRGlyZWN0aW9uQW5kVXB2ZWN0b3IodCxlKXtjb25zdCBzPXQsYT1zLmxlbmd0aCgpO2lmKGE8TnVtYmVyLkVQU0lMT04pcmV0dXJuIHZvaWQgdGhpcy5zZXRJZGVudGl0eSgpO3Muc2NhbGVJblBsYWNlKDEvYSk7Y29uc3QgaT1lLmNyb3NzKHMpLHI9aS5sZW5ndGgoKTtyPk51bWJlci5FUFNJTE9OJiZpLnNjYWxlSW5QbGFjZSgxL3IpO2NvbnN0IG49cy5jcm9zcyhpKSxoPW4ubGVuZ3RoKCk7aD5OdW1iZXIuRVBTSUxPTiYmbi5zY2FsZUluUGxhY2UoMS9oKSx0aGlzLnNldChpLngsaS55LGkueixuLngsbi55LG4ueixzLngscy55LHMueil9aW52ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM10saT10aGlzLl9fZGF0YVs0XSxyPXRoaXMuX19kYXRhWzVdLG49dGhpcy5fX2RhdGFbNl0saD10aGlzLl9fZGF0YVs3XSxvPXRoaXMuX19kYXRhWzhdLF89byppLXIqaCxsPS1vKmErcipuLGM9aCphLWkqbix1PXQqXytlKmwrcypjO3JldHVybiB1Pyh1PTEvdSxuZXcgZChfKnUsKC1vKmUrcypoKSp1LChyKmUtcyppKSp1LGwqdSwobyp0LXMqbikqdSwoLXIqdCtzKmEpKnUsYyp1LCgtaCp0K2UqbikqdSwoaSp0LWUqYSkqdSkpOihjb25zb2xlLndhcm4oIlVuYWJsZSB0byBpbnZlcnQgTWF0MyIpLG51bGwpfWludmVydEluUGxhY2UoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV0scz10aGlzLl9fZGF0YVsyXSxhPXRoaXMuX19kYXRhWzNdLGk9dGhpcy5fX2RhdGFbNF0scj10aGlzLl9fZGF0YVs1XSxuPXRoaXMuX19kYXRhWzZdLGg9dGhpcy5fX2RhdGFbN10sbz10aGlzLl9fZGF0YVs4XSxfPW8qaS1yKmgsZD0tbyphK3IqbixsPWgqYS1pKm4sYz10Kl8rZSpkK3MqbDtyZXR1cm4gYz8oYz0xL2MsdGhpcy5zZXQoXypjLCgtbyplK3MqaCkqYywociplLXMqaSkqYyxkKmMsKG8qdC1zKm4pKmMsKC1yKnQrcyphKSpjLGwqYywoLWgqdCtlKm4pKmMsKGkqdC1lKmEpKmMpLCEwKTooY29uc29sZS53YXJuKCJVbmFibGUgdG8gaW52ZXJ0IE1hdDMiKSwhMSl9dHJhbnNwb3NlKCl7cmV0dXJuIGQodGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbM10sdGhpcy5fX2RhdGFbNl0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbNF0sdGhpcy5fX2RhdGFbN10sdGhpcy5fX2RhdGFbMl0sdGhpcy5fX2RhdGFbNV0sdGhpcy5fX2RhdGFbOF0pfXRyYW5zcG9zZUluUGxhY2UoKXtjb25zdCB0PXRoaXMuX19kYXRhWzFdLGU9dGhpcy5fX2RhdGFbMl0scz10aGlzLl9fZGF0YVs1XTt0aGlzLl9fZGF0YVsxXT10aGlzLl9fZGF0YVszXSx0aGlzLl9fZGF0YVsyXT10aGlzLl9fZGF0YVs2XSx0aGlzLl9fZGF0YVszXT10LHRoaXMuX19kYXRhWzVdPXRoaXMuX19kYXRhWzddLHRoaXMuX19kYXRhWzZdPWUsdGhpcy5fX2RhdGFbN109c310cmFuc2Zvcm1WZWMzKHQpe3JldHVybiBuZXcgcih0aGlzLl9fZGF0YVswXSp0LngrdGhpcy5fX2RhdGFbMV0qdC55K3RoaXMuX19kYXRhWzJdKnQueix0aGlzLl9fZGF0YVszXSp0LngrdGhpcy5fX2RhdGFbNF0qdC55K3RoaXMuX19kYXRhWzVdKnQueix0aGlzLl9fZGF0YVs2XSp0LngrdGhpcy5fX2RhdGFbN10qdC55K3RoaXMuX19kYXRhWzhdKnQueil9Y2xvbmUoKXtyZXR1cm4gbmV3IGQodGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl0sdGhpcy5fX2RhdGFbM10sdGhpcy5fX2RhdGFbNF0sdGhpcy5fX2RhdGFbNV0sdGhpcy5fX2RhdGFbNl0sdGhpcy5fX2RhdGFbN10sdGhpcy5fX2RhdGFbOF0sdGhpcy5fX2RhdGFbOV0pfXN0YXRpYyBjcmVhdGUoLi4udCl7cmV0dXJuIG5ldyBkKC4uLnQpfXN0YXRpYyBjcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcih0LGU9MCl7cmV0dXJuIG5ldyBkKHQsNCplKX10b0pTT04oKXtyZXR1cm4gdGhpcy5fX2RhdGF9ZnJvbUpTT04odCl7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheSh0KX10b1N0cmluZygpe3JldHVybiB0aGlzLnRvSlNPTigpLnRvU3RyaW5nKCl9fWEucmVnaXN0ZXJUeXBlKCJNYXQzIixkKTtjbGFzcyBsIGV4dGVuZHMgc3tjb25zdHJ1Y3Rvcih0PTEsZT0wLHM9MCxhPTAsaT0wLHI9MSxuPTAsaD0wLG89MCxfPTAsZD0xLGw9MCxjPTAsdT0wLGY9MCxtPTEpe2lmKHN1cGVyKCksdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSl0aGlzLl9fZGF0YT10O2Vsc2UgaWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtjb25zdCBzPXQsYT1lO3RoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkocyxhLDE2KX1lbHNlIHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMTYpLHRoaXMuc2V0KHQsZSxzLGEsaSxyLG4saCxvLF8sZCxsLGMsdSxmLG0pfWdldCBtMDAoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMF19c2V0IG0wMCh0KXt0aGlzLl9fZGF0YVswXT10fWdldCBtMDEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMV19c2V0IG0wMSh0KXt0aGlzLl9fZGF0YVsxXT10fWdldCBtMDIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMl19c2V0IG0wMih0KXt0aGlzLl9fZGF0YVsyXT10fWdldCBtMDMoKXtyZXR1cm4gdGhpcy5fX2RhdGFbM119c2V0IG0wMyh0KXt0aGlzLl9fZGF0YVszXT10fWdldCBtMTAoKXtyZXR1cm4gdGhpcy5fX2RhdGFbNF19c2V0IG0xMCh0KXt0aGlzLl9fZGF0YVs0XT10fWdldCBtMTEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbNV19c2V0IG0xMSh0KXt0aGlzLl9fZGF0YVs1XT10fWdldCBtMTIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbNl19c2V0IG0xMih0KXt0aGlzLl9fZGF0YVs2XT10fWdldCBtMTMoKXtyZXR1cm4gdGhpcy5fX2RhdGFbN119c2V0IG0xMyh0KXt0aGlzLl9fZGF0YVs3XT10fWdldCBtMjAoKXtyZXR1cm4gdGhpcy5fX2RhdGFbOF19c2V0IG0yMCh0KXt0aGlzLl9fZGF0YVs4XT10fWdldCBtMjEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbOV19c2V0IG0yMSh0KXt0aGlzLl9fZGF0YVs5XT10fWdldCBtMjIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMTBdfXNldCBtMjIodCl7dGhpcy5fX2RhdGFbMTBdPXR9Z2V0IG0yMygpe3JldHVybiB0aGlzLl9fZGF0YVsxMV19c2V0IG0yMyh0KXt0aGlzLl9fZGF0YVsxMV09dH1nZXQgbTMwKCl7cmV0dXJuIHRoaXMuX19kYXRhWzEyXX1zZXQgbTMwKHQpe3RoaXMuX19kYXRhWzEyXT10fWdldCBtMzEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMTNdfXNldCBtMzEodCl7dGhpcy5fX2RhdGFbMTNdPXR9Z2V0IG0zMigpe3JldHVybiB0aGlzLl9fZGF0YVsxNF19c2V0IG0zMih0KXt0aGlzLl9fZGF0YVsxNF09dH1nZXQgbTMzKCl7cmV0dXJuIHRoaXMuX19kYXRhWzE1XX1zZXQgbTMzKHQpe3RoaXMuX19kYXRhWzE1XT10fWdldCB4QXhpcygpe3JldHVybiByLmNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwwKX1zZXQgeEF4aXModCl7dGhpcy54QXhpcy5zZXQodC54LHQueSx0LnopfWdldCB5QXhpcygpe3JldHVybiByLmNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciw0KX1zZXQgeUF4aXModCl7dGhpcy55QXhpcy5zZXQodC54LHQueSx0LnopfWdldCB6QXhpcygpe3JldHVybiByLmNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciw4KX1zZXQgekF4aXModCl7dGhpcy56QXhpcy5zZXQodC54LHQueSx0LnopfWdldCB0cmFuc2xhdGlvbigpe3JldHVybiByLmNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlciwxMil9c2V0IHRyYW5zbGF0aW9uKHQpe3RoaXMudHJhbnNsYXRpb24uc2V0KHQueCx0LnksdC56KX1zZXQodD0xLGU9MCxzPTAsYT0wLGk9MCxyPTEsbj0wLGg9MCxvPTAsXz0wLGQ9MSxsPTAsYz0wLHU9MCxmPTAsbT0xKXt0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyx0aGlzLl9fZGF0YVszXT1hLHRoaXMuX19kYXRhWzRdPWksdGhpcy5fX2RhdGFbNV09cix0aGlzLl9fZGF0YVs2XT1uLHRoaXMuX19kYXRhWzddPWgsdGhpcy5fX2RhdGFbOF09byx0aGlzLl9fZGF0YVs5XT1fLHRoaXMuX19kYXRhWzEwXT1kLHRoaXMuX19kYXRhWzExXT1sLHRoaXMuX19kYXRhWzEyXT1jLHRoaXMuX19kYXRhWzEzXT11LHRoaXMuX19kYXRhWzE0XT1mLHRoaXMuX19kYXRhWzE1XT1tfXNldElkZW50aXR5KCl7dGhpcy5zZXQoKX1zZXREYXRhQXJyYXkodCl7dGhpcy5fX2RhdGE9dH1zZXRGcm9tTWF0NCh0KXt0aGlzLl9fZGF0YVswXT10Lm0wMCx0aGlzLl9fZGF0YVsxXT10Lm0wMSx0aGlzLl9fZGF0YVsyXT10Lm0wMix0aGlzLl9fZGF0YVszXT10Lm0wMyx0aGlzLl9fZGF0YVs0XT10Lm0xMCx0aGlzLl9fZGF0YVs1XT10Lm0xMSx0aGlzLl9fZGF0YVs2XT10Lm0xMix0aGlzLl9fZGF0YVs3XT10Lm0xMyx0aGlzLl9fZGF0YVs4XT10Lm0yMCx0aGlzLl9fZGF0YVs5XT10Lm0yMSx0aGlzLl9fZGF0YVsxMF09dC5tMjIsdGhpcy5fX2RhdGFbMTFdPXQubTIzLHRoaXMuX19kYXRhWzEyXT10Lm0zMCx0aGlzLl9fZGF0YVsxM109dC5tMzEsdGhpcy5fX2RhdGFbMTRdPXQubTMyLHRoaXMuX19kYXRhWzE1XT10Lm0zM310b01hdDModCl7cmV0dXJuIG5ldyBkKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdLHRoaXMuX19kYXRhWzRdLHRoaXMuX19kYXRhWzVdLHRoaXMuX19kYXRhWzZdLHRoaXMuX19kYXRhWzhdLHRoaXMuX19kYXRhWzldLHRoaXMuX19kYXRhWzEwXSl9dHJhbnNwb3NlSW5QbGFjZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMV0sZT10aGlzLl9fZGF0YVsyXSxzPXRoaXMuX19kYXRhWzNdLGE9dGhpcy5fX2RhdGFbNl0saT10aGlzLl9fZGF0YVs3XSxyPXRoaXMuX19kYXRhWzExXTt0aGlzLl9fZGF0YVsxXT10aGlzLl9fZGF0YVs0XSx0aGlzLl9fZGF0YVsyXT10aGlzLl9fZGF0YVs4XSx0aGlzLl9fZGF0YVszXT10aGlzLl9fZGF0YVsxMl0sdGhpcy5fX2RhdGFbNF09dCx0aGlzLl9fZGF0YVs2XT10aGlzLl9fZGF0YVs5XSx0aGlzLl9fZGF0YVs3XT10aGlzLl9fZGF0YVsxM10sdGhpcy5fX2RhdGFbOF09ZSx0aGlzLl9fZGF0YVs5XT1hLHRoaXMuX19kYXRhWzExXT10aGlzLl9fZGF0YVsxNF0sdGhpcy5fX2RhdGFbMTJdPXMsdGhpcy5fX2RhdGFbMTNdPWksdGhpcy5fX2RhdGFbMTRdPXJ9dHJhbnNwb3NlKCl7cmV0dXJuIG5ldyBsKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzRdLHRoaXMuX19kYXRhWzhdLHRoaXMuX19kYXRhWzEyXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVs1XSx0aGlzLl9fZGF0YVs5XSx0aGlzLl9fZGF0YVsxM10sdGhpcy5fX2RhdGFbMl0sdGhpcy5fX2RhdGFbNl0sdGhpcy5fX2RhdGFbMTBdLHRoaXMuX19kYXRhWzE0XSx0aGlzLl9fZGF0YVszXSx0aGlzLl9fZGF0YVs3XSx0aGlzLl9fZGF0YVsxMV0sdGhpcy5fX2RhdGFbMTVdKX1pbnZlcnNlKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0sYT10aGlzLl9fZGF0YVszXSxpPXRoaXMuX19kYXRhWzRdLHI9dGhpcy5fX2RhdGFbNV0sbj10aGlzLl9fZGF0YVs2XSxoPXRoaXMuX19kYXRhWzddLG89dGhpcy5fX2RhdGFbOF0sXz10aGlzLl9fZGF0YVs5XSxkPXRoaXMuX19kYXRhWzEwXSxjPXRoaXMuX19kYXRhWzExXSx1PXRoaXMuX19kYXRhWzEyXSxmPXRoaXMuX19kYXRhWzEzXSxtPXRoaXMuX19kYXRhWzE0XSxnPXRoaXMuX19kYXRhWzE1XSx5PXQqci1lKmkscD10Km4tcyppLGI9dCpoLWEqaSx4PWUqbi1zKnIsdz1lKmgtYSpyLEk9cypoLWEqbixOPW8qZi1fKnUsRj1vKm0tZCp1LHo9bypnLWMqdSxWPV8qbS1kKmYsTT1fKmctYypmLEE9ZCpnLWMqbTtsZXQgUz15KkEtcCpNK2IqVit4KnotdypGK0kqTjtyZXR1cm4gUz8oUz0xL1MsbmV3IGwoKHIqQS1uKk0raCpWKSpTLChzKk0tZSpBLWEqVikqUywoZipJLW0qdytnKngpKlMsKGQqdy1fKkktYyp4KSpTLChuKnotaSpBLWgqRikqUywodCpBLXMqeithKkYpKlMsKG0qYi11KkktZypwKSpTLChvKkktZCpiK2MqcCkqUywoaSpNLXIqeitoKk4pKlMsKGUqei10Kk0tYSpOKSpTLCh1KnctZipiK2cqeSkqUywoXypiLW8qdy1jKnkpKlMsKHIqRi1pKlYtbipOKSpTLCh0KlYtZSpGK3MqTikqUywoZipwLXUqeC1tKnkpKlMsKG8qeC1fKnArZCp5KSpTKSk6KGNvbnNvbGUud2FybigiVW5hYmxlIHRvIGludmVydCBNYXQ0IiksbnVsbCl9aW52ZXJ0SW5QbGFjZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM10saT10aGlzLl9fZGF0YVs0XSxyPXRoaXMuX19kYXRhWzVdLG49dGhpcy5fX2RhdGFbNl0saD10aGlzLl9fZGF0YVs3XSxvPXRoaXMuX19kYXRhWzhdLF89dGhpcy5fX2RhdGFbOV0sZD10aGlzLl9fZGF0YVsxMF0sbD10aGlzLl9fZGF0YVsxMV0sYz10aGlzLl9fZGF0YVsxMl0sdT10aGlzLl9fZGF0YVsxM10sZj10aGlzLl9fZGF0YVsxNF0sbT10aGlzLl9fZGF0YVsxNV0sZz10KnItZSppLHk9dCpuLXMqaSxwPXQqaC1hKmksYj1lKm4tcypyLHg9ZSpoLWEqcix3PXMqaC1hKm4sST1vKnUtXypjLE49bypmLWQqYyxGPW8qbS1sKmMsej1fKmYtZCp1LFY9XyptLWwqdSxNPWQqbS1sKmY7bGV0IEE9ZypNLXkqVitwKnorYipGLXgqTit3Kkk7cmV0dXJuIEE/KEE9MS9BLHRoaXMuc2V0KChyKk0tbipWK2gqeikqQSwocypWLWUqTS1hKnopKkEsKHUqdy1mKngrbSpiKSpBLChkKngtXyp3LWwqYikqQSwobipGLWkqTS1oKk4pKkEsKHQqTS1zKkYrYSpOKSpBLChmKnAtYyp3LW0qeSkqQSwobyp3LWQqcCtsKnkpKkEsKGkqVi1yKkYraCpJKSpBLChlKkYtdCpWLWEqSSkqQSwoYyp4LXUqcCttKmcpKkEsKF8qcC1vKngtbCpnKSpBLChyKk4taSp6LW4qSSkqQSwodCp6LWUqTitzKkkpKkEsKHUqeS1jKmItZipnKSpBLChvKmItXyp5K2QqZykqQSksITApOihjb25zb2xlLndhcm4oIlVuYWJsZSB0byBpbnZlcnQgTWF0NCIpLCExKX1zZXRJbnZlcnNlKHQpe2NvbnN0IGU9dC5fX2RhdGFbMF0scz10Ll9fZGF0YVsxXSxhPXQuX19kYXRhWzJdLGk9dC5fX2RhdGFbM10scj10Ll9fZGF0YVs0XSxuPXQuX19kYXRhWzVdLGg9dC5fX2RhdGFbNl0sbz10Ll9fZGF0YVs3XSxfPXQuX19kYXRhWzhdLGQ9dC5fX2RhdGFbOV0sbD10Ll9fZGF0YVsxMF0sYz10Ll9fZGF0YVsxMV0sdT10Ll9fZGF0YVsxMl0sZj10Ll9fZGF0YVsxM10sbT10Ll9fZGF0YVsxNF0sZz10Ll9fZGF0YVsxNV0seT1lKm4tcypyLHA9ZSpoLWEqcixiPWUqby1pKnIseD1zKmgtYSpuLHc9cypvLWkqbixJPWEqby1pKmgsTj1fKmYtZCp1LEY9XyptLWwqdSx6PV8qZy1jKnUsVj1kKm0tbCpmLE09ZCpnLWMqZixBPWwqZy1jKm07bGV0IFM9eSpBLXAqTStiKlYreCp6LXcqRitJKk47aWYoIVMpdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gaW52ZXJ0IE1hdDQiKTtTPTEvUyx0aGlzLnNldCgobipBLWgqTStvKlYpKlMsKGEqTS1zKkEtaSpWKSpTLChmKkktbSp3K2cqeCkqUywobCp3LWQqSS1jKngpKlMsKGgqei1yKkEtbypGKSpTLChlKkEtYSp6K2kqRikqUywobSpiLXUqSS1nKnApKlMsKF8qSS1sKmIrYypwKSpTLChyKk0tbip6K28qTikqUywocyp6LWUqTS1pKk4pKlMsKHUqdy1mKmIrZyp5KSpTLChkKmItXyp3LWMqeSkqUywobipGLXIqVi1oKk4pKlMsKGUqVi1zKkYrYSpOKSpTLChmKnAtdSp4LW0qeSkqUywoXyp4LWQqcCtsKnkpKlMpfW11bHRpcGx5KHQpe2NvbnN0IGU9dGhpcy5fX2RhdGFbMF0scz10aGlzLl9fZGF0YVsxXSxhPXRoaXMuX19kYXRhWzJdLGk9dGhpcy5fX2RhdGFbM10scj10aGlzLl9fZGF0YVs0XSxuPXRoaXMuX19kYXRhWzVdLGg9dGhpcy5fX2RhdGFbNl0sbz10aGlzLl9fZGF0YVs3XSxfPXRoaXMuX19kYXRhWzhdLGQ9dGhpcy5fX2RhdGFbOV0sYz10aGlzLl9fZGF0YVsxMF0sdT10aGlzLl9fZGF0YVsxMV0sZj10aGlzLl9fZGF0YVsxMl0sbT10aGlzLl9fZGF0YVsxM10sZz10aGlzLl9fZGF0YVsxNF0seT10aGlzLl9fZGF0YVsxNV0scD10LmFzQXJyYXkoKTtsZXQgYj1wWzBdLHg9cFsxXSx3PXBbMl0sST1wWzNdO2NvbnN0IE49bmV3IGw7cmV0dXJuIE4ubTAwPWIqZSt4KnIrdypfK0kqZixOLm0wMT1iKnMreCpuK3cqZCtJKm0sTi5tMDI9YiphK3gqaCt3KmMrSSpnLE4ubTAzPWIqaSt4Km8rdyp1K0kqeSxiPXBbNF0seD1wWzVdLHc9cFs2XSxJPXBbN10sTi5tMTA9YiplK3gqcit3Kl8rSSpmLE4ubTExPWIqcyt4Km4rdypkK0kqbSxOLm0xMj1iKmEreCpoK3cqYytJKmcsTi5tMTM9YippK3gqbyt3KnUrSSp5LGI9cFs4XSx4PXBbOV0sdz1wWzEwXSxJPXBbMTFdLE4ubTIwPWIqZSt4KnIrdypfK0kqZixOLm0yMT1iKnMreCpuK3cqZCtJKm0sTi5tMjI9YiphK3gqaCt3KmMrSSpnLE4ubTIzPWIqaSt4Km8rdyp1K0kqeSxiPXBbMTJdLHg9cFsxM10sdz1wWzE0XSxJPXBbMTVdLE4ubTMwPWIqZSt4KnIrdypfK0kqZixOLm0zMT1iKnMreCpuK3cqZCtJKm0sTi5tMzI9YiphK3gqaCt3KmMrSSpnLE4ubTMzPWIqaSt4Km8rdyp1K0kqeSxOfW11bHRpcGx5SW5QbGFjZSh0KXtjb25zdCBlPXRoaXMuYXNBcnJheSgpLHM9ZVswXSxhPWVbMV0saT1lWzJdLHI9ZVszXSxuPWVbNF0saD1lWzVdLG89ZVs2XSxfPWVbN10sZD1lWzhdLGw9ZVs5XSxjPWVbMTBdLHU9ZVsxMV0sZj1lWzEyXSxtPWVbMTNdLGc9ZVsxNF0seT1lWzE1XSxwPXQuYXNBcnJheSgpO2xldCBiPXBbMF0seD1wWzFdLHc9cFsyXSxJPXBbM107cmV0dXJuIHRoaXMubTAwPWIqcyt4Km4rdypkK0kqZix0aGlzLm0wMT1iKmEreCpoK3cqbCtJKm0sdGhpcy5tMDI9YippK3gqbyt3KmMrSSpnLHRoaXMubTAzPWIqcit4Kl8rdyp1K0kqeSxiPXBbNF0seD1wWzVdLHc9cFs2XSxJPXBbN10sdGhpcy5tMTA9YipzK3gqbit3KmQrSSpmLHRoaXMubTExPWIqYSt4KmgrdypsK0kqbSx0aGlzLm0xMj1iKmkreCpvK3cqYytJKmcsdGhpcy5tMTM9YipyK3gqXyt3KnUrSSp5LGI9cFs4XSx4PXBbOV0sdz1wWzEwXSxJPXBbMTFdLHRoaXMubTIwPWIqcyt4Km4rdypkK0kqZix0aGlzLm0yMT1iKmEreCpoK3cqbCtJKm0sdGhpcy5tMjI9YippK3gqbyt3KmMrSSpnLHRoaXMubTIzPWIqcit4Kl8rdyp1K0kqeSxiPXBbMTJdLHg9cFsxM10sdz1wWzE0XSxJPXBbMTVdLHRoaXMubTMwPWIqcyt4Km4rdypkK0kqZix0aGlzLm0zMT1iKmEreCpoK3cqbCtJKm0sdGhpcy5tMzI9YippK3gqbyt3KmMrSSpnLHRoaXMubTMzPWIqcit4Kl8rdyp1K0kqeSx0aGlzfXBvc3RtdWx0aXBseUluUGxhY2UodCl7Y29uc3QgZT10LmFzQXJyYXkoKSxzPWVbMF0sYT1lWzFdLGk9ZVsyXSxyPWVbM10sbj1lWzRdLGg9ZVs1XSxvPWVbNl0sXz1lWzddLGQ9ZVs4XSxsPWVbOV0sYz1lWzEwXSx1PWVbMTFdLGY9ZVsxMl0sbT1lWzEzXSxnPWVbMTRdLHk9ZVsxNV0scD10aGlzLmFzQXJyYXkoKTtsZXQgYj1wWzBdLHg9cFsxXSx3PXBbMl0sST1wWzNdO3JldHVybiB0aGlzLm0wMD1iKnMreCpuK3cqZCtJKmYsdGhpcy5tMDE9YiphK3gqaCt3KmwrSSptLHRoaXMubTAyPWIqaSt4Km8rdypjK0kqZyx0aGlzLm0wMz1iKnIreCpfK3cqdStJKnksYj1wWzRdLHg9cFs1XSx3PXBbNl0sST1wWzddLHRoaXMubTEwPWIqcyt4Km4rdypkK0kqZix0aGlzLm0xMT1iKmEreCpoK3cqbCtJKm0sdGhpcy5tMTI9YippK3gqbyt3KmMrSSpnLHRoaXMubTEzPWIqcit4Kl8rdyp1K0kqeSxiPXBbOF0seD1wWzldLHc9cFsxMF0sST1wWzExXSx0aGlzLm0yMD1iKnMreCpuK3cqZCtJKmYsdGhpcy5tMjE9YiphK3gqaCt3KmwrSSptLHRoaXMubTIyPWIqaSt4Km8rdypjK0kqZyx0aGlzLm0yMz1iKnIreCpfK3cqdStJKnksYj1wWzEyXSx4PXBbMTNdLHc9cFsxNF0sST1wWzE1XSx0aGlzLm0zMD1iKnMreCpuK3cqZCtJKmYsdGhpcy5tMzE9YiphK3gqaCt3KmwrSSptLHRoaXMubTMyPWIqaSt4Km8rdypjK0kqZyx0aGlzLm0zMz1iKnIreCpfK3cqdStJKnksdGhpc310cmFuc2xhdGVJblBsYWNlKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGEscz10LngsYT10LnksaT10Lno7cmV0dXJuIGVbMTJdPWVbMF0qcytlWzRdKmErZVs4XSppK2VbMTJdLGVbMTNdPWVbMV0qcytlWzVdKmErZVs5XSppK2VbMTNdLGVbMTRdPWVbMl0qcytlWzZdKmErZVsxMF0qaStlWzE0XSxlWzE1XT1lWzNdKnMrZVs3XSphK2VbMTFdKmkrZVsxNV0sdGhpc31zZXRMb29rQXQodCxlLHMpe2NvbnN0IGE9dC5zdWJ0cmFjdChlKSxpPWEubGVuZ3RoKCk7aWYoaTxOdW1iZXIuRVBTSUxPTilyZXR1cm4gdm9pZCB0aGlzLnNldElkZW50aXR5KCk7YS5zY2FsZUluUGxhY2UoMS9pKTtjb25zdCByPXMuY3Jvc3MoYSksbj1yLmxlbmd0aCgpO24+TnVtYmVyLkVQU0lMT04mJnIuc2NhbGVJblBsYWNlKDEvbik7Y29uc3QgaD1hLmNyb3NzKHIpLG89aC5sZW5ndGgoKTtvPk51bWJlci5FUFNJTE9OJiZoLnNjYWxlSW5QbGFjZSgxL28pLHRoaXMuc2V0KHIueCxyLnksci56LDAsaC54LGgueSxoLnosMCxhLngsYS55LGEueiwwLHQueCx0LnksdC56LDEpfXNldFJvdGF0aW9uKHQsZSl7Y29uc3Qgcz10Lmxlbmd0aCgpO2lmKE1hdGguYWJzKHMpPE51bWJlci5FUFNJTE9OKXJldHVybiBudWxsO2NvbnN0IGE9dC54L3MsaT10LnkvcyxyPXQuei9zLG49TWF0aC5zaW4oZSksaD1NYXRoLmNvcyhlKSxvPTEtaCxfPXRoaXMuX19kYXRhO3JldHVybiBfWzBdPWEqYSpvK2gsX1sxXT1pKmEqbytyKm4sX1syXT1yKmEqby1pKm4sX1szXT0wLF9bNF09YSppKm8tcipuLF9bNV09aSppKm8raCxfWzZdPXIqaSpvK2EqbixfWzddPTAsX1s4XT1hKnIqbytpKm4sX1s5XT1pKnIqby1hKm4sX1sxMF09cipyKm8raCxfWzExXT0wLF9bMTJdPTAsX1sxM109MCxfWzE0XT0wLF9bMTVdPTEsdGhpc31zZXRYUm90YXRpb24odCl7Y29uc3QgZT1NYXRoLnNpbih0KSxzPU1hdGguY29zKHQpLGE9dGhpcy5fX2RhdGE7cmV0dXJuIGFbMF09MSxhWzFdPTAsYVsyXT0wLGFbM109MCxhWzRdPTAsYVs1XT1zLGFbNl09ZSxhWzddPTAsYVs4XT0wLGFbOV09LWUsYVsxMF09cyxhWzExXT0wLGFbMTJdPTAsYVsxM109MCxhWzE0XT0wLGFbMTVdPTEsdGhpc31zZXRZUm90YXRpb24odCl7Y29uc3QgZT1NYXRoLnNpbih0KSxzPU1hdGguY29zKHQpLGE9dGhpcy5fX2RhdGE7cmV0dXJuIGFbMF09cyxhWzFdPTAsYVsyXT0tZSxhWzNdPTAsYVs0XT0wLGFbNV09MSxhWzZdPTAsYVs3XT0wLGFbOF09ZSxhWzldPTAsYVsxMF09cyxhWzExXT0wLGFbMTJdPTAsYVsxM109MCxhWzE0XT0wLGFbMTVdPTEsdGhpc31zZXRaUm90YXRpb24odCl7Y29uc3QgZT1NYXRoLnNpbih0KSxzPU1hdGguY29zKHQpLGE9dGhpcy5fX2RhdGE7cmV0dXJuIGFbMF09cyxhWzFdPWUsYVsyXT0wLGFbM109MCxhWzRdPS1lLGFbNV09cyxhWzZdPTAsYVs3XT0wLGFbOF09MCxhWzldPTAsYVsxMF09MSxhWzExXT0wLGFbMTJdPTAsYVsxM109MCxhWzE0XT0wLGFbMTVdPTEsdGhpc310cmFuc2Zvcm1WZWM0KHQpe2NvbnN0IGU9dGhpcy5fX2RhdGEscz10LngsYT10LnksaT10Lnoscj10LnQ7cmV0dXJuIG5ldyBWZWM0KGVbMF0qcytlWzRdKmErZVs4XSppK2VbMTJdKnIsZVsxXSpzK2VbNV0qYStlWzldKmkrZVsxM10qcixlWzJdKnMrZVs2XSphK2VbMTBdKmkrZVsxNF0qcixlWzNdKnMrZVs3XSphK2VbMTFdKmkrZVsxNV0qcil9dHJhbnNmb3JtVmVjMyh0KXtjb25zdCBlPXRoaXMuX19kYXRhLHM9dC54LGE9dC55LGk9dC56O3JldHVybiBuZXcgcihlWzBdKnMrZVs0XSphK2VbOF0qaStlWzEyXSxlWzFdKnMrZVs1XSphK2VbOV0qaStlWzEzXSxlWzJdKnMrZVs2XSphK2VbMTBdKmkrZVsxNF0pfXJvdGF0ZVZlYzModCl7Y29uc3QgZT10aGlzLl9fZGF0YSxzPXQueCxhPXQueSxpPXQuejtyZXR1cm4gbmV3IHIoZVswXSpzK2VbNF0qYStlWzhdKmksZVsxXSpzK2VbNV0qYStlWzldKmksZVsyXSpzK2VbNl0qYStlWzEwXSppKX1zZXRQZXJzcGVjdGl2ZU1hdHJpeCh0LGUscyxhKXtjb25zdCBpPU1hdGgudGFuKC41Kk1hdGguUEktLjUqdCkscj0xLyhzLWEpO3RoaXMuc2V0KGkvZSwwLDAsMCwwLGksMCwwLDAsMCwocythKSpyLC0xLDAsMCxzKmEqcioyLDApfXNldE9ydGhvZ3JhcGhpY01hdHJpeCh0LGUscyxhLGkscil7Y29uc3Qgbj0xLyh0LWUpLGg9MS8ocy1hKSxvPTEvKGktcik7dGhpcy5zZXQoLTIqbiwwLDAsMCwwLC0yKmgsMCwwLDAsMCwyKm8sMCwodCtlKSpuLChhK3MpKmgsKHIraSkqbywxKX1zZXRTY2FsZSh0LGUscyl7dCBpbnN0YW5jZW9mIHI/dGhpcy5zZXQodC54LDAsMCwwLDAsdC55LDAsMCwwLDAsdC56LDAsMCwwLDAsMSk6dGhpcy5zZXQodCwwLDAsMCwwLGUsMCwwLDAsMCxzLDAsMCwwLDAsMSl9c2V0RnJvbU1hdDN4NEFycmF5KHQpe3RoaXMuc2V0KHRbMF0sdFsxXSx0WzJdLDAsdFszXSx0WzRdLHRbNV0sMCx0WzZdLHRbN10sdFs4XSwwLHRbOV0sdFsxMF0sdFsxMV0sMSl9c3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHQsZT0wKXtyZXR1cm4gbmV3IGwodCw0KmUpfWNsb25lKCl7cmV0dXJuIG5ldyBsKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdLHRoaXMuX19kYXRhWzNdLHRoaXMuX19kYXRhWzRdLHRoaXMuX19kYXRhWzVdLHRoaXMuX19kYXRhWzZdLHRoaXMuX19kYXRhWzddLHRoaXMuX19kYXRhWzhdLHRoaXMuX19kYXRhWzldLHRoaXMuX19kYXRhWzEwXSx0aGlzLl9fZGF0YVsxMV0sdGhpcy5fX2RhdGFbMTJdLHRoaXMuX19kYXRhWzEzXSx0aGlzLl9fZGF0YVsxNF0sdGhpcy5fX2RhdGFbMTVdKX1zdGF0aWMgY3JlYXRlKC4uLnQpe3JldHVybiBuZXcgbCguLi50KX10b0pTT04oKXtyZXR1cm4gdGhpcy5fX2RhdGF9ZnJvbUpTT04odCl7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheSh0KX19YS5yZWdpc3RlclR5cGUoIk1hdDQiLGwpO2NsYXNzIHUgZXh0ZW5kcyBze2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wLGE9MSl7aWYoc3VwZXIoKSx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnN0IHM9dCxhPWU7dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheShzLGEsNCl9ZWxzZSBpZih0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KDQpLCJvYmplY3QiPT10eXBlb2YgdCl7dGhpcy5fX2RhdGFbMF09MCx0aGlzLl9fZGF0YVsxXT0wLHRoaXMuX19kYXRhWzJdPTAsdGhpcy5fX2RhdGFbM109MTtmb3IoY29uc3QgZSBpbiB0KUFycmF5LmlzQXJyYXkodFtlXSk/dGhpc1tlXS5jYWxsKHRoaXMsLi4udFtlXSk6dGhpc1tlXS5jYWxsKHRoaXMsdFtlXSl9ZWxzZSB0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyx0aGlzLl9fZGF0YVszXT1hfWdldCB4KCl7cmV0dXJuIHRoaXMuX19kYXRhWzBdfXNldCB4KHQpe3RoaXMuX19kYXRhWzBdPXR9Z2V0IHkoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMV19c2V0IHkodCl7dGhpcy5fX2RhdGFbMV09dH1nZXQgeigpe3JldHVybiB0aGlzLl9fZGF0YVsyXX1zZXQgeih0KXt0aGlzLl9fZGF0YVsyXT10fWdldCB3KCl7cmV0dXJuIHRoaXMuX19kYXRhWzNdfXNldCB3KHQpe3RoaXMuX19kYXRhWzNdPXR9c2V0KHQsZSxzLGEpe3RoaXMuX19kYXRhWzBdPXQsdGhpcy5fX2RhdGFbMV09ZSx0aGlzLl9fZGF0YVsyXT1zLHRoaXMuX19kYXRhWzNdPWF9c2V0RGF0YUFycmF5KHQpe3RoaXMuX19kYXRhPXR9c2V0RnJvbU90aGVyKHQpe3RoaXMuX19kYXRhWzBdPXQueCx0aGlzLl9fZGF0YVsxXT10LnksdGhpcy5fX2RhdGFbMl09dC56LHRoaXMuX19kYXRhWzNdPXQud31zZXRGcm9tRXVsZXJBbmdsZXModCl7Y29uc3QgZT1uZXcgcjtzd2l0Y2godC5vcmRlcil7Y2FzZSAwOmUuc2V0KHQueCwtdC55LHQueik7YnJlYWs7Y2FzZSAxOmUuc2V0KHQueSwtdC56LHQueCk7YnJlYWs7Y2FzZSAyOmUuc2V0KHQueiwtdC54LHQueSk7YnJlYWs7Y2FzZSAzOmUuc2V0KHQueCx0LnosdC55KTticmVhaztjYXNlIDQ6ZS5zZXQodC56LHQueSx0LngpO2JyZWFrO2Nhc2UgNTplLnNldCh0LnksdC54LHQueik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoInNkcnR5Iil9Y29uc3Qgcz0uNSplLngsYT0uNSplLnksaT0uNSplLnosbj1NYXRoLmNvcyhzKSxoPU1hdGguY29zKGEpLG89TWF0aC5jb3MoaSksXz1NYXRoLnNpbihzKSxkPU1hdGguc2luKGEpLGw9TWF0aC5zaW4oaSksYz1uKm8sdT1uKmwsZj1fKm8sbT1fKmwsZz1oKmYtZCp1LHk9aCptK2QqYyxwPWgqdS1kKmY7c3dpdGNoKHRoaXMudz1oKmMrZCptLHQub3JkZXIpe2Nhc2UgMDp0aGlzLng9Zyx0aGlzLnk9LXksdGhpcy56PXA7YnJlYWs7Y2FzZSAxOnRoaXMueD1wLHRoaXMueT1nLHRoaXMuej0teTticmVhaztjYXNlIDI6dGhpcy54PS15LHRoaXMueT1wLHRoaXMuej1nO2JyZWFrO2Nhc2UgMzp0aGlzLng9Zyx0aGlzLnk9cCx0aGlzLno9eTticmVhaztjYXNlIDQ6dGhpcy54PXAsdGhpcy55PXksdGhpcy56PWc7YnJlYWs7Y2FzZSA1OnRoaXMueD15LHRoaXMueT1nLHRoaXMuej1wO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJzZHJ0eSIpfX10b0V1bGVyQW5nbGVzKHQpe2NvbnN0IGU9bmV3IHI7c3dpdGNoKHQpe2Nhc2UgMDplLnNldCh0aGlzLnosdGhpcy54LHRoaXMueSk7YnJlYWs7Y2FzZSAxOmUuc2V0KHRoaXMueCx0aGlzLnksdGhpcy56KTticmVhaztjYXNlIDI6ZS5zZXQodGhpcy55LHRoaXMueix0aGlzLngpO2JyZWFrO2Nhc2UgMzplLnNldCh0aGlzLnksLXRoaXMueCx0aGlzLnopO2JyZWFrO2Nhc2UgNDplLnNldCh0aGlzLngsLXRoaXMueix0aGlzLnkpO2JyZWFrO2Nhc2UgNTplLnNldCh0aGlzLnosLXRoaXMueSx0aGlzLngpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHJvdGF0aW9uIG9yZGVyOiIrdCl9Y29uc3Qgcz1uZXcgcixhPWUueCplLnkrZS56KnRoaXMudztpZihhPi40OTk5OSlzLnk9MipNYXRoLmF0YW4yKGUueCx0aGlzLncpLHMuej0uNSpNYXRoLlBJLHMueD0wO2Vsc2UgaWYoYTwtLjQ5OTk5KXMueT0tMipNYXRoLmF0YW4yKGUueCx0aGlzLncpLHMuej0tLjUqTWF0aC5QSSxzLng9MDtlbHNle2NvbnN0IHQ9ZS54KmUueCxpPWUueSplLnkscj1lLnoqZS56O3MueT1NYXRoLmF0YW4yKDIqZS55KnRoaXMudy0yKmUueCplLnosMS0yKmktMipyKSxzLno9TWF0aC5hc2luKDIqYSkscy54PU1hdGguYXRhbjIoMiplLngqdGhpcy53LTIqZS55KmUueiwxLTIqdC0yKnIpfXN3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIG5ldyBfKHMueSxzLnoscy54LHQpO2Nhc2UgMTpyZXR1cm4gbmV3IF8ocy54LHMueSxzLnosdCk7Y2FzZSAyOnJldHVybiBuZXcgXyhzLnoscy54LHMueSx0KTtjYXNlIDM6cmV0dXJuIG5ldyBfKC1zLnkscy54LHMueix0KTtjYXNlIDQ6cmV0dXJuIG5ldyBfKHMueCxzLnosLXMueSx0KTtjYXNlIDU6cmV0dXJuIG5ldyBfKHMueiwtcy55LHMueCx0KX19c2V0RnJvbUF4aXNBbmRBbmdsZSh0LGUpe2NvbnN0IHM9ZS8yLGE9dC5ub3JtYWxpemUoKS5zY2FsZShNYXRoLnNpbihzKSk7dGhpcy5zZXQoYS54LGEueSxhLnosTWF0aC5jb3MocykpfXNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3Rvcih0LGUpe2NvbnN0IHM9bmV3IGQ7cy5zZXRGcm9tRGlyZWN0aW9uQW5kVXB2ZWN0b3IodCxlKSx0aGlzLnNldEZyb21NYXQzKHMpfXNldEZyb20yVmVjdG9ycyh0LGUpe3Qubm9ybWFsaXplKCksZS5ub3JtYWxpemUoKTtjb25zdCBzPXQuY3Jvc3MoZSksYT10LmRvdChlKSxpPU1hdGguc3FydCgyKigxK2EpKTt0aGlzLnNldChzLngvaSxzLnkvaSxzLnovaSxpLzIpLHRoaXMubm9ybWFsaXplSW5QbGFjZSgpfXNldEZyb21NYXQzKHQpe2NvbnN0IGU9dC5fX2RhdGFbMF0rdC5fX2RhdGFbNF0rdC5fX2RhdGFbOF07bGV0IHM7aWYoZT4wKXM9TWF0aC5zcXJ0KGUrMSksdGhpcy5fX2RhdGFbM109LjUqcyxzPS41L3MsdGhpcy5fX2RhdGFbMF09KHQuX19kYXRhWzVdLXQuX19kYXRhWzddKSpzLHRoaXMuX19kYXRhWzFdPSh0Ll9fZGF0YVs2XS10Ll9fZGF0YVsyXSkqcyx0aGlzLl9fZGF0YVsyXT0odC5fX2RhdGFbMV0tdC5fX2RhdGFbM10pKnM7ZWxzZXtsZXQgZT0wO3QuX19kYXRhWzRdPnQuX19kYXRhWzBdJiYoZT0xKSx0Ll9fZGF0YVs4XT50Ll9fZGF0YVszKmUrZV0mJihlPTIpO2NvbnN0IGE9KGUrMSklMyxpPShlKzIpJTM7cz1NYXRoLnNxcnQodC5fX2RhdGFbMyplK2VdLXQuX19kYXRhWzMqYSthXS10Ll9fZGF0YVszKmkraV0rMSksdGhpcy5fX2RhdGFbZV09LjUqcyxzPS41L3MsdGhpcy5fX2RhdGFbM109KHQuX19kYXRhWzMqYStpXS10Ll9fZGF0YVszKmkrYV0pKnMsdGhpcy5fX2RhdGFbYV09KHQuX19kYXRhWzMqYStlXSt0Ll9fZGF0YVszKmUrYV0pKnMsdGhpcy5fX2RhdGFbaV09KHQuX19kYXRhWzMqaStlXSt0Ll9fZGF0YVszKmUraV0pKnN9dGhpcy5ub3JtYWxpemVJblBsYWNlKCl9c2V0RnJvbU1hdDQodCl7Y29uc3QgZT10Ll9fZGF0YVswXSt0Ll9fZGF0YVs1XSt0Ll9fZGF0YVsxMF07bGV0IHM7aWYoZT4wKXM9TWF0aC5zcXJ0KGUrMSksdGhpcy5fX2RhdGFbM109LjUqcyxzPS41L3MsdGhpcy5fX2RhdGFbMF09KHQuX19kYXRhWzZdLXQuX19kYXRhWzldKSpzLHRoaXMuX19kYXRhWzFdPSh0Ll9fZGF0YVs4XS10Ll9fZGF0YVsyXSkqcyx0aGlzLl9fZGF0YVsyXT0odC5fX2RhdGFbMV0tdC5fX2RhdGFbNF0pKnM7ZWxzZXtsZXQgZT0wO3QuX19kYXRhWzVdPnQuX19kYXRhWzBdJiYoZT0xKSx0Ll9fZGF0YVsxMF0+dC5fX2RhdGFbNCplK2VdJiYoZT0yKTtjb25zdCBhPShlKzEpJTMsaT0oZSsyKSUzO3M9TWF0aC5zcXJ0KHQuX19kYXRhWzQqZStlXS10Ll9fZGF0YVs0KmErYV0tdC5fX2RhdGFbNCppK2ldKzEpLHRoaXMuX19kYXRhW2VdPS41KnMscz0uNS9zLHRoaXMuX19kYXRhWzNdPSh0Ll9fZGF0YVs0KmEraV0tdC5fX2RhdGFbNCppK2FdKSpzLHRoaXMuX19kYXRhW2FdPSh0Ll9fZGF0YVs0KmErZV0rdC5fX2RhdGFbNCplK2FdKSpzLHRoaXMuX19kYXRhW2ldPSh0Ll9fZGF0YVs0KmkrZV0rdC5fX2RhdGFbNCplK2ldKSpzfXRoaXMubm9ybWFsaXplSW5QbGFjZSgpfWlzSWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5nZXRBbmdsZSgpPE51bWJlci5FUFNJTE9OfWdldEFuZ2xlKCl7cmV0dXJuIDIqTWF0aC5hY29zKHRoaXMudyl9ZXF1YWwodCl7cmV0dXJuIHRoaXMueD09dC54JiZ0aGlzLnk9PXQueSYmdGhpcy56PT10LnomJnRoaXMudz09dC53fW5vdGVxdWFscyh0KXtyZXR1cm4gdGhpcy54IT10LngmJnRoaXMueSE9dC55JiZ0aGlzLnohPXQueiYmdGhpcy53IT10Lnd9YXBwcm94RXF1YWwodCxlPU51bWJlci5FUFNJTE9OKXtyZXR1cm4gTWF0aC5hYnModGhpcy54LXQueCk8ZSYmTWF0aC5hYnModGhpcy55LXQueSk8ZSYmTWF0aC5hYnModGhpcy56LXQueik8ZSYmTWF0aC5hYnModGhpcy53LXQudyk8ZX1hZGQodCl7cmV0dXJuIG5ldyB1KHRoaXMueCt0LngsdGhpcy55K3QueSx0aGlzLnordC56LHRoaXMudyt0LncpfWFkZEluUGxhY2UodCl7dGhpcy54Kz10LngsdGhpcy55Kz10LnksdGhpcy56Kz10LnosdGhpcy53Kz10Lnd9c3VidHJhY3QodCl7cmV0dXJuIG5ldyB1KHRoaXMueC10LngsdGhpcy55LXQueSx0aGlzLnotdC56LHRoaXMudy10LncpfXNjYWxlKHQpe3JldHVybiBuZXcgdSh0aGlzLngqdCx0aGlzLnkqdCx0aGlzLnoqdCx0aGlzLncqdCl9c2NhbGVJblBsYWNlKHQpe3RoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10LHRoaXMudyo9dH1sZW5ndGgoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV0scz10aGlzLl9fZGF0YVsyXSxhPXRoaXMuX19kYXRhWzNdO3JldHVybiBNYXRoLnNxcnQodCp0K2UqZStzKnMrYSphKX1sZW5ndGhTcXVhcmVkKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0sYT10aGlzLl9fZGF0YVszXTtyZXR1cm4gdCp0K2UqZStzKnMrYSphfW5vcm1hbGl6ZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM107bGV0IGk9dCp0K2UqZStzKnMrYSphO3JldHVybiBpPE51bWJlci5FUFNJTE9OP25ldyB1OihpPTEvTWF0aC5zcXJ0KGkpLG5ldyB1KHQqaSxlKmkscyppKSl9bm9ybWFsaXplSW5QbGFjZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM107bGV0IGk9dCp0K2UqZStzKnMrYSphO2k8TnVtYmVyLkVQU0lMT058fChpPTEvTWF0aC5zcXJ0KGkpLHRoaXMuc2V0KHQqaSxlKmkscyppLGEqaSkpfWRvdCh0KXtyZXR1cm4gdGhpcy54KnQueCt0aGlzLnkqdC55K3RoaXMueip0LnordGhpcy53KnQud31jcm9zcyh0KXtjb25zdCBlPXRoaXMueCxzPXRoaXMueSxhPXRoaXMueixpPXRoaXMudyxyPXQueCxuPXQueSxoPXQueixvPXQudztyZXR1cm4gbmV3IHUocypoLWEqbixhKm8taSpoLGkqci1lKm8sZSpuLXMqcil9Y29uanVnYXRlKCl7cmV0dXJuIG5ldyB1KC10aGlzLngsLXRoaXMueSwtdGhpcy56LHRoaXMudyl9aW52ZXJzZSgpe3JldHVybiB0aGlzLmNvbmp1Z2F0ZSgpfWFsaWduV2l0aCh0KXt0aGlzLmRvdCh0KTwwJiZ0aGlzLnNldCgtdGhpcy54LC10aGlzLnksLXRoaXMueiwtdGhpcy53KX1tdWx0aXBseSh0KXtjb25zdCBlPXRoaXMuX19kYXRhWzBdLHM9dGhpcy5fX2RhdGFbMV0sYT10aGlzLl9fZGF0YVsyXSxpPXRoaXMuX19kYXRhWzNdLHI9dC5fX2RhdGFbMF0sbj10Ll9fZGF0YVsxXSxoPXQuX19kYXRhWzJdLG89dC5fX2RhdGFbM107cmV0dXJuIG5ldyB1KGUqbytpKnIrcypoLWEqbixzKm8raSpuK2Eqci1lKmgsYSpvK2kqaCtlKm4tcypyLGkqby1lKnItcypuLWEqaCl9bXVsdGlwbHlJblBsYWNlKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGFbMF0scz10aGlzLl9fZGF0YVsxXSxhPXRoaXMuX19kYXRhWzJdLGk9dGhpcy5fX2RhdGFbM10scj10Ll9fZGF0YVswXSxuPXQuX19kYXRhWzFdLGg9dC5fX2RhdGFbMl0sbz10Ll9fZGF0YVszXTt0aGlzLnNldChlKm8raSpyK3MqaC1hKm4scypvK2kqbithKnItZSpoLGEqbytpKmgrZSpuLXMqcixpKm8tZSpyLXMqbi1hKmgpfXJvdGF0ZVZlYzModCl7Y29uc3QgZT1uZXcgdSh0LngsdC55LHQueiwwKSxzPXRoaXMubXVsdGlwbHkoZSkubXVsdGlwbHkodGhpcy5jb25qdWdhdGUoKSk7cmV0dXJuIG5ldyByKHMueCxzLnkscy56KX1yb3RhdGVYKHQpe3QqPS41O2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGE9dGhpcy56LGk9dGhpcy53LHI9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTt0aGlzLng9ZSpuK2kqcix0aGlzLnk9cypuK2Eqcix0aGlzLno9YSpuLXMqcix0aGlzLnc9aSpuLWUqcn1yb3RhdGVZKHQpe3QqPS41O2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGE9dGhpcy56LGk9dGhpcy53LHI9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTt0aGlzLng9ZSpuLWEqcix0aGlzLnk9cypuK2kqcix0aGlzLno9YSpuK2Uqcix0aGlzLnc9aSpuLXMqcn1yb3RhdGVaKHQpe3QqPS41O2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGE9dGhpcy56LGk9dGhpcy53LHI9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTt0aGlzLng9ZSpuK3Mqcix0aGlzLnk9cypuLWUqcix0aGlzLno9YSpuK2kqcix0aGlzLnc9aSpuLWEqcn10b01hdDMoKXtjb25zdCB0PXRoaXMueCxlPXRoaXMueSxzPXRoaXMueixhPXRoaXMudyxpPXQrdCxyPWUrZSxuPXMrcyxoPXQqaSxvPWUqaSxfPWUqcixsPXMqaSxjPXMqcix1PXMqbixmPWEqaSxtPWEqcixnPWEqbix5PW5ldyBkO3JldHVybiB5Ll9fZGF0YVswXT0xLV8tdSx5Ll9fZGF0YVszXT1vLWcseS5fX2RhdGFbNl09bCttLHkuX19kYXRhWzFdPW8rZyx5Ll9fZGF0YVs0XT0xLWgtdSx5Ll9fZGF0YVs3XT1jLWYseS5fX2RhdGFbMl09bC1tLHkuX19kYXRhWzVdPWMrZix5Ll9fZGF0YVs4XT0xLWgtXyx5fWdldFhheGlzKCl7Y29uc3QgdD10aGlzLngqdGhpcy55LGU9dGhpcy54KnRoaXMueixzPXRoaXMueSp0aGlzLnksYT10aGlzLnkqdGhpcy53LGk9dGhpcy56KnRoaXMueixuPXRoaXMueip0aGlzLnc7cmV0dXJuIG5ldyByKDEtMiooaStzKSwyKih0K24pLDIqKGUtYSkpfWdldFlheGlzKCl7Y29uc3QgdD10aGlzLngqdGhpcy54LGU9dGhpcy54KnRoaXMueSxzPXRoaXMueCp0aGlzLncsYT10aGlzLnkqdGhpcy56LGk9dGhpcy56KnRoaXMueixuPXRoaXMueip0aGlzLnc7cmV0dXJuIG5ldyByKDIqKGUtbiksMS0yKihpK3QpLDIqKGErcykpfWdldFpheGlzKCl7Y29uc3QgdD10aGlzLngqdGhpcy54LGU9dGhpcy54KnRoaXMueixzPXRoaXMueCp0aGlzLncsYT10aGlzLnkqdGhpcy55LGk9dGhpcy55KnRoaXMueixuPXRoaXMueSp0aGlzLnc7bmV3IHI7cmV0dXJuIG5ldyByKDIqKG4rZSksMiooaS1zKSwxLTIqKGErdCkpfW1pcnJvcih0KXtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBuZXcgdSh0aGlzLnosdGhpcy53LHRoaXMueCx0aGlzLnkpO2Nhc2UgMTpyZXR1cm4gbmV3IHUoLXRoaXMudyx0aGlzLnosdGhpcy55LC10aGlzLngpO2Nhc2UgMjpyZXR1cm4gbmV3IHUodGhpcy54LHRoaXMueSx0aGlzLnosLXRoaXMudyl9fXRvTWF0NCgpe2NvbnN0IHQ9dGhpcy54LGU9dGhpcy55LHM9dGhpcy56LGE9dGhpcy53LGk9dCt0LHI9ZStlLG49cytzLGg9dCppLG89ZSppLF89ZSpyLGQ9cyppLGM9cypyLHU9cypuLGY9YSppLG09YSpyLGc9YSpuLHk9bmV3IGw7cmV0dXJuIHkuX19kYXRhWzBdPTEtXy11LHkuX19kYXRhWzRdPW8tZyx5Ll9fZGF0YVs4XT1kK20seS5fX2RhdGFbMV09bytnLHkuX19kYXRhWzVdPTEtaC11LHkuX19kYXRhWzldPWMtZix5Ll9fZGF0YVsyXT1kLW0seS5fX2RhdGFbNl09YytmLHkuX19kYXRhWzEwXT0xLWgtXyx5fWxlcnAodCxlKXtjb25zdCBzPW5ldyB1KHRoaXMueCtlKih0LngtdGhpcy54KSx0aGlzLnkrZSoodC55LXRoaXMueSksdGhpcy56K2UqKHQuei10aGlzLnopLHRoaXMudytlKih0LnctdGhpcy53KSk7cmV0dXJuIHMubm9ybWFsaXplSW5QbGFjZSgpLHN9c3RhdGljIGNyZWF0ZSguLi50KXtyZXR1cm4gbmV3IHUoLi4udCl9c3RhdGljIGNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHQsZT0wKXtyZXR1cm4gbmV3IHUodCw0KmUpfXN0YXRpYyBudW1FbGVtZW50cygpe3JldHVybiA0fWNsb25lKCl7cmV0dXJuIG5ldyB1KHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdLHRoaXMuX19kYXRhWzNdKX10b0pTT04oKXtyZXR1cm57eDp0aGlzLngseTp0aGlzLnksejp0aGlzLnosdzp0aGlzLnd9fWZyb21KU09OKHQpe3RoaXMuX19kYXRhWzBdPXQueCx0aGlzLl9fZGF0YVsxXT10LnksdGhpcy5fX2RhdGFbMl09dC56LHRoaXMuX19kYXRhWzNdPXQudyx0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKX19YS5yZWdpc3RlclR5cGUoIlF1YXQiLHUpO2NsYXNzIGZ7Y29uc3RydWN0b3IodCxlKXt0aGlzLnN0YXJ0PXQgaW5zdGFuY2VvZiByP3Q6bmV3IHIsdGhpcy5kaXI9ZSBpbnN0YW5jZW9mIHI/ZTpuZXcgcn1jbG9zZXN0UG9pbnQodCl7Y29uc3QgZT10LnN1YnRyYWN0KHRoaXMuc3RhcnQpLmRvdCh0aGlzLmRpcik7aWYoZTxOdW1iZXIuRVBTSUxPTilyZXR1cm4gdGhpcy5zdGFydDtjb25zdCBzPWUvdGhpcy5kaXIuZG90KHRoaXMuZGlyKTtyZXR1cm4gdGhpcy5zdGFydC5hZGQodGhpcy5kaXIuc2NhbGUocykpfXBvaW50QXREaXN0KHQpe3JldHVybiB0aGlzLnN0YXJ0LmFkZCh0aGlzLmRpci5zY2FsZSh0KSl9aW50ZXJzZWN0UmF5VmVjdG9yKHQpe2NvbnN0IGU9dGhpcy5kaXIscz10LmRpcixhPXRoaXMuc3RhcnQuc3VidHJhY3QodC5zdGFydCksaT1lLmRvdChlKSxyPWUuZG90KHMpLG49cy5kb3QocyksaD1lLmRvdChhKSxvPXMuZG90KGEpO2lmKDA9PWkmJjA9PW4pcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyh0LnN0YXJ0KTtpZigwPT1pKXJldHVybiB0LmNsb3Nlc3RQb2ludCh0aGlzLnN0YXJ0KTtpZigwPT1uKXJldHVybiB0aGlzLmNsb3Nlc3RQb2ludCh0LnN0YXJ0KTtjb25zdCBfPWkqbi1yKnI7bGV0IGQsbDtyZXR1cm4gXzwuMDAxPyhkPTAsbD1yPm4/aC9yOm8vbik6KGQ9KHIqby1uKmgpL18sbD0oaSpvLXIqaCkvXyksW2QsbF19aW50ZXJzZWN0UmF5UGxhbmUodCl7Y29uc3QgZT10aGlzLnN0YXJ0LnN1YnRyYWN0KHQuc3RhcnQpLHM9dC5kaXIuZG90KHRoaXMuZGlyKSxhPS10LmRpci5kb3QoZSk7aWYoTWF0aC5hYnMocyk8TnVtYmVyLlBSRUNJU0lPTilyZXR1cm4tMTtjb25zdCBpPWEvcztyZXR1cm4gaTwtTnVtYmVyLlBSRUNJU0lPTj8tMTppfWNsb25lKCl7cmV0dXJuIG5ldyBmKHRoaXMuc3RhcnQuY2xvbmUoKSx0aGlzLmRpci5jbG9uZSgpKX1zdGF0aWMgY3JlYXRlKC4uLnQpe3JldHVybiBuZXcgZiguLi50KX10b0pTT04oKXtyZXR1cm57c3RhcnQ6dGhpcy5zdGFydCxkaXI6dGhpcy5kaXJ9fWZyb21KU09OKHQpe3RoaXMuc3RhcnQuZnJvbUpTT04odC5zdGFydCksdGhpcy5kaXIuZnJvbUpTT04odC5kaXIpfXRvU3RyaW5nKCl7cmV0dXJuIGUodGhpcy50b0pTT04oKSl9fWEucmVnaXN0ZXJUeXBlKCJSYXkiLGYpO25ldyByKDEsMSwxKTtjbGFzcyBte2NvbnN0cnVjdG9yKHQsZSxzKXtpZih0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXRoaXMuc2V0RnJvbUZsb2F0MzJBcnJheSh0KTtlbHNle2lmKHQgaW5zdGFuY2VvZiByKXRoaXMudHI9dDtlbHNle2lmKHQgaW5zdGFuY2VvZiB1JiZudWxsPT1lJiZudWxsPT1zKXJldHVybiB0aGlzLnRyPW5ldyByLHRoaXMub3JpPXQsdm9pZCh0aGlzLnNjPW5ldyByKDEsMSwxKSk7dGhpcy50cj1uZXcgcn10aGlzLm9yaT1lIGluc3RhbmNlb2YgdT9lOm5ldyB1LHRoaXMuc2M9cyBpbnN0YW5jZW9mIHI/czpuZXcgcigxLDEsMSl9fXNldCh0LGUscyl7dGhpcy50cj10LHRoaXMub3JpPWUscyBpbnN0YW5jZW9mIHImJih0aGlzLnNjPXMpfXNldEZyb21PdGhlcih0KXt0aGlzLnRyPXQudHIsdGhpcy5vcmk9dC5vcmksdGhpcy5zYz10LnNjfWlzSWRlbnRpdHkoKXtyZXR1cm4gdGhpcy50ci5pc051bGwoKSYmdGhpcy5vcmkuaXNJZGVudGl0eSgpJiZ0aGlzLnNjLmlzMTExKCl9c2V0TG9va0F0KHQsZSxzKXtjb25zdCBhPXQuc3VidHJhY3QoZSk7aWYoYS5sZW5ndGgoKTxOdW1iZXIuRVBTSUxPTil0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgZGlyIik7dGhpcy5vcmkuc2V0RnJvbURpcmVjdGlvbkFuZFVwdmVjdG9yKGEscyksdGhpcy50cj10fW11bHRpcGx5KHQpe2xldCBlPXRoaXMuc2M7cmV0dXJuIHRoaXMuc2MueD09dGhpcy5zYy55JiZ0aGlzLnNjLng9PXRoaXMuc2Muenx8KGU9dC5vcmkucm90YXRlVmVjMyh0aGlzLnNjKSxNYXRoLnNpZ24oZS54KSE9TWF0aC5zaWduKHRoaXMuc2MueCkmJihlLng9LWUueCksTWF0aC5zaWduKGUueSkhPU1hdGguc2lnbih0aGlzLnNjLnkpJiYoZS55PS1lLnkpLE1hdGguc2lnbihlLnopIT1NYXRoLnNpZ24odGhpcy5zYy56KSYmKGUuej0tZS56KSksbmV3IG0odGhpcy50ci5hZGQodGhpcy5vcmkucm90YXRlVmVjMyhlLm11bHRpcGx5KHQudHIpKSksdGhpcy5vcmkubXVsdGlwbHkodC5vcmkpLGUubXVsdGlwbHkodC5zYykpfWludmVyc2UoKXtjb25zdCB0PW5ldyBtO3JldHVybiB0Lm9yaT10aGlzLm9yaS5pbnZlcnNlKCksdGhpcy5zYy54IT10aGlzLnNjLnl8fHRoaXMuc2MueCE9dGhpcy5zYy56Pyh0LnNjPXQub3JpLnJvdGF0ZVZlYzModGhpcy5zYyksTWF0aC5zaWduKHQuc2MueCkhPU1hdGguc2lnbih0aGlzLnNjLngpJiYodC5zYy54PS10LnNjLngpLE1hdGguc2lnbih0LnNjLnkpIT1NYXRoLnNpZ24odGhpcy5zYy55KSYmKHQuc2MueT0tdC5zYy55KSxNYXRoLnNpZ24odC5zYy56KSE9TWF0aC5zaWduKHRoaXMuc2MueikmJih0LnNjLno9LXQuc2MueikpOnQuc2M9dGhpcy5zYy5pbnZlcnNlKCksdC50cj10Lm9yaS5yb3RhdGVWZWMzKHRoaXMudHIubmVnYXRlKCkubXVsdGlwbHkodC5zYykpLHR9dHJhbnNmb3JtVmVjMyh0KXtyZXR1cm4gdGhpcy50ci5hZGQodGhpcy5vcmkucm90YXRlVmVjMyh0aGlzLnNjLm11bHRpcGx5KHQpKSl9dG9NYXQ0KCl7Y29uc3QgdD1uZXcgbCh0aGlzLnNjLngsMCwwLDAsMCx0aGlzLnNjLnksMCwwLDAsMCx0aGlzLnNjLnosMCwwLDAsMCwxKSxlPXRoaXMub3JpLnRvTWF0NCgpLHM9bmV3IGw7cmV0dXJuIHMudHJhbnNsYXRpb249dGhpcy50cixzLm11bHRpcGx5KGUpLm11bHRpcGx5KHQpfWZyb21NYXQ0KHQpe3RoaXMudHI9dC50cmFuc2xhdGlvbix0aGlzLm9yaS5zZXRGcm9tTWF0NCh0KX1zZXRGcm9tRmxvYXQzMkFycmF5KHQpe2lmKDc9PXQubGVuZ3RoKXJldHVybiB0aGlzLnRyPW5ldyByKHQuYnVmZmVyLHQuYnl0ZU9mZnNldCksdGhpcy5vcmk9bmV3IHUodC5idWZmZXIsdC5ieXRlT2Zmc2V0KzEyKSx2b2lkKHRoaXMuc2M9bmV3IHIoMSwxLDEpKTtpZig4IT10Lmxlbmd0aClyZXR1cm4gMTA9PXQubGVuZ3RoPyh0aGlzLnRyPW5ldyByKHQuYnVmZmVyLHQuYnl0ZU9mZnNldCksdGhpcy5vcmk9bmV3IHUodC5idWZmZXIsdC5ieXRlT2Zmc2V0KzEyKSx2b2lkKHRoaXMuc2M9bmV3IHIodC5idWZmZXIsdC5ieXRlT2Zmc2V0KzIxKSkpOnZvaWQgMDt7dGhpcy50cj1uZXcgcih0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQpLHRoaXMub3JpPW5ldyB1KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCsxMik7Y29uc3QgZT10WzddO3RoaXMuc2M9bmV3IHIoZSxlLGUpfX1jbG9uZSgpe3JldHVybiBuZXcgbSh0aGlzLnRyLmNsb25lKCksdGhpcy5vcmkuY2xvbmUoKSx0aGlzLnNjLmNsb25lKCkpfXN0YXRpYyBjcmVhdGUoLi4udCl7cmV0dXJuIG5ldyBtKC4uLnQpfXRvSlNPTigpe2NvbnN0IHQ9e3RyOnRoaXMudHIudG9KU09OKCksb3JpOnRoaXMub3JpLnRvSlNPTigpfTtyZXR1cm4gdGhpcy5zYy5pczExMSgpfHwodC5zYz10aGlzLnNjLnRvSlNPTigpKSx0fWZyb21KU09OKHQpe3RoaXMudHIuZnJvbUpTT04odC50ciksdGhpcy5vcmkuZnJvbUpTT04odC5vcmkpLHQuc2MmJnRoaXMuc2MuZnJvbUpTT04odC5zYyl9dG9TdHJpbmcoKXtyZXR1cm4gZSh0aGlzLnRvSlNPTigpKX19YS5yZWdpc3RlclR5cGUoIlhmbyIsbSk7Y2xhc3MgZ3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMucDA9dCBpbnN0YW5jZW9mIGk/dDpuZXcgaShOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSx0aGlzLnAxPWUgaW5zdGFuY2VvZiBpP2U6bmV3IGkoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLE51bWJlci5ORUdBVElWRV9JTkZJTklUWSl9c2V0KHQsZSl7dGhpcy5wMD10LHRoaXMucDE9ZX1yZXNldCgpe3RoaXMucDAueD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5wMS54PU51bWJlci5ORUdBVElWRV9JTkZJTklUWSx0aGlzLnAwLnk9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHRoaXMucDEueT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9aXNWYWxpZCgpe3JldHVybiB0aGlzLnAwLnghPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSYmdGhpcy5wMS54IT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkmJnRoaXMucDAueSE9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZJiZ0aGlzLnAxLnkhPU51bWJlci5ORUdBVElWRV9JTkZJTklUWX1hZGRQb2ludCh0KXsodGhpcy5wMC54PT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl8fHQueDx0aGlzLnAwLngpJiYodGhpcy5wMC54PXQueCksKHRoaXMucDAueT09TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfHx0Lnk8dGhpcy5wMC55KSYmKHRoaXMucDAueT10LnkpLCh0aGlzLnAxLnk9PU51bWJlci5ORUdBVElWRV9JTkZJTklUWXx8dC54PnRoaXMucDEueCkmJih0aGlzLnAxLng9dC54KSwodGhpcy5wMS55PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl8fHQueT50aGlzLnAxLnkpJiYodGhpcy5wMS55PXQueSl9c2l6ZSgpe3JldHVybiB0aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApfWRpYWdvbmFsKCl7cmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCl9Y2VudGVyKCl7Y29uc3QgdD10aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApO3JldHVybiB0LnNjYWxlSW5QbGFjZSguNSksdC5hZGRJblBsYWNlKHRoaXMucDApLHR9c3RhdGljIGNyZWF0ZSguLi50KXtyZXR1cm4gbmV3IGcoLi4udCl9dG9KU09OKCl7cmV0dXJue3AwOnRoaXMucDAudG9KU09OKCkscDE6dGhpcy5wMS50b0pTT04oKX19dG9TdHJpbmcoKXtyZXR1cm4gZSh0aGlzLnRvSlNPTigpKX19YS5yZWdpc3RlclR5cGUoIkJveDIiLGcpO2NsYXNzIHkgZXh0ZW5kcyBze2NvbnN0cnVjdG9yKHQsZT0wKXtzdXBlcigpLHRoaXMucG9zPXQgaW5zdGFuY2VvZiByP3Q6bmV3IHIsdGhpcy5yYWRpdXM9ZX1jbG9uZSgpe3JldHVybiBuZXcgU3BoZXJlKHRoaXMucG9zLmNsb25lKCksdGhpcy5yYWRpdXMpfWludGVyc2VjdHNCb3godCl7cmV0dXJuIHQuaW50ZXJzZWN0c1NwaGVyZSh0aGlzKX1zdGF0aWMgY3JlYXRlKC4uLnQpe3JldHVybiBuZXcgU3BoZXJlKC4uLnQpfXRvSlNPTigpe3JldHVybntwb3M6dGhpcy5wb3MudG9KU09OKCkscmFkaXVzOnRoaXMucmFkaXVzfX10b1N0cmluZygpe3JldHVybiBlKHRoaXMudG9KU09OKCkpfX1hLnJlZ2lzdGVyVHlwZSgiU3BoZXJlVHlwZSIseSk7Y2xhc3MgcHtjb25zdHJ1Y3Rvcih0LGUpe3QgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/dGhpcy5zZXRGcm9tRmxvYXQzMkFycmF5KHQpOih0aGlzLnAwPXQgaW5zdGFuY2VvZiByP3Q6bmV3IHIoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpLHRoaXMucDE9ZSBpbnN0YW5jZW9mIHI/ZTpuZXcgcihOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkpfWdldCBtaW4oKXtyZXR1cm4gdGhpcy5wMH1nZXQgbWF4KCl7cmV0dXJuIHRoaXMucDF9c2V0KHQsZSl7dGhpcy5wMD10LHRoaXMucDE9ZX1yZXNldCgpe3RoaXMucDAueD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5wMS54PU51bWJlci5ORUdBVElWRV9JTkZJTklUWSx0aGlzLnAwLnk9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHRoaXMucDEueT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksdGhpcy5wMC56PU51bWJlci5QT1NJVElWRV9JTkZJTklUWSx0aGlzLnAxLno9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5wMC54IT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkmJnRoaXMucDEueCE9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZJiZ0aGlzLnAwLnkhPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSYmdGhpcy5wMS55IT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkmJnRoaXMucDAueiE9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZJiZ0aGlzLnAxLnohPU51bWJlci5ORUdBVElWRV9JTkZJTklUWX1hZGRQb2ludCh0KXt0LnghPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSYmdC54IT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkmJih0Lng8dGhpcy5wMC54JiYodGhpcy5wMC54PXQueCksdC54PnRoaXMucDEueCYmKHRoaXMucDEueD10LngpKSx0LnkhPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSYmdC55IT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkmJih0Lnk8dGhpcy5wMC55JiYodGhpcy5wMC55PXQueSksdC55PnRoaXMucDEueSYmKHRoaXMucDEueT10LnkpKSx0LnohPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSYmdC56IT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkmJih0Lno8dGhpcy5wMC56JiYodGhpcy5wMC56PXQueiksdC56PnRoaXMucDEueiYmKHRoaXMucDEuej10LnopKX1hZGRCb3gzKHQsZSl7ZT8odGhpcy5hZGRQb2ludChlLnRyYW5zZm9ybVZlYzModC5wMCkpLHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKG5ldyByKHQucDAueCx0LnAwLnksdC5wMS56KSkpLHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKG5ldyByKHQucDAueCx0LnAxLnksdC5wMC56KSkpLHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKG5ldyByKHQucDEueCx0LnAwLnksdC5wMC56KSkpLHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKG5ldyByKHQucDAueCx0LnAxLnksdC5wMS56KSkpLHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKG5ldyByKHQucDEueCx0LnAwLnksdC5wMS56KSkpLHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKG5ldyByKHQucDEueCx0LnAxLnksdC5wMC56KSkpLHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKHQucDEpKSk6KHRoaXMuYWRkUG9pbnQodC5wMCksdGhpcy5hZGRQb2ludCh0LnAxKSl9c2l6ZSgpe3JldHVybiB0aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApfWRpYWdvbmFsKCl7cmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCl9Y2VudGVyKCl7Y29uc3QgdD10aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApO3JldHVybiB0LnNjYWxlSW5QbGFjZSguNSksdC5hZGRJblBsYWNlKHRoaXMucDApLHR9dG9NYXQ0KCl7Y29uc3QgdD10aGlzLnAxLngtdGhpcy5wMC54LGU9dGhpcy5wMS55LXRoaXMucDAueSxzPXRoaXMucDEuei10aGlzLnAwLno7cmV0dXJuIG5ldyBsKHQsMCwwLDAsMCxlLDAsMCwwLDAscywwLHRoaXMucDAueCx0aGlzLnAwLnksdGhpcy5wMC56LDEpfWdldEJvdW5kaW5nU3BoZXJlKCl7cmV0dXJuIG5ldyB5KHRoaXMuY2VudGVyKCksLjUqdGhpcy5kaWFnb25hbCgpLmxlbmd0aCgpKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiEodC5tYXgueDx0aGlzLm1pbi54fHx0Lm1pbi54PnRoaXMubWF4Lnh8fHQubWF4Lnk8dGhpcy5taW4ueXx8dC5taW4ueT50aGlzLm1heC55fHx0Lm1heC56PHRoaXMubWluLnp8fHQubWluLno+dGhpcy5tYXgueil9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4gY2xvc2VzdFBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHQuY2VudGVyKTw9dC5yYWRpdXMqdC5yYWRpdXN9aW50ZXJzZWN0c1BsYW5lKHQpe2xldCBlLHM7cmV0dXJuIHQubm9ybWFsLng+MD8oZT10Lm5vcm1hbC54KnRoaXMubWluLngscz10Lm5vcm1hbC54KnRoaXMubWF4LngpOihlPXQubm9ybWFsLngqdGhpcy5tYXgueCxzPXQubm9ybWFsLngqdGhpcy5taW4ueCksdC5ub3JtYWwueT4wPyhlKz10Lm5vcm1hbC55KnRoaXMubWluLnkscys9dC5ub3JtYWwueSp0aGlzLm1heC55KTooZSs9dC5ub3JtYWwueSp0aGlzLm1heC55LHMrPXQubm9ybWFsLnkqdGhpcy5taW4ueSksdC5ub3JtYWwuej4wPyhlKz10Lm5vcm1hbC56KnRoaXMubWluLnoscys9dC5ub3JtYWwueip0aGlzLm1heC56KTooZSs9dC5ub3JtYWwueip0aGlzLm1heC56LHMrPXQubm9ybWFsLnoqdGhpcy5taW4ueiksZTw9LXQuY29uc3RhbnQmJnM+PS10LmNvbnN0YW50fWNsb25lKCl7cmV0dXJuIG5ldyBwKHRoaXMucDAuY2xvbmUoKSx0aGlzLnAxLmNsb25lKCkpfXN0YXRpYyBjcmVhdGUoLi4udCl7cmV0dXJuIG5ldyBwKC4uLnQpfXN0YXRpYyBzaXplSW5CeXRlcygpe3JldHVybiAyNH10b0pTT04oKXtyZXR1cm57cDA6dGhpcy5wMC50b0pTT04oKSxwMTp0aGlzLnAxLnRvSlNPTigpfX1mcm9tSlNPTih0KXt0aGlzLnAwLmZyb21KU09OKHQucDApLHRoaXMucDEuZnJvbUpTT04odC5wMSl9bG9hZEJpbih0LGUpe3RoaXMucDAubG9hZEJpbih0LGUpLHRoaXMucDAubG9hZEJpbih0LGUrMTIpfXNldEZyb21GbG9hdDMyQXJyYXkodCl7dGhpcy5wMD1uZXcgcih0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQpLHRoaXMucDE9bmV3IHIodC5idWZmZXIsdC5ieXRlT2Zmc2V0KzEyKX10b1N0cmluZygpe3JldHVybiBlKHRoaXMudG9KU09OKCkpfX1hLnJlZ2lzdGVyVHlwZSgiQm94MyIscCk7Y2xhc3MgeCBleHRlbmRzIHN7Y29uc3RydWN0b3IodCxlPTApe3N1cGVyKCksdGhpcy5ub3JtYWw9dCBpbnN0YW5jZW9mIHI/dDpuZXcgcix0aGlzLnc9ZX1zZXQodCxlLHMsYSl7dGhpcy5ub3JtYWwuc2V0KHQsZSxzKSx0aGlzLnc9YX1kaXZpZGVTY2FsYXIodCl7dGhpcy5ub3JtYWwuc2NhbGVJblBsYWNlKDEvdCksdGhpcy53Lz10fWRpc3RhbmNlVG9Qb2ludCh0KXtyZXR1cm4gdC5kb3QodGhpcy5ub3JtYWwpK3RoaXMud31ub3JtYWxpemVJblBsYWNlKCl7Y29uc3QgdD0xL3RoaXMubm9ybWFsLmxlbmd0aCgpO3RoaXMubm9ybWFsLnNjYWxlSW5QbGFjZSh0KSx0aGlzLncqPXR9Y2xvbmUoKXtyZXR1cm4gbmV3IFBsYW5lKHRoaXMubm9ybWFsLmNsb25lKCksdGhpcy53KX1zdGF0aWMgY3JlYXRlKC4uLnQpe3JldHVybiBuZXcgUGxhbmUoLi4udCl9dG9KU09OKCl7cmV0dXJue25vcm1hbDp0aGlzLm5vcm1hbC50b0pTT04oKSx3OnRoaXMud319dG9TdHJpbmcoKXtyZXR1cm4gZSh0aGlzLnRvSlNPTigpKX19YS5yZWdpc3RlclR5cGUoIlBsYW5lVHlwZSIseCk7YS5yZWdpc3RlclR5cGUoIkZydXN0dW0iLGNsYXNze2NvbnN0cnVjdG9yKHQsZSxzLGEsaSxyKXt0aGlzLnBsYW5lcz1bdHx8bmV3IHgsZXx8bmV3IHgsc3x8bmV3IHgsYXx8bmV3IHgsaXx8bmV3IHgscnx8bmV3IHhdfXNldEZyb21NYXRyaXgodCl7Y29uc3QgZT10LHM9dGhpcy5wbGFuZXM7c1swXS5zZXQoZS5tMDMtZS5tMDAsZS5tMTMtZS5tMTAsZS5tMjMtZS5tMjAsZS5tMzMtZS5tMzApLHNbMV0uc2V0KGUubTAzK2UubTAwLGUubTEzK2UubTEwLGUubTIzK2UubTIwLGUubTMzK2UubTMwKSxzWzJdLnNldChlLm0wMytlLm0wMSxlLm0xMytlLm0xMSxlLm0yMytlLm0yMSxlLm0zMytlLm0zMSksc1szXS5zZXQoZS5tMDMtZS5tMDEsZS5tMTMtZS5tMTEsZS5tMjMtZS5tMjEsZS5tMzMtZS5tMzEpLHNbNF0uc2V0KGUubTAzLWUubTAyLGUubTEzLWUubTEyLGUubTIzLWUubTIyLGUubTMzLWUubTMyKSxzWzVdLnNldChlLm0wMytlLm0wMixlLm0xMytlLm0xMixlLm0yMytlLm0yMixlLm0zMytlLm0zMikscy5mb3JFYWNoKHQ9PnQubm9ybWFsaXplSW5QbGFjZSgpKX1pbnRlcnNlY3RzQm94KHQpe2NvbnN0IGU9bmV3IHIscz10aGlzLnBsYW5lcyx7bWluOmEsbWF4Oml9PXQ7Zm9yKGxldCB0PTA7dDw2O3QrKyl7Y29uc3Qgcj1zW3RdO2lmKGUueD1yLm5vcm1hbC54PjA/aS54OmEueCxlLnk9ci5ub3JtYWwueT4wP2kueTphLnksZS56PXIubm9ybWFsLno+MD9pLno6YS56LHIuZGlzdGFuY2VUb1BvaW50KGUpPDApcmV0dXJuITF9cmV0dXJuITB9dG9KU09OKCl7cmV0dXJue3AwOnRoaXMucDAudG9KU09OKCkscDE6dGhpcy5wMS50b0pTT04oKSxwMjp0aGlzLnAyLnRvSlNPTigpLHAzOnRoaXMucDMudG9KU09OKCkscDQ6dGhpcy5wNC50b0pTT04oKSxwNTp0aGlzLnA1LnRvSlNPTigpfX1mcm9tSlNPTih0KXt0aGlzLnAwLmZyb21KU09OKHQucDApLHRoaXMucDEuZnJvbUpTT04odC5wMSksdGhpcy5wMi5mcm9tSlNPTih0LnAyKSx0aGlzLnAzLmZyb21KU09OKHQucDMpLHRoaXMucDQuZnJvbUpTT04odC5wNCksdGhpcy5wNS5mcm9tSlNPTih0LnA1KX10b1N0cmluZygpe3JldHVybiBlKHRoaXMudG9KU09OKCkpfX0pO2NsYXNzIHd7Y29uc3RydWN0b3IodD0hMSl7dGhpcy5fX3Nsb3RzPVtdLHRoaXMuX190b2dnbGVkU2lnbmFsPXQsdGhpcy5fX3RvZ2dsZWQ9ITEsdGhpcy5fX2RhdGE9bnVsbCx0aGlzLmNvbm5lY3Q9dGhpcy5jb25uZWN0LmJpbmQodGhpcyksdGhpcy5kaXNjb25uZWN0PXRoaXMuZGlzY29ubmVjdC5iaW5kKHRoaXMpLHRoaXMuZW1pdD10aGlzLmVtaXQuYmluZCh0aGlzKX1jb25uZWN0KHQpe2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKCJhIGZ1bmN0aW9uIGNhbGxiYWNrIG11c3QgYmUgcGFzc2VkIHRvIFNpZ25hbC5jb25uZWN0Iik7aWYoLTEhPXRoaXMuX19zbG90cy5pbmRleE9mKHQpKXJldHVybiB2b2lkIGNvbnNvbGUud2FybigiZm4gJyIrdC5uYW1lKyInIGFscmVhZHkgY29ubmVjdGVkIHRvIFNpZ25hbC4iKTtjb25zdCBlPXRoaXMuX19zbG90cy5sZW5ndGg7cmV0dXJuIHRoaXMuX19zbG90c1tlXT10LHRoaXMuX190b2dnbGVkU2lnbmFsJiZ0aGlzLl9fdG9nZ2xlZCYmKHRoaXMuX19kYXRhP3QoLi4udGhpcy5fX2RhdGEpOnQoKSksZX1kaXNjb25uZWN0KHQpe2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKCJhIGZ1bmN0aW9uIGNhbGxiYWNrIG11c3QgYmUgcGFzc2VkIHRvIFNpZ25hbC5kaXNjb25uZWN0Iik7Y29uc3QgZT1bXTtpZih0aGlzLl9fc2xvdHMuZm9yRWFjaCgoZnVuY3Rpb24ocyxhKXtzPT09dCYmZS5wdXNoKGEpfSkpLDAhPWUubGVuZ3RoKWZvcihjb25zdCB0IG9mIGUpdGhpcy5fX3Nsb3RzW3RdPXZvaWQgMDtlbHNlIGNvbnNvbGUud2FybigiY2FsbGJhY2sgOiIrdC5uYW1lKyIgd2FzIG5vdCBjb25uZWN0ZWQgdG8gdGhpcyBzaWduYWw6Iit0aGlzLl9fbmFtZSl9ZGlzY29ubmVjdElkKHQpe2lmKCF0aGlzLl9fc2xvdHNbdF0pdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIElEIik7dGhpcy5fX3Nsb3RzW3RdPXZvaWQgMH1lbWl0KC4uLnQpe3RoaXMuX190b2dnbGVkU2lnbmFsJiYodGhpcy5fX3RvZ2dsZWQ/Y29uc29sZS53YXJuKCJUb2dnbGVkIHNpZ25hbHMgc2hvdWxkIG9ubHkgYmUgZmlyZWQgb25jZSwgb3IgdW50b2dnbGVkIGJlZm9yZSByZS1maXJpbmcuLiIpOih0aGlzLl9fdG9nZ2xlZD0hMCx0aGlzLl9fZGF0YT10KSk7Y29uc3QgZT10aGlzLl9fc2xvdHMubGVuZ3RoO2ZvcihsZXQgcz0wO3M8ZTtzKyspe2NvbnN0IGU9dGhpcy5fX3Nsb3RzW3NdO2UmJmUoLi4udCl9fWlzVG9nZ2xlZCgpe3JldHVybiB0aGlzLl9fdG9nZ2xlZH1zZXRUb2dnbGVkKHQpe3RoaXMuX190b2dnbGVkPXQsdGhpcy5fX2RhdGE9dm9pZCAwfWdldE51bUNvbm5lY3Rpb25zKCl7cmV0dXJuIHRoaXMuX19zbG90cy5sZW5ndGh9dW50b2dnbGUoKXt0aGlzLl9fdG9nZ2xlZD0hMSx0aGlzLl9fZGF0YT12b2lkIDB9fWNvbnN0IEk9bmV3IGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fX3JlZ2lzdGVyZWRDbGFzc2VzPXt9LHRoaXMuX19jbGFzc05hbWVzPXt9fXJlZ2lzdGVyQ2xhc3ModCxlKXt0aGlzLl9fcmVnaXN0ZXJlZENsYXNzZXNbdF09e2NsczplLGNhbGxiYWNrczpbXX0sdGhpcy5fX2NsYXNzTmFtZXNbZS5uYW1lXT10fXJlZ2lzdGVyQ2FsbGJhY2sodCxlKXtjb25zdCBzPXRoaXMuX19yZWdpc3RlcmVkQ2xhc3Nlc1t0XTtzP3MuY2FsbGJhY2tzLnB1c2goZSk6Y29uc29sZS53YXJuKCJGYWN0b3J5IG5vdCByZWdpc3RlcmVkOiIrdCl9Z2V0Q2xhc3ModCl7aWYodGhpcy5fX3JlZ2lzdGVyZWRDbGFzc2VzW3RdKXJldHVybiB0aGlzLl9fcmVnaXN0ZXJlZENsYXNzZXNbdF0uY2xzfWdldENsYXNzTmFtZSh0KXtyZXR1cm4gdGhpcy5fX2NsYXNzTmFtZXNbdC5jb25zdHJ1Y3Rvci5uYW1lXT90aGlzLl9fY2xhc3NOYW1lc1t0LmNvbnN0cnVjdG9yLm5hbWVdOnQuY29uc3RydWN0b3IubmFtZX1pc0NvbnN0cnVjdGluZygpe3JldHVybiB0aGlzLl9fY29uc3RydWN0aW5nfWNvbnN0cnVjdENsYXNzKHQpe2NvbnN0IGU9dGhpcy5fX3JlZ2lzdGVyZWRDbGFzc2VzW3RdO2lmKCFlKXJldHVybiBjb25zb2xlLndhcm4oIkZhY3Rvcnkgbm90IHJlZ2lzdGVyZWQ6Iit0KSxudWxsO3RoaXMuX19jb25zdHJ1Y3Rpbmc9ITA7Y29uc3Qgcz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksYT1uZXcgZS5jbHMoLi4ucyk7cmV0dXJuIHRoaXMuX19jb25zdHJ1Y3Rpbmc9ITEsdGhpcy5pbnZva2VDYWxsYmFja3MoYSksYX1pbnZva2VDYWxsYmFja3ModCl7aWYodGhpcy5fX2NsYXNzTmFtZXNbdC5jb25zdHJ1Y3Rvci5uYW1lXSl7Y29uc3QgZT10aGlzLl9fcmVnaXN0ZXJlZENsYXNzZXNbdGhpcy5fX2NsYXNzTmFtZXNbdC5jb25zdHJ1Y3Rvci5uYW1lXV07Zm9yKGNvbnN0IHMgb2YgZS5jYWxsYmFja3Mpcyh0KX19fSxOPTMsRj0yO2xldCB6PTA7Y2xhc3MgVntjb25zdHJ1Y3Rvcih0LGUscyl7aWYodGhpcy5fX2RhdGFUeXBlPXQsdGhpcy5ub3JtYWxpemVkPSExLG51bGwhPXQubnVtRWxlbWVudHMpdGhpcy5fX2RpbWVuc2lvbj10aGlzLl9fZGF0YVR5cGUubnVtRWxlbWVudHMoKTtlbHNlIHN3aXRjaCh0KXtjYXNlIDY6Y2FzZSA0OmNhc2UgNTp0aGlzLl9fZGltZW5zaW9uPTE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgZGF0YSB0eXBlIGZvciBhdHRyaWJ1dGU6Iit0KX12YXIgYTt0aGlzLl9fZGVmYXVsdEVsZW1lbnRWYWx1ZT1udWxsIT1zP3M6TnVtYmVyLk1BWF9WQUxVRSwoYT1lKSYmdm9pZCAwIT09YS5ieXRlTGVuZ3RoP3RoaXMuX19kYXRhPWU6KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoZSp0aGlzLl9fZGltZW5zaW9uKSx0aGlzLmluaXRSYW5nZSgwKSl9cmVzaXplKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGEubGVuZ3RoLHM9dCp0aGlzLl9fZGltZW5zaW9uLGE9bmV3IEZsb2F0MzJBcnJheShzKTtmb3IobGV0IHQ9MDt0PE1hdGgubWluKHRoaXMuX19kYXRhLmxlbmd0aCxzKTt0KyspYVt0XT10aGlzLl9fZGF0YVt0XTt0aGlzLl9fZGF0YS5sZW5ndGg8cyYmKHRoaXMuX19kYXRhPWEpLHRoaXMuaW5pdFJhbmdlKGUpfWluaXRSYW5nZSh0KXtmb3IobGV0IGU9dDtlPHRoaXMuX19kYXRhLmxlbmd0aDtlKyspdGhpcy5fX2RhdGFbZV09dGhpcy5fX2RlZmF1bHRFbGVtZW50VmFsdWV9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fX2RhdGEubGVuZ3RoL3RoaXMuX19kaW1lbnNpb259Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9fZGF0YS5sZW5ndGgvdGhpcy5fX2RpbWVuc2lvbn1nZXQgZGF0YVR5cGUoKXtyZXR1cm4gdGhpcy5fX2RhdGFUeXBlfWdldCBkYXRhKCl7cmV0dXJuIHRoaXMuX19kYXRhfXNldCBkYXRhKHQpe3RoaXMuX19kYXRhPXR9Z2V0IG51bUVsZW1lbnRzKCl7cmV0dXJuIHRoaXMuX19kaW1lbnNpb259Z2V0RmxvYXQzMlZhbHVlKHQpe3JldHVybiB0aGlzLl9fZGF0YVt0XX1zZXRGbG9hdDMyVmFsdWUodCxlKXt0aGlzLl9fZGF0YVt0XT1lfWdldFZhbHVlUmVmKHQpe2NvbnN0IGU9dGhpcy5fX2RpbWVuc2lvbjtpZih0Pj10aGlzLl9fZGF0YS5sZW5ndGgvZSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgdmVydGV4IGluZGV4OiIrdCsiLiBOdW0gVmVydGljZXM6Iit0aGlzLl9fZGF0YS5sZW5ndGgvMyk7cmV0dXJuIHRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcih0aGlzLl9fZGF0YS5idWZmZXIsdCplKX1zZXRWYWx1ZSh0LGUpe2NvbnN0IHM9dGhpcy5fX2RpbWVuc2lvbjtpZih0Pj10aGlzLl9fZGF0YS5sZW5ndGgvcyl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgdmVydGV4IGluZGV4OiIrdCsiLiBOdW0gVmVydGljZXM6Iit0aGlzLl9fZGF0YS5sZW5ndGgvMyk7dGhpcy5fX2RhdGFUeXBlLmNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHRoaXMuX19kYXRhLmJ1ZmZlcix0KnMpLnNldEZyb21PdGhlcihlKX10b0pTT04odCxlKXtyZXR1cm57ZGF0YTpBcnJheS5mcm9tKHRoaXMuX19kYXRhKSxkYXRhVHlwZTphLmdldFR5cGVOYW1lKHRoaXMuX19kYXRhVHlwZSksZGVmYXVsdFZhbHVlOnRoaXMuX19kZWZhdWx0RWxlbWVudFZhbHVlLGxlbmd0aDp0aGlzLl9fZGF0YS5sZW5ndGgvdGhpcy5fX2RpbWVuc2lvbn19ZnJvbUpTT04odCl7dGhpcy5fX2RhdGE9RmxvYXQzMkFycmF5LmZyb20odC5kYXRhKX10b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLG51bGwsMil9fWNsYXNzIE0gZXh0ZW5kcyBjbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX19pZD0rK3osdGhpcy5fX3BhcmFtcz1bXSx0aGlzLl9fcGFyYW1NYXBwaW5nPXt9LHRoaXMuX19wYXJhbVNpZ25hbElkcz17fSx0aGlzLnBhcmFtZXRlckFkZGVkPW5ldyB3LHRoaXMucGFyYW1ldGVyUmVtb3ZlZD1uZXcgdyx0aGlzLnBhcmFtZXRlclZhbHVlQ2hhbmdlZD1uZXcgd31nZXRJZCgpe3JldHVybiB0aGlzLl9faWR9bnVtUGFyYW1ldGVycygpe3JldHVybiB0aGlzLl9fcGFyYW1zLmxlbmd0aH1nZXRQYXJhbWV0ZXJzKCl7cmV0dXJuIHRoaXMuX19wYXJhbXN9Z2V0UGFyYW1ldGVySW5kZXgodCl7cmV0dXJuIHRoaXMuX19wYXJhbU1hcHBpbmdbdF19Z2V0UGFyYW1ldGVyQnlJbmRleCh0KXtyZXR1cm4gdGhpcy5fX3BhcmFtc1t0XX1oYXNQYXJhbWV0ZXIodCl7cmV0dXJuIHQgaW4gdGhpcy5fX3BhcmFtTWFwcGluZ31nZXRQYXJhbWV0ZXIodCl7Y29uc3QgZT10aGlzLl9fcGFyYW1NYXBwaW5nW3RdO3JldHVybi0xPT1lP251bGw6dGhpcy5fX3BhcmFtc1tlXX1fX3BhcmFtZXRlclZhbHVlQ2hhbmdlZCh0LGUpe3RoaXMucGFyYW1ldGVyVmFsdWVDaGFuZ2VkLmVtaXQodCxlKX1hZGRQYXJhbWV0ZXIodCl7Y29uc3QgZT10LmdldE5hbWUoKTtyZXR1cm4gbnVsbCE9dGhpcy5fX3BhcmFtTWFwcGluZ1tlXSYmKGNvbnNvbGUud2FybigiUmVwbGFjaW5nIFBhcmFtZXRlcjoiK2UpLHRoaXMucmVtb3ZlUGFyYW1ldGVyKGUpKSx0aGlzLl9fcGFyYW1TaWduYWxJZHNbZV09dC52YWx1ZUNoYW5nZWQuY29ubmVjdChlPT50aGlzLl9fcGFyYW1ldGVyVmFsdWVDaGFuZ2VkKHQsZSkpLHRoaXMuX19wYXJhbXMucHVzaCh0KSx0aGlzLl9fcGFyYW1NYXBwaW5nW2VdPXRoaXMuX19wYXJhbXMubGVuZ3RoLTEsdGhpcy5wYXJhbWV0ZXJBZGRlZC5lbWl0KGUpLHR9aW5zZXJ0UGFyYW1ldGVyKHQsZSl7Y29uc3Qgcz10LmdldE5hbWUoKTtudWxsIT10aGlzLl9fcGFyYW1NYXBwaW5nW3NdJiYoY29uc29sZS53YXJuKCJSZXBsYWNpbmcgUGFyYW1ldGVyOiIrcyksdGhpcy5yZW1vdmVQYXJhbWV0ZXIocykpLHRoaXMuX19wYXJhbVNpZ25hbElkc1tzXT10LnZhbHVlQ2hhbmdlZC5jb25uZWN0KGU9PnRoaXMuX19wYXJhbWV0ZXJWYWx1ZUNoYW5nZWQodCxlKSksdGhpcy5fX3BhcmFtcy5zcGxpY2UoZSwwLHQpO2NvbnN0IGE9e307Zm9yKGxldCB0PTA7dDx0aGlzLl9fcGFyYW1zLmxlbmd0aDt0KyspYVt0aGlzLl9fcGFyYW1zW3RdLmdldE5hbWUoKV09dDtyZXR1cm4gdGhpcy5fX3BhcmFtTWFwcGluZz1hLHRoaXMucGFyYW1ldGVyQWRkZWQuZW1pdChzKSx0fXJlbW92ZVBhcmFtZXRlcih0KXtudWxsPT10aGlzLl9fcGFyYW1NYXBwaW5nW3RdJiZjb25zb2xlLnRocm93KCJVbmFibGUgdG8gUmVtb3ZlIFBhcmFtZXRlcjoiK3QpO2NvbnN0IGU9dGhpcy5fX3BhcmFtTWFwcGluZ1t0XTt0aGlzLl9fcGFyYW1zW3RoaXMuX19wYXJhbU1hcHBpbmdbdF1dLnZhbHVlQ2hhbmdlZC5kaXNjb25uZWN0SWQodGhpcy5fX3BhcmFtU2lnbmFsSWRzW3RdKSx0aGlzLl9fcGFyYW1zLnNwbGljZShlLDEpO2NvbnN0IHM9e307Zm9yKGxldCB0PTA7dDx0aGlzLl9fcGFyYW1zLmxlbmd0aDt0Kyspc1t0aGlzLl9fcGFyYW1zW3RdLmdldE5hbWUoKV09dDt0aGlzLl9fcGFyYW1NYXBwaW5nPXMsdGhpcy5wYXJhbWV0ZXJSZW1vdmVkLmVtaXQodCl9cmVwbGFjZVBhcmFtZXRlcih0KXtjb25zdCBlPXQuZ2V0TmFtZSgpLHM9dGhpcy5fX3BhcmFtTWFwcGluZ1tlXTtyZXR1cm4gdGhpcy5fX3BhcmFtc1t0aGlzLl9fcGFyYW1NYXBwaW5nW2VdXS52YWx1ZUNoYW5nZWQuZGlzY29ubmVjdElkKHRoaXMuX19wYXJhbVNpZ25hbElkc1tlXSksdGhpcy5fX3BhcmFtU2lnbmFsSWRzW2VdPXQudmFsdWVDaGFuZ2VkLmNvbm5lY3QoZT0+dGhpcy5fX3BhcmFtZXRlclZhbHVlQ2hhbmdlZCh0LGUpKSx0aGlzLl9fcGFyYW1zW3NdPXQsdH10b0pTT04odCxlKXtjb25zdCBzPXt9O2xldCBhPTA7Zm9yKGNvbnN0IGkgb2YgdGhpcy5fX3BhcmFtcylpZihpLnRlc3RGbGFnKEYpKWlmKGkubnVtUmVmcygpPjEmJjAhPWkuZ2V0UmVmSW5kZXgodGhpcykpc1tpLmdldE5hbWUoKV09e3BhcmFtUGF0aDp0Lm1ha2VSZWxhdGl2ZShpLmdldFBhdGgoKSl9LGErKztlbHNle2NvbnN0IHI9aS50b0pTT04odCxlKTtyJiYoc1tpLmdldE5hbWUoKV09cixhKyspfWlmKGE+MClyZXR1cm57cGFyYW1zOnN9fWZyb21KU09OKHQsZSxzKXtpZih0LnBhcmFtcylmb3IoY29uc3QgcyBpbiB0LnBhcmFtcyl7Y29uc3QgYT10LnBhcmFtc1tzXSxpPXRoaXMuZ2V0UGFyYW1ldGVyKHMpO2k/YS5wYXJhbVBhdGg/ZS5yZXNvbHZlUGF0aChhLnBhcmFtUGF0aCx0PT57dGhpcy5yZXBsYWNlUGFyYW1ldGVyKHQpfSx0PT57Y29uc29sZS53YXJuKCJVbmFibGUgdG8gcmVzb2x2ZSBzaGFyZWQgcGFyYW1ldGVyOiIrYS5wYXJhbVBhdGgpfSk6aS5mcm9tSlNPTihhLGUpOmNvbnNvbGUud2FybigiUGFyYW0gbm90IGZvdW5kOiIrcyl9fXJlYWRCaW5hcnkodCxlKXtpZihlLnZlcnNpb25zWyJ6ZWEtZW5naW5lIl0uZ3JlYXRlck9yRXF1YWxUaGFuKFswLDAsM10pKXtjb25zdCBzPXQubG9hZFVJbnQzMigpO2ZvcihsZXQgYT0wO2E8czthKyspe2NvbnN0IHM9dC5sb2FkU3RyKCksYT10LmxvYWRTdHIoKTtsZXQgaT10aGlzLmdldFBhcmFtZXRlcihhKTtpZighaSl7aWYoaT1JLmNvbnN0cnVjdENsYXNzKHMsYSksIWkpe2NvbnNvbGUuZXJyb3IoIlVuYWJsZSB0byBjb25zdHJ1Y3QgcHJvcDoiK2ErIiBvZiB0eXBlOiIrcyk7Y29udGludWV9dGhpcy5hZGRQYXJhbWV0ZXIoaSl9aS5yZWFkQmluYXJ5KHQsZSl9fX10b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLG51bGwsMil9Y29weUZyb20odCxlKXtsZXQgcz10Lm51bVBhcmFtZXRlcnMoKTtmb3IoO3MtLTspe2NvbnN0IGU9dC5nZXRQYXJhbWV0ZXJCeUluZGV4KHMpLGE9dGhpcy5nZXRQYXJhbWV0ZXIoZS5nZXROYW1lKCkpO2E/YS5zZXRWYWx1ZShlLmdldFZhbHVlKCksTik6dGhpcy5hZGRQYXJhbWV0ZXIoZS5jbG9uZSgpKX19ZGVzdHJveSgpe2Zvcihjb25zdCB0IG9mIHRoaXMuX19wYXJhbXMpdC5kZXN0cm95KCk7c3VwZXIuZGVzdHJveSgpfX17Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuX19ib3VuZGluZ0JveD1uZXcgcCx0aGlzLl9fYm91bmRpbmdCb3hEaXJ0eT0hMCx0aGlzLl9fdmVydGV4QXR0cmlidXRlcz1uZXcgTWFwLHRoaXMuX19tZXRhRGF0YT1uZXcgTWFwLHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCJwb3NpdGlvbnMiLHIsMCksdGhpcy5ib3VuZGluZ0JveERpcnRpZWQ9bmV3IHcsdGhpcy5nZW9tRGF0YUNoYW5nZWQ9bmV3IHcsdGhpcy5nZW9tRGF0YVRvcG9sb2d5Q2hhbmdlZD1uZXcgd31zZXREZWJ1Z05hbWUodCl7dGhpcy5fX25hbWU9dH1hZGRWZXJ0ZXhBdHRyaWJ1dGUodCxlLHMpe2xldCBhO3ZhciBpO3JldHVybiBhPShpPXMpJiZ2b2lkIDAhPT1pLmJ5dGVMZW5ndGg/bmV3IFYoZSxzKTpuZXcgVihlLG51bGwhPXRoaXMudmVydGljZXM/dGhpcy52ZXJ0aWNlcy5sZW5ndGg6MCxzKSx0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5zZXQodCxhKSxhfWhhc1ZlcnRleEF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuaGFzKHQpfWdldFZlcnRleEF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KHQpfWdldFZlcnRleEF0dHJpYnV0ZXModCl7Y29uc3QgZT17fTtmb3IoY29uc3RbdCxzXW9mIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmVudHJpZXMoKSllW3RdPXM7cmV0dXJuIGV9Z2V0IHZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmdldCgicG9zaXRpb25zIil9bnVtVmVydGljZXMoKXtyZXR1cm4gdGhpcy52ZXJ0aWNlcy5sZW5ndGh9Z2V0TnVtVmVydGljZXMoKXtyZXR1cm4gdGhpcy52ZXJ0aWNlcy5sZW5ndGh9c2V0TnVtVmVydGljZXModCl7dGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZm9yRWFjaChlPT5lLnJlc2l6ZSh0KSl9Z2V0VmVydGV4KHQpe3JldHVybiByLmNyZWF0ZUZyb21GbG9hdDMyQnVmZmVyKHRoaXMudmVydGljZXMuZGF0YS5idWZmZXIsMyp0KX1zZXRWZXJ0ZXgodCxlKXtyZXR1cm4gci5jcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcih0aGlzLnZlcnRpY2VzLmRhdGEuYnVmZmVyLDMqdCkuc2V0RnJvbU90aGVyKGUpfW1vdmVWZXJ0aWNlcyh0KXtjb25zdCBlPXRoaXMudmVydGljZXM7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspZS5nZXRWYWx1ZVJlZihzKS5hZGRJblBsYWNlKHQpO3RoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpfXRyYW5zZm9ybVZlcnRpY2VzKHQpe2NvbnN0IGU9dGhpcy52ZXJ0aWNlcztmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl7Y29uc3QgYT1lLmdldFZhbHVlUmVmKHMpLGk9dC50cmFuc2Zvcm1WZWMzKGEpO2Euc2V0KGkueCxpLnksaS56KX10aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKX1nZXQgYm91bmRpbmdCb3goKXtyZXR1cm4gdGhpcy5fX2JvdW5kaW5nQm94RGlydHkmJnRoaXMudXBkYXRlQm91bmRpbmdCb3goKSx0aGlzLl9fYm91bmRpbmdCb3h9c2V0Qm91bmRpbmdCb3hEaXJ0eSgpe3RoaXMuX19ib3VuZGluZ0JveERpcnR5PSEwLHRoaXMuYm91bmRpbmdCb3hEaXJ0aWVkLmVtaXQoKX11cGRhdGVCb3VuZGluZ0JveCgpe2NvbnN0IHQ9dGhpcy52ZXJ0aWNlcyxlPW5ldyBwLHM9dC5sZW5ndGg7Zm9yKGxldCBhPTA7YTxzO2ErKyllLmFkZFBvaW50KHQuZ2V0VmFsdWVSZWYoYSkpO3RoaXMuX19ib3VuZGluZ0JveD1lLHRoaXMuX19ib3VuZGluZ0JveERpcnR5PSExfWdldE1ldGFkYXRhKHQpe3JldHVybiB0aGlzLl9fbWV0YURhdGEuZ2V0KHQpfWhhc01ldGFkYXRhKHQpe3JldHVybiB0aGlzLl9fbWV0YURhdGEuaGFzKHQpfXNldE1ldGFkYXRhKHQsZSl7dGhpcy5fX21ldGFEYXRhLnNldCh0LGUpfWRlbGV0ZU1ldGFkYXRhKHQpe3RoaXMuX19tZXRhRGF0YS5kZWxldGUodCl9Z2VuQnVmZmVycyh0KXtjb25zdCBlPXt9O2Zvcihjb25zdFt0LHNdb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpZVt0XT17dmFsdWVzOnMuZGF0YSxjb3VudDpzLnNpemUsZGF0YVR5cGU6cy5kYXRhVHlwZSxub3JtYWxpemVkOnMubm9ybWFsaXplZH07cmV0dXJue251bVZlcnRpY2VzOnRoaXMubnVtVmVydGljZXMoKSxhdHRyQnVmZmVyczplfX1mcmVlQnVmZmVycygpe31sb2FkQmFzZUdlb21CaW5hcnkodCl7dGhpcy5uYW1lPXQubG9hZFN0cigpO2NvbnN0IGU9dC5sb2FkVUludDgoKTt0aGlzLmRlYnVnQ29sb3I9dC5sb2FkUkdCRmxvYXQzMkNvbG9yKCk7Y29uc3Qgcz10LmxvYWRVSW50MzIoKTt0aGlzLl9fYm91bmRpbmdCb3guc2V0KHQubG9hZEZsb2F0MzJWZWMzKCksdC5sb2FkRmxvYXQzMlZlYzMoKSksdGhpcy5zZXROdW1WZXJ0aWNlcyhzKTtjb25zdCBhPXRoaXMudmVydGljZXM7bGV0IG4saDsyJmUmJihuPXRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCJub3JtYWxzIiksbnx8KG49dGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoIm5vcm1hbHMiLHIsMCkpKSw0JmUmJihoPXRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCJ0ZXhDb29yZHMiKSxofHwoaD10aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgidGV4Q29vcmRzIixpLDApKSk7Y29uc3Qgbz0odCxlLHMsaSk9Pntmb3IobGV0IG49dFswXTtuPHRbMV07bisrKXtjb25zdCB0PW5ldyByKGlbMypuKzBdLzI1NSxpWzMqbisxXS8yNTUsaVszKm4rMl0vMjU1KTt0Lm11bHRpcGx5SW5QbGFjZShzKSx0LmFkZEluUGxhY2UoZSksYS5zZXRWYWx1ZShuLHQpfX0sXz0odCxlLHMsYSk9PntzLmlzTnVsbCgpJiZzLnNldCgxLDEsMSk7Zm9yKGxldCBpPXRbMF07aTx0WzFdO2krKyl7Y29uc3QgdD1uZXcgcihhWzMqaSswXS8yNTUsYVszKmkrMV0vMjU1LGFbMyppKzJdLzI1NSk7dC5tdWx0aXBseUluUGxhY2UocyksdC5hZGRJblBsYWNlKGUpLHQubm9ybWFsaXplSW5QbGFjZSgpLG4uc2V0VmFsdWUoaSx0KX19LGQ9KHQsZSxzLGEpPT57Zm9yKGxldCByPXRbMF07cjx0WzFdO3IrKyl7Y29uc3QgdD1uZXcgaShhWzIqciswXS8yNTUsYVsyKnIrMV0vMjU1KTt0Lm11bHRpcGx5SW5QbGFjZShzKSx0LmFkZEluUGxhY2UoZSksaC5zZXRWYWx1ZShyLHQpfX0sbD10LmxvYWRVSW50MzIoKTtpZigxPT1sKXt7Y29uc3QgZT10aGlzLl9fYm91bmRpbmdCb3gsYT10LmxvYWRVSW50OEFycmF5KDMqcyk7byhbMCxzXSxlLnAwLGUuZGlhZ29uYWwoKSxhKX1pZihuKXtjb25zdCBlPW5ldyBwKHQubG9hZEZsb2F0MzJWZWMzKCksdC5sb2FkRmxvYXQzMlZlYzMoKSksYT10LmxvYWRVSW50OEFycmF5KDMqcyk7XyhbMCxzXSxlLnAwLGUuZGlhZ29uYWwoKSxhKSxuLmxvYWRTcGxpdFZhbHVlcyh0KX1pZihoKXtjb25zdCBlPW5ldyBnKHQubG9hZEZsb2F0MzJWZWMyKCksdC5sb2FkRmxvYXQzMlZlYzIoKSksYT10LmxvYWRVSW50OEFycmF5KDIqcyk7ZChbMCxzXSxlLnAwLGUuZGlhZ29uYWwoKSxhKSxoLmxvYWRTcGxpdFZhbHVlcyh0KX19ZWxzZXtjb25zdCBlPVtdO2xldCBhPTA7Zm9yKGxldCBzPTA7czxsO3MrKyl7Y29uc3Qgcz10LmxvYWRVSW50MzIoKSxpPXtyYW5nZTpbYSxhK3NdLGJib3g6bmV3IHAodC5sb2FkRmxvYXQzMlZlYzMoKSx0LmxvYWRGbG9hdDMyVmVjMygpKX07biYmKGkubm9ybWFsc1JhbmdlPW5ldyBwKHQubG9hZEZsb2F0MzJWZWMzKCksdC5sb2FkRmxvYXQzMlZlYzMoKSkpLGgmJihpLnRleENvb3Jkc1JhbmdlPW5ldyBnKHQubG9hZEZsb2F0MzJWZWMyKCksdC5sb2FkRmxvYXQzMlZlYzIoKSkpLGUucHVzaChpKSxhKz1zfWNvbnN0IGk9dC5sb2FkVUludDhBcnJheSgzKnMpO2xldCByLGM7biYmKHI9dC5sb2FkVUludDhBcnJheSgzKnMpKSxoJiYoYz10LmxvYWRVSW50OEFycmF5KDIqcykpO2ZvcihsZXQgdD0wO3Q8bDt0Kyspe3tjb25zdCBzPWVbdF0uYmJveDtvKGVbdF0ucmFuZ2Uscy5wMCxzLmRpYWdvbmFsKCksaSl9aWYobil7Y29uc3Qgcz1lW3RdLm5vcm1hbHNSYW5nZTtfKGVbdF0ucmFuZ2Uscy5wMCxzLmRpYWdvbmFsKCkscil9aWYoaCl7Y29uc3Qgcz1lW3RdLnRleENvb3Jkc1JhbmdlO2QoZVt0XS5yYW5nZSxzLnAwLHMuZGlhZ29uYWwoKSxjKX19biYmbi5sb2FkU3BsaXRWYWx1ZXModCksaCYmaC5sb2FkU3BsaXRWYWx1ZXModCl9fXRvSlNPTih0LGUpe2xldCBzPXN1cGVyLnRvSlNPTih0LGUpO2lmKHN8fChzPXt9KSxzLnR5cGU9SS5nZXRDbGFzc05hbWUodGhpcyksISgxMDI0JmUpKXtjb25zdCBhPXt9O2Zvcihjb25zdFtzLGldb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKWFbc109aS50b0pTT04odCxlKTtzLnZlcnRleEF0dHJpYnV0ZXM9YX1yZXR1cm4gc31mcm9tSlNPTih0LGUscyl7c3VwZXIuZnJvbUpTT04odCxlLHMpO2Zvcihjb25zdCBlIGluIHQudmVydGV4QXR0cmlidXRlcyl7bGV0IHM9dGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KGUpO2NvbnN0IGk9dC52ZXJ0ZXhBdHRyaWJ1dGVzW2VdO2lmKCFzKXtjb25zdCB0PWEuZ2V0VHlwZShpLmRhdGFUeXBlKTtzPW5ldyBWZXJ0ZXhBdHRyaWJ1dGUodGhpcyx0LDAsaS5kZWZhdWx0U2NhbGFyVmFsdWUpLHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLnNldChlLHMpfXMuZnJvbUpTT04oaSl9fXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksbnVsbCwyKX19Y2xhc3MgQSBleHRlbmRzIE17Y29uc3RydWN0b3IoKXtzdXBlcigpfWxvYWRCaW4odCl7dGhpcy5uYW1lPXQubG9hZFN0cigpO2NvbnN0IGU9dC5sb2FkVUludDMyKCk7dGhpcy5fX2JvdW5kaW5nQm94LnNldCh0LmxvYWRGbG9hdDMyVmVjMygpLHQubG9hZEZsb2F0MzJWZWMzKCkpLHRoaXMuc2V0TnVtVmVydGljZXMoZSk7Y29uc3Qgcz10aGlzLnZlcnRpY2VzO2lmKGU8MjU2KXtjb25zdCBhPXRoaXMuX19ib3VuZGluZ0JveC50b01hdDQoKSxpPXQubG9hZFVJbnQ4QXJyYXkoMyplKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXtjb25zdCBlPW5ldyBWZWMzKGlbMyp0KzBdLzI1NSxpWzMqdCsxXS8yNTUsaVszKnQrMl0vMjU1KTtzLnNldFZhbHVlKHQsYS50cmFuc2Zvcm1WZWMzKGUpKX19ZWxzZXtjb25zdCBhPXQubG9hZFVJbnQzMigpLGk9W107Zm9yKGxldCBlPTA7ZTxhO2UrKyl7Y29uc3QgZT10LmxvYWRVSW50MzJWZWMyKCkscz10LmxvYWRGbG9hdDMyVmVjMygpLGE9dC5sb2FkRmxvYXQzMlZlYzMoKTtpLnB1c2goe3JhbmdlOmUsYmJveDpuZXcgQm94MyhzLGEpfSl9Y29uc3Qgcj10LmxvYWRVSW50OEFycmF5KDMqZSk7Zm9yKGxldCB0PTA7dDxhO3QrKyl7Y29uc3QgZT1pW3RdLmJib3gudG9NYXQ0KCk7Zm9yKGxldCBhPWlbdF0ucmFuZ2UueDthPGlbdF0ucmFuZ2UueTthKyspe2NvbnN0IHQ9bmV3IFZlYzMoclszKmErMF0vMjU1LHJbMyphKzFdLzI1NSxyWzMqYSsyXS8yNTUpO3Muc2V0VmFsdWUoYSxlLnRyYW5zZm9ybVZlYzModCkpfX19fXJlYWRCaW5hcnkodCxlKXtzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkodCksdGhpcy5nZW9tRGF0YUNoYW5nZWQuZW1pdCgpfX1jbGFzcyBTIGV4dGVuZHMgTXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5fX2luZGljZXM9bmV3IFVpbnQzMkFycmF5LHRoaXMuX19zZWdtZW50QXR0cmlidXRlcz1uZXcgTWFwLHRoaXMubGluZVRoaWNrbmVzcz0wfWdldEluZGljZXMoKXtyZXR1cm4gdGhpcy5fX2luZGljZXN9Z2V0TnVtU2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fX2luZGljZXMubGVuZ3RoLzJ9c2V0TnVtU2VnbWVudHModCl7Y29uc3QgZT1uZXcgVWludDMyQXJyYXkoMip0KTt0aGlzLl9faW5kaWNlcz1lfXNldFNlZ21lbnQodCxlLHMpe2lmKHQ+PXRoaXMuX19pbmRpY2VzLmxlbmd0aC8yKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBsaW5lIGluZGV4OiIrdCsiLiBOdW0gU2VnbWVudHM6Iit0aGlzLl9faW5kaWNlcy5sZW5ndGgvMik7dGhpcy5fX2luZGljZXNbMip0KzBdPWUsdGhpcy5fX2luZGljZXNbMip0KzFdPXN9Z2V0U2VnbWVudFZlcnRleEluZGV4KHQsZSl7aWYodDx0aGlzLm51bUxpbmVzKXJldHVybiB0aGlzLl9faW5kaWNlc1syKnQrZV19YWRkU2VnbWVudEF0dHJpYnV0ZSh0LGUscyl7Y29uc3QgYT1uZXcgQXR0cmlidXRlKGUsbnVsbCE9cz9zOnRoaXMucG9seWdvbkNvdW50KTtyZXR1cm4gdGhpcy5fX3NlZ21lbnRBdHRyaWJ1dGVzLnNldCh0LGEpLGF9aGFzU2VnbWVudEF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX3NlZ21lbnRBdHRyaWJ1dGVzLmhhcyh0KX1nZXRTZWdtZW50QXR0cmlidXRlKHQpe3JldHVybiB0aGlzLl9fc2VnbWVudEF0dHJpYnV0ZXMuZ2V0KHQpfWdlbkJ1ZmZlcnMoKXtjb25zdCB0PXN1cGVyLmdlbkJ1ZmZlcnMoKTtsZXQgZTtyZXR1cm4gdC5udW1WZXJ0aWNlczxNYXRoLnBvdygyLDgpPyhlPW5ldyBVaW50OEFycmF5KHRoaXMuX19pbmRpY2VzLmxlbmd0aCksdGhpcy5fX2luZGljZXMuZm9yRWFjaCgodCxzKT0+e2Vbc109dH0pKTp0Lm51bVZlcnRpY2VzPE1hdGgucG93KDIsMTYpPyhlPW5ldyBVaW50MTZBcnJheSh0aGlzLl9faW5kaWNlcy5sZW5ndGgpLHRoaXMuX19pbmRpY2VzLmZvckVhY2goKHQscyk9PntlW3NdPXR9KSk6ZT10aGlzLl9faW5kaWNlcyx0LmluZGljZXM9ZSx0fXJlYWRCaW5hcnkodCxlKXtzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkodCksdGhpcy5zZXROdW1TZWdtZW50cyh0LmxvYWRVSW50MzIoKSk7Y29uc3Qgcz10LmxvYWRVSW50OCgpOzE9PXM/dGhpcy5fX2luZGljZXM9dC5sb2FkVUludDhBcnJheSgpOjI9PXM/dGhpcy5fX2luZGljZXM9dC5sb2FkVUludDE2QXJyYXkoKTo0PT1zJiYodGhpcy5fX2luZGljZXM9dC5sb2FkVUludDMyQXJyYXkoKSksdGhpcy5nZW9tRGF0YUNoYW5nZWQuZW1pdCgpfXRvSlNPTih0LGUpe2NvbnN0IHM9c3VwZXIudG9KU09OKHQsZSk7cmV0dXJuIDEwMjQmZXx8KHMuaW5kaWNlcz1BcnJheS5mcm9tKHRoaXMuX19pbmRpY2VzKSksc31mcm9tSlNPTih0LGUscyl7c3VwZXIuZnJvbUpTT04odCxlLHMpLHRoaXMuX19pbmRpY2VzPVVpbnQzMkFycmF5LmZyb20odC5pbmRpY2VzKX19Y2xhc3MgTyBleHRlbmRzIFZ7Y29uc3RydWN0b3IodCxlLHMsYSl7c3VwZXIoZSxzLGEpLHRoaXMuX19nZW9tPXQsdGhpcy5fX3NwbGl0cz17fSx0aGlzLl9fc3BsaXRWYWx1ZXM9W119Z2V0RmFjZVZlcnRleFZhbHVlUmVmKHQsZSl7Y29uc3Qgcz10aGlzLl9fZ2VvbS5nZXRGYWNlVmVydGV4SW5kZXgodCxlKTtyZXR1cm4gcyBpbiB0aGlzLl9fc3BsaXRzJiZ0IGluIHRoaXMuX19zcGxpdHNbc10/dGhpcy5fX3NwbGl0VmFsdWVzW3RoaXMuX19zcGxpdHNbc11bdF1dOnRoaXMuZ2V0VmFsdWVSZWYocyl9c2V0RmFjZVZlcnRleFZhbHVlKHQsZSxzKXtjb25zdCBhPXRoaXMuX19nZW9tLmdldEZhY2VWZXJ0ZXhJbmRleCh0LGUpO3RoaXMuc2V0RmFjZVZlcnRleFZhbHVlX0J5VmVydGV4SW5kZXgodCxhLHMpfXNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KHQsZSxzKXtjb25zdCBhPXRoaXMuZ2V0VmFsdWVSZWYoZSk7aWYoYS5pc1ZhbGlkKCkpaWYoYS5hcHByb3hFcXVhbChzKSk7ZWxzZXtpZihlIGluIHRoaXMuX19zcGxpdHMpe2NvbnN0IGE9dGhpcy5fX3NwbGl0c1tlXTtmb3IoY29uc3QgZSBpbiBhKXtjb25zdCBpPWFbZV07aWYodGhpcy5fX3NwbGl0VmFsdWVzW2ldLmFwcHJveEVxdWFsKHMpKXJldHVybiB2b2lkKGFbdF09aSl9aWYodCBpbiB0aGlzLl9fc3BsaXRzW2VdKXtyZXR1cm4gdm9pZCB0aGlzLl9fc3BsaXRWYWx1ZXNbdGhpcy5fX3NwbGl0c1tlXVt0XV0uc2V0RnJvbU90aGVyKHMpfX1lbHNlIHRoaXMuX19zcGxpdHNbZV09e307dGhpcy5fX3NwbGl0c1tlXVt0XT10aGlzLl9fc3BsaXRWYWx1ZXMubGVuZ3RoLHRoaXMuX19zcGxpdFZhbHVlcy5wdXNoKHMpfWVsc2UgYS5zZXRGcm9tT3RoZXIocyl9c2V0U3BsaXRWZXJ0ZXhWYWx1ZSh0LGUscyl7aWYodCBpbiB0aGlzLl9fc3BsaXRzfHwodGhpcy5fX3NwbGl0c1t0XT17fSksZSBpbiB0aGlzLl9fc3BsaXRzW3RdKXtpZih0aGlzLl9fc3BsaXRWYWx1ZXNbdGhpcy5fX3NwbGl0c1t0XVtlXV0uYXBwcm94RXF1YWwocykpcmV0dXJuO2NvbnNvbGUud2FybigiRmFjZSBWZXJ0ZXggQWxyZWFkeSBTcGxpdCB3aXRoIGRpZmZlcmVudCB2YWx1ZSIpfXRoaXMuX19zcGxpdHNbdF1bZV09dGhpcy5fX3NwbGl0VmFsdWVzLmxlbmd0aCx0aGlzLl9fc3BsaXRWYWx1ZXMucHVzaChzKX1zZXRTcGxpdFZlcnRleFZhbHVlcyh0LGUscyl7dCBpbiB0aGlzLl9fc3BsaXRzfHwodGhpcy5fX3NwbGl0c1t0XT17fSk7Y29uc3QgYT10aGlzLl9fc3BsaXRWYWx1ZXMubGVuZ3RoO3RoaXMuX19zcGxpdFZhbHVlcy5wdXNoKHMpO2Zvcihjb25zdCBzIG9mIGUpdGhpcy5fX3NwbGl0c1t0XVtzXT1hfWdldFNwbGl0cygpe3JldHVybiB0aGlzLl9fc3BsaXRzfWdldFNwbGl0Q291bnQoKXtsZXQgdD0wO2Zvcihjb25zdCBlIGluIHRoaXMuX19zcGxpdHMpdCs9T2JqZWN0LmtleXModGhpcy5fX3NwbGl0c1tlXSkubGVuZ3RoO3JldHVybiB0fWdlbmVyYXRlU3BsaXRWYWx1ZXModCxlKXtpZigwPT1lKXJldHVybiB0aGlzLl9fZGF0YTtjb25zdCBzPXRoaXMubGVuZ3RoLGE9dGhpcy5sZW5ndGgrZSxpPXRoaXMuX19kYXRhVHlwZS5udW1FbGVtZW50cz90aGlzLl9fZGF0YVR5cGUubnVtRWxlbWVudHMoKToxLHI9bmV3IEZsb2F0MzJBcnJheShhKmkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5fX2RhdGEubGVuZ3RoO3QrKylyW3RdPXRoaXMuX19kYXRhW3RdO2Zvcihjb25zdCBlIGluIHQpe2NvbnN0IGE9dFtlXTtmb3IoY29uc3QgdCBpbiBhKXtjb25zdCBuPXMrYVt0XTtpZihlIGluIHRoaXMuX19zcGxpdHMmJnQgaW4gdGhpcy5fX3NwbGl0c1tlXSl7Y29uc3Qgcz10aGlzLl9fc3BsaXRzW2VdW3RdOzY9PXRoaXMuX19kYXRhVHlwZT9yW24qaV09dGhpcy5fX3NwbGl0VmFsdWVzW3NdOnRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tRmxvYXQzMkJ1ZmZlcihyLmJ1ZmZlcixuKmkpLnNldEZyb21PdGhlcih0aGlzLl9fc3BsaXRWYWx1ZXNbc10pfWVsc2V7Y29uc3QgdD1wYXJzZUludChlKTtmb3IobGV0IGU9MDtlPGk7ZSsrKXQqaStlPnRoaXMuX19kYXRhLmxlbmd0aCYmY29uc29sZS5sb2coIkVycm9yIHJlbWFwcGluZyBzcmM6Iit0KmkrZSksbippK2U+ci5sZW5ndGgmJmNvbnNvbGUubG9nKCJFcnJvciByZW1hcHBpbmcgdGd0OiIrbippK2UpLHJbbippK2VdPXRoaXMuX19kYXRhW3QqaStlXX19fXJldHVybiByfXRvSlNPTih0LGUpe2NvbnN0IHM9c3VwZXIudG9KU09OKHQsZSk7cmV0dXJuIHMuc3BsaXRzPXRoaXMuX19zcGxpdHMscy5zcGxpdFZhbHVlcz10aGlzLl9fc3BsaXRWYWx1ZXMsc31mcm9tSlNPTih0LGUscyl7c3VwZXIuZnJvbUpTT04odCxlLHMpLHRoaXMuX19zcGxpdHM9dC5zcGxpdHMsdGhpcy5fX3NwbGl0VmFsdWVzPVtdO2Zvcihjb25zdCBlIG9mIHQuc3BsaXRWYWx1ZXMpdGhpcy5fX3NwbGl0VmFsdWVzLnB1c2godGhpcy5fX2RhdGFUeXBlLmNyZWF0ZUZyb21KU09OKGUpKX1sb2FkU3BsaXRWYWx1ZXModCl7Y29uc3QgZT10LmxvYWRVSW50MzJBcnJheSgpO2lmKDA9PWUubGVuZ3RoKXJldHVybjtsZXQgcz0wLGE9MDtmb3IoOzspe2NvbnN0IHQ9ZVtzKytdLGk9ZVtzKytdLHI9e307Zm9yKGxldCB0PTA7dDxpO3QrKyl7Y29uc3QgdD1lW3MrK10saT1lW3MrK107clt0XT1pLGk+PWEmJihhPWkrMSl9aWYodGhpcy5fX3NwbGl0c1t0XT1yLHM+PWUubGVuZ3RoKWJyZWFrfWNvbnN0IGk9dGhpcy5fX251bUZsb2F0MzJFbGVtZW50cyxyPXQubG9hZEZsb2F0MzJBcnJheShhKmkpO3RoaXMuX19zcGxpdFZhbHVlcz1bXTtmb3IobGV0IHQ9MDt0PGE7dCsrKXtjb25zdCBlPXRoaXMuX19kYXRhVHlwZS5jcmVhdGVGcm9tRmxvYXQzMkFycmF5KHIuc2xpY2UodCppLHQqaStpKSk7dGhpcy5fX3NwbGl0VmFsdWVzLnB1c2goZSl9fX1jbGFzcyBQIGV4dGVuZHMgTXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5pbml0KCl9aW5pdCgpe3RoaXMuX19mYWNlQ291bnRzPVtdLHRoaXMuX19mYWNlVmVydGV4Q291bnRzPW5ldyBVaW50OEFycmF5LHRoaXMuX19mYWNlT2Zmc2V0cz1uZXcgVWludDMyQXJyYXksdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzPW5ldyBVaW50MzJBcnJheSx0aGlzLl9fbnVtUG9wdWxhdGVkRmFjZVZlcnRleEluZGljZXM9MCx0aGlzLl9fZmFjZUF0dHJpYnV0ZXM9bmV3IE1hcCx0aGlzLl9fZWRnZUF0dHJpYnV0ZXM9bmV3IE1hcCx0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncz0hMSx0aGlzLmVkZ2VWZXJ0cz12b2lkIDAsdGhpcy52ZXJ0ZXhFZGdlcz12b2lkIDAsdGhpcy5udW1FZGdlcz0wLHRoaXMuZWRnZUZsYWdzPW5ldyBVaW50MzJBcnJheSx0aGlzLmVkZ2VBbmdsZXM9bmV3IEZsb2F0MzJBcnJheX1nZXRGYWNlVmVydGV4SW5kaWNlcygpe3JldHVybiB0aGlzLl9fZmFjZVZlcnRleEluZGljZXN9Z2V0RmFjZUNvdW50cygpe3JldHVybiB0aGlzLl9fZmFjZUNvdW50c31jbGVhcigpe3RoaXMuX19mYWNlVmVydGV4SW5kaWNlcz12b2lkIDAsdGhpcy5fX2ZhY2VDb3VudHM9W10sdGhpcy5fX251bVBvcHVsYXRlZEZhY2VWZXJ0ZXhJbmRpY2VzPTB9c2V0RmFjZUNvdW50cyh0KXtpZih0aGlzLl9fbnVtUG9wdWxhdGVkRmFjZVZlcnRleEluZGljZXMpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2V0IGZhY2UgY291bnRzIG9uIGEgbWVzaCB0aGF0IGlzIGFscmVhZHkgcG9wdWxhdGVkLiBQbGVhc2UgY2FsbCAnY2xlYXInIGJlZm9yZSByZS1idWlsZGluZyB0aGUgbWVzaC4iKTt0aGlzLl9fZmFjZUNvdW50cz10O2xldCBlPTAscz0wLGE9Mztmb3IoY29uc3QgdCBvZiB0aGlzLl9fZmFjZUNvdW50cyllKz10LHMrPXQqYSxhKys7dGhpcy5fX2ZhY2VWZXJ0ZXhDb3VudHM9bmV3IFVpbnQ4QXJyYXkoZSksdGhpcy5fX2ZhY2VPZmZzZXRzPW5ldyBVaW50MzJBcnJheShlKSx0aGlzLl9fZmFjZVZlcnRleEluZGljZXM9bmV3IFVpbnQzMkFycmF5KHMpO2Zvcihjb25zdCB0IG9mIHRoaXMuX19mYWNlQXR0cmlidXRlcyl0LnJlc2l6ZShlKX1zZXRGYWNlVmVydGV4SW5kaWNlcyh0KXtjb25zdCBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxzPXRoaXMuX19udW1Qb3B1bGF0ZWRGYWNlVmVydGV4SW5kaWNlcztmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbcyt0XT1lW3RdO3RoaXMuX19mYWNlVmVydGV4Q291bnRzW3RdPWUubGVuZ3RoLTMsdGhpcy5fX2ZhY2VPZmZzZXRzW3RdPXMsdGhpcy5fX251bVBvcHVsYXRlZEZhY2VWZXJ0ZXhJbmRpY2VzKz1lLmxlbmd0aH1nZXRGYWNlVmVydGV4SW5kaWNlcyh0KXtjb25zdCBlPVtdLHM9dGhpcy5fX2ZhY2VPZmZzZXRzW3RdLGE9dGhpcy5fX2ZhY2VWZXJ0ZXhDb3VudHNbdF0rMztmb3IobGV0IHQ9MDt0PGE7dCsrKWUucHVzaCh0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbcyt0XSk7cmV0dXJuIGV9Z2V0RmFjZVZlcnRleEluZGV4KHQsZSl7Y29uc3Qgcz10aGlzLl9fZmFjZU9mZnNldHNbdF07cmV0dXJuIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlc1tzK2VdfWdldE51bUZhY2VzKCl7cmV0dXJuIHRoaXMuX19mYWNlVmVydGV4Q291bnRzLmxlbmd0aH1hZGRWZXJ0ZXhBdHRyaWJ1dGUodCxlLHMpe2NvbnN0IGE9bmV3IE8odGhpcyxlLG51bGwhPXRoaXMudmVydGljZXM/dGhpcy52ZXJ0aWNlcy5sZW5ndGg6MCxzKTtyZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuc2V0KHQsYSksYX1hZGRGYWNlQXR0cmlidXRlKHQsZSxzKXtjb25zdCBhPW5ldyBWKGUsbnVsbCE9cz9zOnRoaXMuZ2V0TnVtRmFjZXMoKSk7cmV0dXJuIHRoaXMuX19mYWNlQXR0cmlidXRlcy5zZXQodCxhKSxhfWhhc0ZhY2VBdHRyaWJ1dGUodCl7cmV0dXJuIHRoaXMuX19mYWNlQXR0cmlidXRlcy5oYXModCl9Z2V0RmFjZUF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX2ZhY2VBdHRyaWJ1dGVzLmdldCh0KX1hZGRFZGdlQXR0cmlidXRlKHQsZSxzKXtjb25zdCBhPW5ldyBWKGUsbnVsbCE9cz9zOnRoaXMuZ2V0TnVtRWRnZXMoKSk7cmV0dXJuIHRoaXMuX19lZGdlQXR0cmlidXRlcy5zZXQodCxhKSxhfWhhc0VkZ2VBdHRyaWJ1dGUodCl7cmV0dXJuIHRoaXMuX19lZGdlQXR0cmlidXRlcy5oYXModCl9Z2V0RWRnZUF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX2VkZ2VBdHRyaWJ1dGVzLmdldCh0KX1nZW5Ub3BvbG9neUluZm8oKXtjb25zdCB0PXt9O3RoaXMudmVydGV4RWRnZXM9W10sdGhpcy5lZGdlRmFjZXM9W10sdGhpcy5lZGdlVmVydHM9W10sdGhpcy5mYWNlRWRnZXM9W10sdGhpcy5udW1FZGdlcz0wO2NvbnN0IGU9KGUscyk9PntsZXQgYT1lLGk9cztpZihpPGEpe2NvbnN0IHQ9YTthPWksaT10fWNvbnN0IHI9YSsiPiIraTtpZihyIGluIHQpcmV0dXJuIHRbcl07Y29uc3Qgbj10aGlzLnZlcnRpY2VzLmdldFZhbHVlUmVmKGEpLGg9dGhpcy52ZXJ0aWNlcy5nZXRWYWx1ZVJlZihpKS5zdWJ0cmFjdChuKSxvPXtlZGdlSW5kZXg6dGhpcy5lZGdlRmFjZXMubGVuZ3RoLzIsZWRnZVZlYzpofTtyZXR1cm4gdFtyXT1vLHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpLHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpLHRoaXMuZWRnZVZlcnRzLnB1c2goYSksdGhpcy5lZGdlVmVydHMucHVzaChpKSx0aGlzLm51bUVkZ2VzKyssb30scz0odCxzLGEpPT57Y29uc3QgaT1lKHQscykuZWRnZUluZGV4O2lmKHM8dCl7Y29uc3QgdD0yKmkrMDt0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyYmLTEhPXRoaXMuZWRnZUZhY2VzW3RdJiZjb25zb2xlLndhcm4oIkVkZ2UgcG9seSAwIGFscmVhZHkgc2V0LiBNZXNoIGlzIG5vbi1tYW5pZm9sZC4iKSx0aGlzLmVkZ2VGYWNlc1t0XT1hfWVsc2V7Y29uc3QgdD0yKmkrMTt0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyYmLTEhPXRoaXMuZWRnZUZhY2VzW3RdJiZjb25zb2xlLndhcm4oIkVkZ2UgcG9seSAxIGFscmVhZHkgc2V0LiBNZXNoIGlzIG5vbi1tYW5pZm9sZC4iKSx0aGlzLmVkZ2VGYWNlc1t0XT1hfWEgaW4gdGhpcy5mYWNlRWRnZXN8fCh0aGlzLmZhY2VFZGdlc1thXT1bXSksdGhpcy5mYWNlRWRnZXNbYV0ucHVzaChpKSxudWxsPT10aGlzLnZlcnRleEVkZ2VzW3RdJiYodGhpcy52ZXJ0ZXhFZGdlc1t0XT1uZXcgU2V0KSxudWxsPT10aGlzLnZlcnRleEVkZ2VzW3NdJiYodGhpcy52ZXJ0ZXhFZGdlc1tzXT1uZXcgU2V0KSx0aGlzLnZlcnRleEVkZ2VzW3RdLmFkZChpKSx0aGlzLnZlcnRleEVkZ2VzW3NdLmFkZChpKX0sYT10aGlzLmdldE51bUZhY2VzKCk7Zm9yKGxldCB0PTA7dDxhO3QrKyl7Y29uc3QgZT10aGlzLmdldEZhY2VWZXJ0ZXhJbmRpY2VzKHQpO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSsrKXtzKGVbYV0sZVsoYSsxKSVlLmxlbmd0aF0sdCl9fX1jb21wdXRlRmFjZU5vcm1hbHMoKXtjb25zdCB0PXRoaXMudmVydGljZXMsZT10aGlzLmFkZEZhY2VBdHRyaWJ1dGUoIm5vcm1hbHMiLHIpLHM9dGhpcy5nZXROdW1GYWNlcygpO2ZvcihsZXQgYT0wO2E8czthKyspe2NvbnN0IHM9dGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyhhKSxpPXQuZ2V0VmFsdWVSZWYoc1swXSk7bGV0IG49dC5nZXRWYWx1ZVJlZihzWzFdKTtjb25zdCBoPW5ldyByO2ZvcihsZXQgZT0yO2U8cy5sZW5ndGg7ZSsrKXtjb25zdCBhPXQuZ2V0VmFsdWVSZWYoc1tlXSkscj1uLnN1YnRyYWN0KGkpLG89YS5zdWJ0cmFjdChpKTtoLmFkZEluUGxhY2Uoci5jcm9zcyhvKS5ub3JtYWxpemUoKSksbj1hfWgubGVuZ3RoU3F1YXJlZCgpLE51bWJlci5FUFNJTE9OLGUuc2V0VmFsdWUoYSxoLm5vcm1hbGl6ZSgpKX19Z2VuZXJhdGVFZGdlRmxhZ3MoKXtudWxsPT10aGlzLnZlcnRleEVkZ2VzJiZ0aGlzLmdlblRvcG9sb2d5SW5mbygpLHRoaXMuaGFzRmFjZUF0dHJpYnV0ZSgibm9ybWFscyIpfHx0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO2NvbnN0IHQ9dGhpcy52ZXJ0aWNlcyxlPXRoaXMuZ2V0RmFjZUF0dHJpYnV0ZSgibm9ybWFscyIpO3RoaXMuZWRnZVZlY3M9W10sdGhpcy5lZGdlQW5nbGVzPW5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1FZGdlcyk7Zm9yKGxldCBzPTA7czx0aGlzLmVkZ2VGYWNlcy5sZW5ndGg7cys9Mil7Y29uc3QgYT10aGlzLmVkZ2VWZXJ0c1tzXSxpPXRoaXMuZWRnZVZlcnRzW3MrMV0scj10LmdldFZhbHVlUmVmKGkpLnN1YnRyYWN0KHQuZ2V0VmFsdWVSZWYoYSkpO3Iubm9ybWFsaXplSW5QbGFjZSgpLHRoaXMuZWRnZVZlY3MucHVzaChyKTtjb25zdCBuPXRoaXMuZWRnZUZhY2VzW3NdLGg9dGhpcy5lZGdlRmFjZXNbcysxXTtpZigtMT09bnx8LTE9PWgpe3RoaXMuZWRnZUFuZ2xlc1tzLzJdPTIqTWF0aC5QSTtjb250aW51ZX1jb25zdCBvPWUuZ2V0VmFsdWVSZWYobiksXz1lLmdldFZhbHVlUmVmKGgpO3RoaXMuZWRnZUFuZ2xlc1tzLzJdPW8uYW5nbGVUbyhfKX19Y29tcHV0ZVZlcnRleE5vcm1hbHModD0xKXt0aGlzLmdlbmVyYXRlRWRnZUZsYWdzKCk7dGhpcy52ZXJ0aWNlcztjb25zdCBlPXRoaXMuZ2V0RmFjZUF0dHJpYnV0ZSgibm9ybWFscyIpLHM9dGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoIm5vcm1hbHMiLHIpLGE9ZS5kYXRhLmJ1ZmZlcixpPXMuZGF0YSxuPSh0LGUpPT57aVszKnQrMF09ZS54LGlbMyp0KzFdPWUueSxpWzMqdCsyXT1lLnp9LGg9KHQsZSk9PntsZXQgcyxhO2NvbnN0IGk9dGhpcy5mYWNlRWRnZXNbdF07Zm9yKGNvbnN0IHQgb2YgaSkodGhpcy5lZGdlVmVydHNbMip0XT09ZXx8dGhpcy5lZGdlVmVydHNbMip0KzFdPT1lKSYmKHM/YT10aGlzLmVkZ2VWZWNzW3RdOnM9dGhpcy5lZGdlVmVjc1t0XSk7cmV0dXJuW3MsYV19O2ZvcihsZXQgZT0wO2U8dGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGg7ZSsrKXtpZihudWxsPT10aGlzLnZlcnRleEVkZ2VzW2VdKWNvbnRpbnVlO2NvbnN0IGk9dGhpcy52ZXJ0ZXhFZGdlc1tlXSxfPVtdLGQ9dD0+e2xldCBlPSExO2Zvcihjb25zdCBzIG9mIF8paWYoZT0tMSE9cy5pbmRleE9mKHQpLGUpYnJlYWs7ZXx8Xy5wdXNoKFt0XSl9O2Zvcihjb25zdCBlIG9mIGkpe2NvbnN0IHM9dGhpcy5lZGdlRmFjZXNbMiplXSxhPXRoaXMuZWRnZUZhY2VzWzIqZSsxXTtpZigtMSE9cyYmLTE9PWEmJnRoaXMuZWRnZUFuZ2xlc1tlXTx0KXtsZXQgdD0tMSxlPS0xO2ZvcihsZXQgaT0wO2k8Xy5sZW5ndGg7aSsrKS0xPT10JiYtMSE9X1tpXS5pbmRleE9mKHMpJiYodD1pKSwtMT09ZSYmLTEhPV9baV0uaW5kZXhPZihhKSYmKGU9aSk7LTE9PXQmJi0xPT1lP18ucHVzaChbcyxhXSk6LTEhPXQmJi0xIT1lP3QhPWUmJihfW3RdPV9bdF0uY29uY2F0KF9bZV0pLF8uc3BsaWNlKGUsMSkpOigtMT09dCYmX1tlXS5wdXNoKHMpLC0xPT1lJiZfW3RdLnB1c2goYSkpfWVsc2UtMSE9cyYmZChzKSwtMSE9YSYmZChhKX1fLnNvcnQoKHQsZSk9PnQubGVuZ3RoPGUubGVuZ3RoPzE6dC5sZW5ndGg+ZS5sZW5ndGg/LTE6MCk7bGV0IGw9ITA7Zm9yKGNvbnN0IHQgb2YgXyl7Y29uc3QgaT1uZXcgcjtmb3IoY29uc3QgcyBvZiB0KXtjb25zdCB0PWgocyxlKSxuPXRbMF0uYW5nbGVUbyh0WzFdKTtpLmFkZEluUGxhY2UoKG89cyxuZXcgcihhLDEyKm8pKS5zY2FsZShuKSl9aS5ub3JtYWxpemVJblBsYWNlKCksbD8obihlLGkpLGw9ITEpOnMuc2V0U3BsaXRWZXJ0ZXhWYWx1ZXMoZSx0LGkpfX12YXIgbztyZXR1cm4gc31jb21wdXRlTnVtVHJpYW5nbGVzKCl7bGV0IHQ9MyxlPTA7Zm9yKGNvbnN0IHMgb2YgdGhpcy5fX2ZhY2VDb3VudHMpZSs9cyoodC0yKSx0Kys7cmV0dXJuIGV9Z2VuZXJhdGVUcmlhbmd1bGF0ZWRJbmRpY2VzKHQsZSxzKXtjb25zdCBhPXRoaXMuY29tcHV0ZU51bVRyaWFuZ2xlcygpO2xldCBpO2k9dDxNYXRoLnBvdygyLDgpP25ldyBVaW50OEFycmF5KDMqYSk6dDxNYXRoLnBvdygyLDE2KT9uZXcgVWludDE2QXJyYXkoMyphKTpuZXcgVWludDMyQXJyYXkoMyphKTtsZXQgcj0wO2NvbnN0IG49ZnVuY3Rpb24odCxhKXt0IGluIHMmJmEgaW4gc1t0XSYmKHQ9ZStzW3RdW2FdKSxpW3JdPXQscisrfSxoPXRoaXMuZ2V0TnVtRmFjZXMoKTtmb3IobGV0IHQ9MDt0PGg7dCsrKXtjb25zdCBlPXRoaXMuZ2V0RmFjZVZlcnRleEluZGljZXModCk7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspcz49MyYmKG4oZVswXSx0KSxuKGVbcy0xXSx0KSksbihlW3NdLHQpfXJldHVybiBpfWNvbXB1dGVIYXJkRWRnZXNJbmRpY2VzKHQ9MSl7Y29uc3QgZT1bXSxzPXQ9PntlLnB1c2godGhpcy5lZGdlVmVydHNbdF0pLGUucHVzaCh0aGlzLmVkZ2VWZXJ0c1t0KzFdKX07Zm9yKGxldCBlPTA7ZTx0aGlzLmVkZ2VGbGFncy5sZW5ndGg7ZSs9Mil0aGlzLmVkZ2VBbmdsZXNbZS8yXT50JiZzKGUpO3JldHVybiBlfWdldFdpcmVmcmFtZUluZGljZXMoKXtyZXR1cm4gaW5kaWNlc31nZW5CdWZmZXJzKHQpe2NvbnN0IGU9e307bGV0IHM9MDtmb3IoY29uc3RbLHRdb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpe2NvbnN0IGE9dC5nZXRTcGxpdHMoKTtmb3IoY29uc3QgdCBpbiBhKXt0IGluIGV8fChlW3RdPXt9KTtjb25zdCBpPWFbdF07Zm9yKGNvbnN0IGEgaW4gaSl7Y29uc3QgaT1wYXJzZUludChhKTtpIGluIGVbdF18fChlW3RdW2ldPXMscysrKX19fWNvbnN0IGE9dGhpcy52ZXJ0aWNlcy5sZW5ndGgsaT1hK3M7bGV0IHI7dCYmMD09dC5pbmNsdWRlSW5kaWNlc3x8KHI9dGhpcy5nZW5lcmF0ZVRyaWFuZ3VsYXRlZEluZGljZXMoaSxhLGUpKTtjb25zdCBuPXt9O2Zvcihjb25zdFt0LGFdb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpe2xldCBpO2k9MD09cz9hLmRhdGE6YS5nZW5lcmF0ZVNwbGl0VmFsdWVzKGUscyk7Y29uc3Qgcj1hLm51bUVsZW1lbnRzLGg9aS5sZW5ndGgvcjtuW3RdPXt2YWx1ZXM6aSxjb3VudDpoLGRpbWVuc2lvbjpyLG5vcm1hbGl6ZWQ6Im5vcm1hbHMiPT10LGRhdGFUeXBlOmEuZGF0YVR5cGV9fWNvbnN0IGg9e251bVZlcnRpY2VzOnRoaXMubnVtVmVydGljZXMoKSxudW1SZW5kZXJWZXJ0czppLGluZGljZXM6cixhdHRyQnVmZmVyczpufTtpZih0JiZ0LmluY2x1ZGVWZXJ0ZXhOZWlnaGJvcnMpe251bGw9PXRoaXMudmVydGV4RWRnZXMmJnRoaXMuZ2VuVG9wb2xvZ3lJbmZvKCk7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMudmVydGV4RWRnZXMubGVuZ3RoO2UrKyl0aGlzLnZlcnRleEVkZ2VzW2VdJiYodCs9dGhpcy52ZXJ0ZXhFZGdlc1tlXS5zaXplKTtjb25zdCBlPW5ldyBVaW50MzJBcnJheSgyKnRoaXMudmVydGV4RWRnZXMubGVuZ3RoK3QpLHM9dD0+e2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBzPXRbZV07Zm9yKGxldCBhPTA7YTxlO2ErKyl7Y29uc3QgaT10W2FdO2lmKC0xIT1zWzBdJiZzWzBdPT1pWzFdKXtlIT1hKzEmJih0LnNwbGljZShlLDEpLHQuc3BsaWNlKGErMSwwLHMpKTticmVha31pZigtMSE9c1sxXSYmc1sxXT09aVswXSl7dC5zcGxpY2UoZSwxKSx0LnNwbGljZShhLDAscyk7YnJlYWt9fX19LGE9dD0+e2lmKCEoLTEhPXRbMF1bMF0mJi0xIT10W3QubGVuZ3RoLTFdWzFdfHwtMT09dFswXVswXSYmLTE9PXRbdC5sZW5ndGgtMV1bMV0pKXRocm93IG5ldyBFcnJvcigiSWYgZmFuIHN0YXJ0cyB3aXRoIC0xLCBpdCBtdXN0IGFsc28gZW5kIHdpdGggLTEiKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgcz10W2VdO2lmKCgtMT09c1swXXx8LTE9PXNbMV0pJiYwIT1lJiZlIT10Lmxlbmd0aC0xKXRocm93IG5ldyBFcnJvcigiLTEgb25seSBhbGxvd2VkIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIGZhbi4iKTtpZigtMSE9c1swXSl7bGV0IGE9ZS0xO2lmKGE8MCYmKGErPXQubGVuZ3RoKSxzWzBdIT10W2FdWzFdKXRocm93IG5ldyBFcnJvcigiRmFjZXMgYXJlIG5vdCBzZXF1ZW50aWFsIil9aWYoLTEhPXNbMV0pe2NvbnN0IGE9KGUrMSkldC5sZW5ndGg7aWYoc1sxXSE9dFthXVswXSl0aHJvdyBuZXcgRXJyb3IoIkZhY2VzIGFyZSBub3Qgc2VxdWVudGlhbCIpfX19O2xldCBpPTIqdGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGg7Zm9yKGxldCB0PTA7dDx0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aDt0Kyspe2lmKG51bGw9PXRoaXMudmVydGV4RWRnZXNbdF0pY29udGludWU7Y29uc3Qgcj10aGlzLnZlcnRleEVkZ2VzW3RdLG49W107Zm9yKGNvbnN0IGUgb2Ygcil7Y29uc3Qgcz10aGlzLmVkZ2VWZXJ0c1syKmVdLGE9dGhpcy5lZGdlVmVydHNbMiplKzFdO2xldCBpLHI9dGhpcy5lZGdlRmFjZXNbMiplXSxoPXRoaXMuZWRnZUZhY2VzWzIqZSsxXTtpZihzPT10KWk9YTtlbHNle2lmKGEhPXQpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHRvcG9sb2d5Iik7e2k9cztjb25zdCB0PXI7cj1oLGg9dH19bi5wdXNoKFtyLGgsaV0pfXMobiksYShuKTtsZXQgaD0wOygtMSE9blswXVswXXx8LTEhPW5bbi5sZW5ndGgtMV1bMV0pJiYoaCs9MSksZVsyKnRdPWksZVsyKnQrMV09ci5zaXplKyhoPDw4KTtmb3IoY29uc3QgdCBvZiBuKWVbaV09dFsyXSxpKyt9aC52ZXJ0ZXhOZWlnaGJvcnM9ZX1yZXR1cm4gaH1mcmVlQnVmZmVycygpe3N1cGVyLmZyZWVCdWZmZXJzKCksdGhpcy5pbml0KCl9cmVhZEJpbmFyeSh0LGUpe3N1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeSh0KSx0aGlzLnNldEZhY2VDb3VudHModC5sb2FkVUludDMyQXJyYXkoKSksdGhpcy5fX2ZhY2VWZXJ0ZXhDb3VudHM9dC5sb2FkVUludDhBcnJheSh0aGlzLl9fZmFjZVZlcnRleENvdW50cy5sZW5ndGgpO2NvbnN0IHM9dC5sb2FkU0ludDMyVmVjMigpLGE9dC5sb2FkVUludDgoKTtsZXQgcjsxPT1hP3I9dC5sb2FkVUludDhBcnJheSgpOjI9PWE/cj10LmxvYWRVSW50MTZBcnJheSgpOjQ9PWEmJihyPXQubG9hZFVJbnQzMkFycmF5KCkpO2NvbnN0IG49dGhpcy5nZXROdW1GYWNlcygpO2xldCBoPTAsbz0wO2ZvcihsZXQgdD0wO3Q8bjt0Kyspe2NvbnN0IGU9dGhpcy5fX2ZhY2VWZXJ0ZXhDb3VudHNbdF0rMzt0aGlzLl9fZmFjZU9mZnNldHNbdF09aDtmb3IobGV0IGE9MDthPGU7YSsrKXtjb25zdCBlPWgrYSxpPXJbZV0rcy54O2lmKDA9PXQpdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW2VdPWk7ZWxzZXtsZXQgcz10aGlzLl9fZmFjZU9mZnNldHNbdC0xXTtzKz1hPG8/YTpvLTEsdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW2VdPXRoaXMuX19mYWNlVmVydGV4SW5kaWNlc1tzXStpfX1oKz1lLG89ZX10aGlzLl9fbnVtUG9wdWxhdGVkRmFjZVZlcnRleEluZGljZXM9aDtjb25zdCBfPXQubG9hZFVJbnQzMigpO2lmKF8+MCl7Y29uc3QgZT10aGlzLnZlcnRpY2VzLHM9dGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoImxpZ2h0bWFwQ29vcmRzIixpKTtmb3IobGV0IGE9MDthPF87YSsrKXtjb25zdCBhPW5ldyBtKHQubG9hZEZsb2F0MzJWZWMzKCksdC5sb2FkRmxvYXQzMlF1YXQoKSkscj10LmxvYWRGbG9hdDMyKCksbj10LmxvYWRGbG9hdDMyVmVjMigpLGg9dC5sb2FkU0ludDMyVmVjMigpLG89dC5sb2FkVUludDgoKTtsZXQgXztfPTE9PW8/dC5sb2FkVUludDhBcnJheSgpOjI9PW8/dC5sb2FkVUludDE2QXJyYXkoKTp0LmxvYWRVSW50MzJBcnJheSgpO2xldCBkPTA7Zm9yKGNvbnN0IHQgb2YgXyl7bGV0IG89dCtoLng7bys9ZCxkPW87Y29uc3QgXz10aGlzLmdldEZhY2VWZXJ0ZXhJbmRpY2VzKG8pO2Zvcihjb25zdCB0IG9mIF8pe2NvbnN0IGg9ZS5nZXRWYWx1ZVJlZih0KSxfPWEudHJhbnNmb3JtVmVjMyhoKSxkPW5ldyBpKF8ueCxfLnopO2Quc2NhbGVJblBsYWNlKHIpLGQuYWRkSW5QbGFjZShuKSxzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KG8sdCxkKX19fX10aGlzLmhhc1ZlcnRleEF0dHJpYnV0ZSgibm9ybWFscyIpfHx0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCksdGhpcy5nZW9tRGF0YUNoYW5nZWQuZW1pdCgpfXRvSlNPTih0LGUpe2NvbnN0IHM9c3VwZXIudG9KU09OKHQsZSk7cmV0dXJuIDEwMjQmZXx8KHMuZmFjZUNvdW50cz1BcnJheS5mcm9tKHRoaXMuX19mYWNlQ291bnRzKSxzLmZhY2VWZXJ0ZXhJbmRpY2VzPUFycmF5LmZyb20odGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzKSksc31mcm9tSlNPTih0LGUscyl7c3VwZXIuZnJvbUpTT04odCxlLHMpLHQuZmFjZUNvdW50cyYmKHRoaXMuX19mYWNlQ291bnRzPVVpbnQzMkFycmF5LmZyb20odC5mYWNlQ291bnRzKSksdC5mYWNlVmVydGV4SW5kaWNlcyYmKHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcz1VaW50MzJBcnJheS5mcm9tKHQuZmFjZVZlcnRleEluZGljZXMpKX19Y2xhc3MgRXtjb25zdHJ1Y3Rvcih0LGU9MCxzPSEwKXt0aGlzLl9fZGF0YT10LHRoaXMuX19ieXRlT2Zmc2V0PWUsdGhpcy5fX2RhdGFWaWV3PW5ldyBEYXRhVmlldyh0aGlzLl9fZGF0YSksdGhpcy5fX2lzTW9iaWxlRGV2aWNlPXMsdGhpcy51dGY4ZGVjb2Rlcj1uZXcgVGV4dERlY29kZXJ9Z2V0IGlzTW9iaWxlRGV2aWNlKCl7cmV0dXJuIHRoaXMuX19pc01vYmlsZURldmljZX1nZXQgZGF0YSgpe3JldHVybiB0aGlzLl9fZGF0YX1nZXQgYnl0ZUxlbmd0aCgpe3JldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aH1nZXQgcmVtYWluaW5nQnl0ZUxlbmd0aCgpe3JldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aC10aGlzLl9fYnl0ZU9mZnNldH1wb3MoKXtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXR9c2Vlayh0KXt0aGlzLl9fYnl0ZU9mZnNldD10fWFkdmFuY2UodCl7dGhpcy5fX2J5dGVPZmZzZXQrPXR9bG9hZFVJbnQ4KCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5fX2J5dGVPZmZzZXQpO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9MSx0fWxvYWRVSW50MTYoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRVaW50MTYodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9Mix0fWxvYWRVSW50MzIoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9NCx0fWxvYWRTSW50MzIoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRJbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz00LHR9bG9hZEZsb2F0MTYoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQxNigpO3JldHVybiBNYXRoLmRlY29kZTE2Qml0RmxvYXQodCl9bG9hZFVGbG9hdDE2KCl7Y29uc3QgdD10aGlzLmxvYWRGbG9hdDE2KCk7cmV0dXJuIHQ8MD8yMDQ4LXQ6dH1sb2FkRmxvYXQxNkZyb20yeFVJbnQ4KCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQxNih0aGlzLl9fYnl0ZU9mZnNldCwhMCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz0yLHR9bG9hZFVJbnQzMkZyb20yeFVGbG9hdDE2KCl7cmV0dXJuIHRoaXMubG9hZFVGbG9hdDE2KCkrNDA5Nip0aGlzLmxvYWRVRmxvYXQxNigpfWxvYWRTSW50MzJGcm9tMnhGbG9hdDE2KCl7cmV0dXJuIHRoaXMubG9hZEZsb2F0MTYoKSsyMDQ4KnRoaXMubG9hZEZsb2F0MTYoKX1sb2FkRmxvYXQzMigpe2NvbnN0IHQ9dGhpcy5fX2RhdGFWaWV3LmdldEZsb2F0MzIodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9NCx0fWxvYWRVSW50OEFycmF5KHQsZT0hMSl7bnVsbD09dCYmKHQ9dGhpcy5sb2FkVUludDMyKCkpO2NvbnN0IHM9bmV3IFVpbnQ4QXJyYXkodGhpcy5fX2RhdGEsdGhpcy5fX2J5dGVPZmZzZXQsdCk7dGhpcy5fX2J5dGVPZmZzZXQrPXQ7dGhpcy5fX2J5dGVPZmZzZXQ7cmV0dXJuIHN9bG9hZFVJbnQxNkFycmF5KHQsZT0hMSl7aWYobnVsbD09dCYmKHQ9dGhpcy5sb2FkVUludDMyKCkpLDA9PXQpcmV0dXJuIG5ldyBVaW50MTZBcnJheTtsZXQgcztpZih0aGlzLnJlYWRQYWRkKDIpLHRoaXMuX19pc01vYmlsZURldmljZSl7cz1uZXcgVWludDE2QXJyYXkodCk7Zm9yKGxldCBlPTA7ZTx0O2UrKylzW2VdPXRoaXMuX19kYXRhVmlldy5nZXRVaW50MTYodGhpcy5fX2J5dGVPZmZzZXQsITApLHRoaXMuX19ieXRlT2Zmc2V0Kz0yfWVsc2Ugcz1uZXcgVWludDE2QXJyYXkodGhpcy5fX2RhdGEsdGhpcy5fX2J5dGVPZmZzZXQsdCksdGhpcy5fX2J5dGVPZmZzZXQrPTIqdDtyZXR1cm4gc31sb2FkVUludDMyQXJyYXkodCxlPSExKXtpZihudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSksMD09dClyZXR1cm4gbmV3IFVpbnQzMkFycmF5O2xldCBzO2lmKHRoaXMucmVhZFBhZGQoNCksdGhpcy5fX2lzTW9iaWxlRGV2aWNlKXtzPW5ldyBVaW50MzJBcnJheSh0KTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXNbZV09dGhpcy5fX2RhdGFWaWV3LmdldFVpbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCksdGhpcy5fX2J5dGVPZmZzZXQrPTR9ZWxzZSBzPW5ldyBVaW50MzJBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KSx0aGlzLl9fYnl0ZU9mZnNldCs9NCp0O3JldHVybiBzfWxvYWRGbG9hdDMyQXJyYXkodCxlPSExKXtpZihudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSksMD09dClyZXR1cm4gbmV3IEZsb2F0MzJBcnJheTtsZXQgcztpZih0aGlzLnJlYWRQYWRkKDQpLHRoaXMuX19pc01vYmlsZURldmljZSl7cz1uZXcgRmxvYXQzMkFycmF5KHQpO2ZvcihsZXQgZT0wO2U8dDtlKyspc1tlXT10aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCksdGhpcy5fX2J5dGVPZmZzZXQrPTR9ZWxzZSBzPW5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEsdGhpcy5fX2J5dGVPZmZzZXQsdCksdGhpcy5fX2J5dGVPZmZzZXQrPTQqdDtyZXR1cm4gc31sb2FkU3RyKCl7Y29uc3QgdD10aGlzLmxvYWRVSW50MzIoKSxlPW5ldyBVaW50OEFycmF5KHRoaXMuX19kYXRhLHRoaXMuX19ieXRlT2Zmc2V0LHQpO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9dCx0aGlzLnV0ZjhkZWNvZGVyLmRlY29kZShlKX1sb2FkU3RyQXJyYXkoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQzMigpLGU9W107Zm9yKGxldCBzPTA7czx0O3MrKyllW3NdPXRoaXMubG9hZFN0cigpO3JldHVybiBlfWxvYWRTSW50MzJWZWMyKCl7Y29uc3QgdD10aGlzLmxvYWRTSW50MzIoKSxlPXRoaXMubG9hZFNJbnQzMigpO3JldHVybiBuZXcgaSh0LGUpfWxvYWRVSW50MzJWZWMyKCl7Y29uc3QgdD10aGlzLmxvYWRVSW50MzIoKSxlPXRoaXMubG9hZFVJbnQzMigpO3JldHVybiBuZXcgaSh0LGUpfWxvYWRGbG9hdDE2VmVjMigpe2NvbnN0IHQ9dGhpcy5sb2FkRmxvYXQxNigpLGU9dGhpcy5sb2FkRmxvYXQxNigpO3JldHVybiBuZXcgaSh0LGUpfWxvYWRGbG9hdDMyVmVjMigpe2NvbnN0IHQ9dGhpcy5sb2FkRmxvYXQzMigpLGU9dGhpcy5sb2FkRmxvYXQzMigpO3JldHVybiBuZXcgaSh0LGUpfWxvYWRGbG9hdDE2VmVjMygpe2NvbnN0IHQ9dGhpcy5sb2FkRmxvYXQxNigpLGU9dGhpcy5sb2FkRmxvYXQxNigpLHM9dGhpcy5sb2FkRmxvYXQxNigpO3JldHVybiBuZXcgcih0LGUscyl9bG9hZEZsb2F0MzJWZWMzKCl7Y29uc3QgdD10aGlzLmxvYWRGbG9hdDMyKCksZT10aGlzLmxvYWRGbG9hdDMyKCkscz10aGlzLmxvYWRGbG9hdDMyKCk7cmV0dXJuIG5ldyByKHQsZSxzKX1sb2FkRmxvYXQxNlF1YXQoKXtjb25zdCB0PXRoaXMubG9hZEZsb2F0MTYoKSxlPXRoaXMubG9hZEZsb2F0MTYoKSxzPXRoaXMubG9hZEZsb2F0MTYoKSxhPXRoaXMubG9hZEZsb2F0MTYoKTtyZXR1cm4gbmV3IHUodCxlLHMsYSl9bG9hZEZsb2F0MzJRdWF0KCl7Y29uc3QgdD10aGlzLmxvYWRGbG9hdDMyKCksZT10aGlzLmxvYWRGbG9hdDMyKCkscz10aGlzLmxvYWRGbG9hdDMyKCksYT10aGlzLmxvYWRGbG9hdDMyKCk7cmV0dXJuIG5ldyB1KHQsZSxzLGEpfWxvYWRSR0JGbG9hdDMyQ29sb3IoKXtjb25zdCB0PXRoaXMubG9hZEZsb2F0MzIoKSxlPXRoaXMubG9hZEZsb2F0MzIoKSxzPXRoaXMubG9hZEZsb2F0MzIoKTtyZXR1cm4gbmV3IG8odCxlLHMpfWxvYWRSR0JBRmxvYXQzMkNvbG9yKCl7Y29uc3QgdD10aGlzLmxvYWRGbG9hdDMyKCksZT10aGlzLmxvYWRGbG9hdDMyKCkscz10aGlzLmxvYWRGbG9hdDMyKCksYT10aGlzLmxvYWRGbG9hdDMyKCk7cmV0dXJuIG5ldyBvKHQsZSxzLGEpfWxvYWRSR0JVSW50OENvbG9yKCl7Y29uc3QgdD10aGlzLmxvYWRVSW50OCgpLGU9dGhpcy5sb2FkVUludDgoKSxzPXRoaXMubG9hZFVJbnQ4KCk7cmV0dXJuIG5ldyBvKHQvMjU1LGUvMjU1LHMvMjU1KX1sb2FkUkdCQVVJbnQ4Q29sb3IoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQ4KCksZT10aGlzLmxvYWRVSW50OCgpLHM9dGhpcy5sb2FkVUludDgoKSxhPXRoaXMubG9hZFVJbnQ4KCk7cmV0dXJuIG5ldyBvKHQvMjU1LGUvMjU1LHMvMjU1LGEvMjU1KX1sb2FkQm94Migpe3JldHVybiBuZXcgZyh0aGlzLmxvYWRGbG9hdDMyVmVjMigpLHRoaXMubG9hZEZsb2F0MzJWZWMyKCkpfWxvYWRCb3gzKCl7cmV0dXJuIG5ldyBwKHRoaXMubG9hZEZsb2F0MzJWZWMzKCksdGhpcy5sb2FkRmxvYXQzMlZlYzMoKSl9cmVhZFBhZGQodCl7Y29uc3QgZT10aGlzLl9fYnl0ZU9mZnNldCV0OzAhPWUmJih0aGlzLl9fYnl0ZU9mZnNldCs9dC1lKX19Y2xhc3Mgdntjb25zdHJ1Y3Rvcih0KXtpZih0KXtjb25zdCBlPXQuc3BsaXQoIi0iKSxzPWVbMF0uc3BsaXQoIi4iKTt0aGlzLm1ham9yPXBhcnNlSW50KHNbMF0pLHRoaXMubWlub3I9cGFyc2VJbnQoc1sxXSksdGhpcy5wYXRjaD1wYXJzZUludChzWzJdKSwyPT1lLmxlbmd0aCYmKHRoaXMuYnJhbmNoPWVbMV0pfWVsc2UgdGhpcy5tYWpvcj0wLHRoaXMubWlub3I9MCx0aGlzLnBhdGNoPTB9ZXF1YWxzKHQpe3JldHVybiEodGhpcy5wYXRjaD09dFsyXSYmdGhpcy5taW5vcj09dFsxXSYmdGhpcy5tYWpvcj09dFswXSl9bGVzc1RoYW4odCl7cmV0dXJuISh0aGlzLm1ham9yPj10WzBdfHx0aGlzLm1pbm9yPj10WzFdfHx0aGlzLnBhdGNoPj10WzJdKX1ncmVhdGVyVGhhbih0KXtyZXR1cm4gdGhpcy5tYWpvcj50WzBdfHx0aGlzLm1pbm9yPnRbMV18fHRoaXMucGF0Y2g+dFsyXX1ncmVhdGVyT3JFcXVhbFRoYW4odCl7cmV0dXJuISh0aGlzLm1ham9yPHRbMF0pJiYodGhpcy5tYWpvcj50WzBdfHwhKHRoaXMubWlub3I8dFsxXSkmJih0aGlzLm1pbm9yPnRbMV18fCEodGhpcy5wYXRjaDx0WzJdKSkpfX1zZWxmLm9ubWVzc2FnZT1mdW5jdGlvbih0KXsoKHQsZSk9Pntmb3IobGV0IGUgaW4gdC5jb250ZXh0LnZlcnNpb25zKXtjb25zdCBzPXQuY29udGV4dC52ZXJzaW9uc1tlXSxhPW5ldyB2O2EubWFqb3I9cy5tYWpvcixhLm1pbm9yPXMubWlub3IsYS5wYXRjaD1zLnBhdGNoLGEuYnJhbmNoPXMuYnJhbmNoLHQuY29udGV4dC52ZXJzaW9uc1tlXT1hfWNvbnN0IHM9W10saT10LnRvY1t0Lmdlb21zUmFuZ2VbMF1dLHI9W107Zm9yKGxldCBlPXQuZ2VvbXNSYW5nZVswXTtlPHQuZ2VvbXNSYW5nZVsxXTtlKyspe2NvbnN0IG49bmV3IEUodC5idWZmZXJTbGljZSx0LnRvY1tlXS1pLHQuaXNNb2JpbGVEZXZpY2UpLGg9bi5sb2FkU3RyKCksbz1uLnBvcygpO2xldCBfO3N3aXRjaChoKXtjYXNlIlBvaW50cyI6Xz1uZXcgQTticmVhaztjYXNlIkxpbmVzIjpfPW5ldyBTO2JyZWFrO2Nhc2UiTWVzaCI6Xz1uZXcgUDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgR2VvbSB0eXBlOiIraCl9dHJ5e24uc2VlayhvKSxfLnJlYWRCaW5hcnkobix0LmNvbnRleHQpfWNhdGNoKHQpe2NvbnNvbGUud2FybigiRXJyb3IgbG9hZGluZzoiK18ubmFtZSsiXG46Iit0KSxzLnB1c2goe30pO2NvbnRpbnVlfWNvbnN0IGQ9Xy5nZW5CdWZmZXJzKHQuZ2VuQnVmZmVyc09wdHMpO2QuaW5kaWNlcyYmci5wdXNoKGQuaW5kaWNlcy5idWZmZXIpO2Zvcihjb25zdCB0IGluIGQuYXR0ckJ1ZmZlcnMpe2NvbnN0IGU9ZC5hdHRyQnVmZmVyc1t0XSxzPWEuZ2V0VHlwZU5hbWUoZS5kYXRhVHlwZSk7ZS5kYXRhVHlwZT1zLHIucHVzaChlLnZhbHVlcy5idWZmZXIpfWQudmVydGV4TmVpZ2hib3JzJiZyLnB1c2goZC52ZXJ0ZXhOZWlnaGJvcnMuYnVmZmVyKSxyLnB1c2goXy5ib3VuZGluZ0JveC5wMC5fX2RhdGEuYnVmZmVyKSxyLnB1c2goXy5ib3VuZGluZ0JveC5wMS5fX2RhdGEuYnVmZmVyKSxzLnB1c2goe25hbWU6Xy5uYW1lLHR5cGU6aCxnZW9tQnVmZmVyczpkLGJib3g6Xy5ib3VuZGluZ0JveH0pfWUoe2tleTp0LmtleSxnZW9tSW5kZXhPZmZzZXQ6dC5nZW9tSW5kZXhPZmZzZXQsZ2VvbXNSYW5nZTp0Lmdlb21zUmFuZ2UsZ2VvbURhdGFzOnN9LHIpfSkodC5kYXRhLCh0LGUpPT57c2VsZi5wb3N0TWVzc2FnZSh0LGUpfSl9OwoK",null,!1);class oa{constructor(){this.rangeLoaded=new S,this.streamFileParsed=new S,this.loaded=new S(!0),this.__streamInfos={},this.__genBuffersOpts={},this.__workers=[],this.__nextWorker=0;for(let e=0;e<3;e++)this.__workers.push(this.__constructWorker());this.clear();}clear(){this.__loaded=0,this.__numGeoms=0,this.geoms=[];}__constructWorker(){const e=new ra;return e.onmessage=e=>{this.__recieveGeomDatas(e.data.key,e.data.geomDatas,e.data.geomIndexOffset,e.data.geomsRange);},e}__terminateWorkers(){for(const e of this.__workers)e.terminate();this.__workers=[];}setGenBufferOption(e,t){this.__genBuffersOpts[e]=t;}setNumGeoms(e){this.__numGeoms=e;}getGeom(e){return e>=this.geoms.length?null:this.geoms[e]}loadUrl(e){ee(e,e=>{this.loadBin(e);},e=>{console.warn(e);});}readBinaryBuffer(e,a,i){const s=t.isMobileDevice,n=new de(a,0,s),l=n.loadUInt32(),r=n.loadUInt32();if(this.__streamInfos[e]={total:l,done:0},0==l)return this.streamFileParsed.emit(1),l;0==this.__numGeoms&&(this.__numGeoms=l);const o=n.loadUInt32Array(l);let d=window.navigator.hardwareConcurrency;d||(d=s?2:4);const h=Math.max(1,Math.floor(l/d+1));let c=0;for(;c<l;){const t=o[c];let s,d;c+h>=l?(d=[c,l],s=a.byteLength):(d=[c,c+h],s=o[d[1]]);const m=a.slice(t,s);c+=h,this.__workers[this.__nextWorker].postMessage({key:e,toc:o,geomIndexOffset:r,geomsRange:d,isMobileDevice:n.isMobileDevice,bufferSlice:m,genBuffersOpts:this.__genBuffersOpts,context:i},[m]),this.__nextWorker=(this.__nextWorker+1)%this.__workers.length;}return l}__recieveGeomDatas(e,t,a,i){const s=a+i[0],n=[s,a+i[1]];for(let e=0;e<t.length;e++){const a=t[e];if(!a.type)continue;let i;switch(a.type){case"Points":i=new Ct(a);break;case"Lines":i=new Yt(a);break;case"Mesh":case"Plane":case"Sphere":case"Cone":i=new Nt(a);break;default:throw new Error("Unsupported Geom type:"+className)}this.geoms[s+e]=i;}this.rangeLoaded.emit(n);const l=n[1]-n[0],r=this.__streamInfos[e];r.done+=l,r.done==r.total&&this.streamFileParsed.emit(1),this.__loaded+=l,this.__loaded==this.__numGeoms&&(this.__terminateWorkers(),this.loaded.emit());}toJSON(){return {numGeoms:this.geoms.length()}}toString(){return JSON.stringify(this.toJSON(),null,2)}}class da extends $t{constructor(e){super(e),this.__geomLibrary=new oa,this.__materials=new xt,this.loaded=new S(!0),this.loaded.setToggled(!0);}isLoaded(){return this.loaded.isToggled()}getEngineDataVersion(){return this.__engineDataVersion}getGeometryLibrary(){return this.__geomLibrary}getMaterialLibrary(){return this.__materials}getUnitsConversion(){return this.__unitsScale}readBinary(e,t={}){let a;t.assetItem=this,t.numTreeItems=0,t.numGeomItems=0,t.versions["zea-engine"]||(t.versions["zea-engine"]=new oe(e.loadStr())),this.__engineDataVersion=t.versions["zea-engine"],console.log("Loading Engine File version:",t.versions["zea-engine"]);const i={};t.addGeomToLayer=(e,t)=>{if(!i[t]){a||(a=new $t("Layers"),this.addChild(a,!1));const e=new la(t);e.propagateXfoToItems=!1,a.addChild(e,!1),i[t]=e;}i[t].addItem(e);};const s=()=>{this.__units=e.loadStr();let t=1;switch(this.__units){case"Millimeters":t=.001;break;case"Centimeters":t=.01;break;case"Meters":t=1;break;case"Kilometers":t=1e3;break;case"Inches":t=.0254;break;case"Feet":t=.3048;break;case"Miles":t=1609.34;}this.__unitsScale=t;const a=this.getLocalXfo().clone();a.sc.scaleInPlace(t),this.setLocalXfo(a);};t.versions["zea-engine"].greaterThan([0,0,6])&&s(),this.__materials.readBinary(e,t),super.readBinary(e,t),t.versions["zea-engine"].greaterOrEqualThan([0,0,5])&&t.versions["zea-engine"].lessThan([0,0,7])&&s();}toJSON(e={},t=0){return e.makeRelative=e=>{const t=this.getPath(),a=e.slice(0,t.length);for(let i=0;i<a.length-1;i++)if(a[i]!=t[i])return console.warn("Param Path is not relative to the asset. May not be able to be resolved at load time:"+e),e;const i=e.slice(t.length-1);return i[0]=".",i},e.assetItem=this,super.toJSON(e,t)}fromJSON(e,t={},a=0,i){t||(t={}),t.assetItem=this,t.numTreeItems=0,t.numGeomItems=0,null==t.version&&(t.version=0),t.assetItem=this;const s=[];t.resolvePath=(e,t)=>{if(!e)throw new Error("Path not spcecified");const a=this.resolvePath(e);a?t(a):s.push(()=>{const a=this.resolvePath(e);a?t(a):console.warn("Path unable to be resolved:"+e);});},t.addPLCB=e=>s.push(e),super.fromJSON(e,t,a);for(const e of s)e();i&&i();}}C.registerClass("AssetItem",da);class ha extends $t{constructor(e,t){super(e);const a=this.addParameter(new Ve("image"));t&&a.setValue(t),this.addParameter(new ue("scale",.01)),this.addParameter(new ue("alpha",1)),this.addParameter(new Ge("color",new u(1,1,1))),this.addParameter(new pe("alignedToCamera",!1));const i=this.addParameter(new _e("lineStartOffset")),s=this.addParameter(new Se("lineEnd",d)),n=[],l=new Ke("LabelLinesMaterial","LinesShader");l.getParameter("Color").setValue(new u(0,0,0),N.OPERATOR_SETVALUE),l.getParameter("Opacity").setValue(1,N.OPERATOR_SETVALUE),s.elementAdded.connect((e,t)=>{const a=new Mt;a.setNumVertices(2),a.setNumSegments(1),a.setSegment(0,0,1);const i=new sa("line"+t);i.setGeometry(a,N.OPERATOR_SETVALUE),i.setMaterial(l,N.OPERATOR_SETVALUE),n[t]=i,r(t),this.addChild(i,!1);}),s.elementRemoved.connect(()=>{});const r=e=>{const t=this.__globalXfoParam.getValue().inverse(),a=i.getValue(),l=s.getValue()[e],r=n[e].getGeometry();r.setVertex(0,a),r.setVertex(1,t.transformVec3(l));},o=()=>{for(let e=0;e<n.length;e++)r(e);};i.valueChanged.connect(o),s.valueChanged.connect(o),this.__globalXfoParam.valueChanged.connect(o);}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,a){return super.fromJSON(e,t,a)}}C.registerClass("BillboardItem",ha);class ca extends $t{constructor(e){null==e&&(e="Camera"),super(e),this.__isOrthographicParam=this.addParameter(new pe("isOrthographic",!1)),this.__fovParam=this.addParameter(new ue("fov",1)),this.__nearParam=this.addParameter(new ue("near",.1)),this.__farParam=this.addParameter(new ue("far",1e3)),this.__focalDistanceParam=this.addParameter(new ue("focalDistance",5)),this.projectionParamChanged=new S,this.movementFinished=new S,this.__isOrthographicParam.valueChanged.connect(this.projectionParamChanged.emit),this.__fovParam.valueChanged.connect(this.projectionParamChanged.emit),this.__nearParam.valueChanged.connect(this.projectionParamChanged.emit),this.__farParam.valueChanged.connect(this.projectionParamChanged.emit),this.setPositionAndTarget(new d(3,3,1.75),new d(0,0,1),N.GENERATED_VALUE),this.setLensFocalLength("28mm",N.GENERATED_VALUE);}getNear(){return this.__nearParam.getValue()}setNear(e){this.__nearParam.setValue(e);}getFar(){return this.__farParam.getValue()}setFar(e){this.__farParam.setValue(e);}getFov(){return this.__fovParam.getValue()}setFov(e){this.__fovParam.setValue(e);}setLensFocalLength(e,t=N.USER_SETVALUE){const a={"10mm":100.4,"11mm":95,"12mm":90,"14mm":81.2,"15mm":77.3,"17mm":70.4,"18mm":67.4,"19mm":64.6,"20mm":61.9,"24mm":53.1,"28mm":46.4,"30mm":43.6,"35mm":37.8,"45mm":29.9,"50mm":27,"55mm":24.6,"60mm":22.6,"70mm":19.5,"75mm":18.2,"80mm":17.1,"85mm":16.1,"90mm":15.2,"100mm":13.7,"105mm":13,"120mm":11.4,"125mm":11,"135mm":10.2,"150mm":9.1,"170mm":8.1,"180mm":7.6,"210mm":6.5,"300mm":4.6,"400mm":3.4,"500mm":2.7,"600mm":2.3,"800mm":1.7};!e in a?console.warn("Camera lense focal length not suported:"+e):this.__fovParam.setValue(Math.degToRad(a[e]),t);}getFocalDistance(){return this.__focalDistanceParam.getValue()}setFocalDistance(e,t=N.USER_SETVALUE){e<1e-4&&console.error("Never set focal distance to zero"),this.__focalDistanceParam.setValue(e,t),this.__nearParam.setValue(.01*e,t),this.__farParam.setValue(200*e,t);}getIsOrthographic(){return this.__isOrthographicParam.getValue()}setIsOrthographic(e,t=N.USER_SETVALUE){this.__isOrthographicParam.setValue(e,t);}setPositionAndTarget(e,t,a=N.USER_SETVALUE){this.setFocalDistance(e.distanceTo(t),a);const i=new X;i.setLookAt(e,t,new d(0,0,1)),this.setGlobalXfo(i,a);}getTargetPostion(){const e=this.__focalDistanceParam.getValue(),t=this.getGlobalXfo(),a=t.ori.getZaxis();return a.scaleInPlace(-e),a.addInPlace(t.tr),a}frameView(e,t,a=N.USER_SETVALUE){const i=new V;for(const e of t)i.addBox3(e.getBoundingBox());if(!i.isValid())return void console.warn("Bounding box not valid.");const s=this.__focalDistanceParam.getValue(),n=this.__fovParam.getValue(),l=this.getGlobalXfo().clone(),r=l.ori.getZaxis(),o=r.scale(-s),d=l.tr.add(o),h=i.center().subtract(d);l.tr.addInPlace(h);const c=new V;c.addBox3(i,l.inverse());c.center();const m=n*(e.getWidth()/e.getHeight()),u=c.p1,b=Math.abs(u.x)/Math.tan(.5*m)*1.2,p=Math.abs(u.y)/Math.tan(.5*n)*1.2,g=-.5*(c.p0.z-c.p1.z),_=Math.max(b,p)+g,Z=_-s;l.tr.addInPlace(r.scale(Z)),this.setFocalDistance(_,a),this.setGlobalXfo(l,a),this.movementFinished.emit();}updateProjectionMatrix(e,t){this.__isOrthographicParam.getValue();const a=this.__fovParam.getValue(),i=this.__nearParam.getValue(),s=this.__farParam.getValue();e.setPerspectiveMatrix(a,t,i,s);}}C.registerClass("Camera",ca);class ma extends D{constructor(e){super(e),this.addParameter(new Ge("BackgroundColor",new u("#808080"))),this.addParameter(new Ve("EnvMap")),this.addParameter(new pe("Display EnvMap",!1)),this.addParameter(new ue("EnvMapLOD",0));}}class ua extends da{constructor(e){super(e),this.loaded.setToggled(!1),this.lightmap=null,this.geomsLoaded=new S(!0),this.geomsLoaded.setToggled(!1),this.loaded.setToggled(!1),this.__geomLibrary.loaded.connect(()=>{this.geomsLoaded.emit();}),this.__datafileParam=this.addParameter(new Re("DataFilePath")),this.__datafileParam.valueChanged.connect(()=>{const e=this.__datafileParam.getFileDesc();if(e){if(console.log(e),this.getName()==C.getClassName(this)){const e=this.__datafileParam.getStem();this.setName(e);}this.geomsLoaded.setToggled(!1),this.loadDataFile(()=>{this.loaded.isToggled()||this.loaded.emit();},()=>{});}}),this.addParameter(new Ge("LightmapTint",new u(1,1,1,1)));}getLightmap(){return this.lightmap}readBinary(e,t){if(-1!=t.version){const e=new oe;e.patch=t.version,t.versions={"zea-mesh":e,"zea-engine":e},t.meshSdk="FBX";}else {const a=e.loadUInt8();if(e.seek(0),10!=a){const a=new oe;a.patch=e.loadUInt32(),t.versions={"zea-mesh":a,"zea-engine":a},t.meshSdk="FBX";}else {const a=new oe(e.loadStr());t.versions={"zea-mesh":a},t.meshSdk="FBX";}}this.meshfileversion=t.versions["zea-mesh"],this.meshSdk=t.meshSdk,console.log("Loading CAD File version:",t.versions["zea-mesh"]," exported using SDK:",t.meshSdk);const a=e.loadUInt32();return super.readBinary(e,t),t.versions["zea-engine"].lessThan([0,0,5])&&e.seek(e.byteLength-4),this.__geomLibrary.setNumGeoms(e.loadUInt32()),a}loadDataFile(e,a){const i=this.__datafileParam.getFileDesc();if(!i)return void console.warn("VLAAsset data file not found.");const s=this.__datafileParam.getFileFolderPath(),n=this.__datafileParam.getValue(),l=this.__datafileParam.getStem();let r=0;const o=new RegExp("\\.(vla)$","i").test(i.name),d=[],h=i=>{let s,l=-1;if(i.tree2)s=new de(i.tree2.buffer,0,t.isMobileDevice);else {const e=i.tree?i.tree:i[Object.keys(i)[0]];s=new de(e.buffer,0,t.isMobileDevice),l=0;}r=this.readBinary(s,{assetItem:this,version:l}),o||r!=d.length&&console.error("The number of GeomFiles does not match the count given by the VLA file."),e(),0==r&&i.geoms0?(re.addWork(n+"geoms",1),this.__geomLibrary.readBinaryBuffer(n,i.geoms0.buffer,{version:l}),a()):(re.addWork(n+"geoms",4*r),c());},c=()=>{const e=[];for(let t=0;t<r;t++)if(o){const a=s+l+t+".vlageoms",i=re.resolveFilepath(a);if(!i)throw new Error("VLA Geoms file not found:"+a);e.push(m(t,i.url));}else e.push(m(t,d[t].url));Promise.all(e).then(()=>{a&&a();});},m=(e,t)=>new Promise(a=>{re.loadUrl(n+e,t,e=>{const t=e[Object.keys(e)[0]];this.__geomLibrary.readBinaryBuffer(n,t.buffer),a();},!1);});if(o)re.loadResource(n,h);else if(i.metadata.ConvertFile){let e;i.metadata.ConvertFile.map(t=>{t.filename.endsWith(".vla")?e=t:t.filename.endsWith(".vlageoms")&&d.push(t);}),e?re.loadUrl(n,e.url,h):console.warn("ConvertFile metadata contains no vla file.");}this.__geomLibrary.streamFileParsed.connect(e=>{re.addWorkDone(n+"geoms",e);});}fromJSON(e,t,a){t||(t={}),t.assetItem=this;const i=()=>{super.fromJSON(e,t,a),a&&a();};if(e.params&&e.params.DataFilePath){this.__datafileLoaded=i;const a=e.params.DataFilePath;delete e.params.DataFilePath,this.__datafileParam.fromJSON(a,t);}else i();}}C.registerClass("VLAAsset",ua);const ba=new u("#DCDCDC");class pa{constructor(e){e&&re.setResources(e),this.settings=new ma("Scene Settings"),this.root=new $t("root"),this.root.addChild(this.settings),this.__commonResources={};}getSettings(){return this.settings}getRoot(){return this.root}getResourceLoader(){return re}setEnvMap(e){console.warn("Deprecated Function. Please access the Scene Settings object."),this.settings.getParameter("EnvMap").setValue(e);}addAsset(e){console.warn("Deprecated Function. Please access the Scene Root object."),this.root.addChild(e,!1);}setupGrid(e=5,t=50,a=ba){const i=new $t("Grid"),s=new Ke("gridMaterial","LinesShader");s.getParameter("BaseColor").setValue(a);const n=new Pt(e,e,t,t,!0);i.addChild(new sa("GridItem",n,s),!1);const l=new Mt;l.setNumVertices(2),l.setNumSegments(1),l.setSegment(0,0,1),l.getVertex(0).set(-.5*e,0,0),l.getVertex(1).set(.5*e,0,0);const r=new Ke("gridXAxisMaterial","LinesShader");r.getParameter("BaseColor").setValue(new u(a.luminance(),0,0)),i.addChild(new sa("xAxisLine",l,r),!1);const o=new Ke("gridZAxisMaterial","LinesShader");o.getParameter("BaseColor").setValue(new u(0,a.luminance(),0));const h=new X;h.ori.setFromAxisAndAngle(new d(0,0,1),.5*Math.PI);const c=new sa("yAxisLine",l,o);return c.setGeomOffsetXfo(h),i.addChild(c,!1),i.setSelectable(!1,!0),i.setFlag(k.IGNORE_BBOX),i.clearFlag(k.USER_EDITED),i.setFlag(k.INVISIBLE),this.root.addChild(i,!1),i}loadCommonAssetResource(e){if(e in this.__commonResources)return this.__commonResources[e];const t=new ua;return t.getParameter("DataFilePath").setValue(e),this.__commonResources[e]=t,t}toJSON(e={},t=0){return e.makeRelative=e=>e,{root:this.root.toJSON(e,t)}}fromJSON(e,t={}){const a=[];t.resolvePath=(e,t)=>{if(!e)throw new Error("Path not spcecified");const i=this.root.resolvePath(e);i?t(i):a.push(()=>{const a=this.resolvePath(e);a?t(a):console.warn("Path unable to be resolved:"+e);});},t.addPLCB=e=>a.push(e),t.settings=this.settings,e.root&&this.root.fromJSON(e.root,t);for(const e of a)e();}}class ga extends da{constructor(e){super(e),this.geomsLoaded=new S(!0),this.geomsLoaded.setToggled(!1),this.loaded.setToggled(!1),this.addParameter(new pe("splitObjects",!1)),this.addParameter(new pe("splitGroupsIntoObjects",!1)),this.addParameter(new pe("loadMtlFile",!0)),this.addParameter(new ue("unitsConversion",1)),this.addParameter(new xe("defaultShader","")),this.objfileParam=this.addParameter(new Re("ObjFilePath")),this.objfileParam.valueChanged.connect(()=>{this.loaded.untoggle(),this.__loadObj(()=>{this.loaded.emit();},()=>{this.geomsLoaded.emit();});}),this.geomLibrary=new oa,this.materials=new xt;}getGeometryLibrary(){return this.geomLibrary}getMaterialLibrary(){return this.materials}__loadObj(e,t){const a=this.objfileParam.getStem(),i=e=>{const t=e.split("\n"),a=/\s+/;let i;const s=function(e){if(3==e.length)return new u(parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2]));throw new Error("Unable to parse a color from the following parts:"+e.join("_"))},n=e=>{const t=this.objfileParam.getFileFolder();return new FileImage(e[0],t+e[0])};for(let e=0;e<t.length;e++){let l=t[e].trim();if(l.startsWith("#"))continue;-1!=l.indexOf("#")&&(l=l.substring(0,l.indexOf("#")).trim());const r=l.split(a),o=r.shift(),d=r.join(" ");switch(o){case"newmtl":i=new Ke(d),i.setShaderName("StandardSurfaceShader"),this.materials.addMaterial(i);break;case"Kd":i.getParameter("BaseColor").setValue(s(r));break;case"map_Kd":i.getParameter("BaseColor").setValue(n(r));break;case"Ks":const e=(parseFloat(r[0])+parseFloat(r[1])+parseFloat(r[2]))/3;i.roughness=1-e,i.getParameter("Roughness").setValue(1-e),i.getParameter("Reflectance").setValue(e);break;case"map_Ks":i.getParameter("Roughness").setValue(n(r)),i.getParameter("Reflectance").setValue(.2);break;case"d":const t=parseFloat(d);t<1&&(i.setShaderName("TransparentSurfaceShader"),i.getParameter("Opacity").setValue(t));break;case"map_d":i.getParameter("alpha").setValue(parseFloat(r));break;case"map_bump":i.getParameter("normal").setValue(n(r));}}},s=new L;s.incAsyncCount(),s.ready.connect(()=>{b();});const n=e=>new Promise(t=>{A(e.url,e=>{re.addWorkDone(a,1),i(e),s.decAsyncCount(),re.addWorkDone(a,1),t();});}),l=new Array,r=new Array,h=new Array,c={},m=async e=>{const t=e.split("\n"),i=/\s+/;let o=void 0,d=void 0;const m=e=>{let t=0;for(;e in c;)t++,e+=String(t);o={verticesRemapping:{},texCoordsRemapping:{},normalsRemapping:{},vertexIndices:[],texCoordIndices:[],normalIndices:[],numVertices:0,numTexCoords:0,numNormals:0,numTris:0,numQuads:0,material:d},c[e]=o;};m(a);const u=this.getParameter("splitGroupsIntoObjects").getValue();for(let e=0;e<t.length;e++){let b=t[e].trim();if(b.startsWith("#"))continue;-1!=b.indexOf("#")&&(b=b.substring(0,b.indexOf("#")).trim());const p=b.split(i),g=p.shift(),_=p.join(" ");switch(g){case"":case"s":continue;case"mtllib":if(!this.getParameter("loadMtlFile").getValue())continue;s.incAsyncCount(),re.addWork(a,2);const e=this.objfileParam.getFileFolderPath(),t=re.resolveFilepath(e+_);t&&await n(t);break;case"o":m(_);break;case"usemtl":d=_,m(_+Object.keys(c).length);break;case"g":u&&m(p.join("_"));break;case"v":l.push(p.map(e=>parseFloat(e)));break;case"vt":h.push(p.map(e=>parseFloat(e)));break;case"vn":r.push(p.map(e=>parseFloat(e)));break;case"f":{const e=[],t=[],a=[];for(let i=0,s=p.length;i<s;i++){const s=p[i].split("/").map(e=>parseInt(e)-1),n=s[0];let l=o.verticesRemapping[n];if(null==l&&(l=o.numVertices,o.verticesRemapping[n]=l,o.numVertices++),e.push(l),s.length>1&&!isNaN(s[1])){const e=s[1];t.push(e);}if(s.length>2&&!isNaN(s[2])){const e=s[2];a.push(e);}}o.vertexIndices.push(e),a.length>0&&o.normalIndices.push(a),t.length>0&&o.texCoordIndices.push(t),3==e.length?o.numTris++:o.numQuads++;break}default:console.warn("Unhandled line:"+b);}}s.decAsyncCount();},b=()=>{for(const e in c)0!=c[e].numVertices&&p(e,c[e]);e(),t();},p=(e,t)=>{const a=t.numVertices,i=new Ft(e);i.setFaceCounts([t.numTris,t.numQuads]),i.setNumVertices(a);const s=i.getVertexAttribute("positions"),n=this.getParameter("unitsConversion").getValue();for(const e in t.verticesRemapping){const a=t.verticesRemapping[e];s.getValueRef(a).set(l[e][0]*n,l[e][1]*n,l[e][2]*n);}let c,m;t.normalIndices.length>0&&(c=i.addVertexAttribute("normals",d)),t.texCoordIndices.length>0&&(m=i.addVertexAttribute("texCoords",o));for(let e=0;e<t.vertexIndices.length;e++){const a=t.vertexIndices[e];if(i.setFaceVertexIndices(e,...a),c){const a=t.normalIndices[e];for(let t=0;t<a.length;t++){const i=new d(r[a[t]][0],r[a[t]][1],r[a[t]][2]);c.setFaceVertexValue(e,t,i);}}if(m&&t.texCoordIndices.length==t.vertexIndices.length){const a=t.texCoordIndices[e];for(let t=0;t<a.length;t++){const i=new o(h[a[t]][0],h[a[t]][1]);m.setFaceVertexValue(e,t,i);}}}const b=new sa(e,i);b.selectable=!0;const p=i.boundingBox.center();if(i.moveVertices(p.negate()),b.setLocalXfo(new X(p)),null!=t.material&&this.materials.hasMaterial(t.material))b.setMaterial(this.materials.getMaterial(t.material));else {const t=this.getParameter("defaultShader").getValue(),a=new Ke(e+"mat");a.setShaderName(""!=t?t:"StandardSurfaceShader");const i=a.getParameter("BaseColor");if(i)i.setValue(u.random(.5));else {const e=a.getParameter("Color");e&&e.setValue(u.random(.5));}const s=a.getParameter("Roughness");s&&s.setValue(.6);const n=a.getParameter("Reflectance");n&&n.setValue(.2),this.materials.addMaterial(a),b.setMaterial(a);}this.addChild(b,!1);};(()=>{const e=this.objfileParam.getFileDesc(),t=this.objfileParam.getStem();re.addWork(t,2),A(e.url,e=>{re.addWorkDone(t,1),m(e),re.addWorkDone(t,1);});})();}}class _a extends D{constructor(e){super(e),this.setFlag(k.USER_EDITED),this.__outputs=[],this.__evalOutput=this.__evalOutput.bind(this),this.postEval=new S;}setDirty(){for(const e of this.__outputs)e.setDirtyFromOp();}__parameterValueChanged(e,t){this.setDirty();}addOutput(e){return this.__outputs.push(e),e.paramSet.connect(e=>{e.bindOperator(this);}),e}removeOutput(e){e.getParam()&&e.getParam().unbindOperator(this),this.__outputs.splice(this.__outputs.indexOf(e),1);}getNumOutputs(){return this.__outputs.length}getOutputByIndex(e){return this.__outputs[e]}getOutput(e){for(const t of this.__outputs)if(t.getName()==e)return t}__evalOutput(e){for(const e of this.__outputs)e.removeCleanerFn(this.__evalOutput);this.evaluate();}__opInputChanged(){this.setDirty();}evaluate(){throw new Error("Not yet implemented")}toJSON(e,t){const a=super.toJSON(e,t);a.type=C.getClassName(this);const i=[];for(const a of this.__outputs)i.push(a.toJSON(e,t));return a.outputs=i,a}fromJSON(e,t,a){if(super.fromJSON(e,t,a),e.outputs){for(let a=0;a<this.__outputs.length;a++){this.__outputs[a].fromJSON(e.outputs[a],t);}t.addPLCB(()=>{this.__opInputChanged();});}}detach(){this.__outputs.forEach(e=>e.detach());}reattach(){this.__outputs.forEach(e=>e.reattach());}destroy(){super.destroy(),this.__outputs=[];}}class Za{constructor(e,t){this.__name=e,this.__filterFn=t,this._param=void 0,this.detached=!1,this.paramSet=new S;}getName(){return this.__name}getFilterFn(){return this.__filterFn}isConnected(){return null!=this._param}getParam(){return this._param}setParam(e){this._param=e,this.paramSet.emit();}getValue(e=Y.OPERATOR_GETVALUE){if(this._param)return this._param.getValue(e)}setValue(e,t=N.OPERATOR_SETVALUE){this._param&&this._param.setValue(e,t);}setClean(e){this._param&&this._param.setClean(e);}setDirty(e){this._param&&this._param.setDirty(e);}setDirtyFromOp(){this._param&&this._param.setDirtyFromOp();}removeCleanerFn(e){this._param&&this._param.removeCleanerFn(e);}toJSON(e,t){const a=this._param?this._param.getPath():"";return {type:this.constructor.name,paramPath:e&&e.makeRelative?e.makeRelative(a):a}}fromJSON(e,t,a){e.paramPath&&t.resolvePath(e.paramPath,e=>{this.setParam(e);},t=>{console.warn("Operator Output: '"+this.getName()+"'. Unable to load item:"+e.paramPath);});}detach(){this.detached=!0;}reattach(){this.detached=!1;}}C.registerClass("OperatorOutput",Za);class Ga extends Za{constructor(e){super(e,e=>"Xfo"==e.getDataType());}getInitialValue(){return this._initialParamValue}setParam(e){(()=>{if(this._initialParamValue=e.getValue(),this._initialParamValue.clone&&(this._initialParamValue=this._initialParamValue.clone()),null==this._initialParamValue)throw new Error("WTF?")})(),this._param=e,this.paramSet.emit(e);}}C.registerClass("XfoOperatorOutput",Ga);class Xa extends _a{constructor(e){super(e),this.addParameter(new fe("ParentGlobal")),this.addParameter(new fe("LocalXfo")),this.addOutput(new Ga("GlobalXfo"));}evaluate(){const e=this.getParameter("ParentGlobal").getValue(),t=this.getParameter("LocalXfo").getValue();this.getOutputByIndex(0).setClean(e.multiply(t));}}C.registerClass("CalcGlobalXfoOperator",Xa);class ya extends We{constructor(e){super(e),this.__stageParam=this._addMember(new ue("Stage",0)),this.__axisParam=this._addMember(new _e("Axis",new d(1,0,0))),this.__movementParam=this._addMember(new ge("MovementTiming",new o(0,1),[new o(0,0),new o(1,1)])),this.__multiplierParam=this._addMember(new ue("Multiplier",1)),this.__output=new Ga("Part");}getStage(e=N.USER_GETVALUE){return this.__stageParam.getValue(e)}setStage(e,t=N.USER_SETVALUE){this.__stageParam.setValue(e,t);}getOutput(){return this.__output}evaluate(e,t,a,i,s,n,l,r){if(!this.__output.isConnected())return;const o=this.__stageParam.getValue(),d=this.__movementParam.getValue();let h;if(s){let a=o/i;n&&(a-=.5),h=t*Math.linStep(d.x,d.y,Math.max(0,e-a));}else {let a=1-o/i;n&&(a-=.5),h=t*Math.linStep(d.x,d.y,e)*a;}h+=a;let c=this.__axisParam.getValue();const m=this.__multiplierParam.getValue(),u=this.__output.getInitialValue();let b;l?(b=r.multiply(u),c=l.ori.rotateVec3(c),b.tr.addInPlace(c.scale(h*m))):(b=this.__output.getValue(),b.tr=u.tr.add(c.scale(h*m))),this.__output.setClean(b);}toJSON(e,t){const a=super.toJSON(e,t);return a&&(a.output=this.__output.toJSON(e,t)),a}fromJSON(e,t,a){super.fromJSON(e,t,a),e.output&&this.__output.fromJSON(e.output,t);}}class fa extends _a{constructor(e){super(e),this.__stagesParam=this.addParameter(new ue("Stages",0)),this._explodeParam=this.addParameter(new ue("Explode",0,[0,1])),this._distParam=this.addParameter(new ue("Dist",1)),this._offsetParam=this.addParameter(new ue("Offset",0)),this._cascadeParam=this.addParameter(new pe("Cascade",!1)),this._centeredParam=this.addParameter(new pe("Centered",!1)),this.__parentItemParam=this.addParameter(new Le("RelativeTo")),this.__parentItemParam.valueChanged.connect(()=>{const e=this.__parentItemParam.getValue();this.__invParentSpace=e?e.getGlobalXfo().inverse():void 0;}),this.__parentItemParam.treeItemGlobalXfoChanged.connect(()=>{this.setDirty();}),this.__itemsParam=this.addParameter(new Se("Parts",ya)),this.__itemsParam.elementAdded.connect((e,t)=>{if(t>0){const a=this.__itemsParam.getElement(t-1).getStage();e.setStage(a+1),this.__stagesParam.setClean(a+2);}else this.__stagesParam.setClean(1);this.addOutput(e.getOutput()),this.setDirty();}),this.__itemsParam.elementRemoved.connect((e,t)=>{this.removeOutput(e.getOutput());}),this.__localXfos=[],this.__parts=[],this.__stages=2;}evaluate(){const e=this.__stagesParam.getValue(),t=this._explodeParam.getValue(),a=this._distParam.getValue(),i=this._offsetParam.getValue(),s=this._cascadeParam.getValue(),n=this._centeredParam.getValue(),l=this.__parentItemParam.getValue();let r,o;l&&(r=l.getGlobalXfo(),o=this.__invParentSpace.multiply(r));const d=this.__itemsParam.getValue();for(let l=0;l<d.length;l++){d[l].evaluate(t,a,i,e,s,n,r,o);}}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,a){super.fromJSON(e,t,a);}destroy(){clearTimeout(this.__timeoutId),super.destroy();}}C.registerClass("ExplodePartsOperator",fa);class Va extends We{constructor(e){super(e),this.__ratioParam=this._addMember(new ue("Ratio",1)),this.__offsetParam=this._addMember(new ue("Offset",0)),this.__axisParam=this._addMember(new _e("Axis",new d(1,0,0))),this.__output=new Ga("Gear");}getOutput(){return this.__output}getRatio(){return this.__ratioParam.getValue()}getOffset(){return this.__offsetParam.getValue()}getAxis(){return this.__axisParam.getValue()}toJSON(e,t){const a=super.toJSON(e,t);return a&&(a.output=this.__output.toJSON(e,t)),a}fromJSON(e,t,a){super.fromJSON(e,t,a),e.output&&this.__output.fromJSON(e.output,t);}}class xa extends _a{constructor(e){super(e),this.__revolutionsParam=this.addParameter(new ue("Revolutions",0));const t=this.addParameter(new ue("RPM",0));t.valueChanged.connect(()=>{const e=t.getValue();if(Math.abs(e)>0){if(!this.__timeoutId){const e=()=>{const a=t.getValue(),i=this.__revolutionsParam.getValue();this.__revolutionsParam.setValue(i+a*(1/3e3)),this.__timeoutId=setTimeout(e,20);};e();}}else clearTimeout(this.__timeoutId),this.__timeoutId=void 0;}),this.__gearsParam=this.addParameter(new Se("Gears",Va)),this.__gearsParam.elementAdded.connect((e,t)=>{this.addOutput(e.getOutput());}),this.__gearsParam.elementRemoved.connect((e,t)=>{this.removeOutput(t);}),this.__gears=[];}evaluate(){const e=this.__revolutionsParam.getValue(),t=this.__gearsParam.getValue();for(const a of t){const t=a.getOutput(),i=t.getInitialValue();if(!i)return;const s=e*a.getRatio()+a.getOffset(),n=new Z;n.setFromAxisAndAngle(a.getAxis(),s*Math.PI*2);const l=t.getValue();l.ori=n.multiply(i.ori),t.setClean(l);}}detach(){super.detach(),this.__timeoutId&&(clearTimeout(this.__timeoutId),this.__timeoutId=null);}reattach(){super.reattach(),this.getParameter("RPM").valueChanged.emit();}destroy(){this.__timeoutId&&(clearTimeout(this.__timeoutId),this.__timeoutId=null),super.destroy();}}C.registerClass("GearsOperator",xa);class Ia extends We{constructor(){super("Piston"),this.__pistonAngleParam=this._addMember(new ue("PistonAngle",0)),this.__camPhaseParam=this._addMember(new ue("CamPhase",0)),this.__camLengthParam=this._addMember(new ue("CamLength",3)),this.__rodLengthParam=this._addMember(new ue("RodLength",3)),this.__rodoutput=new Ga("Rod"),this.__capoutput=new Ga("Cap"),this.__pistonAngleParam.valueChanged.connect(this.init.bind(this)),this.__camPhaseParam.valueChanged.connect(this.init.bind(this)),this.__camLengthParam.valueChanged.connect(this.init.bind(this)),this.__rodLengthParam.valueChanged.connect(this.init.bind(this)),this.__bindXfos={};}getRodOutput(){return this.__rodoutput}getCapOutput(){return this.__capoutput}setCrankXfo(e){this.__baseCrankXfo=e,this.init();}init(){if(!this.__baseCrankXfo)return;const e=this.__camPhaseParam.getValue(),t=this.__camLengthParam.getValue(),a=this.__rodLengthParam.getValue(),i=this.__pistonAngleParam.getValue(),s=new d(Math.sin(Math.degToRad(i)),Math.cos(Math.degToRad(i)),0);this.__pistonAxis=this.__baseCrankXfo.ori.rotateVec3(s),this.__camVec=this.__baseCrankXfo.ori.rotateVec3(new d(Math.sin(2*e*Math.PI)*t,Math.cos(2*e*Math.PI)*t,0));const n=2*e*Math.PI,l=Math.sin(n)*t,r=Math.sqrt(a*a-l*l)+Math.cos(n)*t;this.__pistonOffset=r;}evaluate(e,t,a){const i=this.__camPhaseParam.getValue(),s=this.__camLengthParam.getValue(),n=this.__rodLengthParam.getValue(),l=2*(i+a)*Math.PI,r=Math.sin(l)*s,o=Math.asin(r/n),d=Math.sqrt(n*n-r*r)+Math.cos(l)*s;if(this.__rodoutput.isConnected()){const a=this.__rodoutput.getInitialValue().clone(),i=this.__rodoutput.getValue(),s=i.tr.subtract(this.__baseCrankXfo.tr).dot(t),n=new Z;n.setFromAxisAndAngle(t,-o),i.tr=this.__baseCrankXfo.tr.add(e.rotateVec3(this.__camVec)),i.tr.addInPlace(t.scale(s)),i.ori=n.multiply(a.ori),this.__rodoutput.setValue(i);}if(this.__capoutput.isConnected()){const e=this.__capoutput.getInitialValue().clone(),t=this.__capoutput.getValue();t.tr=e.tr.add(this.__pistonAxis.scale(d-this.__pistonOffset)),this.__capoutput.setValue(t);}}setOwner(e){this.__owner=e;}getOwner(){return this.__owner}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,a){super.fromJSON(e,t,a);}clone(e){return new Ia(this.__name,this.__value)}}class Ra extends _a{constructor(e){super(e),this.__revolutionsParam=this.addParameter(new ue("Revolutions",0,[0,1]));const t=this.addParameter(new ue("RPM",0));t.valueChanged.connect(()=>{let e=t.getValue();if(e>0){if(!this.__timeoutId){const a=()=>{e=t.getValue();const i=this.__revolutionsParam.getValue();this.__revolutionsParam.setValue(i+e*(1/3e3)),this.__timeoutId=setTimeout(a,20);};a();}}else clearTimeout(this.__timeoutId),this.__timeoutId=void 0;}),this.__crankOutput=this.addOutput(new Ga("Crank")),this.__crankOutput.paramSet.connect(this.init.bind(this)),this.__crankAxisParam=this.addParameter(new _e("CrankAxis",new d(1,0,0))),this.__crankAxisParam.valueChanged.connect(()=>{this.__baseCrankXfo.ori.setFromDirectionAndUpvector(this.__crankAxisParam.getValue(),new d(0,0,1)),this.init();}),this.__pistonsParam=this.addParameter(new Se("Pistons",Ia)),this.__pistonsParam.elementAdded.connect(e=>{e.setCrankXfo(this.__baseCrankXfo),this.addOutput(e.getRodOutput()),this.addOutput(e.getCapOutput());}),this.__pistonsParam.elementRemoved.connect(e=>{this.removeOutput(e.getRodOutput()),this.removeOutput(e.getCapOutput());}),this.__baseCrankXfo=new X,this.__pistons=[];}setOwner(e){super.setOwner(e);}getCrankOutput(){return this.__crankOutput}init(){const e=this.__pistonsParam.getValue();for(const t of e)t.setCrankXfo(this.__baseCrankXfo);this.__crankOutput.isConnected()&&(this.__crankOffset=this.__baseCrankXfo.inverse().multiply(this.__crankOutput.getInitialValue()));}evaluate(){const e=this.__revolutionsParam.getValue(Y.OPERATOR_GETVALUE),t=this.__crankAxisParam.getValue(Y.OPERATOR_GETVALUE),a=new Z;if(a.setFromAxisAndAngle(t,e*Math.PI*2),this.__crankOutput.isConnected()){const e=this.__crankOutput.getValue();e.ori=a.multiply(this.__crankOutput.getInitialValue().ori),this.__crankOutput.setValue(e);}const i=this.__pistonsParam.getValue(),s=i.length;for(let n=0;n<s;n++){i[n].evaluate(a,t,e);}this.postEval.emit(e);}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,a){super.fromJSON(e,t,a),e.crankOutput&&this.__crankOutput.fromJSON(e.crankOutput,t),this.init();}destroy(){clearTimeout(this.__timeoutId),super.destroy();}}C.registerClass("PistonOperator",Ra);class Sa extends _a{constructor(e){super(e),this.__inputParam=this.addParameter(new ue("Input")),this.__routesParam=this.addParameter(new Se("Routes",ue)),this.__routesParam.elementAdded.connect(e=>{e.setValue(1),this.addOutput(new Za("Output"));}),this.__routesParam.elementRemoved.connect((e,t)=>{this.removeOutput(this.getOutputByIndex(t));});}evaluate(){const e=this.__inputParam.getValue(Y.OPERATOR_GETVALUE),t=this.__routesParam.getValue();let a=this.__outputs.length;for(;a--;){this.__outputs[a].setValue(e*t[a].getValue(Y.OPERATOR_GETVALUE));}this.postEval.emit(e);}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,t,a){super.fromJSON(e,t,a);}destroy(){super.destroy();}}C.registerClass("RouterOperator",Sa);class Wa extends _a{constructor(e){super(e),this.addParameter(new ue("Weight",1)),this.addParameter(new be("Axis",0,["+X Axis","-X Axis","+Y Axis","-Y Axis","+Z Axis","-Z Axis"])),this.addParameter(new ue("Stretch",0)),this.addParameter(new ue("Initial Dist",1)),this.addParameter(new fe("Target")),this.addOutput(new Ga("InputOutput"));}resetStretchRefDist(){const e=this.getParameter("Target").getValue(),t=this.getOutputByIndex(0).getValue(),a=e.tr.subtract(t.tr).length();this.getParameter("Initial Dist").setValue(a);}evaluate(){const e=this.getParameter("Weight").getValue(),t=this.getParameter("Target").getValue(),a=this.getParameter("Axis").getValue(),i=this.getOutputByIndex(0),s=i.getValue(),n=t.tr.subtract(s.tr),l=n.length();if(l<1e-6)return;let r;switch(n.scaleInPlace(1/l),a){case 0:r=s.ori.getXaxis();break;case 1:r=s.ori.getXaxis().negate();break;case 2:r=s.ori.getYaxis();break;case 3:r=s.ori.getYaxis().negate();break;case 4:r=s.ori.getZaxis();break;case 5:r=s.ori.getZaxis().negate();}let o=new Z;o.setFrom2Vectors(r,n),o.alignWith(new Z),e<1&&(o=(new Z).lerp(o,e)),s.ori=o.multiply(s.ori);const d=this.getParameter("Stretch").getValue();if(d>0){const e=1+(l/this.getParameter("Initial Dist").getValue()-1)*d;switch(a){case 0:case 1:s.sc.x=e;break;case 2:case 3:s.sc.y=e;break;case 4:case 5:s.sc.z=e;}}i.setClean(s);}}C.registerClass("AimOperator",Wa);class La extends H{constructor(e){null==e&&(e="Camera"),super(e),this.__defaultManipulationState="orbit",this.__manipulationState=this.__defaultManipulationState,this.__mouseDown=!1,this.__dragging=!1,this.__mouseDragDelta=new o,this.__keyboardMovement=!1,this.__keysPressed=[],this.__maxVel=.002,this.__velocity=new d,this.__ongoingTouches={},this.__orbitRateParam=this.addParameter(new ue("orbitRate",t.isMobileDevice?-.3:1)),this.__dollySpeedParam=this.addParameter(new ue("dollySpeed",.02)),this.__mouseWheelDollySpeedParam=this.addParameter(new ue("mouseWheelDollySpeed",5e-4)),this.movementFinished=new S;}setDefaultManipulationMode(e){this.__defaultManipulationState=e;}look(e,t){const{viewport:a}=e,i=a.getCamera(),s=i.getFocalDistance(),n=this.__orbitRateParam.getValue();if(this.__keyboardMovement){const e=i.getGlobalXfo();this.__mouseDownCameraXfo=e.clone(),this.__mouseDownZaxis=e.ori.getZaxis();const t=this.__mouseDownZaxis.scale(-s);this.__mouseDownCameraTarget=e.tr.add(t);}const l=this.__mouseDownCameraXfo.clone(),r=new Z;r.rotateZ(t.x/a.getWidth()*Math.PI*n),l.ori=r.multiply(l.ori);const o=new Z;o.rotateX(t.y/a.getHeight()*Math.PI*n),l.ori.multiplyInPlace(o),i.setGlobalXfo(l);}orbit(e,t){const{viewport:a}=e,i=a.getCamera(),s=i.getFocalDistance(),n=this.__orbitRateParam.getValue();if(this.__keyboardMovement){const e=i.getGlobalXfo();this.__mouseDownCameraXfo=e.clone(),this.__mouseDownZaxis=e.ori.getZaxis();const t=this.__mouseDownZaxis.scale(-s);this.__mouseDownCameraTarget=e.tr.add(t);}const l=this.__mouseDownCameraXfo.clone(),r=new Z;r.rotateZ(t.x/a.getWidth()*2*Math.PI*-n),l.ori=r.multiply(l.ori);const o=new Z;o.rotateX(t.y/a.getHeight()*Math.PI*-n),l.ori.multiplyInPlace(o),l.tr=this.__mouseDownCameraTarget.add(l.ori.getZaxis().scale(s)),i.setGlobalXfo(l);}pan(e,t){const{viewport:a}=e,i=a.getCamera(),s=i.getFocalDistance(),n=i.getFov(),l=new d(1,0,0),r=new d(0,1,0),o=2*s*Math.tan(.5*n),h=o*(a.getWidth()/a.getHeight()),c=new X;c.tr=l.scale(-t.x/a.getWidth()*h),c.tr.addInPlace(r.scale(t.y/a.getHeight()*o)),i.setGlobalXfo(this.__mouseDownCameraXfo.multiply(c));}dolly(e,t){const{viewport:a}=e,i=a.getCamera(),s=t.x*this.__dollySpeedParam.getValue(),n=new X;n.tr.set(0,0,s),i.setGlobalXfo(this.__mouseDownCameraXfo.multiply(n));}panAndZoom(e,t,a){const{viewport:i}=e,s=i.getCamera(),n=s.getFocalDistance(),l=s.getFov(),r=new d(1,0,0),o=new d(0,1,0),h=2*n*Math.tan(.5*l),c=h*(i.getWidth()/i.getHeight()),m=new X;m.tr=r.scale(-t.x/i.getWidth()*c),m.tr.addInPlace(o.scale(t.y/i.getHeight()*h));const u=a*n;s.setFocalDistance(this.__mouseDownFocalDist+u),m.tr.z+=u,s.setGlobalXfo(this.__mouseDownCameraXfo.multiply(m));}initDrag(e){const{viewport:t}=e,a=t.getCamera(),i=a.getFocalDistance();this.__mouseDown=!0,this.__calculatingDragAction=!1,this.__mouseDownPos=e.mousePos,this.__mouseDownViewport=t,this.__mouseDragDelta.set(0,0),this.__mouseDownCameraXfo=a.getGlobalXfo().clone(),this.__mouseDownZaxis=this.__mouseDownCameraXfo.ori.getZaxis();const s=this.__mouseDownZaxis.scale(-i);this.__mouseDownCameraTarget=a.getGlobalXfo().tr.add(s),this.__mouseDownFocalDist=i,this.__dragListenerId=a.getParameter("GlobalXfo").valueChanged.connect(this.__globalXfoChangedDuringDrag.bind(this));}__globalXfoChangedDuringDrag(e){if(!this.__calculatingDragAction){this.__mouseDownViewport.getCamera().getParameter("GlobalXfo").valueChanged.disconnectId(this.__dragListenerId),this.initDrag({viewport:this.__mouseDownViewport,mousePos:this.__mouseDownPos});}}endDrag(e){if(this.__dragListenerId){const{viewport:t}=e;t.getCamera().getParameter("GlobalXfo").valueChanged.disconnectId(this.__dragListenerId),this.__dragListenerId=null;}this.__mouseDown=!1,this.__dragging=!1;}aimFocus(e,t){const{viewport:a}=e,i=a.getCamera();this.__focusIntervalId&&clearInterval(this.__focusIntervalId);let s=0;const n=()=>{const e=i.getGlobalXfo(),a=i.getFocalDistance(),l=t.subtract(e.tr),r=l.normalizeInPlace(),o=new Z,d=new Z;{const t=e.ori.getZaxis().clone();t.z=0;const a=l.negate();a.z=0,o.setFrom2Vectors(t,a);}{const t=e.ori.getZaxis().clone(),a=l.negate();t.x=a.x,t.y=a.y,t.normalizeInPlace(),t.cross(a).dot(e.ori.getXaxis())>0?d.rotateX(t.angleTo(a)):d.rotateX(-t.angleTo(a));}const h=e.clone();h.ori=o.multiply(h.ori),h.ori.multiplyInPlace(d);const c=Math.pow(s/20,2),m=e.clone();m.ori=e.ori.lerp(h.ori,c),i.setFocalDistance(a+(r-a)*c),i.setGlobalXfo(m),s++,s<=20?this.__focusIntervalId=setTimeout(n,20):(this.__focusIntervalId=void 0,this.movementFinished.emit());};n(),this.__manipulationState="focussing";}onMouseMove(e){}onDoubleClick(e){if(e.intersectionData){const t=e.viewport.getCamera().getGlobalXfo().tr.add(e.mouseRay.dir.scale(e.intersectionData.dist));this.aimFocus(e,t);}}onMouseDown(e){this.initDrag(e),2==e.button?this.__manipulationState="pan":e.ctrlKey&&e.altKey?this.__manipulationState="dolly":e.ctrlKey||2==e.button?this.__manipulationState="look":this.__manipulationState=this.__defaultManipulationState;}onMouseMove(e){if(!this.__mouseDown)return;const t=e.mousePos;switch(this.__calculatingDragAction=!0,this.__keyboardMovement?this.__mouseDragDelta=t:this.__mouseDragDelta=t.subtract(this.__mouseDownPos),this.__manipulationState){case"orbit":this.orbit(e,this.__mouseDragDelta);break;case"look":this.look(e,this.__mouseDragDelta);break;case"pan":this.pan(e,this.__mouseDragDelta);break;case"dolly":this.dolly(e,this.__mouseDragDelta);}this.__dragging=!0,this.__calculatingDragAction=!1,e.stopPropagation();}onMouseUp(e){this.__dragging&&(this.movementFinished.emit(),e.stopPropagation()),this.endDrag(e);}onWheel(e){const{viewport:t}=e,a=t.getCamera(),i=this.__mouseWheelDollySpeedParam.getValue(),s=e.shiftKey?.1:.5,n=a.getGlobalXfo(),l=n.ori.getZaxis();this.__mouseWheelZoomIntervalId&&clearInterval(this.__mouseWheelZoomIntervalId);let r=0;const o=()=>{const t=a.getFocalDistance(),d=e.deltaY*i*t*s;n.tr.addInPlace(l.scale(d)),"orbit"==this.__defaultManipulationState&&a.setFocalDistance(a.getFocalDistance()+d),a.setGlobalXfo(n),r++,r<10?this.__mouseWheelZoomIntervalId=setTimeout(o,10):(this.__mouseWheelZoomIntervalId=void 0,this.movementFinished.emit());};o();}__integrateVelocityChange(e){const{viewport:t}=e,a=t.getCamera(),i=new X;i.tr=this.__velocity.normalize().scale(this.__maxVel),a.setGlobalXfo(a.getGlobalXfo().multiply(i));}onKeyPressed(e,t){return !1}onKeyDown(e,t){}onKeyUp(e,t){}__startTouch(e){this.__ongoingTouches[e.identifier]={identifier:e.identifier,pos:new o(e.pageX,e.pageY)};}__endTouch(e){delete this.__ongoingTouches[e.identifier];}onTouchStart(e){console.log("onTouchStart"),e.preventDefault(),e.stopPropagation(),0==Object.keys(this.__ongoingTouches).length&&(this.__manipMode=void 0);const t=e.changedTouches;for(let e=0;e<t.length;e++)this.__startTouch(t[e]);1==Object.keys(this.__ongoingTouches).length&&(this.initDrag(e),this.__dragging=!0);}onTouchMove(e){e.preventDefault(),e.stopPropagation(),this.__calculatingDragAction=!0;const t=e.touches;if(1==t.length&&"panAndZoom"!=this.__manipMode){const a=t[0],i=new o(a.pageX,a.pageY),s=this.__ongoingTouches[a.identifier].pos.subtract(i);"look"==this.__defaultManipulationState?(s.scaleInPlace(6),this.look(e,s)):this.orbit(e,s);}else if(2==t.length){const a=t[0],i=this.__ongoingTouches[a.identifier],s=t[1],n=this.__ongoingTouches[s.identifier],l=new o(a.pageX,a.pageY),r=new o(s.pageX,s.pageY),d=n.pos.subtract(i.pos).length()-r.subtract(l).length(),h=l.subtract(i.pos),c=r.subtract(n.pos),m=h.add(c);m.scaleInPlace(.5),this.panAndZoom(e,m,.002*d),this.__manipMode="panAndZoom";}this.__calculatingDragAction=!1;}onTouchEnd(e){e.preventDefault(),e.stopPropagation();const t=e.changedTouches;for(let e=0;e<t.length;e++)this.__endTouch(t[e]);0==Object.keys(this.__ongoingTouches).length&&this.endDrag(e);}onTouchCancel(e){e.preventDefault();const t=e.touches;for(let e=0;e<t.length;e++)this.__endTouch(t[e]);0==Object.keys(this.__ongoingTouches).length&&this.endDrag(e);}onDoubleTap(e){if(e.intersectionData){const{viewport:t}=e,a=t.getCamera().getGlobalXfo().tr.add(e.touchRay.dir.scale(e.intersectionData.dist));this.aimFocus(e,a);}e.preventDefault();}}var va=Object.freeze({__proto__:null,RefCounted:T,ParameterOwner:H,ItemFlags:k,BaseItem:D,getFileFolder:O,loadTextfile:A,loadJSONfile:q,loadXMLfile:$,loadBinfile:ee,sgFactory:C,isObject:ne,mergeDeep:le,resourceLoader:re,Version:oe,BinReader:de,BinWriter:he,Command:me,ParamFlags:K,ValueGetMode:Y,ValueSetMode:N,BaseParameter:J,Parameter:P,MultiChoiceParameter:be,BooleanParameter:pe,NumberParameter:ue,Vec2Parameter:ge,Vec3Parameter:_e,Vec4Parameter:Ze,ColorParameter:Ge,Mat3Parameter:Xe,Mat4Parameter:ye,XfoParameter:fe,ImageParameter:Ve,StringParameter:xe,CodeParameter:Ie,FilePathParameter:Re,ListParameter:Se,StructParameter:We,TreeItemParameter:Le,ItemSetParameter:ve,ProxyParameter:Me,GeometryParameter:Fe,MaterialParameter:Rt,MaterialFloatParam:Ce,MaterialColorParam:Ye,Attribute:St,BaseGeom:Wt,SAVE_FLAG_SKIP_GEOMDATA:1024,VertexAttribute:Lt,Points:vt,Lines:Mt,Mesh:Ft,PointsProxy:Ct,LinesProxy:Yt,MeshProxy:Nt,PointGrid:Kt,Rect:wt,Circle:zt,Cross:Ut,LinesCuboid:Jt,Grid:Pt,Cone:Et,Cuboid:Ht,Cylinder:kt,Disc:Bt,Plane:Dt,Sphere:Ot,Torus:Qt,DataImage:we,FileImage:it,FileImage2D:st,LDRImage:lt,LDRVideo:rt,GIFImage:ot,EnvMap:Zt,Lightmap:Gt,LightmapMixer:Xt,Label:ft,VideoStreamImage2D:Vt,labelManager:yt,SaveFlags:At,LoadFlags:jt,CloneFlags:qt,TreeItem:$t,InstanceItem:ea,AudioItem:ta,FileAudioItem:aa,BaseGeomItem:ia,GeomItem:sa,AssetItem:da,BillboardItem:ha,Camera:ca,Group:la,GeomLibrary:oa,Material:Ke,BaseImage:Te,MaterialLibrary:xt,materialLibraryManager:It,Scene:pa,VLAAsset:ua,ObjAsset:ga,Operator:_a,OperatorOutput:Za,XfoOperatorOutput:Ga,CalcGlobalXfoOperator:Xa,ExplodePartsOperator:fa,GearsOperator:xa,PistonOperator:Ra,RouterOperator:Sa,AimOperator:Wa,CameraMouseAndKeyboard:La});const Ma=function(e,a){console.log(t);let i=null;if(null!=a.webglContextType)try{i=e.getContext(a.webglContextType,a),i.name=a.webglContextType;}catch(e){}else {["webgl2","webgl"].some(t=>{try{i=e.getContext(t,a),i.name=t;}catch(e){}if(i)return !0});}if(i)return i.sizeInBytes=function(e){switch(e){case this.BYTE:case this.UNSIGNED_BYTE:return 1;case this.SHORT:case this.UNSIGNED_SHORT:return 2;case this.INT:case this.UNSIGNED_INT:case this.FLOAT:return 4;default:throw new Error("unknown type")}},"webgl2"==i.name?(i.floatTexturesSupported=!0,i.__ext_float_linear=i.getExtension("OES_texture_float_linear"),i.__ext_texture_half_float_linear=i.getExtension("OES_texture_half_float_linear"),i.__ext_color_buffer_float=i.getExtension("EXT_color_buffer_float")):(i.__ext_float=i.getExtension("OES_texture_float"),i.__ext_float?(i.floatTexturesSupported=!0,i.__ext_float_linear=i.getExtension("OES_texture_float_linear")):console.warn("OES_texture_float is not available"),i.__ext_half_float=i.getExtension("OES_texture_half_float"),i.__ext_half_float&&(i.HALF_FLOAT=i.__ext_half_float.HALF_FLOAT_OES,i.floatTexturesSupported=!0,i.__ext_texture_half_float_linear=i.getExtension("OES_texture_half_float_linear")),i.__ext_color_buffer_float=i.getExtension("EXT_color_buffer_float"),i.__ext_std_derivatives=i.getExtension("OES_standard_derivatives"),i.__ext_Inst=i.getExtension("ANGLE_instanced_arrays"),i.__ext_Inst&&(i.vertexAttribDivisor=i.__ext_Inst.vertexAttribDivisorANGLE.bind(i.__ext_Inst),i.drawArraysInstanced=i.__ext_Inst.drawArraysInstancedANGLE.bind(i.__ext_Inst),i.drawElementsInstanced=i.__ext_Inst.drawElementsInstancedANGLE.bind(i.__ext_Inst)),i.__ext_VAO=i.getExtension("OES_vertex_array_object"),i.__ext_VAO&&(i.createVertexArray=i.__ext_VAO.createVertexArrayOES.bind(i.__ext_VAO),i.deleteVertexArray=i.__ext_VAO.deleteVertexArrayOES.bind(i.__ext_VAO),i.bindVertexArray=i.__ext_VAO.bindVertexArrayOES.bind(i.__ext_VAO)),i.__ext_element_index_uint=i.getExtension("OES_element_index_uint"),i.__ext_WEBGL_depth_texture=i.getExtension("WEBGL_depth_texture"),i.__ext_WEBGL_depth_texture&&(i.UNSIGNED_INT_24_8=i.__ext_WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL),i.DRAW_FRAMEBUFFER=i.FRAMEBUFFER),i.__ext_frag_depth=i.getExtension("EXT_frag_depth"),i.setupInstancedQuad=function(){const e=new Float32Array([0,1,2,3]),t=new Uint16Array([0,1,2,2,1,3]);this.__quadVertexIdsBuffer=this.createBuffer(),this.bindBuffer(this.ARRAY_BUFFER,this.__quadVertexIdsBuffer),this.bufferData(this.ARRAY_BUFFER,e,this.STATIC_DRAW),this.__quadIndexBuffer=this.createBuffer(),this.bindBuffer(this.ELEMENT_ARRAY_BUFFER,this.__quadIndexBuffer),this.bufferData(this.ELEMENT_ARRAY_BUFFER,t,this.STATIC_DRAW),this.__quadattrbuffers={vertexIDs:{buffer:this.__quadVertexIdsBuffer,dataType:6,dimension:1,count:e.length,shared:!0}};},i.drawQuad=function(){this.drawElements(this.TRIANGLES,6,this.UNSIGNED_SHORT,0);},i.setupLineSegAttrBuffers=function(){const e=new Float32Array([0,1]),t=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,t),i.bufferData(i.ARRAY_BUFFER,e,i.STATIC_DRAW),i.__linesegattrbuffers={vertexIDs:{buffer:t,dimension:1,count:e.length,shared:!0}};},i};class Fa extends T{constructor(e,t){if(super(),this.__gl=e,this.ready=new S(!0),this.updated=new S,this.resized=new S,this.width=0,this.height=0,this.textureType=1,this.textureDesc=[0,0,0,0],this.__loaded=!1,this.__bound=!1,null!=t)if(t instanceof Te){this.__texture=t,this.__texture.setMetadata("gltexture",this);const e=()=>{const e=this.__texture.getParams(),t=e.width,a=e.height,i=e.data;this.bufferData(i,t,a);};this.__texture.isLoaded()?(this.configure(this.__texture.getParams()),this.__texture.updated.connect(e)):this.__texture.loaded.connect(()=>{this.configure(this.__texture.getParams()),this.__texture.updated.connect(e);});}else this.configure(t);}isLoaded(){return this.__loaded}getTexture(){return this.__texture}getInternalFormat(){return this.__internalFormat}getType(){return this.__typeParam}getTypeID(){return this.__type}getFormat(){return this.__formatParam}getFormatID(){return this.__format}getFilter(){return this.__filterParam}getWrap(){return this.__wrapParam}getMipMapped(){return this.__mipMapped}configure(e,t=!0){if(!("type"in e&&"format"in e&&"width"in e&&"height"in e))throw new Error("Invalid texture params");const a=this.__gl,i=e.width,s=e.height,n=e.data,l=a.getParameter(a.MAX_TEXTURE_SIZE);if(i<=0||i>l||s<=0||s>l)throw new Error("gl-texture2d: Invalid texture size. width:"+i+" height:"+s+" maxSize:"+l);const r=e.format,o=e.type;let d="minFilter"in e?e.minFilter:"filter"in e?e.filter:"LINEAR",h="magFilter"in e?e.magFilter:"filter"in e?e.filter:"LINEAR";const c="wrap"in e?e.wrap:"CLAMP_TO_EDGE";if("FLOAT"==o)if(this.textureType=3,"webgl2"==a.name)"LINEAR"!=d||a.__ext_float_linear||(console.warn("Floating point texture filtering not supported on this device"),d="NEAREST"),"LINEAR"!=h||a.__ext_float_linear||(console.warn("Floating point texture filtering not supported on this device"),h="NEAREST");else if(a.__ext_float)"LINEAR"!=d||a.__ext_float_linear||(console.warn("Floating point texture filtering not supported on this device"),d="NEAREST"),"LINEAR"!=h||a.__ext_float_linear||(console.warn("Floating point texture filtering not supported on this device"),h="NEAREST");else {if(!a.__ext_half_float)throw new Error("OES_texture_half_float is not available");o="HALF_FLOAT","LINEAR"!=d||a.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on this device"),d="NEAREST"),"LINEAR"!=h||a.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on this device"),h="NEAREST");}else if("HALF_FLOAT"==o)if("webgl2"==a.name);else {if(!a.supportUploadingHalfFloat&&null!=n)throw new Error("Safari does not support uploading HALF_FLOAT texture data.");if(!a.__ext_half_float)throw new Error("OES_texture_half_float is not available");if("LINEAR"!=d||a.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on this device"),d="NEAREST"),"LINEAR"!=h||a.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on this device"),h="NEAREST"),"RGB"==r)throw new Error("OES_texture_half_float onlysupports RGBA textures")}else if("sRGB"==o&&!a.__ext_sRGB)throw new Error("EXT_sRGB is not available");this.__formatParam=r,this.__typeParam=o,this.__minFilterParam=d,this.__magFilterParam=h,this.__wrapParam=c,this.__format=a[r],this.__internalFormat="internalFormat"in e?a[e.internalFormat]:this.__format,this.__type=a[o],"webgl2"==a.name&&("internalFormat"in e||(this.__type==a.FLOAT?this.__format==a.RED?this.__internalFormat=a.R32F:this.__format==a.RG?this.__internalFormat=a.RG32F:this.__format==a.RGB?this.__internalFormat=a.RGB32F:this.__format==a.RGBA&&(this.__internalFormat=a.RGBA32F):this.__type==a.HALF_FLOAT?this.__format==a.RED?this.__internalFormat=a.R16F:this.__format==a.RG?this.__internalFormat=a.RG16F:this.__format==a.RGB?this.__internalFormat=a.RGB16F:this.__format==a.RGBA&&(this.__internalFormat=a.RGBA16F):this.__type==a.UNSIGNED_BYTE&&(this.__format==a.RED&&(this.__internalFormat=a.R8),this.__format==a.RG&&(this.__internalFormat=a.RG8),this.__format==a.RGB?this.__internalFormat=a.RGB8:this.__format==a.RGBA&&(this.__internalFormat=a.RGBA8)))),this.__minFilter=a[d],this.__magFilter=a[h],this.__wrap=a[c],this.__flipY="flipY"in e&&e.flipY,this.__mipMapped="mipMapped"in e&&e.mipMapped,this.invert="invert"in e&&e.invert,this.alphaFromLuminance="alphaFromLuminance"in e&&e.alphaFromLuminance,this.textureDesc=[i,s,0,0],this.__gltex&&a.deleteTexture(this.__gltex),this.__gltex=a.createTexture(),this.__updateGLTexParams(),n?this.bufferData(n,i,s,!1,!1):this.resize(i,s,!1,!1),this.__loaded||(this.ready.emit(),this.__loaded=!0);}__updateGLTexParams(){const e=this.__gl;e.bindTexture(e.TEXTURE_2D,this.__gltex),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,this.__minFilter),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,this.__magFilter),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,this.__wrap),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,this.__wrap);}bufferData(e,t=-1,a=-1,i=!0,s=!0){const n=this.__gl;if(i&&n.bindTexture(n.TEXTURE_2D,this.__gltex),null!=e){if(e instanceof Image||e instanceof ImageData||e instanceof HTMLCanvasElement||e instanceof HTMLImageElement||e instanceof HTMLVideoElement)n.texImage2D(n.TEXTURE_2D,0,this.__internalFormat,this.__format,this.__type,e),this.width=e.width,this.height=e.height;else {-1==t&&(t=this.width),-1==a&&(a=this.height);const i=t*a;let s;switch(this.__format){case n.RED:case n.RED_INTEGER:case n.ALPHA:case n.LUMINANCE:case n.LUMINANCE_ALPHA:s=1;break;case n.RG:s=2;break;case n.RGB:s=3;break;case n.RGBA:s=4;}e.length!=i*s&&console.warn("Invalid data for Image width:"+t+" height:"+a+" format:"+this.__formatParam+" type:"+this.__typeParam+" Data Length:"+e.length+" Expected:"+i*s),this.__type==n.HALF_FLOAT&&e instanceof Float32Array&&(e=Math.convertFloat32ArrayToUInt16Array(e)),"webgl2"==n.name?n.texImage2D(n.TEXTURE_2D,0,this.__internalFormat,t,a,0,this.__format,this.__type,e,0):n.texImage2D(n.TEXTURE_2D,0,this.__internalFormat,t,a,0,this.__format,this.__type,e),this.width=t,this.height=a;}this.__mipMapped&&n.generateMipmap(n.TEXTURE_2D);}else n.texImage2D(n.TEXTURE_2D,0,this.__internalFormat,this.width,this.height,0,this.__format,this.__type,null),this.width=t,this.height=a;s&&this.updated.emit();}clear(){const e=this.__gl,t=this.width*this.height;let a,i;switch(this.__format){case e.RED:case e.RED_INTEGER:case e.ALPHA:case e.LUMINANCE:case e.LUMINANCE_ALPHA:a=1;break;case e.RG:a=2;break;case e.RGB:a=3;break;case e.RGBA:a=4;break;default:throw new Error("Invalid Format")}switch(this.__type){case e.UNSIGNED_BYTE:i=new UInt8Array(t*a);break;case e.HALF_FLOAT:i=new UInt16Array(t*a);break;case e.FLOAT:i=new Float32Array(t*a);break;default:throw new Error("Invalid Type")}"webgl2"==e.name?e.texImage2D(e.TEXTURE_2D,0,this.__internalFormat,this.width,this.height,0,this.__format,this.__type,i,0):e.texImage2D(e.TEXTURE_2D,0,this.__internalFormat,this.width,this.height,0,this.__format,this.__type,i);}resize(e,t,a=!1,i=!0){const s=this.__gl;if(this.width!=e||this.height!=t){const n=s.getParameter(s.MAX_TEXTURE_SIZE);if(e<0||e>n||t<0||t>n)throw new Error("gl-texture2d: Invalid texture size. width:"+e+" height:"+t+" maxSize:"+n);if(a){const a=s.createTexture();s.bindTexture(s.TEXTURE_2D,a),s.texImage2D(s.TEXTURE_2D,0,this.__internalFormat,e,t,0,this.__format,this.__type,null);const i=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,i),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,this.__gltex,0),s.bindTexture(s.TEXTURE_2D,a),s.copyTexImage2D(s.TEXTURE_2D,0,this.__internalFormat,0,0,this.width,this.height,0),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteFramebuffer(i),this.__gl.deleteTexture(this.__gltex),this.__gltex=a,this.__updateGLTexParams();}else s.bindTexture(s.TEXTURE_2D,this.__gltex),s.texImage2D(s.TEXTURE_2D,0,this.__internalFormat,e,t,0,this.__format,this.__type,null);this.width=e,this.height=t,i&&this.resized.emit(e,t);}}populate(e,t,a,i=0,s=0,n=!0){const l=this.__gl;n&&l.bindTexture(l.TEXTURE_2D,this.__gltex),l.texSubImage2D(l.TEXTURE_2D,0,i,s,t,a,this.__format,this.__type,e);}getSize(){return [this.width,this.height]}get glTex(){return this.__gltex}getTexHdl(){return this.__gltex}bind(e,t){return console.warn("'bind' is deprecated. Please use 'bindToUniform'"),this.bindToUniform(e,t)}preBind(e,t){return {textureTypeUnif:t[e.name+"Type"],textureDescUnif:t[e.name+"Desc"]}}bindToUniform(e,t,a){if(!this.__loaded)return !1;if(!this.__gltex)throw new Error("Unable to bind non-initialized or deleted texture.");const i=e.boundTextures++,s=this.__gl.TEXTURE0+i,n=this.__gl;return n.activeTexture(s),n.bindTexture(n.TEXTURE_2D,this.__gltex),n.uniform1i(t.location,i),a&&(a.textureTypeUnif&&n.uniform1i(a.textureTypeUnif.location,this.textureType),a.textureDescUnif&&this.__gl.uniform4fv(a.textureDescUnif.location,this.textureDesc)),!0}destroy(){super.destroy(),this.__texture&&this.__texture.setMetadata("gltexture",void 0),this.__gl.deleteTexture(this.__gltex),this.__gltex=void 0;}}class Ta{constructor(e,t,a,i){this.__gl=e,this.__shaderAttrs=t,this.__glattrbuffers=a,this.__indexBuffer=i;}bind(e){const t=this.__gl;for(const e in this.__shaderAttrs){if("instancedIds"==e)continue;const a=this.__shaderAttrs[e],i=a.location;if(-1==i)continue;const s=this.__glattrbuffers[e];if(!s){t.disableVertexAttribArray(i);continue}let n,l,r;switch(s.dataType){case 0:n=1,l=4,r=t.UNSIGNED_BYTE;break;case 1:n=1,l=4,r=t.BYTE;break;case 2:n=1,l=4,r=t.UNSIGNED_SHORT;break;case 3:n=1,l=4,r=t.SHORT;break;case 4:n=1,l=4,r=t.UNSIGNED_INT;break;case 5:n=1,l=4,r=t.INT;break;case 6:n=1,l=4,r=t.FLOAT;break;case o:n=2,l=4,r=t.FLOAT;break;case d:n=3,l=4,r=t.FLOAT;break;case h:case u:n=4,l=4,r=t.FLOAT;break;case m:n=4,l=1,r=t.UNSIGNED_BYTE;break;default:throw "Unhandled Type"}const c=n*l,b=null!=s.offset?s.offset*n*l:0,p=1==s.normalized,g=a.instanced;t.enableVertexAttribArray(i),t.bindBuffer(t.ARRAY_BUFFER,s.buffer),t.vertexAttribPointer(i,n,r,p,c,b),t.vertexAttribDivisor&&(1==g?t.vertexAttribDivisor(i,1):t.vertexAttribDivisor(i,0));}return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),!0}unbind(){const e=this.__gl;for(const t in this.__shaderAttrs){const a=this.__shaderAttrs[t].location;-1!=a&&(e.disableVertexAttribArray(a),e.vertexAttribDivisor(a,0));}e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null);}destroy(){}}class Ca{constructor(e,t,a,i){this.__gl=e,this.__vao=e.createVertexArray(),e.bindVertexArray(this.__vao);for(const i in t){if("instancedIds"==i)continue;const s=t[i],n=s.location;if(-1==n)continue;const l=a[i];if(!l){e.disableVertexAttribArray(n);continue}let r,c,b;switch(l.dataType){case 0:r=1,c=4,b=e.UNSIGNED_BYTE;break;case 1:r=1,c=4,b=e.BYTE;break;case 2:r=1,c=4,b=e.UNSIGNED_SHORT;break;case 3:r=1,c=4,b=e.SHORT;break;case 4:r=1,c=4,b=e.UNSIGNED_INT;break;case 5:r=1,c=4,b=e.INT;break;case 6:r=1,c=4,b=e.FLOAT;break;case o:r=2,c=4,b=e.FLOAT;break;case d:r=3,c=4,b=e.FLOAT;break;case h:case u:r=4,c=4,b=e.FLOAT;break;case m:r=4,c=1,b=e.UNSIGNED_BYTE;break;default:throw "Unhandled Type"}const p=r*c,g=null!=l.offset?l.offset*r*c:0,_=1==l.normalized,Z=s.instanced;e.enableVertexAttribArray(n),e.bindBuffer(e.ARRAY_BUFFER,l.buffer),e.vertexAttribPointer(n,r,b,_,p,g),Z?e.vertexAttribDivisor(n,1):e.vertexAttribDivisor(n,0);}this.__indexBuffer=i;}bind(e){return this.__gl.bindVertexArray(this.__vao),this.__indexBuffer&&this.__gl.bindBuffer(this.__gl.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),!0}unbind(){const e=this.__gl;for(const t in this.__shaderAttrs){const a=this.__shaderAttrs[t].location;-1!=a&&(e.disableVertexAttribArray(a),e.vertexAttribDivisor(a,0));}this.__gl.bindVertexArray(null),this.__indexBuffer&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null);}destroy(){this.__gl.deleteVertexArray(this.__vao);}}function Ya(e,t,a,i){return null==e.createVertexArray?new Ta(e,t,a,i):new Ca(e,t,a,i)}class Na extends T{constructor(e,t){super(),this.__gl=e,this.__geom=t,this.__glattrs={},this.__glattrbuffers={},this.__shaderBindings={},this.destructing=new S,this.updated=new S;this.__geom.geomDataChanged.connect(e=>{this.updateBuffers(e),this.updated.emit();});this.__geom.geomDataTopologyChanged.connect(e=>{this.clearShaderBindings(),this.updateBuffers(e),this.updated.emit();});}getGeom(){return this.__geom}genBuffers(){}updateBuffers(e){}bind(e){if(this.__destroyed)throw new Error("Error binding a destroyed geom");let t=this.__shaderBindings[e.shaderkey];if(!t){t=Ya(this.__gl,e.attrs,this.__glattrbuffers,this.__indexBuffer),this.__shaderBindings[e.shaderkey]=t;}return t.bind(e),!0}unbind(e){const t=this.__shaderBindings[e.shaderkey];t&&t.unbind(e);}draw(){throw new Error("Not implemented. Implement this method in a derived class.")}drawInstanced(e){throw new Error("Not implemented. Implement this method in a derived class.")}bindAndDraw(e){this.bind(e),this.draw(e);}clearShaderBindings(){for(const e in this.__shaderBindings){this.__shaderBindings[e].destroy();}this.__shaderBindings={};}destroy(){this.__geom.deleteMetadata("glgeom"),this.clearShaderBindings();const e=this.__gl;for(const t in this.__glattrbuffers){const a=this.__glattrbuffers[t];a.shared||e.deleteBuffer(a.buffer);}this.__glattrs={},this.__shaderBindings={},this.__destroyed=!0,this.destructing.emit(this);}}class Ka extends Na{constructor(e,t){super(e,t),this.genBuffers();}getNumTriangles(){return this.__numTriangles}genBuffers(){super.genBuffers();const e=this.__gl,t=this.__geom.genBuffers(),a=t.indices;this.__numTriIndices=t.indices.length,a instanceof Uint8Array&&(this.__indexDataType=this.__gl.UNSIGNED_BYTE),a instanceof Uint16Array&&(this.__indexDataType=this.__gl.UNSIGNED_SHORT),a instanceof Uint32Array&&(this.__indexDataType=this.__gl.UNSIGNED_INT),this.__numTriangles=a.length/3,this.__numRenderVerts=t.numRenderVerts,this.__indexBuffer=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,t.indices,e.STATIC_DRAW);for(const a in t.attrBuffers){const i=t.attrBuffers[a],s=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,i.values,e.STATIC_DRAW),this.__glattrbuffers[a]={buffer:s,dataType:i.dataType,normalized:i.normalized},"textureCoords"==a&&(this.__glattrbuffers.texCoords=this.__glattrbuffers.textureCoords);}}updateBuffers(e){const t=this.__gl,a=this.__geom.genBuffers({includeIndices:!1});for(const e in a.attrBuffers){const i=a.attrBuffers[e],s=this.__glattrbuffers[e];t.bindBuffer(t.ARRAY_BUFFER,s.buffer),t.bufferData(t.ARRAY_BUFFER,i.values,t.STATIC_DRAW);}}getNumUnSplitVerts(){return this.__geom.vertices.length}getNumSplitVerts(){return this.__numRenderVerts}generateWireframesVAO(){if(!this.__vao)return !1;this.__geom.edgeVerts||this.__geom.genTopologyInfo(),this.__wireframesVao&&this.__ext.deleteVertexArrayOES(this.__wireframesVao),this.__wireframesVao=this.__ext.createVertexArrayOES(),this.__ext.bindVertexArrayOES(this.__wireframesVao);const e=this.__gl,t=e.createBuffer(),a=Uint32Array.from(this.__geom.edgeVerts);e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,a,e.STATIC_DRAW);const i=this.__glattrbuffers.positions.buffer;e.enableVertexAttribArray(0),e.bindBuffer(e.ARRAY_BUFFER,i),e.vertexAttribPointer(0,3,e.FLOAT,!1,12,0),this.__numWireIndices=a.length,this.__ext.bindVertexArrayOES(null);}bindWireframeVAO(e){return null!=this.__wireframesVao&&(this.__ext.bindVertexArrayOES(this.__wireframesVao),!0)}unbindWireframeVAO(){this.__ext.bindVertexArrayOES(null);}drawWireframe(){this.__wireframesVao&&this.__gl.drawElements(this.__gl.LINES,this.__numWireIndices,this.__gl.UNSIGNED_INT,0);}generateHardEdgesVAO(){if(!this.__vao)return !1;this.__geom.edgeVerts||this.__geom.generateHardEdgesFlags(),this.__hardEdgesVao&&this.__ext.deleteVertexArrayOES(this.__hardEdgesVao),this.__hardEdgesVao=this.__ext.createVertexArrayOES(),this.__ext.bindVertexArrayOES(this.__hardEdgesVao);const e=this.__gl,t=e.createBuffer(),a=Uint32Array.from(this.__geom.computeHardEdgesIndices());e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,a,e.STATIC_DRAW);const i=this.__glattrbuffers.positions.buffer;e.enableVertexAttribArray(0),e.bindBuffer(e.ARRAY_BUFFER,i),e.vertexAttribPointer(0,3,e.FLOAT,!1,12,0),this.__numEdgeIndices=a.length,this.__ext.bindVertexArrayOES(null);}bindHardEdgesVAO(e){return null!=this.__hardEdgesVao&&(this.__ext.bindVertexArrayOES(this.__hardEdgesVao),!0)}unbindHardEdgesVAO(){this.__ext.bindVertexArrayOES(null);}drawHardEdges(){this.__hardEdgesVao&&this.__gl.drawElements(this.__gl.LINES,this.__numEdgeIndices,this.__gl.UNSIGNED_INT,0);}drawPoints(){this.__gl.drawArrays(this.__gl.POINTS,0,this.__geom.numVertices());}draw(){this.__gl.drawElements(this.__gl.TRIANGLES,this.__numTriIndices,this.__indexDataType,0);}drawInstanced(e){this.__gl.drawElementsInstanced(this.__gl.TRIANGLES,this.__numTriIndices,this.__indexDataType,0,e);}destroy(){super.destroy(),this.__gl.deleteBuffer(this.__indexBuffer),this.__indexBuffer=void 0;}}class wa extends Na{constructor(e,t){super(e,t),this.genBuffers();}genBuffers(){super.genBuffers();const e=this.__gl,t=this.__geom.genBuffers(),a=t.indices;if(this.fatLines=(this.__geom.lineThickness>0||t.attrBuffers.lineThickness)&&e.floatTexturesSupported,this.fatLines){e.__quadVertexIdsBuffer||e.setupInstancedQuad(),this.__glattrbuffers.vertexIDs=e.__quadattrbuffers.vertexIDs,this.__drawCount=a.length/2;const t=this.__geom.getVertexAttributes(),i=t.positions,s=t.lineThickness,n=4,l=new Float32Array(i.length*n);for(let e=0;e<i.length;e++){d.createFromFloat32Buffer(l.buffer,4*e).setFromOther(i.getValueRef(e)),l[4*e+3]=s?s.getFloat32Value(e):this.__geom.lineThickness;}this.__positionsTexture=new Fa(e,{format:"RGBA",type:"FLOAT",width:i.length,height:1,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",data:l,mipMapped:!1});const r=new Float32Array(a.length);for(let e=0;e<a.length;e++){let t;t=e%2==0?e>0?a[e]==a[e-1]:a[e]==a[a.length-1]:e<a.length-1?a[e]==a[e+1]:a[e]==a[0],r[e]=(t?1:0)+2*a[e];}const o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW),this.__glattrbuffers.segmentIndices={buffer:o,dimension:2};}else {this.__indexBuffer=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,a,e.STATIC_DRAW);for(const a in t.attrBuffers){const i=t.attrBuffers[a],s=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,i.values,e.STATIC_DRAW),this.__glattrbuffers[a]={buffer:s,dataType:i.dataType,normalized:i.normalized};}this.__numSegIndices=a.length,this.__numVertices=t.numVertices;}a instanceof Uint8Array&&(this.__indexDataType=this.__gl.UNSIGNED_BYTE),a instanceof Uint16Array&&(this.__indexDataType=this.__gl.UNSIGNED_SHORT),a instanceof Uint32Array&&(this.__indexDataType=this.__gl.UNSIGNED_INT);}updateBuffers(e){const t=this.__gl,a=this.__geom.genBuffers(),i=a.indices;if(this.fatLines){this.__drawCount=i.length/2;const e=this.__geom.getVertexAttributes(),a=e.positions,s=e.lineThickness,n=4,l=new Float32Array(a.length*n);for(let e=0;e<a.length;e++){d.createFromFloat32Buffer(l.buffer,4*e).setFromOther(a.getValueRef(e)),l[4*e+3]=s?s.getFloat32Value(e):this.__geom.lineThickness;}this.__positionsTexture.bufferData(l,a.length,1);const r=new Float32Array(i.length);for(let e=0;e<i.length;e++){let t;t=e%2==0?e>0&&i[e]==i[e-1]:e<i.length-1&&i[e]==i[e+1],r[e]=(t?1:0)+2*i[e];}t.bindBuffer(t.ARRAY_BUFFER,this.__glattrbuffers.segmentIndices.buffer),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW);}else {this.__geom.getVertexAttributes();if(e&&e.indicesChanged){const e=this.__geom.getIndices();this.__numSegIndices!=e.length&&(t.deleteBuffer(this.__indexBuffer),this.__indexBuffer=t.createBuffer()),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW),this.__numSegIndices=e.length;}const s=a.numVertices!=this.__numVertices;for(const e in a.attrBuffers){const i=a.attrBuffers[e],n=this.__glattrbuffers[e];s&&(t.deleteBuffer(n.buffer),n.buffer=t.createBuffer()),t.bindBuffer(t.ARRAY_BUFFER,n.buffer),t.bufferData(t.ARRAY_BUFFER,i.values,t.STATIC_DRAW);}this.__numVertices=a.numVertices,this.__numSegIndices=i.length;}i instanceof Uint8Array&&(this.__indexDataType=this.__gl.UNSIGNED_BYTE),i instanceof Uint16Array&&(this.__indexDataType=this.__gl.UNSIGNED_SHORT),i instanceof Uint32Array&&(this.__indexDataType=this.__gl.UNSIGNED_INT);}bind(e){if(this.fatLines&&"LineThickness"in e.unifs){const t=this.__gl;let a=this.__shaderBindings[e.shaderkey];a||(a=Ya(t,e.attrs,this.__glattrbuffers,t.__quadIndexBuffer),this.__shaderBindings[e.shaderkey]=a),a.bind(e);{const a=e.unifs;a.positionsTexture&&(this.__positionsTexture.bindToUniform(e,a.positionsTexture),t.uniform1i(a.positionsTextureSize.location,this.__positionsTexture.width));}const i=e.unifs;return t.uniform1f(i.LineThickness.location,(this.__geom.lineThickness?this.__geom.lineThickness:1)*e.viewScale),!0}return super.bind(e)}drawPoints(){this.__gl.drawArrays(this.__gl.POINTS,0,this.__geom.numVertices());}draw(e){const t=this.__gl;this.fatLines?e.unifs.LineThickness&&t.drawElementsInstanced(t.TRIANGLES,6,t.UNSIGNED_SHORT,0,this.__drawCount):t.drawElements(this.__gl.LINES,this.__numSegIndices,this.__indexDataType,0);}drawInstanced(e){this.__gl.drawElementsInstanced(this.__gl.LINES,this.__numSegIndices,this.__indexDataType,0,e);}}class za extends Na{constructor(e,t){super(e,t),this.genBuffers();}genBuffers(){super.genBuffers();const e=this.__gl,t=this.__geom.genBuffers();for(const a in t.attrBuffers){const i=t.attrBuffers[a],s=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,i.values,e.STATIC_DRAW),this.__glattrbuffers[a]={buffer:s,dataType:i.dataType,normalized:i.normalized};}this.__numVerts=t.numVertices,this.__vboState=2;}bind(e){if(e.unifs.PointSize){const t=this.__gl;let a=this.__shaderBindings[e.shaderkey];if(!a){t.__quadVertexIdsBuffer||t.setupInstancedQuad();const i=Object.assign(this.__glattrbuffers,t.__quadattrbuffers);a=Ya(t,e.attrs,i,t.__quadIndexBuffer),this.__shaderBindings[e.shaderkey]=a;}return a.bind(e),!0}return super.bind(e)}draw(e){const t=this.__gl;e.unifs.PointSize?t.drawElementsInstanced(t.TRIANGLES,6,t.UNSIGNED_SHORT,0,this.__numVerts):t.drawArrays(t.POINTS,0,this.__numVerts);}drawInstanced(e){this.__gl.drawArraysInstanced(this.__gl.POINTS,0,this.__numVerts,e);}}const Ua={bool:Boolean,int:5,uint:4,float:6,ivec2:o,ivec3:d,ivec4:h,vec2:o,vec3:d,vec4:h,color:u,mat3:g,mat4:_,sampler2D:Te};const Ja=new class{constructor(){this.__shaderModules={};}hasShaderModule(e){return e in this.__shaderModules}setShaderModule(e,t){return this.parseShader(e,t)}getShaderModule(e){return this.__shaderModules[e]}getShaderModuleNames(){const e=[];for(const t in this.__shaderModules)e.push(t);return e}parseShader(e,t){const a=e=>{if(e.startsWith("..")){return i.substring(0,i.lastIndexOf("/"))+e.substring(2)}return e.startsWith(".")?i+e.substring(1):e.startsWith("/")?e.substring(1):e},i=(s(e),e.substring(0,e.lastIndexOf("/"))),n=t.split("\n"),l={glsl:" //starting:"+e+"\n",lines:n,numLines:0,includeMetaData:[],uniforms:{},attributes:{}},r=/\s+/;for(let t=0;t<n.length;t++){let i=n[t],o=i.trim();if(o.startsWith("//")||o.startsWith("*"))l.glsl=l.glsl+i+"\n",l.numLines++;else if(-1!=o.indexOf("//")&&(o=o.slice(0,o.indexOf("//")).trim()),o.startsWith("<%")||o.startsWith("</%")){const o=function(e){const t=(e=(e=e.startsWith("</%")?e.slice(3):e.slice(2)).endsWith("/>")?e.slice(0,e.length-2):e.slice(0,e.length-1)).split(r),a={tag:t.shift(),attributes:{}};for(const e of t){const t=e.split("=");a.attributes[t[0]]=t[1].replace(/['"]+/g,"");}return a}(n[t].trim());switch(o.tag){case"include":{const i=a(o.attributes.file);if(!this.hasShaderModule(i))throw new Error("Error while parsing :"+e+" \nShader module not found:"+i+"\n in:"+this.getShaderModuleNames());const n=this.getShaderModule(i);s(o.attributes.file);let r=n.glsl;r=r.substring(r.indexOf("\n")+1),l.glsl=l.glsl+" //including:"+o.attributes.file+"\n";const d={};for(const e in o.attributes){if("file"==e)continue;const t=o.attributes[e];r=r.replaceAll(e,t),d[e]=t;}l.glsl=l.glsl+r,l.includeMetaData.push({src:l.numLines,tgt:t,length:n.numLines,key:i}),l.glsl=l.glsl+" //continuing:"+e+"\n",l.numLines+=n.numLines+1;for(const e in n.attributes){let t=e;for(const e in d)t=t.replaceAll(e,d[e]);l.attributes[t]=n.attributes[e];}for(const e in n.uniforms){let t=e;for(const e in d)t=t.replaceAll(e,d[e]);l.uniforms[t]=n.uniforms[e];}break}default:console.warn("Error while parsing :"+e+" \nUnhandled line:"+i);continue}}else {const a=(t,a)=>{if(!(t[1]in Ua))throw new Error("Error while parsing :"+e+" \nType not recognized:"+t[1]);const s=t[2].slice(0,t[2].length-1);l.attributes[s]={type:Ua[t[1]],instanced:a},"color"==t[1]&&(t[1]="vec4",i=t.join(" "));};if(o.startsWith("struct")){let e="";if(-1!=o.indexOf("}"))e=o.substring(o.indexOf("{")+1,o.indexOf("}")-1);else for(t++;i+=n[t]+"\n",e+=i.trim(),t++,-1==e.indexOf("}"););const a=e.substring(e.indexOf("{")+1,e.indexOf("}")-1).split(";"),s=[];for(const e of a){if(0==e.length)continue;const t=e.trim().split(r);s.push({name:t[1],type:Ua[t[0]]});}const l=o.split(r);Ua[l[1]]=s;}if(o.startsWith("attribute")){a(o.split(r),!1);}if(o.startsWith("instancedattribute")){const e=o.split(r);a(e,!0),e[0]="attribute",i=e.join(" ");}else if(o.startsWith("uniform")){const t=o.split(r);let a=1;4==t.length&&(a=2);const s=t[a];if(!(s in Ua))throw new Error("Error while parsing :"+e+" \nType not recognized:"+t[1]);const n=t[a+1].slice(0,t[a+1].length-1);l.uniforms[n]=Ua[s],"struct"==l.uniforms[n]&&console.log(t),"color"==t[1]&&(t[1]="vec4",i=t.join(" "));}l.glsl=l.glsl+i+"\n",l.numLines++;}}return this.__shaderModules[e]=l,l}};class Pa extends D{constructor(e){if(super(),!e)throw new Error("gl context must be passed to shader constructor");this.__gl=e,this.__shaderStages={VERTEX_SHADER:{glsl:"",lines:0,uniforms:{},attributes:{}},FRAGMENT_SHADER:{glsl:"",lines:0,uniforms:{},attributes:{}}},this.__shaderProgramHdls={},this.__gltextures={},this.updated=new S,this.invisibleToGeomBuffer=!1;}static isTransparent(){return !1}static isOverlay(){return !1}__compileShaderStage(e,t,a,i){const s=this.__gl;if(i||(i=s.shaderopts),i){if(i.repl)for(const t in i.repl)e=e.replaceAll(t,i.repl[t]);i.defines&&(e=i.defines+e);}"webgl2"==s.name&&(e=e.replaceAll("attribute","in"),e="#version 300 es\n"+(e=(e="vertexShader"==a?e.replaceAll("varying","out"):e.replaceAll("varying","in")).replaceAll("texture2D","texture")));const l=s.createShader(t);if(s.shaderSource(l,e),s.compileShader(l),!s.getShaderParameter(l,s.COMPILE_STATUS)){console.log("Errors in :"+this.constructor.name);const t=s.getShaderInfoLog(l).split("\n"),i={};for(let e in t){if(t[e].startsWith("'")){t[e-1]=t[e-1]+t[e],delete t[e],e--;continue}const a=t[e].split(":");if(a.length>=2){const s=parseInt(a[2]);isNaN(s)||(i[s]?i[s].push(t[e]):i[s]=[t[e]]);}}const n=[],r=e.split("\n");for(let e=0;e<r.length;e++)if(n.push((e+1+":").lpad(" ",3)+r[e]),e+1 in i){const t=i[e+1];for(const e of t)n.push(e),n.push("-".lpad("-",e.length));}throw new Error("An error occurred compiling the shader \n=================\n"+this.constructor.name+"."+a+": \n\n"+t.join("\n")+"\n"+n.join("\n"))}return l}__createProgram(e){const t=this.__gl;this.__shaderCompilationAttempted=!0;const a=t.createProgram(),i=this.__shaderStages.VERTEX_SHADER.glsl,s={};if(null!=i){const n=this.__compileShaderStage(i,t.VERTEX_SHADER,"vertexShader",e);if(!n)return !1;t.attachShader(a,n),s[t.VERTEX_SHADER]=n;}const n=this.__shaderStages.FRAGMENT_SHADER.glsl;if(null!=n){const i=Object.assign({},t.shaderopts,e);i.frag&&(i.defines=i.frag.defines+i.defines);const l=this.__compileShaderStage(n,t.FRAGMENT_SHADER,"fragmentShader",i);if(!l)return !1;t.attachShader(a,l),s[t.FRAGMENT_SHADER]=l;}if(t.linkProgram(a),!t.getProgramParameter(a,t.LINK_STATUS)){const e=t.getProgramInfoLog(a);if(e.includes("D3D shader compilation failed")){const e=t.getExtension("WEBGL_debug_shaders");if(e){const a=e.getTranslatedShaderSource(s[t.VERTEX_SHADER]);console.log(a);}}throw console.log("vertexShaderGLSL:"+i),console.log("fragmentShaderGLSL:"+n),new Error("Unable to link the shader program:"+this.constructor.name+"\n==================\n"+e)}const l=this.__extractAttributeAndUniformLocations(a,e);return l.shaderProgramHdl=a,l}__extractAttributeAndUniformLocations(e,t){const a=this.__gl,i=this.getAttributes(),s={attrs:{},unifs:{}};for(const t in i){const n=a.getAttribLocation(e,t);if(null==n){console.warn("Shader attribute not found:"+t);continue}const l=i[t];s.attrs[t]={name:t,location:n,type:l.type,instanced:l.instanced};}const n=this.getUniforms();for(let i in n){const l=n[i];if(l instanceof Array)for(const t of l){const n=i+"."+t.name,l=a.getUniformLocation(e,n);null!=l&&(s.unifs[n]={name:n,location:l,type:t.type});}if(t&&t.repl)for(const e in t.repl)i=i.replace(e,t.repl[e]);const r=a.getUniformLocation(e,i);null!=r&&(s.unifs[i]={name:i,location:r,type:l});}return s}getAttributes(){const e={};for(const t in this.__shaderStages){const a=this.__shaderStages[t];for(const t in a.attributes)e[t]=a.attributes[t];}return e}getUniforms(){const e={};for(const t in this.__shaderStages){const a=this.__shaderStages[t];for(const t in a.uniforms)e[t]=a.uniforms[t];}return e}finalize(){}compileForTarget(e,t){e||(e=this.constructor.name);let a=this.__shaderProgramHdls[e];return a||!1!==a&&(a=this.__createProgram(t),this.__shaderProgramHdls[e]=a),a}compile(){this.compileForTarget();}bind(e,t){const a=this.__gl;if(e.glshader!=this){const i=this.compileForTarget(t,e.shaderopts);if(!1===i)return console.warn(this.constructor.name+" is not compiled for "+t),!1;const s=i.shaderProgramHdl;a.useProgram(s),e.shaderkey=this.constructor.name,e.glshader=this,e.boundTextures=0,e.boundLightmap=void 0,e.glgeom=void 0,e.unifs=i.unifs,e.attrs=i.attrs,e.bindRendererUnifs&&e.bindRendererUnifs(i.unifs);}return e.supportsInstancing=!0,!0}unbind(e){return !0}static getParamDeclarations(){return []}static getGeomDataShaderName(){}static getSelectedShaderName(){}destroy(){const e=this.__gl;for(const t in this.__shaderProgramHdls){const a=this.__shaderProgramHdls[t];e.deleteProgram(a.shaderProgramHdl);}this.__shaderProgramHdls={};}}Ja.setShaderModule("utils/quadVertexFromID.glsl","\n\nattribute float vertexIDs;\n\nvec2 getQuadVertexPositionFromID(){\n    int vertexID = int(vertexIDs);\n    if(vertexID == 0)\n        return vec2(-0.5, -0.5);\n    else if(vertexID == 1)\n        return vec2(0.5, -0.5);\n    else if(vertexID == 2)\n        return vec2(-0.5, 0.5);\n    else if(vertexID == 3)\n        return vec2(0.5, 0.5);\n    return vec2(0,0);\n}\n"),Ja.setShaderModule("utils/unpackHDR.glsl","\n\nvec3 decodeHDR(const in vec3 ldrPixel, const in float cdmAlpha) {\n    float avg = (cdmAlpha * 16.0 - 8.0);\n    float scl = 1.0;\n    vec3 color;\n    color.x = (tan((ldrPixel.x-0.5)*1.5)/scl)+avg;\n    color.y = (tan((ldrPixel.y-0.5)*1.5)/scl)+avg;\n    color.z = (tan((ldrPixel.z-0.5)*1.5)/scl)+avg;\n\n    // convert from logarithmic curve to linear curve.\n    // subtract the epsilon that was added during encoding.\n    const float eps = 0.001;\n    color.x = pow(10.0, color.x) - eps;\n    color.y = pow(10.0, color.y) - eps;\n    color.z = pow(10.0, color.z) - eps;\n    return color;\n}\n\nvec3 decodeHDR(sampler2D ldrSampler, sampler2D cdmSampler, vec2 texCoord) {\n#ifdef ENABLE_ES3\n    float cdm = texture2D(cdmSampler, texCoord).r;\n#else\n    float cdm = texture2D(cdmSampler, texCoord).a;\n#endif\n    return decodeHDR(texture2D(ldrSampler, texCoord).rgb, cdm);\n}\n\n");class Ea extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("UnpackHDRShader.vertexShader",'\nprecision highp float;\n\n<%include file="utils/quadVertexFromID.glsl"/>\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    vec2 position = getQuadVertexPositionFromID();\n    v_texCoord = position+0.5;\n    gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("UnpackHDRShader.fragmentShader",'\nprecision highp float;\n\nvarying vec2 v_texCoord;\nuniform sampler2D ldrSampler;\nuniform sampler2D cdmSampler;\nuniform float exposure;\nuniform vec4 tint;\n\n<%include file="utils/unpackHDR.glsl"/>\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    fragColor = vec4(decodeHDR(ldrSampler, cdmSampler, v_texCoord) * tint.rgb * exposure, 1.0);\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n\n');}}class Ha{constructor(e,a,i=!1){!t.isIOSDevice||"FLOAT"!=a.getType()&&"HALF_FLOAT"!=a.getType()||console.error("IOS devices are unable to render to float textures."),this.__gl=e,this.__colorTexture=a,this.__createDepthTexture=i,this.__clearColor=[0,0,0,0],this.__depthTexture=void 0,this.setup=this.setup.bind(this),this.resize=this.resize.bind(this),this.__colorTexture&&this.__colorTexture.resized.connect(this.resize),this.setup();}setClearColor(e){this.__clearColor=e;}getWidth(){return this.__colorTexture.width}getHeight(){return this.__colorTexture.height}getSize(){return [this.__colorTexture.width,this.__colorTexture.height]}getColorTexture(){return this.__colorTexture}getDepthTextureGL(){return this.__depthTexture}get width(){return this.__colorTexture.width}get height(){return this.__colorTexture.height}get size(){return [this.__colorTexture.width,this.__colorTexture.height]}get colorTexture(){return this.__colorTexture}setColorTexture(e){this.__colorTexture=e,gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,this.__colorTexture.glTex,0);}get depthTextureGL(){return this.__depthTexture}setup(){const e=this.__gl;if(this.__fbo=e.createFramebuffer(),"webgl2"==e.name?e.bindFramebuffer(e.DRAW_FRAMEBUFFER,this.__fbo):e.bindFramebuffer(e.FRAMEBUFFER,this.__fbo),this.__colorTexture&&("webgl2"==e.name?e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.__colorTexture.glTex,0):e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.__colorTexture.glTex,0)),this.__createDepthTexture)if("webgl2"==e.name||e.__ext_WEBGL_depth_texture)e.activeTexture(e.TEXTURE0),this.__depthTexture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.__depthTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),"webgl2"==e.name?(e.texImage2D(e.TEXTURE_2D,0,e.DEPTH_COMPONENT24,this.width,this.height,0,e.DEPTH_COMPONENT,e.UNSIGNED_INT,null),e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,this.__depthTexture,0)):(e.texImage2D(e.TEXTURE_2D,0,e.DEPTH_COMPONENT,this.width,this.height,0,e.DEPTH_COMPONENT,e.UNSIGNED_INT,null),e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,this.__depthTexture,0));else {const t=e.createRenderbuffer();e.bindRenderbuffer(e.RENDERBUFFER,t),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,t);}this.__checkFramebuffer(),"webgl2"==e.name?e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null):e.bindFramebuffer(e.FRAMEBUFFER,null);}resize(){const e=this.__gl;"webgl2"==e.name?e.bindFramebuffer(e.DRAW_FRAMEBUFFER,this.__fbo):e.bindFramebuffer(e.FRAMEBUFFER,this.__fbo),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.__colorTexture.glTex,0),this.__depthTexture&&(e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.__depthTexture),"webgl2"==e.name?e.texImage2D(e.TEXTURE_2D,0,e.DEPTH_COMPONENT24,this.width,this.height,0,e.DEPTH_COMPONENT,e.UNSIGNED_INT,null):e.texImage2D(e.TEXTURE_2D,0,e.DEPTH_COMPONENT,this.width,this.height,0,e.DEPTH_COMPONENT,e.UNSIGNED_INT,null)),this.__checkFramebuffer();}__checkFramebuffer(){const e=this.__gl;let t;if(t="webgl2"==e.name?e.checkFramebufferStatus(e.DRAW_FRAMEBUFFER):e.checkFramebufferStatus(e.FRAMEBUFFER),t!==e.FRAMEBUFFER_COMPLETE)switch(e.bindTexture(e.TEXTURE_2D,null),"webgl2"==e.name?e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null):e.bindFramebuffer(e.FRAMEBUFFER,null),console.warn("Error creating Fbo width:",this.width,", height:",this.height," Texture Type:",this.__colorTexture.getType()),t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error("There is no attachment.");case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("Height and width of the attachment are not the same.");case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");case 36061:throw new Error("The framebuffer is unsupported");default:throw new Error("Incomplete Frambuffer")}}bindForWriting(e){e&&(this.__prevBoundFbo=e.boundRendertarget,e.boundRendertarget=this.__fbo);const t=this.__gl;"webgl2"==t.name?t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.__fbo):t.bindFramebuffer(t.FRAMEBUFFER,this.__fbo),t.viewport(0,0,this.width,this.height);}unbindForWriting(e){e&&(e.boundRendertarget=this.__prevBoundFbo);const t=this.__gl;"webgl2"==t.name?t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.__prevBoundFbo):t.bindFramebuffer(t.FRAMEBUFFER,this.__prevBoundFbo);}bind(e){this.bindForWriting(e);}unbind(e){this.unbindForWriting(e);}bindForReading(){const e=this.__gl;"webgl2"==e.name?e.bindFramebuffer(e.READ_FRAMEBUFFER,this.__fbo):e.bindFramebuffer(e.FRAMEBUFFER,this.__fbo);}unbindForReading(){const e=this.__gl;"webgl2"==e.name?e.bindFramebuffer(e.READ_FRAMEBUFFER,null):e.bindFramebuffer(e.FRAMEBUFFER,null);}clear(){const e=this.__gl;e.colorMask(!0,!0,!0,!0),e.clearColor(...this.__clearColor),this.__createDepthTexture?e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT):e.clear(e.COLOR_BUFFER_BIT);}bindAndClear(e){this.bind(e),this.clear(e);}unbind(){const e=this.__gl;e.bindFramebuffer(e.FRAMEBUFFER,null);}destroy(){const e=this.__gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.__fbo),this.__fbo=null,this.__colorTexture.resized.disconnect(this.resize);}}class ka extends Fa{constructor(e,t){super(e),this.__hdrImage=t,this.__hdrImage.setMetadata("gltexture",this),this.__hdrImage.updated.connect(()=>{this.__unpackHDRImage(this.__hdrImage.getParams());}),this.__hdrImage.isLoaded()?this.__unpackHDRImage(this.__hdrImage.getParams()):this.__hdrImage.loaded.connect(()=>{this.__unpackHDRImage(this.__hdrImage.getParams());});}__unpackHDRImage(e){const t=this.__gl,a=e.data.ldr,i=e.data.cdm;if(this.__fbo)this.__srcLDRTex.bufferData(a),this.__srcCDMTex.bufferData(i);else {this.configure({format:"RGBA",type:"FLOAT",width:a.width,height:a.height,filter:"LINEAR",wrap:"CLAMP_TO_EDGE"}),this.__fbo=new Ha(t,this),this.__fbo.setClearColor([0,0,0,0]),this.__srcLDRTex=new Fa(t,{format:"RGB",type:"UNSIGNED_BYTE",width:a.width,height:a.height,filter:"NEAREST",mipMapped:!1,wrap:"CLAMP_TO_EDGE",data:a}),this.__srcCDMTex=new Fa(t,{format:"webgl2"==t.name?"RED":"ALPHA",type:"UNSIGNED_BYTE",width:a.width,height:a.height,filter:"NEAREST",mipMapped:!1,wrap:"CLAMP_TO_EDGE",data:i}),this.__unpackHDRShader=new Ea(t);const e=this.__unpackHDRShader.compileForTarget("GLHDRImage");this.__shaderBinding=Ya(t,e.attrs,t.__quadattrbuffers,t.__quadIndexBuffer);}this.__fbo.bindAndClear();const s={};this.__unpackHDRShader.bind(s,"GLHDRImage"),this.__shaderBinding.bind(s);const n=s.unifs;this.__srcLDRTex.bindToUniform(s,n.ldrSampler),this.__srcCDMTex.bindToUniform(s,n.cdmSampler),t.uniform1f(n.exposure.location,1),t.uniform4fv(n.tint.location,this.__hdrImage.getHDRTint().asArray()),t.drawQuad(),this.__fbo.unbind(),this.updated.emit();}bindToUniform(e,t,a){return super.bindToUniform(e,t,a)}destroy(){super.destroy(),this.__fbo&&(this.__fbo.destroy(),this.__srcLDRTex.destroy(),this.__srcCDMTex.destroy()),this.__unpackHDRShader&&this.__unpackHDRShader.destroy(),this.__shaderBinding&&this.__shaderBinding.destroy(),this.__hdrImage.loaded.disconnectScope(this),this.__hdrImage.updated.disconnectScope(this);}}Ja.setShaderModule("GLSLUtils.glsl","\n\n\nint ftoi(float val){\n    return int(floor(val + 0.5));\n}\n\n#ifdef ENABLE_ES3\n\nint imod(int x, int y) {\n    return x % y;\n}\n\nvoid setFlag(inout int flags, int flag) {\n    flags |= flag;\n}\n\nvoid clearFlag(inout int flags, int flag) {\n    flags &= ~flag;\n}\n\nbool testFlag(int flags, int flag) {\n    return (flags & flag) != 0;\n}\n\n// private function: Mangle me...\nivec2 _pixelIndexToUV(int index, int textureWidth){\n    return ivec2(index % textureWidth, index / textureWidth);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureWidth, int index) {\n    return texelFetch(texture, _pixelIndexToUV(index, textureWidth), 0);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n    return texelFetch(texture, texCoord, 0);\n}\n\n#else\n\n// TODO: integrate: https://gist.github.com/mattatz/70b96f8c57d4ba1ad2cd\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\n\nfloat round(float val){\n    return floor(val + 0.4);\n}\n\nint imod(int x, int y) {\n    return x-y*(x/y);\n}\n\nvoid setFlag(inout int flags, int flag) {\n    flags += flag;\n}\nvoid clearFlag(inout int flags, int flag) {\n    flags -= flag;\n}\n\nbool testFlag(int flags, int flag) {\n    return imod(flags / flag, 2) != 0;\n}\n\n// private function: Mangle me...\nvec2 _pixelIndexToUV(int index, int textureSize){\n    float flTexSize = float(textureSize);\n    float x = (float(imod(index, textureSize))+0.5)/flTexSize;\n    float y = (floor(float(index / textureSize))+0.5)/flTexSize;\n    return vec2(x, y);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureSize, int index) {\n    vec2 texCoord = _pixelIndexToUV(index, textureSize);\n    return texture2D(texture, texCoord);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n    vec2 ftextureSize = vec2(textureSize);\n    return texture2D(texture, (vec2(texCoord) + 0.5) / ftextureSize);\n}\n\n\n#endif\n\nint uvToPixelIndex(vec2 uv, int textureSize){\n    return int(uv.x * float(textureSize)) + (int(floor(uv.y * float(textureSize))) * textureSize);\n}\n\n\n\n"),Ja.setShaderModule("utils/ImageStream.glsl","\n\n// Stream Desc looks like the following\n// x : atlas Width in images\n// y : atlas height in images\n// z : image Width\n// w : image Height\n\nvec2 calcFrameImageTexCoords(vec2 texCoord, int index, in vec4 streamDesc){\n\tfloat index_x = floor(mod(float(index), streamDesc.x));\n\tfloat index_y = floor(float(index) / streamDesc.x);\n    return vec2( \n    \t(index_x + texCoord.x) / streamDesc.x, \n    \t(index_y + texCoord.y) / streamDesc.y\n    \t);\n}\n\nvec4 sampleStreamFrame(vec2 texCoord, int index, in sampler2D streamImage, in vec4 streamDesc){\n    return texture2D(streamImage, calcFrameImageTexCoords(texCoord, index, streamDesc));\n}\n\n");class Ba{constructor(e,t){this.__gl=e,this.__streamImage=t,this.ready=new S(!0),this.updated=new S,this.resized=new S,this.__descParam=this.__streamImage.getParameter("StreamAtlasDesc"),this.__indexParam=this.__streamImage.getParameter("StreamAtlasIndex"),this.__indexParam.valueChanged.connect(this.updated.emit);const a=()=>{const t=this.__streamImage.getParams();t.data.__atlasTexture||(t.data.__atlasTexture=new Fa(e,t)),this.__atlasTexture=t.data.__atlasTexture,this.__atlasTexture.textureType=2,this.__atlasTexture.textureDesc=this.__descParam.getValue().asArray();};this.__streamImage.isLoaded()?a():this.__streamImage.loaded.connect(()=>{a();});}preBind(e,t){const a=this.__atlasTexture.preBind(e,t);return a.textureDescUnif=t[e.name+"Desc"],a.textureIndexUnif=t[e.name+"Index"],a}bindToUniform(e,t,a){return !!this.__atlasTexture.bindToUniform(e,t,a)&&(a&&a.textureIndexUnif&&this.__gl.uniform1i(a.textureIndexUnif.location,this.__indexParam.getValue()),!0)}}class Da{constructor(e,t,a,i){switch(this.__unif=i,i.type){case Boolean:this.uniformXX=e.uniform1i.bind(e);break;case 4:"webgl2"==e.name?this.uniformXX=e.uniform1ui.bind(e):this.uniformXX=e.uniform1i.bind(e);break;case 5:this.uniformXX=e.uniform1i.bind(e);break;case 6:this.uniformXX=e.uniform1f.bind(e);}this.__val=a.getValue(),a.valueChanged.connect(()=>{this.__val=a.getValue(),t.updated.emit();});}bind(e){this.uniformXX(this.__unif.location,this.__val);}unbind(){}destroy(){}}class Oa{constructor(e,t,a,i){switch(this.__unif=i,i.type){case o:this.uniformXX=e.uniform2fv.bind(e);break;case d:this.uniformXX=e.uniform3fv.bind(e);break;case h:this.uniformXX=e.uniform4fv.bind(e);}this.__vals=a.getValue().asArray(),a.valueChanged.connect(()=>{this.__vals=a.getValue().asArray(),t.updated.emit();});}bind(e){this.uniformXX(this.__unif.location,this.__vals);}unbind(){}destroy(){}}class Qa{constructor(e,t,a,i){switch(this.__unif=i,i.type){case Mat3:this.uniformMatrixXXX=e.uniformMatrix3fv.bind(e);break;case _:this.uniformMatrixXXX=e.uniformMatrix4fv.bind(e);}this.__vals=a.getValue().asArray(),a.valueChanged.connect(()=>{this.__val=a.getValue().asArray(),t.updated.emit();});}bind(e){this.uniformMatrixXXX(this.__unif.location,!1,this.__val);}unbind(){}destroy(){}}class Aa{constructor(e,t,a,i,s){this.__gl=e,this.__unif=i,this.__textureUnif=s[i.name+"Tex"],this.__textureTypeUnif=s[i.name+"TexType"],this.__vals=[0,0,0,0],this.bind=this.bindValue;const n=e=>{let a=e.getMetadata("gltexture");a||(a="FLOAT"===e.type?new ka(this.__gl,e):e.isStreamAtlas()?new Ba(this.__gl,e):new Fa(this.__gl,e)),this.texBinding=a.preBind(this.__textureUnif,s),a.updated.connect(()=>{t.updated.emit();}),this.gltexture=a,this.gltexture.addRef(this),this.textureType=1,this.bind=this.bindTexture,t.updated.emit();};let l,r;const o=()=>{n(l);},d=e=>{e.isLoaded()?n(e):e.loaded.connect(o),l=e;},h=()=>{l.getMetadata("gltexture").removeRef(this),this.texBinding=null,this.gltexture=null,this.textureType=null,this.bind=this.bindValue,r&&l.loaded.disconnectId(r),l=null,r=null,t.updated.emit();},c=()=>{const e=a.getValue(!1);if(this.__vals=e.asArray(),this.__textureUnif){let e;a.getImage&&(e=a.getImage()),e&&e!=l?d(e):!e&&l&&h();}t.updated.emit();};c(),a.textureConnected&&a.textureConnected.connect(()=>{d(a.getImage());}),a.valueChanged.connect(c),this.uniform1i=e.uniform1i.bind(e),this.uniform4fv=e.uniform4fv.bind(e);}bindValue(e){this.uniform4fv(this.__unif.location,this.__vals),this.__textureTypeUnif&&this.uniform1i(this.__textureTypeUnif.location,0);}bindTexture(e){this.gltexture.bindToUniform(e,this.__textureUnif,this.texBinding);}}const ja={};class qa{constructor(e,t,a,i){this.__uniformBindings=[];const s=s=>{const n=s.getName(),l=a[n];if(null!=l)switch(l.type){case Boolean:case 4:case 5:case 6:this.__uniformBindings.push(new Da(e,t,s,l));break;case o:case d:case h:this.__uniformBindings.push(new Oa(e,t,s,l));break;case u:this.__uniformBindings.push(new Aa(e,t,s,l,a));break;case _:this.__uniformBindings.push(new Qa(e,t,s,l));break;default:return void console.warn("Param :"+n+" has unhandled data type:"+l.type)}else if(i){const e=t.getMaterial().getShaderName();ja[e]||(ja[e]={}),ja[e][n]||(console.warn("Material:"+t.getMaterial().getName(),"with Shader ",e,"Param has no unif",n),ja[e][n]=!0);}},n=t.getMaterial().getParameters();for(const e of n)s(e);}bind(e){for(const t of this.__uniformBindings)t.bind(e);return !0}unbind(){for(const e of this.__uniformBindings)e.unbind(renderstate);}destroy(){for(const e of this.__uniformBindings)e.destroy(renderstate);}}class $a{constructor(e,t,a){this.__gl=e,this.__material=t,this.__glshader=a,this.updated=new S,this.__shaderBindings={};}getMaterial(){return this.__material}getGLShader(){return this.__glshader}generateShaderBinding(){const e=this.__material.getParameters();for(const t of e)bindParam(gl,t);}bind(e,t){this.__boundTexturesBeforeMaterial=e.boundTextures;let a=this.__shaderBindings[e.shaderkey];if(!a){const i=this.__gl;a=new qa(i,this,e.unifs,t),this.__shaderBindings[e.shaderkey]=a;}return a.bind(e)}unbind(e){e.boundTextures=this.__boundTexturesBeforeMaterial;}}class ei{constructor(e,t){this.resized=new S,this.updated=new S,this.__gl=e,this.textureTargets=[],this.depthTexture=null,t&&this.configure(t);}configure(e){const t=this.__gl,a=function(e,t){if(!t.width||!t.height)throw new Error("Invalid texture params");const a=e.getParameter(e.MAX_TEXTURE_SIZE);if(t.width<=0||t.width>a||t.height<=0||t.height>a)throw new Error("GLTextureParams: Invalid texture size. width:"+t.width+" height:"+t.height+" maxSize:"+a);const i={width:t.width,height:t.height},s=(a,s)=>{a in t?i[a]=isNaN(t[a])?e[t[a]]:t[a]:s&&(i[a]=s);};if(s("format"),s("internalFormat",i.format),s("type",e.UNSIGNED_BYTE),s("minFilter",e.LINEAR),s("magFilter",e.LINEAR),s("wrapS",e.CLAMP_TO_EDGE),s("wrapT",e.CLAMP_TO_EDGE),s("flipY",!1),s("mipMapped",!1),s("depthFormat"),s("depthType"),i.format==e.FLOAT)if("webgl2"==e.name)i.filter!=e.LINEAR||e.__ext_float_linear||(console.warn("Floating point texture filtering not supported on result device"),i.filter=e.NEAREST);else if(e.__ext_float)i.filter!=e.LINEAR||e.__ext_float_linear||(console.warn("Floating point texture filtering not supported on result device"),i.filter=e.NEAREST);else {if(!e.__ext_half_float)throw new Error("OES_texture_half_float is not available");i.format=e.HALF_FLOAT,i.filter!=e.LINEAR||e.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on result device"),i.filter=e.NEAREST);}else if(i.format==e.HALF_FLOAT)if("webgl2"==e.name);else {if(!e.__ext_half_float)throw new Error("OES_texture_half_float is not available");if(i.filter!=e.LINEAR||e.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on result device"),i.filter=e.NEAREST),i.channels==e.RGB)throw new Error("OES_texture_half_float onlysupports RGBA textures")}else if("sRGB"==i.format&&!e.__ext_sRGB)throw new Error("EXT_sRGB is not available");return null!=i.format&&"webgl2"==e.name&&i.internalFormat==i.format&&(i.type==e.FLOAT?i.format==e.RED||i.format==e.RED?i.internalFormat=e.R32F:i.format==e.RG?i.internalFormat=e.RG32F:i.format==e.RGBA&&(i.internalFormat=e.RGBA32F):i.type==e.HALF_FLOAT?i.format==e.RED?i.internalFormat=e.R16F:i.format==e.RGB?i.internalFormat=e.RGB16F:i.format==e.RGBA&&(i.internalFormat=e.RGBA16F):i.type==e.UNSIGNED_BYTE&&(i.format==e.RED&&(i.internalFormat=e.R8),i.format==e.RGB?i.internalFormat=e.RGB8:i.format==e.RGBA&&(i.internalFormat=e.RGBA8))),null!=i.depthFormat&&("webgl2"==e.name?i.depthType==e.UNSIGNED_SHORT?i.depthInternalFormat=e.DEPTH_COMPONENT16:i.depthType==e.UNSIGNED_INT&&(i.depthInternalFormat=e.UNSIGNED_INT):i.depthInternalFormat=i.depthFormat),i}(t,e);this.textureTargets.forEach(e=>{t.deleteTexture(e);}),this.textureTargets=[],this.depthTexture&&(t.deleteTexture(this.depthTexture),this.depthTexture=null),this.frameBuffer&&t.deleteFramebuffer(this.frameBuffer),this.type=a.type,this.format=a.format,this.internalFormat=a.internalFormat,this.filter=a.filter,this.wrap=a.wrap,this.flipY=a.flipY,this.width=a.width,this.height=a.height,this.clearColor=new u(0,0,0,0),this.colorMask=[!0,!0,!0,!0],this.textureType=1,this.textureDesc=[this.width,this.height,0,0];const i=null!=e.numColorChannels?e.numColorChannels:null!=a.format?1:0;for(let e=0;e<i;e++){t.activeTexture(t.TEXTURE0+1);const e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,a.wrapS),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,a.wrapT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,a.minFilter),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,a.magFilter),t.texImage2D(t.TEXTURE_2D,0,this.internalFormat,a.width,a.height,0,this.format,this.type,null),this.textureTargets.push(e);}if(a.depthFormat){if("webgl"==t.name&&!t.__ext_WEBGL_depth_texture)throw new Error("Depth textures not support on this device");t.activeTexture(t.TEXTURE0),this.depthTexture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.depthTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,a.wrapS),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,a.wrapT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,a.minFilter),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,a.magFilter),t.texImage2D(t.TEXTURE_2D,0,a.depthInternalFormat,a.width,a.height,0,a.depthFormat,a.depthType,null);}if(this.frameBuffer=t.createFramebuffer(),"webgl2"==t.name?t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.frameBuffer):t.bindFramebuffer(t.FRAMEBUFFER,this.frameBuffer),this.textureTargets.length>0){if(this.textureTargets.length>1&&"webgl"==t.name&&!t.drawBuffers){t.__ext_draw_buffers=t.getExtension("WEBGL_draw_buffers"),t.drawBuffers=t.__ext_draw_buffers.drawBuffersWEBGL.bind(t.__ext_draw_buffers);for(let e=1;e<14;e++)t["COLOR_ATTACHMENT"+e]=t.__ext_draw_buffers["COLOR_ATTACHMENT"+e+"_WEBGL"];t.MAX_COLOR_ATTACHMENTS=t.__ext_draw_buffers.MAX_COLOR_ATTACHMENTS_WEBGL,t.MAX_DRAW_BUFFERS=t.__ext_draw_buffers.MAX_DRAW_BUFFERS_WEBGL;}const e=[];for(let a=0;a<this.textureTargets.length;a++)t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+a,t.TEXTURE_2D,this.textureTargets[a],0),e.push(t.COLOR_ATTACHMENT0+a);this.textureTargets.length>1&&t.drawBuffers(e);}this.depthTexture&&t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,this.depthTexture,0);const s=t.checkFramebufferStatus(t.DRAW_FRAMEBUFFER);if(s!=t.FRAMEBUFFER_COMPLETE)switch(s){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error("There is no attachment.");case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("Height and width of the attachment are not the same.");case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");case 36061:throw new Error("The framebuffer is unsupported");default:throw new Error("Incomplete Frambuffer")}this.unbind();}bindForWriting(e,t=!1){e&&(this.__prevBoundFbo=e.boundRendertarget,e.boundRendertarget=this.frameBuffer);const a=this.__gl;"webgl2"==a.name?a.bindFramebuffer(a.DRAW_FRAMEBUFFER,this.frameBuffer):a.bindFramebuffer(a.FRAMEBUFFER,this.frameBuffer),a.viewport(0,0,this.width,this.height),t&&this.clear();}unbindForWriting(e){e&&(e.boundRendertarget=this.__prevBoundFbo);const t=this.__gl;"webgl2"==t.name?t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.__prevBoundFbo):t.bindFramebuffer(t.FRAMEBUFFER,this.__prevBoundFbo);}clear(e=!0){const t=this.__gl;t.colorMask(...this.colorMask),t.clearColor(...this.clearColor.asArray());let a=0;this.textureTargets.length>0&&(a|=t.COLOR_BUFFER_BIT),this.depthTexture&&(a|=t.DEPTH_BUFFER_BIT),t.clear(a);}bindForReading(){const e=this.__gl;"webgl2"==e.name?e.bindFramebuffer(e.READ_FRAMEBUFFER,this.frameBuffer):e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer);}unbindForReading(){const e=this.__gl;"webgl2"==e.name?e.bindFramebuffer(e.READ_FRAMEBUFFER,null):e.bindFramebuffer(e.FRAMEBUFFER,null);}bindColorTexture(e,t,a=0){const i=this.__gl,s=e.boundTextures++;return i.uniform1i(t.location,s),i.activeTexture(i.TEXTURE0+s),i.bindTexture(i.TEXTURE_2D,this.textureTargets[a]),!0}bindDepthTexture(e,t){const a=this.__gl,i=e.boundTextures++;return a.uniform1i(t.location,i),a.activeTexture(a.TEXTURE0+i),a.bindTexture(a.TEXTURE_2D,this.depthTexture),!0}unbind(){const e=this.__gl;e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null);}resize(e,t,a=!1){}bindToUniform(e,t,a){const i=e.boundTextures++,s=this.__gl.TEXTURE0+i,n=this.__gl;return n.activeTexture(s),n.bindTexture(n.TEXTURE_2D,this.textureTargets[0]),n.uniform1i(t.location,i),a&&(a.textureTypeUnif&&n.uniform1i(a.textureTypeUnif.location,this.textureType),a.textureDescUnif&&this.__gl.uniform4fv(a.textureDescUnif.location,this.textureDesc)),!0}destroy(){const e=this.__gl;this.textureTargets.forEach(t=>{e.deleteTexture(t);}),this.textureTargets=[],this.depthTexture&&(e.deleteTexture(this.depthTexture),this.depthTexture=null),this.frameBuffer&&e.deleteFramebuffer(this.frameBuffer);}}const ti=new Uint32Array(1);function ai(e){return ti[0]=e,ti[0]=(ti[0]<<16|ti[0]>>16)>>>0,ti[0]=(1431655765&ti[0])<<1|(2863311530&ti[0])>>>1>>>0,ti[0]=(858993459&ti[0])<<2|(3435973836&ti[0])>>>2>>>0,ti[0]=(252645135&ti[0])<<4|(4042322160&ti[0])>>>4>>>0,ti[0]=(16711935&ti[0])<<8|(4278255360&ti[0])>>>8>>>0,2.3283064365386963e-10*ti[0]}function ii(e,t){return [e/t,ai(e)]}Ja.setShaderModule("utils/imageAtlas.glsl","\n\n// Note: On mobile, I can't seem to pass around a stuct containing sampler2D.\n// I have to unpack the struct and pass its members. :(\n// struct ImageAtlas {\n//     sampler2D layout;\n//     sampler2D image;\n//     vec4 desc;\n// };\n\n\n\nvec4 getSubImageLayout(int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    return fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n}\n\nvec2 calcSubImageTexCoords(vec2 texCoord, int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    // The following line is a hack to fix artifacts in our PBR lighting\n    // We were seeing loads of lighting garbage on some sufaces that were orthogonal\n    // to the world. The UV coordinates would have been landing right on the edges\n    // of our subimages and were often sampling outside the image. This couuld\n    // have been because of filtering, or an error in the uv coords. \n    texCoord = clamp(texCoord, vec2(0.01, 0.01), vec2(0.99, 0.99));\n    vec2 subimageTexel = texCoord * layoutData.zw;\n    // subimageTexel = clamp(subimageTexel, vec2(0.0, 0.0), vec2(1.0, 1.0));\n    return subimageTexel + layoutData.xy;\n}\n\nvec4 sampleSubImage(vec2 texCoord, int index, in sampler2D atlasLayout, in sampler2D atlasImage, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    vec2 atlasCoords = calcSubImageTexCoords(texCoord, index, atlasLayout, atlasDesc);\n    return texture2D(atlasImage, atlasCoords);\n}\n\n");class si extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("AtlasLayoutShader.vertexShader",'\n\nprecision highp float;\n\n<%include file="utils/quadVertexFromID.glsl"/>\n\nuniform vec2 pos;\nuniform vec2 size;\nuniform vec2 srctextureDim;\nconst int border = 2;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * size * 2.0), 0.0, 1.0);\n\n  vec2 borderVec2 = vec2(float(border), float(border));\n  v_texCoord *= (srctextureDim + (borderVec2 * 2.0)) / srctextureDim;\n  v_texCoord -= borderVec2 / srctextureDim;\n}\n\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("AtlasLayoutShader.fragmentShader","\nprecision highp float;\n\nuniform sampler2D srctexture;\nuniform vec2 srctextureDim;\nuniform bool alphaFromLuminance;\nuniform bool invert;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\nfloat luminanceFromRGB(vec3 rgb) {\n  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n  vec2 pixelCoord = v_texCoord*srctextureDim;\n  vec2 uv = v_texCoord;\n\n  // Wrap X coords\n  if(pixelCoord.x < 0.0){\n    uv.x += 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n  else if(pixelCoord.x > srctextureDim.x){\n    uv.x -= 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n\n  // Wrap Y coords\n  if(pixelCoord.y < 0.0){\n    uv.y += 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n  else if(pixelCoord.y > srctextureDim.y){\n    uv.y -= 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n\n  vec4 texel = texture2D(srctexture, uv);\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  // TODO: check why we pre-multiply alphas here.\n  // fragColor = vec4(texel.rgb/texel.a, texel.a);\n\n  if(alphaFromLuminance) {\n    fragColor = vec4(texel.rgb, luminanceFromRGB(texel.rgb));\n  }\n  else {\n    fragColor = texel;\n  }\n  \n  if(invert) {\n    fragColor = vec4(1.0) - fragColor;\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n");}}class ni extends ei{constructor(e,t,a="RGBA",i="FLOAT"){super(e),this.__name=t,this.__formatParam=a,this.__typeParam=i,this.clearColor=new u(0,0,0,0),this.__subImages=[],this.__layoutNeedsRegeneration=!1,this.__async=new L,this.loaded=this.__async.ready;}isLoaded(){return 0==this.__async.count}getMainImage(){return this.super}addSubImage(e){if(e instanceof Te){const t=new Fa(this.__gl,e);e.isLoaded()||(this.__async.incAsyncCount(),e.loaded.connect(()=>{this.__async.decAsyncCount();})),e.setMetadata("ImageAtlas_gltex",t),t.addRef(this),e.updated.connect(()=>{this.__layoutNeedsRegeneration=!0,this.renderAtlas();}),this.__subImages.push(t);}else e.addRef(this),this.__subImages.push(e);return this.__layoutNeedsRegeneration=!0,this.__subImages.length-1}removeSubImage(e){let t;if(e instanceof Te){const a=e.getMetadata("ImageAtlas_gltex");t=this.__subImages.indexOf(a),e.deleteMetadata("ImageAtlas_gltex");}else t=this.__subImages.indexOf(e);this.__subImages[t].removeRef(this),this.__subImages.splice(t,1),this.__layoutNeedsRegeneration=!0;}getSubImage(e){return this.__subImages[e]}numSubImages(){return this.__layout?this.__layout.length:this.__subImages.length}generateAtlasLayout(){if(0==this.__subImages.length)return void(this.__layoutNeedsRegeneration=!1);const e=[];this.__subImages.forEach((t,a)=>{e.push({w:t.width+4,h:t.height+4,area:t.width*t.height,index:a});}),e.sort((e,t)=>e.area>t.area?-1:e.area<t.area?1:0);const t=new W;t.fit(e),this.__layout=[],e.forEach((e,t)=>{e.fit?this.__layout[e.index]={pos:new o(e.fit.x+2,e.fit.y+2),size:new o(e.w,e.h)}:console.warn("Unable to fit image");});const a=t.root.w,i=t.root.h;this.configure({width:a,height:i,format:"FLOAT"==this.__typeParam&&"RGB"==this.__formatParam?"RGBA":this.__formatParam,type:this.__typeParam,filter:"LINEAR"});const s=this.__gl;if(s.__quadVertexIdsBuffer||s.setupInstancedQuad(),!s.__atlasLayoutShader){s.__atlasLayoutShader=new si(s);const e=s.__atlasLayoutShader.compileForTarget("GLImageAtlas");s.__atlasLayoutShaderBinding=Ya(s,e.attrs,s.__quadattrbuffers,s.__quadIndexBuffer);}let n=Math.round(Math.sqrt(1*this.__layout.length)+.5);if(n=Math.nextPow2(n),n%1!=0&&(n+=1-n%1),s.floatTexturesSupported){const e=new Float32Array(n*n*4);for(let t=0;t<this.__layout.length;t++){const s=this.__layout[t];h.createFromFloat32Buffer(e.buffer,4*t).set(s.pos.x/a,s.pos.y/i,s.size.x/a,s.size.y/i);}this.__atlasLayoutTexture&&this.__atlasLayoutTexture.width==n&&this.__atlasLayoutTexture.height==n?this.__atlasLayoutTexture.bufferData(e,n,n):(this.__atlasLayoutTexture&&this.__atlasLayoutTexture.destroy(),this.__atlasLayoutTexture=new Fa(s,{format:"RGBA",type:"FLOAT",filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,width:n,height:n,data:e}));}else this.__layoutVec4s=[],this.__layout.forEach((e,t)=>{this.__layoutVec4s[t]=[e.pos.x/a,e.pos.y/i,e.size.x/a,e.size.y/i];});this.__layoutNeedsRegeneration=!1;}getLayoutData(e){return this.__layoutVec4s[e]}renderAtlas(e=!1,t=0){if(0==this.__subImages.length)return;this.__layoutNeedsRegeneration&&this.generateAtlasLayout();const a=this.__gl,i={};this.bindForWriting(i,!0),a.__atlasLayoutShader.bind(i,"GLImageAtlas"),a.__atlasLayoutShaderBinding.bind(i);const s=new o(1/this.width,1/this.height),n=i.unifs;for(let e=t;e<this.__subImages.length;e++){const t=this.__subImages[e],l=this.__layout[e];t.bindToUniform(i,n.srctexture),a.uniform2fv(n.pos.location,l.pos.multiply(s).asArray()),a.uniform2fv(n.size.location,l.size.multiply(s).asArray()),a.uniform2f(n.srctextureDim.location,t.width,t.height),a.uniform1i(n.alphaFromLuminance.location,t.alphaFromLuminance),a.uniform1i(n.invert.location,t.invert),a.drawQuad(),i.boundTextures--;}e&&this.cleanup(),this.unbind(i),this.updated.emit();}isReady(){return null!=this.__atlasLayoutTexture}bindToUniform(e,t){if(!this.__atlasLayoutTexture)return !1;super.bindToUniform(e,t);const a=e.unifs,i=a[t.name+"_layout"];i&&this.__atlasLayoutTexture.bindToUniform(e,i);const s=a[t.name+"_desc"];return s&&this.__gl.uniform4f(s.location,this.width,this.height,this.__atlasLayoutTexture.width,0),!0}cleanup(){for(const e of this.__subImages)e.removeRef(this);this.__subImages=[],this.destroy();}destroy(){this.cleanup(),super.destroy();}}class li extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("ConvolverShader.vertexShader",'\nprecision highp float;\n\n<%include file="utils/quadVertexFromID.glsl"/>\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("ConvolverShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="utils/imagePyramid.glsl"/>\n<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>\n\nuniform float roughness;\nvarying vec2 v_texCoord;\n\nuniform sampler2D hammersleyMap;\nvec2 Hammersley(int i, int N) {\n  vec4 rgba =  texture2D(hammersleyMap, vec2((float(i) + 0.5)/float(N)), 0.5);\n  return rgba.rg;\n}\n\nmat3 matrixFromVector(vec3 n) { // frisvad\n  float a = 1.0 / (1.0 + n.z);\n  float b = -n.x * n.y * a;\n  vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n  vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n  return mat3(b1, b2, n);\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, float a) {\n  float phi = 2.0 * PI * Xi.x;\n  float cos_theta = sqrt((1.0 - Xi.y)/(1.0 + (a*a - 1.0) * Xi.y));\n  float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n  // float phi = Xi.y * 2.0 * PI;\n  // float cos_theta = sqrt(1.0 - Xi.x);\n  // float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n  vec3 H;\n  H.x = sin_theta * cos(phi);\n  H.y = sin_theta * sin(phi);\n  H.z = cos_theta;\n  return H;\n}\n\n// TODO: use tobias\'s code. The guy clearly knows what he\'s doing...\n// https://github.com/thefranke/dirtchamber/blob/master/shader/importance.hlsl\n// Compute a LOD level for filtered importance sampling.\n// From GPU Gems 3: GPU-Based Importance Sampling.\n\n\n#define M_PI       3.14159265358979323846   // pi\n#define M_HALF_PI  1.57079632679489661923   // pi/2\nfloat sqr(float val){ return val*val; }\nfloat saturate(float val) { return clamp(val, 0.0, 1.0); }\nvec3 saturate(vec3 val) { return clamp(val, 0.0, 1.0); }\n\n// Microfacet Models for Refraction through Rough Surfaces\n// Walter et al.\n// http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html\n// aka Towbridge-Reitz\nfloat D_ggx(in float alpha, in float NoH)\n{\n  float a2 = alpha*alpha;\n  float cos2 = NoH*NoH;\n\n  return (1.0/M_PI) * sqr(alpha/(cos2 * (a2 - 1.0) + 1.0));\n\n  /*\n  // version from the paper, eq 33\n  float CosSquared = NoH*NoH;\n  float TanSquared = (1.0 - CosSquared)/CosSquared;\n  return (1.0/M_PI) * sqr(alpha/(CosSquared * (alpha*alpha + TanSquared)));\n  */\n}\nfloat compute_lod(in vec3 H, in float pdf, in int num_samples, in int ww, in int hh)\n{\n  return max(0.0, 0.5*log2(float(ww*hh)/float(num_samples)) - 0.5*log2(pdf));\n}\n\nuniform sampler2D   envMapPyramid;\nuniform sampler2D   envMapPyramid_layout;\nuniform vec4        envMapPyramid_desc;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec3 N = sphOctUvToDir(v_texCoord);\n\n  if(false){\n    vec2 uv = dirToSphOctUv(N);\n    // fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n    fragColor = sampleImagePyramid(uv, 0.5, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc);\n    // fragColor = sampleSubImage(uv, 0, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc);\n    // fragColor = texture2D(envMapPyramid, uv);\n  }\n  else{\n    const int numSamples = NUM_SAMPLES;\n    int w = int(floor(envMapPyramid_desc.x + 0.5));\n    int h = int(floor(envMapPyramid_desc.y + 0.5));\n\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    float weight = 0.0;\n    mat3 vecSpace = matrixFromVector(N);\n    float a = roughness*roughness;\n    for(int i=0; i<numSamples; i++) {\n      vec2 Xi = Hammersley(i, numSamples);\n      vec3 H = ImportanceSampleGGX(Xi, a);\n      vec3 V = normalize(vecSpace * H);\n      float VdotN = dot(V, N);\n      float NoH = saturate( dot( N, H ) );\n      float VoH = saturate( dot( V, H ) );\n\n      vec2 uv = dirToSphOctUv(V);\n      // float pdf = D_ggx(a, NoH) * NoH / (4.0 * VoH);\n      // float lod = compute_lod(H, pdf, numSamples, w, h);\n\n      color += sampleImagePyramid(uv, a, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc) * VdotN;\n      weight += VdotN;\n    }\n    color /= float(weight);\n    fragColor = vec4(color.rgb, 1.0);\n  }\n  \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n');}}Ja.setShaderModule("utils/imagePyramid.glsl",'\n\n<%include file="utils/imageAtlas.glsl"/>\n\nvec4 sampleImagePyramid(vec2 uv, float lod, in sampler2D atlasLayout, in sampler2D atlasImage, in vec4 atlasDesc){\n  if (lod < 0.00001 || lod > 0.9999) {\n    float imageIndex = lod * (atlasDesc.z-1.0);\n    int imageId0 = int(imageIndex);\n    return sampleSubImage(uv, imageId0, atlasLayout, atlasImage, atlasDesc);\n  } else {\n    float imageIndex = lod * (atlasDesc.z-1.0);\n    int imageId0 = int(floor(imageIndex));\n    int imageId1 = imageId0+1;\n    float blend = fract(imageIndex);\n    vec4 c0 = sampleSubImage(uv, imageId0, atlasLayout, atlasImage, atlasDesc);\n    vec4 c1 = sampleSubImage(uv, imageId1, atlasLayout, atlasImage, atlasDesc);\n    return mix(c0, c1, blend);\n  } \n}\n\n\n');class ri extends ni{constructor(e,t,a,i=!0,s=16){super(e,t),this.__srcGLTex=a,this.__fbos=[],a.updated.connect(()=>{this.renderAtlas(i);}),this.__srcGLTex.isLoaded()?(this.generateAtlasLayout(s),this.renderAtlas(i)):this.__srcGLTex.updated.connect(()=>{this.generateAtlasLayout(s),this.renderAtlas(i);});}generateAtlasLayout(e){const t=this.__gl;this.size=this.__srcGLTex.height;const a=this.__srcGLTex.width/this.__srcGLTex.height;this.addSubImage(this.__srcGLTex);for(let i=Math.round(function(e){return Math.log2(e)}(this.size))-1;i>=0;--i){const s=Math.pow(2,i);if(s<e)break;const n=new Fa(t,{format:this.__srcGLTex.getFormat(),type:this.__srcGLTex.getType(),width:s*a,height:s,filter:"LINEAR",wrap:"CLAMP_TO_EDGE"});this.addSubImage(n),this.__fbos.push(new Ha(t,n));}super.generateAtlasLayout();}renderAtlas(e=!0){const t=this.__gl,a={};t.screenQuad.bindShader(a);for(let e=0;e<this.__fbos.length;e++)this.__fbos[e].bindAndClear(),t.screenQuad.draw(a,this.getSubImage(e));super.renderAtlas(e);}destroy(){super.destroy();for(const e of this.__fbos)e.destroy();}}class oi extends ni{constructor(e,t){super(e,t),this.__gl=e,e.__quadVertexIdsBuffer||e.setupInstancedQuad(),this.__convolved=!1,this.__fbos=[];}generateHammersleySamples(e){const t=this.__gl;if(!t["Hammersley"+e]){const a=new Float32Array(3*e);for(let t=0;t<e;t++){const i=ii(t,e),s=3*t;a[s+0]=i[0],a[s+1]=i[1];}t["Hammersley"+e]=new Fa(t,{format:"RGB",type:"FLOAT",filter:"NEAREST",wrap:"CLAMP_TO_EDGE",width:e,height:1,data:a,mipMapped:!1});}return t["Hammersley"+e]}convolveProbe(e){const t=this.__gl,a=this.generateHammersleySamples(1024);if(!this.__convolved){this.__lodPyramid||(this.__lodPyramid=new ri(t,"Probe Lods",e,!1),this.__lodPyramid.updated.connect(()=>{this.convolveProbe(e);})),this.addSubImage(e);let a=[e.width/2,e.height/2];const i=6;for(let e=0;e<i;e++){const e=new Fa(t,{format:"RGBA",type:"FLOAT",filter:"LINEAR",wrap:"CLAMP_TO_EDGE",width:a[0],height:a[1]});this.addSubImage(e);const i=new Ha(t,e);i.setClearColor([0,1,0,0]),this.__fbos.push(i),a=[a[0]/2,a[1]/2];}this.generateAtlasLayout(),this.__convolverShader=new li(t);const s=this.__convolverShader.compileForTarget("GLProbe",Object.assign({repl:{NUM_SAMPLES:1024}},t.shaderopts));this.__covolverShaderBinding=Ya(t,s.attrs,t.__quadattrbuffers,t.__quadIndexBuffer);}const i={};this.__convolverShader.bind(i,"GLProbe"),this.__covolverShaderBinding.bind(i);const s=i.unifs;for(let e=0;e<this.__fbos.length;e++){if(this.__fbos[e].bindAndClear(),this.__lodPyramid.bindToUniform(i,s.envMapPyramid),"hammersleyMap"in s&&a.bindToUniform(i,s.hammersleyMap),"roughness"in s){const a=(e+1)/this.__fbos.length;t.uniform1f(s.roughness.location,a);}t.drawQuad();}this.__convolved=!0,this.renderAtlas(!1);}bindProbeToUniform(e,t){this.__convolved&&super.bindToUniform(e,t);}destroy(){super.destroy(),this.__convolverShader.destroy();for(const e of this.__fbos)e.destroy();}}Ja.setShaderModule("stack-gl/inverse.glsl","\n\n\n#ifndef ENABLE_ES3\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n#endif\n\n"),Ja.setShaderModule("stack-gl/transpose.glsl","\n\n\n#ifndef ENABLE_ES3\n\nfloat transpose(float m) {\n  return m;\n}\n\nmat2 transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n#endif\n\n"),Ja.setShaderModule("pragmatic-pbr/envmap-octahedral.glsl","\n\n#define sectorize(value) step(0.0, (value))*2.0-1.0\n#define sum(value) dot(clamp((value), 1.0, 1.0), (value))\n\n\nvec2 dirToSphOctUv(vec3 normal){\n    normal = normalize(normal);\n    vec3 aNorm = abs(normal);\n    vec3 sNorm = sectorize(normal);\n\n    vec2 dir = max(aNorm.xy, 1e-20);\n    float orient = atan(dir.x, dir.y)/HalfPI;\n\n    dir = max(vec2(aNorm.z, length(aNorm.xy)), 1e-20);\n    float pitch = atan(dir.y, dir.x)/HalfPI;\n\n    vec2 uv = vec2(sNorm.x*orient, sNorm.y*(1.0-orient))*pitch;\n\n    if(normal.z < 0.0){\n        uv = sNorm.xy - abs(uv.ts)*sNorm.xy;\n    }\n    return uv*0.5+0.5;\n}\n\n\nvec3 sphOctUvToDir(vec2 uv){\n    uv = uv*2.0-1.0;\n    vec2 suv = sectorize(uv);\n    float sabsuv =  sum(abs(uv));\n    float pitch = sabsuv*HalfPI;\n\n    if (pitch <= 0.0) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n    if (abs(pitch - PI) < 0.000001) {\n        return vec3(0.0, 0.0, -1.0);\n    }\n    if(sabsuv > 1.0){\n        uv = (1.0-abs(uv.ts))*suv;\n    }\n\n    float orient = (abs(uv.s)/sabsuv)*HalfPI;\n    float sOrient = sin(orient);\n    float cOrient = cos(orient);\n    float sPitch = sin(pitch);\n    float cPitch = cos(pitch);\n\n    return vec3(\n        sOrient*suv.s*sPitch,\n        cOrient*suv.t*sPitch,\n        cPitch\n    );\n}\n\n"),Ja.setShaderModule("pragmatic-pbr/envmap-equirect.glsl","\n\n\nvec2 latLongUVsFromDir(vec3 dir) {\n  // Math function taken from...\n  // http://gl.ict.usc.edu/Data/HighResProbes/\n  // Note: Scaling from u=[0,2], v=[0,1] to u=[0,1], v=[0,1]\n  float phi = acos(dir.z);\n  float theta = atan(dir.x, dir.y);\n  return vec2((1.0 + theta / PI) / 2.0, phi / PI);\n}\n\n// Note: when u == 0.5 z = 1.0\nvec3 dirFromLatLongUVs(float u, float v) {\n    // http://gl.ict.usc.edu/Data/HighResProbes/\n    float theta = PI*((u * 2.0) - 1.0);\n    float phi = PI*v;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec3 dirFromPolar(vec2 polar) {\n    float u = polar.x / (PI * 2.0);\n    float v = polar.y / PI;\n    return dirFromLatLongUVs(u, v);\n}\n\n"),Ja.setShaderModule("pragmatic-pbr/envmap-dualfisheye.glsl","\n\n\n\nvec2 dualfisheyeUVsFromDir(vec3 dir) {\n  vec2 result;\n  float angle = 0.465;\n    if(dir.x < 0.0) {\n        result = vec2(((dir.z * -angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n    }\n    else {\n        result = vec2( 0.5 + ((dir.z * angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n    }\n    return result;\n}\n\n\n");class di extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("EnvMapShader.vertexShader",'\nprecision highp float;\n\n<%include file="utils/quadVertexFromID.glsl"/>\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID() * 2.0;\n  v_texCoord = position * 0.5 + 0.5;\n\n  mat4 inverseProjection = inverse(projectionMatrix);\n  mat3 inverseModelview = transpose(mat3(viewMatrix));\n\n  // transform from the normalized device coordinates back to the view space\n  vec3 unprojected = (inverseProjection * vec4(position, 0, 1)).xyz;\n\n  // transfrom from the view space back to the world space\n  // and use it as a sampling vector\n  v_worldDir = inverseModelview * unprojected;\n\n  gl_Position = vec4(position, 0, 1);\n}\n\n');}}class hi extends di{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("LatLongEnvMapShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-equirect.glsl"/>\n\n#define ENABLE_INLINE_GAMMACORRECTION\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\nuniform float exposure;\n#endif\n\nuniform sampler2D backgroundImage;\n\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec4 texel = texture2D(backgroundImage, v_texCoord);\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  //fragColor.rgb = toGamma(fragColor.rgb * exposure);\n\n  // Assuming a simple RGB image in gamma space for now.\n  fragColor.rgb = fragColor.rgb * exposure;\n#endif\n\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}}class ci extends di{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("OctahedralEnvMapShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>\n<%include file="utils/imagePyramid.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n\nuniform float focus;\n\n#define ENABLE_INLINE_GAMMACORRECTION\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\n// uniform ImageAtlas envMap;\nuniform sampler2D   envMapPyramid;\nuniform sampler2D   envMapPyramid_layout;\nuniform vec4        envMapPyramid_desc;\n\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 uv = dirToSphOctUv(normalize(v_worldDir));\n  if(false){\n    // Use these lines to debug the src GL image.\n    vec4 texel = texture2D(envMapPyramid, uv);\n    fragColor = vec4(texel.rgb/texel.a, 1.0);\n  }\n  else{\n    fragColor = vec4(sampleImagePyramid(uv, focus, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc).rgb, 1.0);\n  }\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}}class mi extends di{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("LatLongEnvMapShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-equirect.glsl"/>\n\n#define ENABLE_INLINE_GAMMACORRECTION\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\nuniform float exposure;\n#endif\n\nuniform sampler2D backgroundImage;\n\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 uv = latLongUVsFromDir(normalize(v_worldDir));\n\n  vec4 texel = texture2D(backgroundImage, uv);\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){return super.getParamDeclarations()}}class ui extends di{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("SterioLatLongEnvMapShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-equirect.glsl"/>\n\n#define ENABLE_INLINE_GAMMACORRECTION\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\nuniform float exposure;\n#endif\n\nuniform int eye;// L = 0, R = 1;\n\nuniform sampler2D backgroundImage;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 uv = latLongUVsFromDir(normalize(v_worldDir));\n  uv.y *= 0.5;\n  if(eye == 1){\n    uv.y += 0.5;\n  }\n\n  vec4 texel = texture2D(backgroundImage, uv);\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  //fragColor.rgb = toGamma(fragColor.rgb * exposure);\n\n  // Assuming a simple RGB image in gamma space for now.\n  fragColor.rgb = fragColor.rgb * exposure;\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}}class bi extends di{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("DualFishEyeEnvMapShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-dualfisheye.glsl"/>\n\n#define ENABLE_INLINE_GAMMACORRECTION\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\nuniform float exposure;\n#endif\n\nuniform sampler2D backgroundImage;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 uv = dualfisheyeUVsFromDir(normalize(v_worldDir));\n\n  vec4 texel = texture2D(backgroundImage, uv);\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  //fragColor.rgb = toGamma(fragColor.rgb * exposure);\n\n  // Assuming a simple RGB image in gamma space for now.\n  fragColor.rgb = fragColor.rgb * exposure;\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}}class pi extends di{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("DualFishEyeEnvMapShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-equirect.glsl"/>\n<%include file="pragmatic-pbr/envmap-dualfisheye.glsl"/>\n\n#define ENABLE_INLINE_GAMMACORRECTION\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\nuniform float exposure;\n#endif\n\nuniform sampler2D backgroundImage;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 uv = dualfisheyeUVsFromDir(dirFromLatLongUVs(v_texCoord.x, v_texCoord.y));\n  vec4 texel = texture2D(backgroundImage, uv);\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  //fragColor.rgb = toGamma(fragColor.rgb * exposure);\n\n  // Assuming a simple RGB image in gamma space for now.\n  // fragColor.rgb = fragColor.rgb * exposure;\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}}class gi extends oi{constructor(e,t,a){super(e.gl,"EnvMap"),this.__renderer=e,this.__envMap=t,this.__backgroundFocus=0;const i=e.gl;i.__quadVertexIdsBuffer||i.setupInstancedQuad();let s=this.__envMap.getMetadata("gltexture");s||(s=new ka(i,this.__envMap)),this.__srcGLTex=s,this.__envMapShader=new ci(i);const n=this.__envMapShader.compileForTarget("GLEnvMap",a);this.__envMapShaderBinding=Ya(i,n.attrs,i.__quadattrbuffers,i.__quadIndexBuffer),this.__envMap.isLoaded()?this.convolveProbe(s):this.__envMap.loaded.connect(()=>{this.convolveProbe(s),this.loaded.emit();});}getEnvMap(){return this.__envMap}getBackgroundFocus(){return this.__backgroundFocus}setBackgroundFocus(e){this.__backgroundFocus=e,this.__renderer.requestRedraw();}draw(e){if(this.__envMap.isLoaded()){const t=this.__gl;{this.__envMapShader.bind(e,"GLEnvMap");const a=e.unifs;this.bindProbeToUniform(e,a.envMapPyramid);{const e=a.focus;e&&t.uniform1f(e.location,this.__backgroundFocus);}{const i=a.exposure;i&&t.uniform1f(i.location,e.exposure);}this.__envMapShaderBinding.bind(e),t.depthMask(!1),e.bindViewports(a,()=>{t.drawQuad();});}}}bindToUniform(e,t,a){return this.__srcGLTex.bindToUniform(e,t,a)}destroy(){super.destroy(),this.__srcGLTex.loaded.disconnectScope(this),this.__srcGLTex.updated.disconnectScope(this),this.__srcGLTex.destroy();}}class _i extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("ScreenQuadShader.vertexShader",'\nprecision highp float;\n\n<%include file="utils/quadVertexFromID.glsl"/>\n\nuniform vec2 pos;\nuniform vec2 size;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    vec2 position = getQuadVertexPositionFromID();\n    v_texCoord = position+0.5;\n    gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * abs(size) * 2.0), 0.0, 1.0);\n    if(size.x < 0.0)\n        v_texCoord.x = 1.0 - v_texCoord.x;\n    if(size.y < 0.0)\n        v_texCoord.y = 1.0 - v_texCoord.y;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("ScreenQuadShader.fragmentShader","\nprecision highp float;\n\nuniform sampler2D image;\n\nvarying vec2 v_texCoord;\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    fragColor = texture2D(image, v_texCoord);\n    fragColor = vec4(fragColor.rgb/fragColor.a, 1.0);\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n"),this.finalize();}}class Zi{constructor(e,t){this.__gl=e,this.__pos=[0,0],this.__size=[1,1],this.flipY=!0,this.__glshader=new _i(e),e.__quadVertexIdsBuffer||e.setupInstancedQuad();const a=this.__glshader.compileForTarget("GLScreenQuad",t);this.__quadBinding=Ya(e,a.attrs,e.__quadattrbuffers,e.__quadIndexBuffer),this.ready=!0;}bind(e,t,a,i){const s=e.unifs;t.bindToUniform(e,e.unifs.image);const n=this.__gl;{const e=s.pos;e&&n.uniform2fv(e.location,a?a instanceof l?a.asArray():a:this.__pos);}{const e=s.size;e&&n.uniform2fv(e.location,i?i instanceof l?i.asArray():i:this.__size);}this.__quadBinding.bind(e);}bindShader(e){return this.__glshader.bind(e,"GLScreenQuad")}draw(e,t,a,i){this.bind(e,t,a,i),this.__gl.drawQuad();}destroy(){}}class Gi extends H{constructor(e){super(),this.__renderer=e,this.__doubleClickTimeMSParam=this.addParameter(new ue("DoubleClickTimeMS",200)),this.__fbo=void 0,this.updated=new S,this.resized=new S,this.__renderer.sceneSet.connect(()=>{const t=e.getScene().settings.getParameter("BackgroundColor"),a=e=>{const a=t.getValue();let i=this.__renderer.gl;a instanceof Te?"FLOAT"===a.type?(this.__backgroundTexture=a,this.__backgroundGLTexture=new ka(i,a)):(this.__backgroundTexture=a,this.__backgroundGLTexture=new Fa(i,a)):a instanceof u?(this.__backgroundGLTexture&&(this.__backgroundGLTexture.destroy(),this.__backgroundGLTexture=void 0,this.__backgroundTexture=void 0),this.__backgroundColor=a):console.warn("Invalid background:"+a),this.updated.emit();};a(t.getValue()),t.valueChanged.connect(a);});}getRenderer(){return this.__renderer}getName(){return this.__name}getBl(){return this.__bl}setBl(e){this.__bl=e,this.resize(this.__canvasWidth,this.__canvasHeight);}getTr(){return this.__tr}setTr(e){this.__tr=e,this.resize(this.__canvasWidth,this.__canvasHeight);}getPosX(){return this.__x}getPosY(){return this.__y}getWidth(){return this.__width}getHeight(){return this.__height}getBackground(){return console.warn("Deprecated Function. Please access the Scene Settings object."),this.__renderer.getScene().settings.getParameter("BackgroundColor").getValue()}setBackground(e){console.warn("Deprecated Function. Please access the Scene Settings object."),this.__renderer.getScene().settings.getParameter("BackgroundColor").setValue(e),this.updated.emit();}resize(e,t){this.__canvasWidth=e,this.__canvasHeight=t,this.__width=e,this.__height=t,this.resized.emit();}onMouseDown(e){return !1}onMouseUp(e){return !1}onMouseMove(e){return !1}onMouseLeave(e){return !1}onKeyPressed(e,t){return !1}onKeyDown(e,t){return !1}onKeyUp(e,t){return !1}}class Xi extends Gi{constructor(e,t,a,i){super(e),this.__name=t,this.__projectionMatrix=new _,this.__frustumDim=new o,this.__bl=new o(0,0),this.__tr=new o(1,1),this.__exposure=0,this.__exposureRange=[-5,10],this.__tonemap=!0,this.__gamma=2.2,this.__prevDownTime=0,this.__geomDataBuffer=void 0,this.__geomDataBufferFbo=void 0,this.viewChanged=new S,this.capturedItem=null,this.keyDown=new S,this.keyPressed=new S,this.keyUp=new S,this.mouseDown=new S,this.mouseDoubleClicked=new S,this.mouseMove=new S,this.mouseUp=new S,this.mouseLeave=new S,this.mouseDownOnGeom=new S,this.mouseWheel=new S,this.touchStart=new S,this.touchMove=new S,this.touchEnd=new S,this.touchCancel=new S,this.doubleTapped=new S,this.setCamera(new ca("Default")),this.setManipulator(new La),this.resize(a,i);}resize(e,t){this.__canvasWidth=e,this.__canvasHeight=t,this.__x=e*this.__bl.x,this.__y=e*this.__bl.y,this.__width=e*this.__tr.x-e*this.__bl.x,this.__height=t*this.__tr.y-t*this.__bl.y,this.region=[this.__x,this.__y,this.__width,this.__height],this.__camera&&this.__updateProjectionMatrix(),this.__geomDataBufferFbo&&(this.__geomDataBuffer.resize(this.__width,this.__height),this.__geomDataBufferFbo.resize()),this.resized.emit();}getCamera(){return this.__camera}setCamera(e){this.__camera=e;const t=e.getParameter("GlobalXfo"),a=()=>{this.__cameraXfo=t.getValue(),this.__cameraMat=this.__cameraXfo.toMat4(),this.__viewMat=this.__cameraMat.inverse();};a(),t.valueChanged.connect(()=>{a(),this.invalidateGeomDataBuffer(),this.updated.emit(),this.viewChanged.emit({interfaceType:"CameraAndPointer",viewXfo:this.__cameraXfo,focalDistance:this.__camera.getFocalDistance()});}),this.__camera.projectionParamChanged.connect(()=>{this.__updateProjectionMatrix(),this.updated.emit();}),this.__updateProjectionMatrix();}getManipulator(){return this.__cameraManipulator}setManipulator(e){this.__cameraManipulator=e;}__updateProjectionMatrix(){const e=this.__width/this.__height;this.__camera.updateProjectionMatrix(this.__projectionMatrix,e);const t=Math.tan(this.__camera.getFov()/2)*this.__camera.getNear()*2,a=t*e;this.__frustumDim.set(a,t);}getProjectionMatrix(){return this.__projectionMatrix}getViewMatrix(){return this.__viewMat}setActive(e){activeViewport=e?this:void 0;}frameView(e){this.__camera.frameView(this,e);}calcRayFromScreenPos(e){const t=this.__canvasHeight*(1-this.__tr.y);let a=(e.x-this.__x)/this.__width,i=(e.y-t)/this.__height;a=2*a-1,i=2*i-1;const s=this.__cameraMat,n=this.__projectionMatrix.inverse();if(null==n)return null;let l,r;return this.__camera.getIsOrthographic()?(l=s.transformVec3(n.transformVec3(new d(a,-i,-1))),r=new d(0,0,-1)):(l=s.translation,r=n.transformVec3(new d(a,-i,-1))),r=s.rotateVec3(r).normalize(),new G(l,r)}createGeomDataFbo(e){const t=this.__renderer.gl;this.__floatGeomBuffer=e,this.__floatGeomBuffer?this.__geomDataBuffer=new Fa(t,{type:"FLOAT",format:"RGBA",filter:"NEAREST",width:this.__width<=1?1:this.__width,height:this.__height<=1?1:this.__height}):this.__geomDataBuffer=new Fa(t,{type:"UNSIGNED_BYTE",format:"RGBA",filter:"NEAREST",width:this.__width<=1?1:this.__width,height:this.__height<=1?1:this.__height}),this.__geomDataBufferFbo=new Ha(t,this.__geomDataBuffer,!0),this.__geomDataBufferFbo.setClearColor([0,0,0,0]);}getGeomDataFbo(){return this.__geomDataBufferFbo}renderGeomDataFbo(){if(this.__geomDataBufferFbo){this.__geomDataBufferFbo.bindAndClear();const e={};this.__initRenderState(e),this.__renderer.drawSceneGeomData(e),this.__geomDataBufferInvalid=!1;}}invalidateGeomDataBuffer(){this.__geomDataBufferInvalid=!0;}getGeomDataAtPos(e,t){if(this.__geomDataBufferFbo){if(this.__geomDataBufferInvalid&&(this.renderGeomDataFbo(),this.__screenPos=null),e===this.__screenPos)return this.__intersectionData;this.__screenPos=e,this.__intersectionData=null;const a=this.__renderer.gl;let i,s;if(a.finish(),this.__geomDataBufferFbo.bindForReading(),a.floatGeomBuffer){if(s=new Float32Array(4),a.readPixels(e.x,this.__height-e.y,1,1,a.RGBA,a.FLOAT,s),0==s[3])return;i=63&Math.round(s[0]);}else {if(s=new Uint8Array(4),a.readPixels(e.x,this.__height-e.y,1,1,a.RGBA,a.UNSIGNED_BYTE,s),a.bindFramebuffer(a.FRAMEBUFFER,null),0==s[0]&&0==s[1])return;i=0;}this.__geomDataBufferFbo.unbind();const n=this.__renderer.getPass(i);if(!n)return void console.warn("Geom data buffer returns invalid pass id:",i);const l=n.getGeomItemAndDist(s);if(l){t||(t=this.calcRayFromScreenPos(e));const a=t.start.add(t.dir.scale(l.dist));this.__intersectionData={screenPos:e,mouseRay:t,intersectionPos:a,geomItem:l.geomItem,dist:l.dist,geomData:s};}return this.__intersectionData}}getGeomItemsInRect(e,t){if(this.__geomDataBufferFbo){const a=this.__renderer.gl;a.finish();const i=Math.round(this.__height-t.y),s=Math.round(e.x),n=Math.round(t.x-e.x),l=Math.round(t.y-e.y),r=n*l;let o;this.__geomDataBufferFbo.bindForReading(),a.floatGeomBuffer?(o=new Float32Array(4*r),a.readPixels(s,i,n,l,a.RGBA,a.FLOAT,o)):(o=new Uint8Array(4*r),a.readPixels(s,i,n,l,a.RGBA,a.UNSIGNED_BYTE,o)),a.bindFramebuffer(a.FRAMEBUFFER,null);const d=new Set;for(let e=0;e<r;e++){let t;const i=o.subarray(4*e,4*(e+1));t=a.floatGeomBuffer?Math.round(i[0]):0;const s=this.__renderer.getPass(t).getGeomItemAndDist(i);s&&d.add(s.geomItem);}return d}}__eventMousePos(e){return new o(e.rendererX-this.getPosX(),e.rendererY-this.getPosY())}__prepareEvent(e){if(e.viewport=this,e.propagating=!0,e.stopPropagation(),e.stopPropagation=()=>{e.propagating=!1;},e.setCapture=e=>{this.capturedItem=e;},e.getCapture=e=>this.capturedItem,e.releaseCapture=()=>{this.capturedItem=null,this.renderGeomDataFbo();},e instanceof MouseEvent){const t=this.__eventMousePos(e);e.mousePos=t,e.mouseRay=this.calcRayFromScreenPos(t);const a=this.getGeomDataAtPos(e.mousePos,e.mouseRay);null!=a&&(e.intersectionData=a);}}setCapture(e){this.capturedItem=e;}getCapture(){return this.capturedItem}releaseCapture(){this.capturedItem=null,this.renderGeomDataFbo();}onMouseDown(e){if(this.__prepareEvent(e),this.capturedItem)return void this.capturedItem.onMouseDown(e);if(null!=e.intersectionData){if(e.intersectionData.geomItem.onMouseDown(e),!e.propagating||this.capturedItem)return;if(this.mouseDownOnGeom.emit(e),!e.propagating)return}const t=Date.now();if(t-this.__prevDownTime<this.__doubleClickTimeMSParam.getValue()){if(this.__cameraManipulator&&(this.__cameraManipulator.onDoubleClick(e),!e.propagating))return;this.mouseDoubleClicked.emit(e);}else {if(this.__prevDownTime=t,this.__cameraManipulator&&(this.__cameraManipulator.onMouseDown(e),!e.propagating))return;this.mouseDown.emit(e);}return !1}onMouseMove(e){if(this.__prepareEvent(e),this.capturedItem)this.capturedItem.onMouseMove(e);else {if(null!=e.intersectionData){if(e.intersectionData.geomItem!=this.mouseOverItem&&(this.mouseOverItem&&this.mouseOverItem.onMouseLeave(e),this.mouseOverItem=e.intersectionData.geomItem,this.mouseOverItem.onMouseEnter(e)),e.intersectionData.geomItem.onMouseMove(e),!e.propagating||this.capturedItem)return}else this.mouseOverItem&&(this.mouseOverItem.onMouseLeave(e),this.mouseOverItem=null);this.__cameraManipulator&&(this.__cameraManipulator.onMouseMove(e),!e.propagating)||this.mouseMove.emit(e);}}onMouseUp(e){this.__prepareEvent(e),this.capturedItem?this.capturedItem.onMouseUp(e):(null==e.intersectionData||(e.intersectionData.geomItem.onMouseUp(e),e.propagating))&&(this.__cameraManipulator&&(this.__cameraManipulator.onMouseUp(e),!e.propagating)||this.mouseUp.emit(e));}onMouseLeave(e){this.__prepareEvent(e),this.mouseLeave.emit(e);}onKeyPressed(e,t){this.__prepareEvent(t),this.__cameraManipulator&&this.__cameraManipulator.onKeyPressed(e,t)||this.keyPressed.emit(e,t);}onKeyDown(e,t){this.__prepareEvent(t),this.__cameraManipulator&&this.__cameraManipulator.onKeyDown(e,t)||this.keyDown.emit(e,t);}onKeyUp(e,t){this.__prepareEvent(t),this.__cameraManipulator&&this.__cameraManipulator.onKeyUp(e,t)||this.keyUp.emit(e,t);}onWheel(e){this.__prepareEvent(e),(null==e.intersectionData||(e.intersectionData.geomItem.onWheel(e),e.propagating))&&(this.__cameraManipulator?this.__cameraManipulator.onWheel(e):this.mouseWheel.emit(e));}__eventTouchPos(e){return new o(e.rendererX-this.getPosX(),e.rendererY-this.getPosY())}onTouchStart(e){if(this.__prepareEvent(e),1==e.touches.length){const t=e.touches[0],a=this.__eventTouchPos(t);e.touchPos=a,e.touchRay=this.calcRayFromScreenPos(a);const i=this.getGeomDataAtPos(a,e.touchRay);if(null!=i){if(e.intersectionData=i,i.geomItem.onMouseDown(e,i),!e.propagating)return;if(this.capturedItem)return;if(this.mouseDownOnGeom.emit(e),!e.propagating)return}const s=Date.now();if(s-this.__prevDownTime<this.__doubleClickTimeMSParam.getValue()){if(this.__cameraManipulator&&(this.__cameraManipulator.onDoubleTap(e),!e.propagating))return;return void this.doubleTapped.emit(e)}this.__prevDownTime=s;}this.__cameraManipulator?this.__cameraManipulator.onTouchStart(e):this.touchStart.emit(e);}onTouchMove(e){if(this.__prepareEvent(e),this.capturedItem){e.touchPos=[],e.touchRay=[];for(let t=0;t<e.touches.length;t++){const a=e.touches[t],i=this.__eventTouchPos(a);e.touchPos[t]=i,e.touchRay[t]=this.calcRayFromScreenPos(i);}return e.mousePos=e.touchPos[0],e.mouseRay=e.touchRay[0],void this.capturedItem.onMouseMove(e)}this.__cameraManipulator?this.__cameraManipulator.onTouchMove(e):this.touchMove.emit(e);}onTouchEnd(e){this.__prepareEvent(e),this.capturedItem?this.capturedItem.onMouseUp(e):this.__cameraManipulator?this.__cameraManipulator.onTouchEnd(e):this.touchEnd.emit(e);}onTouchCancel(e){this.__prepareEvent(e),this.capturedItem?this.capturedItem.onTouchCancel(e):this.__cameraManipulator?this.__cameraManipulator.onTouchCancel(e):this.touchCancel.emit(e);}__initRenderState(e){e.viewXfo=this.__cameraXfo,e.viewScale=1,e.region=this.region,e.cameraMatrix=this.__cameraMat,e.viewports=[{region:this.region,viewMatrix:this.__viewMat,projectionMatrix:this.__projectionMatrix,viewportFrustumSize:this.__frustumDim,isOrthographic:this.__camera.getIsOrthographic(),fovY:this.__camera.getFov()}];}draw(){const e=this.__renderer.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.viewport(...this.region),this.__backgroundColor&&e.clearColor(...this.__backgroundColor.asArray()),e.colorMask(!0,!0,!0,!0),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const t={};this.__initRenderState(t),this.__renderer.drawScene(t);}}class yi{constructor(e,t){this.__vrviewport=e,this.__treeItem=new $t("VRHead"),t.addChild(this.__treeItem),this.__mat4=new _,this.__localXfo=new X;}update(e){this.__mat4.setDataArray(e.transform.matrix),this.__localXfo.fromMat4(this.__mat4),this.__treeItem.setLocalXfo(this.__localXfo);}getTreeItem(){return this.__treeItem}getXfo(){return this.__localXfo}}class fi{constructor(e,a,i){if(this.__vrviewport=e,this.__inputSource=a,this.__id=i,this.__isDaydramController=t.isMobileDevice,this.touchpadTouched=new S,this.buttonPressed=new S,this.buttonReleased=new S,this.__pressedButtons=[],this.__mat4=new _,this.__xfo=new X,this.__treeItem=new $t("VRController:"+a.handedness+i),!this.__isDaydramController){this.__tip=new $t("Tip");const t=new X;t.tr.set(0,-.05,-.13),this.__tip.setLocalXfo(t),this.__treeItem.addChild(this.__tip,!1),e.getTreeItem().addChild(this.__treeItem),this.__activeVolumeSize=.04,e.loadHMDResources().then(e=>{e.loaded.connect(()=>{let t;0==i?t=e.getChildByName("LeftController"):1==i&&(t=e.getChildByName("RightController")),t||(t=e.getChildByName("Controller"));const a=t.clone();a.setLocalXfo(new X(new d(0,-.035,-.085),new Z({setFromAxisAndAngle:[new d(0,1,0),Math.PI]}),new d(.001,.001,.001))),this.__treeItem.addChild(a,!1);});});}}getHandedness(){return this.__inputSource.handedness}getId(){return this.__id}getTreeItem(){return this.__treeItem}getTipItem(){return this.__tip}getTipXfo(){return this.__tip.getGlobalXfo()}getTouchPadValue(){return this.__touchpadValue}isButtonPressed(){return this.__buttonPressed}getControllerStageLocalXfo(){return this.__xfo}getControllerTipStageLocalXfo(){return this.__xfo.multiply(this.__tip.getLocalXfo())}updatePose(e,t,a){const i=t.getPose(a.gripSpace,e);i&&i.transform&&(this.__mat4.setDataArray(i.transform.matrix),this.__xfo.fromMat4(this.__mat4),this.__treeItem.setLocalXfo(this.__xfo),this.__geomAtTip=void 0,this.__hitTested=!1);}getGeomItemAtTip(){if(this.__hitTested)return this.__intersectionData;this.__hitTested=!0;const e=this.__vrviewport.getRenderer(),t=this.__tip.getGlobalXfo(),a=this.__activeVolumeSize;return this.__intersectionData=e.raycastWithXfo(t,a,a),this.__intersectionData}}class Vi extends Gi{constructor(e){super(e),this.getParameter("DoubleClickTimeMS").setValue(300),this.__projectionMatriciesUpdated=!1,this.__far=1024,this.__near=.1,this.__stageTreeItem=new $t("VRStage"),this.__stageTreeItem.setSelectable(!1),this.__stageTreeItem.setVisible(!1),this.__renderer.addTreeItem(this.__stageTreeItem),this.__vrhead=new yi(this.__renderer.gl,this.__stageTreeItem),this.__vrControllersMap={},this.__vrControllers=[];const t=new X;t.ori.setFromAxisAndAngle(new d(1,0,0),.5*Math.PI),this.setXfo(t),this.__leftViewMatrix=new _,this.__leftProjectionMatrix=new _,this.__rightViewMatrix=new _,this.__rightProjectionMatrix=new _,this.resized=new S,this.viewChanged=new S,this.presentingChanged=new S,this.controllerAdded=new S,this.controllerButtonDown=new S,this.controllerButtonUp=new S,this.controllerDoubleClicked=new S,this.controllerTouchpadTouched=new S;}getVRDisplay(){return this.__vrDisplay}getAsset(){return this.__vrAsset}getTreeItem(){return this.__stageTreeItem}getVRHead(){return this.__vrhead}getXfo(){return this.__stageXfo}setXfo(e){this.__stageXfo=e,this.__stageTreeItem.setGlobalXfo(e),this.__stageMatrix=e.inverse().toMat4(),this.__stageScale=e.sc.x;}getControllers(){return this.__vrControllers}canPresent(){return this.__canPresent}isPresenting(){return this.__session}__startSession(){const e=(t,a)=>{this.__session&&(this.__session.requestAnimationFrame(e),this.draw(a));};this.__session.requestAnimationFrame(e);}loadHMDResources(){const e=localStorage.getItem("hmd");return this.__hmd!=e&&(this.__hmdAssetPromise=void 0),this.__hmdAssetPromise||(this.__hmd=e,this.__hmdAssetPromise=new Promise((a,i)=>{this.__renderer.sceneSet.connect(s=>{const n=s.getResourceLoader();let l;switch(e){case"Vive":l="ZeaEngine/Vive.vla";break;case"Oculus":default:l="ZeaEngine/Oculus.vla";}const r=n.resolveFilePathToId(l);r&&!t.isMobileDevice?(this.__vrAsset=this.__renderer.getScene().loadCommonAssetResource(r),this.__vrAsset.loaded.connect(()=>{const e=this.__vrAsset.getMaterialLibrary(),t=e.getMaterialNames();for(const a of t){const t=e.getMaterial(a,!1);t&&(t.visibleInGeomDataBuffer=!1,t.setShaderName("SimpleSurfaceShader"));}a(this.__vrAsset);})):i();});})),this.__hmdAssetPromise}startPresenting(){const e=this.__renderer.gl;this.loadHMDResources().then(()=>{navigator.xr.requestSession("immersive-vr",{requiredFeatures:["local-floor"],optionalFeatures:["bounded-floor"]}).then(t=>{this.__renderer.__xrViewportPresenting=!0;const a=document.createElement("canvas");a.style.position="relative",a.style.left="0px",a.style.top="0px",a.style.width="100%",a.style.height="100%",this.__renderer.getDiv().replaceChild(a,this.__renderer.getGLCanvas()),t.addEventListener("end",e=>{this.__stageTreeItem.setVisible(!1),this.__renderer.getDiv().replaceChild(this.__renderer.getGLCanvas(),a),this.__session=null,this.presentingChanged.emit(!1);});t.addEventListener("selectstart",e=>{const t=this.__vrControllersMap[e.inputSource.handedness];if(t){const a=Date.now();console.log("controller:",e.inputSource.handedness," down",a-t.__prevDownTime),a-t.__prevDownTime<this.__doubleClickTimeMSParam.getValue()?this.controllerDoubleClicked.emit({button:1,controller:t,vleStopPropagation:!1,vrviewport:this},this):(t.__prevDownTime=a,this.controllerButtonDown.emit({button:1,controller:t,vleStopPropagation:!1,vrviewport:this},this));}}),t.addEventListener("selectend",e=>{const t=this.__vrControllersMap[e.inputSource.handedness];t&&(console.log("controller:",e.inputSource.handedness," up"),this.controllerButtonUp.emit({button:1,controller:t,vleStopPropagation:!1,vrviewport:this},this));}),this.__session=t,t.updateRenderState({baseLayer:new XRWebGLLayer(t,e,{compositionDisabled:"inline"==t.mode}),outputContext:a.getContext("xrpresent")}),t.requestReferenceSpace("local-floor").catch(e=>(console.log("Falling back to identity reference space"),t.requestReferenceSpace("viewer").then(e=>e.getOffsetReferenceSpace(new XRRigidTransform({y:-1.6}))))).then(e=>{this.__refSpace=e,this.__stageTreeItem.setVisible(!0),this.presentingChanged.emit(!0),this.__startSession();}).catch(e=>{console.warn(e.message);});}).catch(e=>{console.warn(e.message);});});}stopPresenting(){this.__session&&this.__session.end();}togglePresenting(){this.__session?this.stopPresenting():this.startPresenting();}getHMDCanvasSize(){return this.__hmdCanvasSize}__createController(e,t){console.log("creating controller:",t.handedness);const a=new fi(this,t,e);return this.__vrControllersMap[t.handedness]=a,this.__vrControllers[e]=a,this.controllerAdded.emit(a),a}updateControllers(e){const t=this.__session.inputSources;for(let a=0;a<t.length;a++){const i=t[a];if(""==i.handedness||"none"==i.handedness)return;this.__vrControllers[a]||this.__createController(a,i),this.__vrControllers[a].updatePose(this.__refSpace,e,i);}}draw(e){const t=e.session.renderState.baseLayer,a=e.getViewerPose(this.__refSpace),i=a.views;if(!this.__projectionMatriciesUpdated){this.__projectionMatrices=[],this.__viewMatrices=[],this.__cameraMatrices=[],this.__region=[0,0,0,0];for(let e=0;e<i.length;e++){const a=i[e],s=new _;s.setDataArray(a.projectionMatrix),this.__projectionMatrices[e]=s,this.__viewMatrices[e]=new _,this.__cameraMatrices[e]=new _;const n=t.getViewport(a);this.__region[2]=Math.max(this.__region[2],n.x+n.width),this.__region[3]=Math.max(this.__region[3],n.y+n.height);}this.__renderer.resizeFbos(this.__region[2],this.__region[3]),this.__projectionMatriciesUpdated=!0;}const s=this.__renderer.gl;s.bindFramebuffer(s.FRAMEBUFFER,t.framebuffer),this.__backgroundColor&&s.clearColor(...this.__backgroundColor.asArray()),s.colorMask(!0,!0,!0,!0),s.clear(s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT);const n={boundRendertarget:t.framebuffer,region:this.__region,viewports:[]};for(let e=0;e<i.length;e++){const a=i[e];this.__viewMatrices[e].setDataArray(a.transform.inverse.matrix),this.__viewMatrices[e].multiplyInPlace(this.__stageMatrix);const s=t.getViewport(a);n.viewports.push({viewMatrix:this.__viewMatrices[e],projectionMatrix:this.__projectionMatrices[e],region:[s.x,s.y,s.width,s.height]});}if(this.__vrhead.update(a),this.updateControllers(e),n.viewXfo=this.__vrhead.getTreeItem().getGlobalXfo(),n.viewScale=1/this.__stageScale,n.cameraMatrix=n.viewXfo.toMat4(),n.region=this.__region,this.__renderer.drawScene(n),this.capturedElement){const e={viewport:this};this.capturedElement.onMouseMove(e);}const l={interfaceType:"VR",hmd:this.__hmd,viewXfo:n.viewXfo,controllers:this.__vrControllers,vrviewport:this};this.viewChanged.emit(l,this);}setCapture(e){this.capturedElement=e;}getCapture(){return this.capturedElement}releaseCapture(){this.capturedElement=null,this.renderGeomDataFbo();}}let xi=void 0,Ii=!1,Ri=!1;const Si={};const Wi={OPAQUE:1,TRANSPARENT:2,OVERLAY:4};class Li extends H{constructor(){super(),this.updated=new S,this.enabled=!0,this.__passIndex=0;const e=this.addParameter(new pe("Enabled",!0));e.valueChanged.connect(t=>this.enabled=e.getValue());}__parameterValueChanged(e,t){super.__parameterValueChanged(e,t),this.__renderer&&this.__renderer.requestRedraw();}init(e,t){if(null==t)throw new Error("Missing constructor argument.");this.__gl=e.gl,this.__renderer=e,this.__passIndex=t;}setPassIndex(e){this.__passIndex=e;}startPresenting(){}stopPresenting(){}draw(e){}drawHighlightedGeoms(e){}drawGeomData(e){}getGeomItemAndDist(e){}}class vi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("OutlinesShader.vertexShader","\nprecision highp float;\n\nattribute vec3 positions;    //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    v_texCoord = positions.xy+0.5;\n    gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);\n}\n\n"),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("OutlinesShader.fragmentShader","\nprecision highp float;\n\nuniform sampler2D highlightDataTexture;\nuniform vec2 highlightDataTextureSize;\n\nvarying vec2 v_texCoord;\n\n\nbool isFilledPixel(vec4 p) {\n    return p.r > 0.01 || p.g > 0.01 || p.b > 0.01;\n}\nvoid accumOutlinePixel(vec2 fragCoord, inout vec4 res) {\n    vec3 p = texture2D(highlightDataTexture, fragCoord/highlightDataTextureSize).rgb;\n    if(p.r > 0.01 || p.g > 0.01 || p.b > 0.01) {\n        res.r += p.r;\n        res.g += p.g;\n        res.b += p.b;\n        res.a += 1.0;\n    }\n}\nvec4 getOutlinePixelColor(vec2 fragCoord) {\n    vec4 M = texture2D(highlightDataTexture, fragCoord/highlightDataTextureSize);\n    \n    /// To display a fill instead of an outline.\n    // return M;\n\n    if( isFilledPixel(M) ) {\n        // Note: the filled pixel has an alpha value\n        // that determines how much fill is applied\n        // The outline is a solid color. \n        return M;\n    }\n    // Search surrounding pixels for selected geoms.\n    vec4 res;\n    accumOutlinePixel(fragCoord+vec2( 1, 1), res); // NW\n    accumOutlinePixel(fragCoord+vec2(-1, 1), res); // NE\n    accumOutlinePixel(fragCoord+vec2( 1,-1), res); // SW\n    accumOutlinePixel(fragCoord+vec2(-1,-1), res); // SE\n    accumOutlinePixel(fragCoord+vec2( 0, 2), res); // NN\n    accumOutlinePixel(fragCoord+vec2(-2, 0), res); // EE\n    accumOutlinePixel(fragCoord+vec2( 2, 0), res); // WW\n    accumOutlinePixel(fragCoord+vec2( 0,-2), res); // SS\n    accumOutlinePixel(fragCoord+vec2( 1, 2), res); // NNW\n    accumOutlinePixel(fragCoord+vec2(-1, 2), res); // NNE\n    accumOutlinePixel(fragCoord+vec2(-2, 1), res); // EEN\n    accumOutlinePixel(fragCoord+vec2(-2,-1), res); // EES\n    accumOutlinePixel(fragCoord+vec2( 2, 1), res); // WWN\n    accumOutlinePixel(fragCoord+vec2( 2,-1), res); // WWS\n    accumOutlinePixel(fragCoord+vec2( 1,-2), res); // SSW\n    accumOutlinePixel(fragCoord+vec2(-1,-2), res); // SSE\n\n    if(isFilledPixel(res))\n        return vec4(res.rgb / res.a, 1.0);\n    else\n        return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n    // fragColor = texture2D(highlightDataTexture, v_texCoord);;\n    //can also use gl_FragCoord.xy\n    mediump vec2 fragCoord = v_texCoord * highlightDataTextureSize; \n    /////////////////\n    // Selection Outlines\n    vec4 outlineColor = getOutlinePixelColor(fragCoord);\n    if(outlineColor.a > 0.0001){\n#ifndef ENABLE_ES3\n        gl_FragColor = outlineColor;\n#else\n        fragColor = outlineColor;\n#endif\n    }\n    else {\n        discard;\n    }\n}\n\n");}}const Mi=Wi.OPAQUE|Wi.TRANSPARENT|Wi.OVERLAY;class Fi extends class{constructor(e,a={}){if(t.gpuDesc){this.__shaders={},this.__passes={},this.__passCallbacks=[],this.addTreeItem=this.addTreeItem.bind(this),this.removeTreeItem=this.removeTreeItem.bind(this),this.__viewports=[],this.__activeViewport=void 0,this.__continuousDrawing=!1,this.__redrawRequested=!1,this.__isMobile=t.isMobileDevice,this.__drawSuspensionLevel=1,this.__shaderDirectives={},this.__preproc={},this.__xrViewportPresenting=!1,this.renderGeomDataFbos=this.renderGeomDataFbos.bind(this),this.requestRedraw=this.requestRedraw.bind(this),this.resized=new S,this.keyPressed=new S,this.sceneSet=new S(!0),this.vrViewportSetup=new S(!0),this.sessionClientSetup=new S(!0),this.viewChanged=new S,this.redrawOccured=new S,this.setupWebGL(e,a.webglOptions?a.webglOptions:{}),this.bindEventHandlers();for(const e in Si)for(const t of Si[e])this.addPass(new t,e,!1);this.addViewport("main"),this.__supportXR=void 0===a.supportXR||a.supportXR,this.__xrViewport=void 0,this.__xrViewportPromise=new Promise((e,t)=>{if(this.__supportXR&&navigator.xr){const t=()=>{this.__gl.makeXRCompatible().then(()=>{this.__xrViewport=this.__setupXRViewport(),this.vrViewportSetup.emit(this.__xrViewport),e(this.__xrViewport);});};navigator.xr.supportsSessionMode?navigator.xr.supportsSessionMode("immersive-vr").then(t).catch(e=>{console.warn("Unable to setup XR:"+e);}):navigator.xr.isSessionSupported("immersive-vr").then(e=>{e&&t();}).catch(e=>{console.warn("Unable to setup XR:"+e);});}});}else console.warn("Unable to create renderer");}addShaderPreprocessorDirective(e,t){this.__shaderDirectives[e]=t?"#define "+e+" = "+t:"#define "+e;const a=[];for(const e in this.__shaderDirectives)a.push(this.__shaderDirectives[e]);this.__preproc.defines=a.join("\n")+"\n",this.__gl.shaderopts=this.__preproc;}getShaderPreproc(){return this.__preproc}getWidth(){return this.__glcanvas.width}getHeight(){return this.__glcanvas.height}addViewport(e){const t=new Xi(this,e,this.getWidth(),this.getHeight());return t.updated.connect(()=>{this.requestRedraw();}),t.createGeomDataFbo(this.__floatGeomBuffer),t.viewChanged.connect(e=>{this.__xrViewportPresenting||this.viewChanged.emit(e);}),this.__viewports.push(t),t}getViewport(e=0){return this.__viewports[e]}getViewportAtPos(e,t){for(const a of this.__viewports){const i=a.getPosX(),s=a.getPosY(),n=a.getWidth(),l=a.getHeight();if(e>=i&&t>=s&&e<=n+i&&t<=l+s)return a}}activateViewport(e){this.__activeViewport!=e&&(this.__activeViewport=e);}activateViewportAtPos(e,t){if(this.__xrViewportPresenting)return;const a=this.getViewportAtPos(e,t);a&&a!=this.__activeViewport&&this.activateViewport(a);}getActiveViewport(){return this.__xrViewportPresenting?this.__xrViewport:this.__activeViewport}suspendDrawing(){this.__drawSuspensionLevel++;}resumeDrawing(){this.__drawSuspensionLevel--,0==this.__drawSuspensionLevel&&(this.__loadingImg&&this.__glcanvasDiv.removeChild(this.__loadingImg),this.renderGeomDataFbos(),this.requestRedraw());}renderGeomDataFbos(){if(1==this.__renderGeomDataFbosRequested)return;this.__renderGeomDataFbosRequested=!0;window.requestAnimationFrame(()=>{for(const e of this.__viewports)e.renderGeomDataFbo();this.__renderGeomDataFbosRequested=!1;});}setupGrid(e,t,a,i){return console.warn("Deprecated Method. Please use scene.setupGrid"),this.__scene.setupGrid(e,a,t)}getScene(){return this.__scene}setScene(e){this.__scene=e,this.addTreeItem(this.__scene.getRoot()),this.__gizmoContext&&this.__gizmoContext.setSelectionManager(e.getSelectionManager()),this.sceneSet.emit(this.__scene);}addTreeItem(e){if(e instanceof $t){for(const t of this.__passCallbacks){const a={continueInSubTree:!0};if(t.itemAddedFn(e,a)){if(!a.continueInSubTree)return;break}}for(const t of e.getChildren())t&&this.addTreeItem(t);e.childAdded.connect(this.addTreeItem),e.childRemoved.connect(this.removeTreeItem),this.renderGeomDataFbos();}}removeTreeItem(e){if(e instanceof $t){e.childAdded.disconnect(this.addTreeItem),e.childRemoved.disconnect(this.removeTreeItem);for(const t of this.__passCallbacks){if(!t.itemRemovedFn)continue;const a={continueInSubTree:!0};if(t.itemRemovedFn(e,a)){if(!a.continueInSubTree)return;break}}for(const t of e.getChildren())t&&this.removeTreeItem(t);this.renderGeomDataFbos();}}get gl(){return this.__gl}getGL(){return this.__gl}resizeFbos(e,t){}__onResize(){if(!this.__xrViewportPresenting){const e=1;this.__glcanvas.width=this.__glcanvas.clientWidth*e,this.__glcanvas.height=this.__glcanvas.clientHeight*e;for(const e of this.__viewports)e.resize(this.__glcanvas.width,this.__glcanvas.height);this.resizeFbos(this.__glcanvas.width,this.__glcanvas.height),this.resized.emit(this.__glcanvas.width,this.__glcanvas.height),this.requestRedraw();}}getDiv(){return this.__glcanvasDiv}setupWebGL(a,i){this.__glcanvas=document.createElement("canvas"),this.__glcanvas.style.position=i.canvasPosition?i.canvasPosition:"absolute",this.__glcanvas.style.left="0px",this.__glcanvas.style.top="0px",this.__glcanvas.style.width="100%",this.__glcanvas.style.height="100%",this.__glcanvasDiv=a,this.__glcanvasDiv.appendChild(this.__glcanvas),e(this.__glcanvas,e=>{this.__onResize();}),this.__onResize(),i.preserveDrawingBuffer=!0,i.stencil=!!i.stencil&&i.stencil,i.alpha=!!i.alpha&&i.alpha,i.xrCompatible=!0,this.__gl=Ma(this.__glcanvas,i),this.__gl||alert("Unable to create WebGL context. WebGL not supported."),this.__gl.renderer=this,"webgl2"==this.__gl.name&&this.addShaderPreprocessorDirective("ENABLE_ES3"),this.__gl.floatTexturesSupported&&this.addShaderPreprocessorDirective("ENABLE_FLOAT_TEXTURES"),this.__gl.screenQuad=new Zi(this.__gl),this.__screenQuad=this.__gl.screenQuad,this.__floatGeomBuffer=this.__gl.floatTexturesSupported&&"Safari"!=t.browserName,this.__gl.floatGeomBuffer=this.__floatGeomBuffer;}bindEventHandlers(){const e=()=>this.__glcanvas.width>0&&this.__glcanvas.height,t=e=>{const t=this.__glcanvas.getBoundingClientRect();e.rendererX=1*(e.clientX-t.left),e.rendererY=1*(e.clientY-t.top);};this.__glcanvas.addEventListener("mouseenter",e=>{e.stopPropagation(),e.undoRedoManager=this.undoRedoManager,Ii||(xi=this,t(e),xi.activateViewportAtPos(e.rendererX,e.rendererY),Ri=!1);}),this.__glcanvas.addEventListener("mouseleave",t=>{if(xi==this&&e())if(t.stopPropagation(),t.undoRedoManager=this.undoRedoManager,Ii)Ri=!0;else {const e=xi.getActiveViewport();e&&(e.onMouseLeave(t),t.preventDefault()),xi=void 0;}}),this.__glcanvas.addEventListener("mousedown",e=>{e.stopPropagation(),e.undoRedoManager=this.undoRedoManager,t(e),Ii=!0,xi=this,xi.activateViewportAtPos(e.rendererX,e.rendererY);const a=xi.getActiveViewport();return a&&a.onMouseDown(e),Ri=!1,!1}),document.addEventListener("mouseup",a=>{if(xi!=this||!e())return;a.stopPropagation(),a.undoRedoManager=this.undoRedoManager,t(a),Ii=!1;const i=xi.getActiveViewport();if(i&&i.onMouseUp(a),Ri){const e=xi.getActiveViewport();e&&(e.onMouseLeave(a),a.preventDefault()),xi=void 0;}return !1}),document.addEventListener("mousemove",a=>{if(xi!=this||!e())return;a.preventDefault(),a.stopPropagation(),a.undoRedoManager=this.undoRedoManager,t(a),Ii||xi.activateViewportAtPos(a.rendererX,a.rendererY);const i=xi.getActiveViewport();return i&&i.onMouseMove(a),!1});const a=t=>{if(xi==this&&e())return xi&&(t.stopPropagation(),t.undoRedoManager=this.undoRedoManager,window.addEventListener||t.preventDefault(),this.onWheel(t)),!1};window.addEventListener?window.addEventListener("wheel",a,{passive:!0}):window.onmousewheel=document.onmousewheel=a,window.oncontextmenu=function(){return !1},document.addEventListener("keypress",t=>{if(xi!=this||!e())return;const a=String.fromCharCode(t.keyCode).toLowerCase(),i=xi.getActiveViewport();i&&i.onKeyPressed(a,t);}),document.addEventListener("keydown",t=>{if(xi!=this||!e())return;const a=String.fromCharCode(t.keyCode).toLowerCase(),i=xi.getActiveViewport();i&&i.onKeyDown(a,t);}),document.addEventListener("keyup",t=>{if(xi!=this||!e())return;const a=String.fromCharCode(t.keyCode).toLowerCase(),i=xi.getActiveViewport();i&&i.onKeyUp(a,t);}),this.__glcanvas.addEventListener("touchstart",e=>{e.stopPropagation(),e.undoRedoManager=this.undoRedoManager;for(let a=0;a<e.touches.length;a++)t(e.touches[a]);this.getViewport().onTouchStart(e);},!1),this.__glcanvas.addEventListener("touchmove",e=>{e.stopPropagation(),e.undoRedoManager=this.undoRedoManager;for(let a=0;a<e.touches.length;a++)t(e.touches[a]);this.getViewport().onTouchMove(e);},!1),this.__glcanvas.addEventListener("touchend",e=>{e.stopPropagation(),e.undoRedoManager=this.undoRedoManager;for(let a=0;a<e.touches.length;a++)t(e.touches[a]);this.getViewport().onTouchEnd(e);},!1),this.__glcanvas.addEventListener("touchcancel",e=>{e.stopPropagation(),e.undoRedoManager=this.undoRedoManager,this.getViewport().onTouchCancel(e);},!1);}setUndoRedoManager(e){this.undoRedoManager=e;}getGLCanvas(){return this.__glcanvas}getScreenQuad(){return this.__screenQuad}onWheel(e){this.__viewports[0].onWheel(e);}frameAll(e=0){this.__viewports[e].frameView([this.__scene.getRoot()]);}getOrCreateShader(e){let t=this.__shaders[e];return t||(t=C.constructClass(e,this.__gl),t||console.error("Shader not registered with the SGFactory:",e),this.__shaders[e]=t),t}addPass(e,t=0,a=!0){this.__passes[t]||(this.__passes[t]=[]);let i=0;for(const e in this.__passes){if(e==t)break;i+=this.__passes[e].length;}if(i+=this.__passes[t].length,e.updated.connect(this.requestRedraw.bind(this)),e.init(this,i),this.__passes[t].push(e),a){let e=0;for(const t in this.__passes){const a=this.__passes[t];a.forEach((t,a)=>{t.setPassIndex(e+a);}),e+=a.length;}}return this.requestRedraw(),i}registerPass(e,t){this.__passCallbacks.splice(0,0,{itemAddedFn:e,itemRemovedFn:t});}getPass(e){let t=0;for(const a in this.__passes){const i=this.__passes[a];if(e-t<i.length)return i[e-t];t+=i.length;}}findPass(e){for(const t in this.__passes){const a=this.__passes[t];for(const t of a)if(t.constructor==e)return t}}getGizmoPass(){return this.__gizmoPass}supportsVR(){return console.warn("Deprecated Method. Please instead connect to the vrViewportSetup signal."),this.__supportXR&&null!=navigator.xr}__setupXRViewport(){const e=new Vi(this);return e.presentingChanged.connect(t=>{if(this.__xrViewportPresenting=t,t){for(const e in this.__passes){const t=this.__passes[e];for(const e of t)e.startPresenting();}e.viewChanged.connect(this.viewChanged.emit);}else {e.viewChanged.disconnect(this.viewChanged.emit);for(const e in this.__passes){const t=this.__passes[e];for(const e of t)e.stopPresenting();}this.viewChanged.emit({interfaceType:"CameraAndPointer",viewXfo:this.getViewport().getCamera().getGlobalXfo()}),this.resizeFbos(this.__glcanvas.width,this.__glcanvas.height),this.requestRedraw();}}),e}getVRViewport(){return this.__xrViewport}getXRViewport(){return this.__xrViewportPromise}isXRViewportPresenting(){return this.__xrViewportPresenting}isContinuouslyDrawing(){return this.__continuousDrawing}startContinuousDrawing(){if(this.isContinuouslyDrawing()||this.__xrViewportPresenting)return;const e=()=>{this.__continuousDrawing&&!this.__xrViewportPresenting&&window.requestAnimationFrame(e);for(const e of this.__viewports)e.draw();};this.__continuousDrawing=!0,window.requestAnimationFrame(e);}stopContinuousDrawing(){this.__continuousDrawing=!1;}toggleContinuousDrawing(){this.__continuousDrawing?this.stopContinuousDrawing():this.startContinuousDrawing();}drawItemChanged(){for(const e of this.__viewports)e.invalidateGeomDataBuffer();this.requestRedraw();}requestRedraw(){if(this.__redrawRequested||this.__continuousDrawing||this.__xrViewportPresenting)return !1;return window.requestAnimationFrame(()=>{this.__redrawRequested=!1;for(const e of this.__viewports)e.draw();}),this.__redrawRequested=!0,!0}bindGLBaseRenderer(e){e.shaderopts=this.__preproc;const t=this.__gl;e.viewports&&1!=e.viewports.length?(e.bindRendererUnifs=a=>{const{cameraMatrix:i}=a;i&&t.uniformMatrix4fv(i.location,!1,e.cameraMatrix.asArray());},e.bindViewports=(a,i)=>{e.viewports.forEach((e,s)=>{t.viewport(...e.region);const{viewMatrix:n,projectionMatrix:l,eye:r}=a;n&&t.uniformMatrix4fv(n.location,!1,e.viewMatrix.asArray()),l&&t.uniformMatrix4fv(l.location,!1,e.projectionMatrix.asArray()),r&&t.uniform1i(r.location,s),i();});}):(e.bindRendererUnifs=a=>{const{cameraMatrix:i,viewMatrix:s,projectionMatrix:n,eye:l}=a;i&&t.uniformMatrix4fv(i.location,!1,e.cameraMatrix.asArray());const r=e.viewports[0];s&&t.uniformMatrix4fv(s.location,!1,r.viewMatrix.asArray()),n&&t.uniformMatrix4fv(n.location,!1,r.projectionMatrix.asArray()),l&&t.uniform1i(l.location,index);},e.bindViewports=(e,t)=>t());}drawScene(e){for(const t in this.__passes){const a=this.__passes[t];for(const t of a)t.enabled&&t.draw(e);}}drawHighlightedGeoms(e){this.bindGLBaseRenderer(e);for(const t in this.__passes){const a=this.__passes[t];for(const t of a)t.enabled&&t.drawHighlightedGeoms(e);}}drawSceneGeomData(e,t=255){this.bindGLBaseRenderer(e);for(const a in this.__passes){if(0==(Number.parseInt(a)&t))continue;const i=this.__passes[a];for(const t of i)t.enabled&&t.drawGeomData(e);}}static registerPass(e,t){Si[t]||(Si[t]=[]),Si[t].push(e);}}{constructor(e,a={}){super(e,a,{antialias:!0,depth:!0}),this.__exposure=1,this.__tonemap=!0,this.__gamma=2.2,this.__glEnvMap=void 0,this.__glBackgroundMap=void 0,this.envMapAssigned=new S(!0),this.__glLightmaps={},this.__displayEnvironment=!0,this.__debugMode=0,this.__debugLightmaps=!1,this._planeDist=0,this.__cutPlaneNormal=new d(1,0,0);const i=this.__gl;this.__debugTextures=[void 0],this.addShaderPreprocessorDirective("ENABLE_INLINE_GAMMACORRECTION"),a.disableLightmaps||this.addShaderPreprocessorDirective("ENABLE_LIGHTMAPS"),a.disableTextures||this.addShaderPreprocessorDirective("ENABLE_TEXTURES"),t.isMobileDevice||a.disableSpecular||this.addShaderPreprocessorDirective("ENABLE_SPECULAR"),this.__outlineShader=new vi(i),this.quad=new Ka(i,new Dt(1,1)),this.createSelectedGeomsFbo(),this.createRayCastRenderTarget();}__bindEnvMap(e){if(e instanceof Zt)this.__glEnvMap=e.getMetadata("gltexture"),this.__glEnvMap||("FLOAT"===e.type?(this.addShaderPreprocessorDirective("ENABLE_SPECULAR"),this.__glEnvMap=new gi(this,e,this.__preproc)):e.isStreamAtlas()?this.__glEnvMap=new GLImageStream(this.__gl,e):this.__glEnvMap=new Fa(this.__gl,e)),this.__glEnvMap.loaded.connect(this.requestRedraw),this.__glEnvMap.updated.connect(this.requestRedraw),this.envMapAssigned.emit(this.__glEnvMap);else {const t=e;if(this.__glBackgroundMap=t.getMetadata("gltexture"),this.__glBackgroundMap||("FLOAT"===t.type?this.__glBackgroundMap=new ka(gl,t):this.__glBackgroundMap=new Fa(gl,t)),this.__glBackgroundMap.loaded.connect(this.requestRedraw),this.__glBackgroundMap.updated.connect(this.requestRedraw),!this.__backgroundMapShader){switch(gl.__quadVertexIdsBuffer||gl.setupInstancedQuad(),t.getMapping()){case"octahedral":this.__backgroundMapShader=new ci(gl);break;case"latlong":this.__backgroundMapShader=new mi(gl);break;case"steriolatlong":this.__backgroundMapShader=new ui(gl);break;case"dualfisheye":this.__backgroundMapShader=new pi(gl);break;case"uv":default:this.__backgroundMapShader=new hi(gl);}const e=this.__backgroundMapShader.compileForTarget();this.__backgroundMapShaderBinding=Ya(gl,e.attrs,gl.__quadattrbuffers,gl.__quadIndexBuffer);}}}getGLEnvMap(){return this.__glEnvMap}getEnvMapTex(){return console.warn("Deprecated Function"),this.__glEnvMap}setScene(e){const t=e.settings.getParameter("EnvMap");null!=t.getValue()&&this.__bindEnvMap(t.getValue()),t.valueChanged.connect(()=>{this.__bindEnvMap(t.getValue());});const a=e.settings.getParameter("Display EnvMap");this.__displayEnvironment=a.getValue(),a.valueChanged.connect(()=>{this.__displayEnvironment=a.getValue(),this.requestRedraw();}),super.setScene(e);}addTreeItem(e){if(super.addTreeItem(e),e instanceof ua){const t=(e,t)=>{let a=t.image.getMetadata("gltexture");a||(a=new ka(this.__gl,t.image)),a.updated.connect(e=>{this.requestRedraw();}),this.__glLightmaps[e]={atlasSize:t.atlasSize,glimage:a};},a=e;a.loaded.connect(()=>{this.__glEnvMap&&a.getLightmap()&&t(a.getName(),a.getLightmap());});}}removeTreeItem(e){super.removeTreeItem(e);}addViewport(e){return super.addViewport(e)}onKeyPressed(e,t){switch(e){case"b":this.__displayEnvironment=!this.__displayEnvironment,this.requestRedraw();break;default:super.onKeyPressed(e,t);}}get exposure(){return this.__exposure}set exposure(e){this.__exposure=e,this.requestRedraw();}get gamma(){return this.__gamma}set gamma(e){this.__gamma=e,this.requestRedraw();}get displayEnvironment(){return this.__displayEnvironment}set displayEnvironment(e){this.__displayEnvironment=e,this.requestRedraw();}get planeDist(){return this._planeDist}set planeDist(e){this._planeDist=e,this.requestRedraw();}get cutPlaneNormal(){return this.__cutPlaneNormal}set cutPlaneNormal(e){this.__cutPlaneNormal=e,this.requestRedraw();}resizeFbos(e,t){super.resizeFbos(),this.__fbo&&this.__fbo.colorTexture.resize(e,t),this.__highlightedGeomsBufferFbo&&this.__highlightedGeomsBuffer.resize(e,t);}createSelectedGeomsFbo(){const e=this.__gl;this.__highlightedGeomsBuffer=new Fa(e,{type:"UNSIGNED_BYTE",format:"RGBA",filter:"NEAREST",width:this.__glcanvas.width<=1?1:this.__glcanvas.width,height:this.__glcanvas.height<=1?1:this.__glcanvas.height}),this.__highlightedGeomsBufferFbo=new Ha(e,this.__highlightedGeomsBuffer,!0),this.__highlightedGeomsBufferFbo.setClearColor([0,0,0,0]);}getFbo(){return this.__fbo}createOffscreenFbo(e="RGB"){const t=this.__glcanvas.width,a=this.__glcanvas.height,i=this.__gl;this.__fwBuffer=new Fa(i,{type:"FLOAT",format:e,filter:"NEAREST",width:t,height:a}),this.__fbo=new Ha(i,this.__fwBuffer,!0),this.__fbo.setClearColor(this.__backgroundColor.asArray());}createRayCastRenderTarget(){const e=this.__gl;this.__rayCastRenderTarget=new ei(e,{type:"FLOAT",format:"RGBA",filter:"NEAREST",width:3,height:3,numColorChannels:1}),this.__rayCastRenderTargetProjMatrix=new _,this.rayCastDist=0,this.rayCastArea=0;}raycastWithRay(e,t,a=.01,i=Mi){const s=new X;return s.setLookAt(e.start,e.start.add(e.dir)),this.raycast(s,e,t,a,i)}raycastWithXfo(e,t,a=.01,i=Mi){const s=new G(e.tr,e.ori.getZaxis().negate());return this.raycast(e,s,t,a,i)}raycast(e,t,a,i=.01,s=Mi){this.rayCastDist==a&&this.rayCastArea==i||(this.__rayCastRenderTargetProjMatrix.setOrthographicMatrix(-.5*i,.5*i,-.5*i,.5*i,0,a),this.rayCastDist=a,this.rayCastArea=i);const n=this.__gl,l={cameraMatrix:e.toMat4(),viewports:[{region:[0,0,3,3],viewMatrix:e.inverse().toMat4(),projectionMatrix:this.__rayCastRenderTargetProjMatrix,isOrthographic:!0}]};this.__rayCastRenderTarget.bindForWriting(l,!0),n.enable(n.CULL_FACE),n.enable(n.DEPTH_TEST),n.depthFunc(n.LEQUAL),n.depthMask(!0),this.drawSceneGeomData(l,s),n.finish(),this.__rayCastRenderTarget.unbindForWriting(),this.__rayCastRenderTarget.bindForReading();const r=new Float32Array(36);n.readPixels(0,0,3,3,n.RGBA,n.FLOAT,r),this.__rayCastRenderTarget.unbindForReading();const o=[4,3,5,1,7];let d;for(const e of o)if(0!=r[4*e+3]){d=r.subarray(4*e,4*e+4);break}if(!d)return;const h=63&Math.round(d[0]),c=this.getPass(h).getGeomItemAndDist(d);if(c){const e=t.start.add(t.dir.scale(c.dist));return {ray:t,intersectionPos:e,geomItem:c.geomItem,dist:c.dist,geomData:d}}}drawBackground(e){if(this.__glBackgroundMap){if(!this.__glBackgroundMap.isLoaded())return;const t=this.__gl;t.depthMask(!1),this.__backgroundMapShader.bind(e);const a=e.unifs;this.__glBackgroundMap.bindToUniform(e,a.backgroundImage),this.__backgroundMapShaderBinding.bind(e),t.drawQuad();}else this.__glEnvMap&&this.__glEnvMap.draw&&this.__glEnvMap.draw(e);}bindGLRenderer(e){super.bindGLBaseRenderer(e),e.envMap=this.__glEnvMap,e.exposure=this.__exposure,e.gamma=this.__gamma,e.lightmaps=this.__glLightmaps,e.boundLightmap=void 0;const t=this.__gl,a=e.bindRendererUnifs;e.bindRendererUnifs=i=>{if(a(i),this.__glEnvMap){const t=i.envMapPyramid;if(t&&this.__glEnvMap.bindProbeToUniform)this.__glEnvMap.bindProbeToUniform(e,t);else {const{envMapTex:t,envMapTexType:a}=i;t&&this.__glEnvMap.bindToUniform(e,t,{textureTypeUnif:a});}}{const e=i.exposure;e&&t.uniform1f(e.location,this.__exposure);}{const e=i.gamma;e&&t.uniform1f(e.location,this.__gamma);}};}drawScene(e){if(this.bindGLRenderer(e),this.__displayEnvironment&&this.drawBackground(e),super.drawScene(e),this.__highlightedGeomsBufferFbo){const t=this.__gl;this.__highlightedGeomsBufferFbo.bindForWriting(e),this.__highlightedGeomsBufferFbo.clear(),t.disable(t.BLEND),t.enable(t.DEPTH_TEST),t.depthFunc(t.LESS),t.depthMask(!0),this.drawHighlightedGeoms(e),this.__highlightedGeomsBufferFbo.unbindForWriting(e),t.viewport(...e.region),this.__outlineShader.bind(e),t.enable(t.BLEND),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA);const a=e.unifs;this.__highlightedGeomsBuffer.bindToUniform(e,a.highlightDataTexture),t.uniform2f(a.highlightDataTextureSize.location,e.region[2],e.region[3]),this.quad.bindAndDraw(e),t.disable(t.BLEND);}this.redrawOccured.emit();}}Ja.setShaderModule("drawItemId.glsl","\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nattribute float instancedIds;    // instanced attribute..\nuniform int instancedDraw;\nuniform int transformIndex;\n\nint getDrawItemId() {\n    if(instancedDraw == 0){\n       return transformIndex;\n    }\n    else{\n       return int(instancedIds);\n    }\n}\n\n\n#else\n\nuniform int transformIndex;\n\nint getDrawItemId() {\n    return transformIndex;\n}\n\n#endif\n\n"),Ja.setShaderModule("drawItemTexture.glsl",'\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nuniform sampler2D instancesTexture;\nuniform highp int instancesTextureSize;\n\n<%include file="GLSLUtils.glsl"/>\n\nconst int pixelsPerItem = 6;\n\nvec4 getInstanceData(int id) {\n    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 0);\n}\n\n#else\n\nuniform vec4 drawItemData;\n\nvec4 getInstanceData(int id) {\n    return drawItemData;\n}\n\n#endif\n\n\n'),Ja.setShaderModule("modelMatrix.glsl","\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n    // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n    vec4 col0 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 1);\n    vec4 col1 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 2);\n    vec4 col2 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 3);\n    mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n    return transpose(result);\n    // return mat4(1.0);\n}\n\nmat4 getModelMatrix(int id) {\n    return getMatrix(instancesTexture, instancesTextureSize, id);\n}\n\n#else\n\nuniform mat4 modelMatrix;\n\nmat4 getModelMatrix(int id) {\n    return modelMatrix;\n}\n\n#endif\n\n\n"),Ja.setShaderModule("materialparams.glsl","\n\n////////////////////////\n// Material Param Helpers.\n\nvec4 getColorParamValue(vec4 value, sampler2D tex, int texType, vec2 texCoord) {\n    if(texType == 0){\n        return toLinear(value);\n    }\n    else if(texType == 1 || texType == 2){\n        // TODO: Use SRGB textures.\n        return toLinear(texture2D(tex, texCoord));\n    }\n    else if(texType == 3){\n        // Float HDR Texture\n        return texture2D(tex, texCoord);\n    }\n    else\n        return value;\n}\n\n\n\nfloat luminanceFromRGB(vec3 rgb) {\n    return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\nfloat getLuminanceParamValue(float value, sampler2D tex, int texType, vec2 texCoord) {\n    if(texType == 0)\n        return value;\n    else\n        return luminanceFromRGB(texture2D(tex, texCoord).rgb);\n}\n"),Ja.setShaderModule("debugColors.glsl","\n\nfloat modI(float a, float b) {\n    float m=a-floor((a+0.5)/b)*b;\n    return floor(m+0.5);\n}\n\nvec3 getDebugColor(float id) {\n#ifdef GLSL_ES3\n    const vec3 clusterColors[4] = vec3[4]( vec3(0.0, 0.25, 0.25), vec3(0.0, 0.85, 0.25), vec3(0.0, 0.25, 0.85), vec3(0.0, 0.85, 0.85) );\n#else\n    vec3 clusterColors[8];\n    clusterColors[0] = vec3(0.0, 0.15, 0.15);\n    clusterColors[1] = vec3(0.0, 0.85, 0.15);\n    clusterColors[2] = vec3(0.0, 0.15, 0.85);\n    clusterColors[3] = vec3(0.0, 0.85, 0.85);\n    clusterColors[4] = vec3(0.75, 0.15, 0.15);\n    clusterColors[5] = vec3(0.75, 0.85, 0.15);\n    clusterColors[6] = vec3(0.75, 0.15, 0.85);\n    clusterColors[7] = vec3(0.75, 0.85, 0.85);\n#endif\n\n    if(modI(id, 8.0) == 0.0)\n        return clusterColors[0];\n    else if(modI(id, 8.0) == 1.0)\n        return clusterColors[1];\n    else if(modI(id, 8.0) == 2.0)\n        return clusterColors[2];\n    else if(modI(id, 8.0) == 3.0)\n        return clusterColors[3];\n    else if(modI(id, 8.0) == 4.0)\n        return clusterColors[4];\n    else if(modI(id, 8.0) == 5.0)\n        return clusterColors[5];\n    else if(modI(id, 8.0) == 6.0)\n        return clusterColors[6];\n    else if(modI(id, 8.0) == 7.0)\n        return clusterColors[7];\n\n    return vec3(1,0,0);\n}\n\n\n");class Ti extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("BillboardShader.vertexShader",'\nprecision highp float;\n\n\n<%include file="utils/quadVertexFromID.glsl"/>\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 cameraMatrix;\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\ninstancedattribute float instanceIds;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="utils/imageAtlas.glsl"/>\n\nuniform sampler2D atlasBillboards_layout;\nuniform vec4 atlasBillboards_desc;\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\n\n\nconst int cols_per_instance = 5;\n\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 0);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 1);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 2);\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n  return transpose(result);\n  // return mat4(1.0);\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\nvec4 getInstanceData(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 3);\n}\nvec4 getTintColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 4);\n}\n\n\n#else\n\nuniform vec4 atlasBillboards_desc;\n\nuniform mat4 modelMatrix;\nuniform vec4 billboardData;\nuniform vec4 tintColor;\nuniform vec4 layoutData;\n\n\n#endif\n\nmat4 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  // vec3 rr = vec3(sin(roll), 0.0, cos(roll));\n  vec3 rr = vec3(0.0, 0.0, 1.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(rr, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  return mat4(vec4(uu, 0.0), vec4(vv, 0.0), vec4(ww, 0.0), vec4(origin, 1.0));\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\n\nvoid main(void) {\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n  int instanceID = int(instanceIds);\n\n  mat4 modelMatrix = getModelMatrix(instanceID);\n  vec4 billboardData = getInstanceData(instanceID);\n  vec4 layoutData = fetchTexel(atlasBillboards_layout, int(atlasBillboards_desc.z), int(billboardData.z));\n  v_tint = getTintColor(instanceID);\n\n#else\n\n  v_tint = tintColor;\n\n#endif\n\n  vec2 quadVertex = getQuadVertexPositionFromID();\n\n\n  v_texCoord = vec2(quadVertex.x, -quadVertex.y) + 0.5;\n  v_alpha = billboardData.w;\n  v_texCoord *= layoutData.zw;\n  v_texCoord += layoutData.xy;\n\n  float scl = billboardData.x;\n  float width = layoutData.z * atlasBillboards_desc.x * scl * 0.002;\n  float height = layoutData.w * atlasBillboards_desc.y * scl * 0.002;\n  int flags = int(billboardData.y);\n  bool alignedToCamera = flags > 0;\n  if(alignedToCamera){\n    vec3 cameraPos = vec3(cameraMatrix[3][0], cameraMatrix[3][1], cameraMatrix[3][2]);\n    vec3 billboardPos = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);\n    mat4 lookAt = calcLookAtMatrix(billboardPos, cameraPos, 0.0);\n    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * lookAt;\n    gl_Position = modelViewProjectionMatrix * vec4(quadVertex.x * width, (quadVertex.y + 0.5) * height, 0.0, 1.0);\n  }\n  else{\n    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = modelViewProjectionMatrix * vec4(quadVertex.x * width, (quadVertex.y + 0.5) * height, 0.0, 1.0);\n  }\n\n  bool overlay = flags > 0;\n  if(overlay){\n    gl_Position.z -= 0.05;\n  }\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("BillboardShader.fragmentShader",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="utils/imageAtlas.glsl"/>\n\nuniform sampler2D atlasBillboards;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\n\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = texture2D(atlasBillboards, v_texCoord) * v_tint;\n  fragColor.a *= v_alpha;\n\n  // fragColor.r = 1.0;\n  // fragColor.a = 1.0;\n  \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n');}}class Ci extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("DepthMapShader.vertexShader","\nprecision highp float;\n\nattribute vec3 positions;    //(location = 0)\n\nuniform mat4 modelMatrix;\nuniform mat4 lightViewMatrix;\nuniform mat4 lightProjectionMatrix;\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\n\nvoid main(void) {\n  mat4 modelViewMatrix = lightViewMatrix * modelMatrix;\n  v_viewPos = modelViewMatrix * vec4(positions, 1.0);\n  gl_Position = lightProjectionMatrix * v_viewPos;\n}\n\n"),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("DepthMapShader.fragmentShader","\n#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\nuniform float near;\nuniform float far;\n\nvarying vec3 v_viewPos;\n\nfloat linstep(float edge0, float edge1, float value){\n  return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);\n}\n\nvoid main(void) {\n  float depth = linstep(near, far, -v_viewPos.z);\n  //gl_FragColor = vec4(depth, depth, depth,  1.0);\n\n  float dx = dFdx(depth);\n  float dy = dFdy(depth);\n  gl_FragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n}\n");}}class Yi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("EnvProjectionShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;    //(location = 0)\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 projectionCenter;\n\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n \nvoid main()\n{\n  int drawItemId = getDrawItemId();\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n\n  gl_Position = modelViewProjectionMatrix * pos;\n\n  vec4 worldPos = modelMatrix * pos;\n  v_worldDir = worldPos.xyz - projectionCenter;\n}\n\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"projectionCenter",defaultValue:new d(0,0,1.7)}),e}}class Ni extends Yi{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("OctahedralEnvProjectionShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n\n\nuniform color envMap;\nuniform sampler2D envMapTex;\nuniform int envMapTexType;\n\n\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 texCoord = dirToSphOctUv(normalize(v_worldDir));\n  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);\n\n  fragColor = vec4(env.rgb/env.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}}C.registerClass("OctahedralEnvProjectionShader",Ni);class Ki extends Yi{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("LatLongEnvProjectionShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-equirect.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n\nuniform color envMap;\nuniform sampler2D envMapTex;\nuniform int envMapTexType;\n\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 texCoord = latLongUVsFromDir(normalize(v_worldDir));\n  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);\n  fragColor = vec4(env.rgb/env.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}}C.registerClass("LatLongEnvProjectionShader",Ki);class wi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("FatLinesShader.vertexShader",'\nprecision highp float;\n\ninstancedattribute vec2 segmentIndices;\nattribute float vertexIDs;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\nuniform sampler2D positionsTexture;\nuniform int positionsTextureSize;\n\nuniform float LineThickness;\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  int vertexID = int(vertexIDs);\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  int seqentialIndex_0 = int(mod(segmentIndices.x, 2.));\n  int seqentialIndex_1 = int(mod(segmentIndices.y, 2.));\n  int index_0 = int(segmentIndices.x) / 2;\n  int index_1 = int(segmentIndices.y) / 2;\n\n  vec3 viewPos;\n  vec4 data_0 = fetchTexel(positionsTexture, positionsTextureSize, index_0);\n  vec4 data_1 = fetchTexel(positionsTexture, positionsTextureSize, index_1);\n\n  vec4 pos_0 = modelViewMatrix * vec4(data_0.xyz, 1.0);\n  vec4 pos_1 = modelViewMatrix * vec4(data_1.xyz, 1.0);\n  // Note: multiply the per-vertex line thickness with the line thickness uniform value;\n  float lineThickness_0 = LineThickness * data_0.w;\n  float lineThickness_1 = LineThickness * data_1.w;\n\n  if(vertexID < 2){\n    viewPos = pos_0.xyz;\n  }\n  else{\n    viewPos = pos_1.xyz;\n  }\n  if(pos_1 != pos_0){\n    vec3 segmentDir = normalize(pos_1.xyz - pos_0.xyz);\n    vec3 viewVector = normalize(viewPos);\n\n    if(vertexID < 2){\n      vec3 segmentStartDir = segmentDir;\n      if(seqentialIndex_0 != 0){\n        //if index_0 == 0, get the last index in the line as previous\n        int index_prev = (index_0 > 0) ? (index_0-1) : (positionsTextureSize-1);\n        vec4 data_prev = fetchTexel(positionsTexture, positionsTextureSize, index_prev);\n        vec4 pos_prev = modelViewMatrix * vec4(data_prev.xyz, 1.0);\n        segmentStartDir = normalize(segmentDir + normalize(pos_0.xyz - pos_prev.xyz));\n      }\n      vec3 startBiTangent = normalize(cross(segmentStartDir, viewVector));\n      v_viewNormal = normalize(cross(segmentStartDir, startBiTangent));\n      // Move the endpoints to overlap a bit more.\n      //viewPos -= vec3(segmentStartDir * lineThickness_0 * 0.25);\n      if(mod(vertexIDs, 2.0) == 0.0){\n        viewPos += vec3(startBiTangent * lineThickness_0);\n        v_texCoord.x = 1.0;\n      }\n      else{\n        viewPos -= vec3(startBiTangent * lineThickness_0);\n        v_texCoord.x = 0.0;\n      }\n      v_texCoord.y = 0.0;\n    }\n    else{\n      vec3 segmentEndDir = segmentDir;\n      if(seqentialIndex_1 != 0){\n        //if index_1 == numPoints-1, get the first index in the line as next\n        int index_next = (index_1 < (positionsTextureSize-1)) ? (index_1+1) : 0;\n        vec4 data_next = fetchTexel(positionsTexture, positionsTextureSize, index_next);\n        vec4 pos_next = modelViewMatrix * vec4(data_next.xyz, 1.0);\n        segmentEndDir = normalize(segmentDir + normalize(pos_next.xyz - pos_1.xyz));\n      }\n      vec3 endBiTangent = normalize(cross(segmentEndDir, viewVector));\n      v_viewNormal = normalize(cross(segmentEndDir, endBiTangent));\n      // Move the endpoints to overlap a bit more.\n      //viewPos += vec3(segmentEndDir * lineThickness_1 * 0.25);\n      if(mod(vertexIDs, 2.0) == 0.0){\n        viewPos += vec3(endBiTangent * lineThickness_1);\n        v_texCoord.x = 1.0;\n      }\n      else{\n        viewPos -= vec3(endBiTangent * lineThickness_1);\n        v_texCoord.x = 0.0;\n      }\n      v_texCoord.y = 1.0;\n    }\n\n    // Move the line towards the viewer by the line thickness.\n    // this is to avoid depth issues when lines are rendered over meshes. \n    viewPos.z -= (lineThickness_0 + lineThickness_1) * 0.25;\n  }\n\n  v_viewPos       = viewPos;\n  gl_Position     = projectionMatrix * vec4(viewPos, 1.0);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("FatLinesShader.fragmentShader","\nprecision highp float;\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\n\nuniform color BaseColor;\nuniform mat4 cameraMatrix;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int debugLevel = 0;\n  if(debugLevel == 0){\n\n    vec3 viewVector = mat3(cameraMatrix) * normalize(-v_viewPos);\n    vec3 normal = mat3(cameraMatrix) * v_viewNormal;\n    float NdotV = dot(normalize(normal), normalize(viewVector));\n\n    // Modulate the lighting using the texture coord so the line looks round.\n    NdotV *= cos((v_texCoord.x - 0.5) * 2.0);\n\n    vec4 color = BaseColor * NdotV;\n    fragColor = vec4(color.rgb, BaseColor.a);\n  }\n  else{\n    fragColor = vec4(v_texCoord.x, 0.0, 0.0, 1.0);\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n"),this.finalize();}bind(e){return !!super.bind(e)&&(e.supportsInstancing=!1,!0)}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e.push({name:"Opacity",defaultValue:1}),e}}C.registerClass("FatLinesShader",wi),Ja.setShaderModule("stack-gl/gamma.glsl","\n\nconst float gamma_const = 2.2;\n\nfloat toLinear(float v) {\n  return pow(v, gamma_const);\n}\n\nvec2 toLinear(vec2 v) {\n  return pow(v, vec2(gamma_const));\n}\n\nvec3 toLinear(vec3 v) {\n  return pow(v, vec3(gamma_const));\n}\n\nvec4 toLinear(vec4 v) {\n  return vec4(toLinear(v.rgb), v.a);\n}\n\n\nfloat toGamma(float v) {\n  return pow(v, 1.0 / gamma_const);\n}\n\nvec2 toGamma(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_const));\n}\n\nvec3 toGamma(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_const));\n}\n\nvec4 toGamma(vec4 v) {\n  return vec4(toGamma(v.rgb), v.a);\n}\n\nfloat toGamma(float v, float gamma) {\n  return pow(v, 1.0 / gamma);\n}\n\nvec2 toGamma(vec2 v, float gamma) {\n  return pow(v, vec2(1.0 / gamma));\n}\n\nvec3 toGamma(vec3 v, float gamma) {\n  return pow(v, vec3(1.0 / gamma));\n}\n\nvec4 toGamma(vec4 v, float gamma) {\n  return vec4(toGamma(v.rgb, gamma), v.a);\n}\n\n\n");class zi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("FlatSurfaceShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n    vec4 viewPos = (modelViewMatrix * vec4(positions, 1.0));\n    gl_Position = projectionMatrix * viewPos;\n\n    v_viewPos = viewPos.xyz;\n    v_textureCoord = texCoords;\n    v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("FlatSurfaceShader.fragmentShader",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n\nuniform color BaseColor;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n#endif\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_TEXTURES\n    vec4 baseColor = BaseColor;\n#else\n    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n#endif\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    fragColor = baseColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e}static getGeomDataShaderName(){return "StandardSurfaceGeomDataShader"}static getSelectedShaderName(){return "StandardSurfaceSelectedGeomsShader"}}C.registerClass("FlatSurfaceShader",zi);class Ui extends zi{static isTransparent(){return !0}bind(e,t){return "ADD"==e.pass&&super.bind(e,t)}}C.registerClass("FlatAlphaSurfaceShader",Ui),Ja.setShaderModule("math/constants.glsl","\n\n#define PI 3.141592653589793\n#define TwoPI (2.0 * PI)\n#define HalfPI (0.5 * PI)\n\n"),Ja.setShaderModule("GGX_Specular.glsl",'\n\n\n<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>\n<%include file="utils/imagePyramid.glsl"/>\n\n// uniform ImageAtlas envMap;\n// see: GLImageAtlas.js: line 460.\nuniform sampler2D   envMapPyramid;\nuniform sampler2D   envMapPyramid_layout;\nuniform vec4        envMapPyramid_desc;\n\n\nvec3 sampleEnvMap(vec3 dir, float roughness) {\n    return sampleImagePyramid(dirToSphOctUv(dir), roughness, envMapPyramid_layout, envMapPyramid, envMapPyramid_desc).rgb;\n}\n\n\n// Borrowed heavily from here: http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n\nvec3 Fresnel_Schlick(float cosT, vec3 F0)\n{\n    return F0 + (vec3(1.0)-F0) * vec3(pow( 1.0 - cosT, 5.0));\n\n    // for now we calculate this in the suface shader\n    // float schlick = reflectance + pow((1.0-reflectance)*(1.0-dot(N,V)), 5.0);\n}\n\nfloat chiGGX(float v)\n{\n    return v > 0.0 ? 1.0 : 0.0;\n}\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 v)\n{\n    return clamp(v, vec3(0.0), vec3(1.0));\n}\n\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n    return max( dot( a, b ), 0.0 );   \n}\n\nfloat GGX_PartialGeometryTerm(vec3 v, vec3 n, vec3 h, float alpha)\n{\n    float VoH2 = saturate(dot(v,h));\n    float chi = chiGGX( VoH2 / saturate(dot(v,n)) );\n    VoH2 = VoH2 * VoH2;\n    float tan2 = ( 1.0 - VoH2 ) / VoH2;\n    return (chi * 2.0) / ( 1.0 + sqrt( 1.0 + alpha * alpha * tan2 ) );\n}\n\nvec3 GGX_Specular_PrefilteredEnv(vec3 normal, vec3 viewVector, float roughness, float fresnel)\n{\n    vec3 reflectionVector = reflect(-viewVector, normal);\n    vec3 radiance = vec3(0.0);\n    float NoV = saturate(dot(normal, viewVector));\n\n    vec3 sampleVector = reflectionVector;\n\n    // Calculate the half vector\n    vec3 halfVector = normalize(sampleVector + viewVector);\n    float cosT = saturatedDot(reflectionVector, normal);\n    float sinT = sqrt( 1.0 - cosT * cosT);\n\n    // Calculate fresnel\n    // vec3 fresnel = Fresnel_Schlick( saturate(dot( halfVector, viewVector ) ), F0 );\n    // Geometry term\n    float geometry = GGX_PartialGeometryTerm(viewVector, normal, halfVector, clamp(roughness, 0.01, 1.0)) * GGX_PartialGeometryTerm(reflectionVector, normal, halfVector, clamp(roughness, 0.01, 1.0));\n\n    // Calculate the Cook-Torrance denominator\n    float denominator = clamp( 4.0 * (NoV * saturate(dot(halfVector, normal)) + 0.05), 0.0, 1.0 );\n    // kS += fresnel;\n\n    // Accumulate the radiance\n    vec3 envColor = sampleEnvMap(reflectionVector, roughness);\n    radiance += envColor * geometry * fresnel * sinT / denominator;\n    //radiance += envColor * fresnel; // Removing "geometry" for now until we construct a better geometric shading term\n\n    return radiance;        \n}\n'),Ja.setShaderModule("PBRSurfaceRadiance.glsl","\n\nstruct MaterialParams {\n    vec3 baseColor;\n    float metallic;\n    float roughness;\n    float reflectance;\n};\n\nvec4 pbrSpecularReflectance(in MaterialParams materialParams, vec3 normal, in vec3 viewVector) {\n\n    float NdotV = dot(normal, viewVector);\n    \n    // -------------------------- Specular Reflectance --------------------------\n    // vec3 ks = vec3(0.0);\n    // vec3 specular = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, F0, ks );\n    // vec3 kd = (vec3(1.0) - ks) * vec3(1.0 - metallic);    \n\n    float schlickFresnel = materialParams.reflectance + pow((1.0-materialParams.reflectance)*(1.0-NdotV), 5.0);\n\n    vec3 specularReflectance = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, schlickFresnel);\n\n\n    // -------------------------- Specular Occlusion --------------------------\n    // Fast and quick way of reducing specular reflection in areas that are less exposed to the environment\n    // A better approch is to try screen space specular occlusion but need to check performance and feasibility in webGL\n    //float specularOcclusion = clamp(length(irradiance), 0.01, 1.0);    \n    //specularReflectance = (specularReflectance * specularOcclusion); \n\n    return vec4(specularReflectance, schlickFresnel);\n}\n\n\nvec3 pbrSurfaceRadiance(in MaterialParams materialParams, vec3 irradiance, vec3 normal, in vec3 viewVector) {\n\n    float NdotV = dot(normal, viewVector);\n    vec3 specularReflectance;\n\n    // -------------------------- Diffuse Reflectance --------------------------\n\n    vec3 diffuseReflectance = materialParams.baseColor * irradiance;\n\n    // From the Disney dielectric BRDF    \n    // Need to check if this is useful for us but the implementation works based on their paper\n    //diffuseReflectance = (diffuseReflectance / PI); // << [PT 18-08-2018] What did this line do??? (makes everything 3.1x darker.)\n    // diffuseReflectance = vec3(mix(diffuseReflectance, diffuseReflectance * mix(0.5, 2.5, materialParams.roughness), pow(1.0 - NdotV, 5.0)));\n    diffuseReflectance = vec3(mix(diffuseReflectance, diffuseReflectance * mix(0.5, 1.0, materialParams.roughness), pow(1.0 - NdotV, 5.0)));\n\n\n    // -------------------------- Color at normal incidence --------------------------\n    \n    // Need to use 'Reflectance' here instead of 'ior'\n    //vec3 F0 = vec3(abs((1.0 - ior) / (1.0 + ior)));    \n    //F0 = F0 * F0;\n    //F0 = mix(F0, materialParams.baseColor, materialParams.metallic);      \n\n\n    // -------------------------- Specular Reflectance --------------------------\n    // vec3 ks = vec3(0.0);\n    // vec3 specular = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, F0, ks );\n    // vec3 kd = (vec3(1.0) - ks) * vec3(1.0 - metallic);    \n\n    float schlickFresnel = materialParams.reflectance + pow((1.0-materialParams.reflectance)*(1.0-NdotV), 5.0);\n\n    specularReflectance = GGX_Specular_PrefilteredEnv(normal, viewVector, materialParams.roughness, schlickFresnel);\n\n\n    // -------------------------- Specular Occlusion --------------------------\n    // Fast and quick way of reducing specular reflection in areas that are less exposed to the environment\n    // A better approch is to try screen space specular occlusion but need to check performance and feasibility in webGL\n    //float specularOcclusion = clamp(length(irradiance), 0.01, 1.0);    \n    //specularReflectance = (specularReflectance * specularOcclusion);  \n      \n\n    // -------------------------- Metallic --------------------------\n    // We need to do few things given a higher > 0 metallic value\n    //      1. tint specular reflectance by the albedo color (not at grazing angles)\n    //      2. almost elliminate all diffuse reflectance (in reality metals have some diffuse due to layering (i.e. dust, prints, etc.))\n    //      3. set \"specular\" artistic value to metallic range (0.6 - 0.85)\n\n    specularReflectance = mix(specularReflectance, specularReflectance * materialParams.baseColor, materialParams.metallic);\n    diffuseReflectance = mix(diffuseReflectance, vec3(0.0,0.0,0.0), materialParams.metallic); // Leaveing at pure black for now but always need some %3 diffuse left for imperfection of pulished pure metal\n    // Would be best to compute reflectace internally and set here to 0.6-0.85 for metals\n    \n\n    // -------------------------- Final color --------------------------\n    // Energy conservation already taken into account in both the diffuse and specular reflectance\n    vec3 radiance = diffuseReflectance + specularReflectance;\n\n    // radiance = vec4( kd * diffuse + /*ks */ specular, 1);\n    return radiance;\n}\n");class Ji extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("LayeredCarPaintShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\nattribute vec2 lightmapCoords;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\nattribute float clusterIDs;\nuniform vec2 lightmapSize;\n\n/* VS Outputs */\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n// varying vec2 v_lightmapCoord;\n// #ifdef ENABLE_DEBUGGING_LIGHTMAPS\n// varying float v_clusterID;\n// #endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\nvoid main(void) {\n    int drawItemId = getDrawItemId();\n\n    v_geomItemData = getInstanceData(drawItemId);\n\n    vec4 pos = vec4(positions, 1.);\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    vec4 viewPos    = modelViewMatrix * pos;\n    gl_Position     = projectionMatrix * viewPos;\n\n\n#ifdef ENABLE_TEXTURES\n    v_textureCoord  = texCoords;\n#endif\n    // v_lightmapCoord = (lightmapCoords + geomItemData.zw) / lightmapSize;\n\n    // mat4 mvp = projectionMatrix * viewMatrix * modelMatrix;\n    // gl_Position = mvp * vec4((lightmapCoords + geomItemData.xy), 0., 1.);\n// #ifdef ENABLE_DEBUGGING_LIGHTMAPS\n//     v_clusterID = clusterIDs;\n// #endif\n\n    v_worldPos      = (modelMatrix * pos).xyz;\n    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n    v_viewPos       = -viewPos.xyz;\n    v_viewNormal    = normalMatrix * normals;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("LayeredCarPaintShader.fragmentShader",'\n#ifndef ENABLE_ES3\n    #extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GGX_Specular.glsl"/>\n<%include file="PBRSurfaceRadiance.glsl"/>\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\n#endif\n<%include file="materialparams.glsl"/>\n\n/* VS Outputs */\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n// varying vec2 v_lightmapCoord;\n// #ifdef ENABLE_DEBUGGING_LIGHTMAPS\n// varying float v_clusterID;\n// #endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n\nuniform sampler2D lightmap;\nuniform vec2 lightmapSize;\n#ifdef ENABLE_DEBUGGING_LIGHTMAPS\n<%include file="debugColors.glsl"/>\nuniform bool debugLightmapTexelSize;\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nuniform mat4 cameraMatrix;\n\nuniform color BaseColor;\nuniform color MidColorTint;\nuniform float MidColorTintReflectance;\n\nuniform float MicroflakePerturbation;\nuniform sampler2D FlakesNormalTex;\nuniform float FlakesScale;\n\n#ifdef ENABLE_SPECULAR\n\nuniform float BaseRoughness;\nuniform float BaseMetallic;\nuniform float BaseReflectance;\nuniform float GlossRoughness;\nuniform float GlossMetallic;\nuniform float GlossReflectance;\n\n#endif\n\n#ifdef ENABLE_TEXTURES\n\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n\n#endif\n\n// Followup: Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\nmat3 cotangent_frame( vec3 normal, vec3 position, vec2 uv )\n{\n    // get edge vectors of the pixel triangle\n    vec3 dp1 = dFdx( position );\n    vec3 dp2 = dFdy( position );\n    vec2 duv1 = dFdx( uv );\n    vec2 duv2 = dFdy( uv );\n \n    // solve the linear system\n    vec3 dp2perp = cross( dp2, normal );\n    vec3 dp1perp = cross( normal, dp1 );\n    vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n \n    // construct a scale-invariant frame \n    float invmax = inversesqrt( max( dot(tangent,tangent), dot(bitangent,bitangent) ) );\n    return mat3( tangent * invmax, bitangent * invmax, normal );\n}\n\n#define WITH_NORMALMAP_UNSIGNED 1\n\nvec3 sampleNormalMap( sampler2D normalMap, vec2 texcoord )\n{\n    // assume normal, the interpolated vertex normal and \n    // viewVec, the view vector (vertex to eye)\n    vec3 map = texture2D( normalMap, texcoord ).xyz;\n#ifdef WITH_NORMALMAP_UNSIGNED\n    map = map * 255./127. - 128./127.;\n#endif\n#ifdef WITH_NORMALMAP_2CHANNEL\n    map.z = sqrt( 1. - dot( map.xy, map.xy ) );\n#endif\n#ifdef WITH_NORMALMAP_GREEN_UP\n    map.y = -map.y;\n#endif\n    return map;\n}\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n    MaterialParams material;\n\n#ifndef ENABLE_TEXTURES\n    material.baseColor      = BaseColor.rgb;\n#else\n    vec2 texCoord           = vec2(v_textureCoord.x, 1.0 - v_textureCoord.y);\n    material.baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, texCoord).rgb;\n#endif\n\n#ifdef ENABLE_SPECULAR\n    material.roughness      = BaseRoughness;\n    material.metallic       = BaseMetallic;\n    material.reflectance    = BaseReflectance;\n#endif\n\n    vec3 irradiance = texture2D(lightmap, v_lightmapCoord).rgb;\n \n#ifdef ENABLE_DEBUGGING_LIGHTMAPS\n    if(debugLightmapTexelSize)\n    {\n        vec2 coord_texelSpace = (v_lightmapCoord * lightmapSize) - v_geomItemData.zw;\n        //vec2 coord_texelSpace = (v_textureCoord * lightmapSize);\n        float total = floor(coord_texelSpace.x) +\n                      floor(coord_texelSpace.y);\n                      \n        vec3 clustercolor = getDebugColor(v_clusterID);\n\n        if(mod(total,2.0)==0.0){\n            material.baseColor = clustercolor;\n            irradiance = vec3(1.0);\n        }\n        else{\n            material.baseColor = material.baseColor * 1.5;\n        }\n    }\n#endif\n\n    vec3 viewNormal = normalize(v_viewNormal);\n    vec3 surfacePos = -v_viewPos;\n\n    // The vector from the camera to the surface point.\n    vec3 viewVector = mat3(cameraMatrix) * normalize(v_viewPos);\n    vec3 viewDir = normalize(viewVector);\n    vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n\n    float NdotV = dot(normal, viewDir);\n    if(NdotV < 0.0){\n        normal = -normal;\n        NdotV = dot(normal, viewDir);\n    }\n\n#ifndef ENABLE_SPECULAR\n    vec3 radiance = material.baseColor * irradiance;\n#else\n    \n    // Mix the base color to give a multi-layered paint look.\n    material.baseColor      = mix(material.baseColor, material.baseColor * MidColorTint.rgb, (1.0-NdotV));\n\n    mat3 TBN = cotangent_frame( normal, surfacePos, v_lightmapCoord );\n    vec3 flakesNormal = TBN * -sampleNormalMap( FlakesNormalTex, (v_lightmapCoord * lightmapSize) / FlakesScale );\n    flakesNormal = normalize(mix(normal, flakesNormal, MicroflakePerturbation));\n\n    vec3 baseRadiance = pbrSurfaceRadiance(material, irradiance, flakesNormal, viewVector);\n\n    material.roughness      = GlossRoughness;\n    material.reflectance    = GlossReflectance;\n    vec4 gloss = pbrSpecularReflectance(material, normal, viewVector);\n    vec3 radiance = mix(baseRadiance, gloss.rgb, gloss.a);\n    //vec3 radiance = baseRadiance;\n\n#endif\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    fragColor = vec4(radiance, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();e.push({name:"BaseColor",defaultValue:new u(1,0,0)}),e.push({name:"BaseMetallic",defaultValue:0}),e.push({name:"BaseRoughness",defaultValue:.35}),e.push({name:"BaseReflectance",defaultValue:.03}),e.push({name:"MidColorTint",defaultValue:new u(1,1,1)}),e.push({name:"MidColorTintReflectance",defaultValue:.03}),e.push({name:"GlossMetallic",defaultValue:0}),e.push({name:"GlossRoughness",defaultValue:.35}),e.push({name:"GlossReflectance",defaultValue:.03});const t=new it("flakes","ZeaEngine/FlakesNormalMap.png");return t.wrap="REPEAT",t.mipMapped=!0,e.push({name:"FlakesNormal",defaultValue:t}),e.push({name:"FlakesScale",defaultValue:.1}),e.push({name:"MicroflakePerturbation",defaultValue:.1}),e}static getGeomDataShaderName(){return "StandardSurfaceGeomDataShader"}static getSelectedShaderName(){return "StandardSurfaceSelectedGeomsShader"}}C.registerClass("LayeredCarPaintShader",Ji);class Pi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("FlatShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\nattribute vec2 lightmapCoords;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 ProjectionCenter;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\nattribute float clusterIDs;\nuniform vec2 lightmapSize;\n\n/* VS Outputs */\n// varying vec2 v_lightmapCoord;\nvarying vec3 v_worldDir;\n\nvoid main(void) {\n    int drawItemId = getDrawItemId();\n\n    vec4 geomItemData = getInstanceData(drawItemId);\n\n    vec4 pos = vec4(positions, 1.);\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position     = modelViewProjectionMatrix * pos;\n\n    vec4 worldPos = modelMatrix * pos;\n    v_worldDir = worldPos.xyz - ProjectionCenter;\n\n    v_lightmapCoord = (lightmapCoords + geomItemData.zw) / lightmapSize;\n}\n');}}C.registerClass("ShadowCatcherShader",class extends Pi{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("ShadowCatcherShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\n#endif\n\n/* VS Outputs */\nvarying vec2 v_lightmapCoord;\nvarying vec3 v_worldDir;\n\nuniform sampler2D lightmap;\nuniform float ShadowMultiplier;\n\nuniform color envMap;\nuniform sampler2D envMapTex;\nuniform int envMapTexType;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nfloat luminanceFromRGB(vec3 rgb) {\n    return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n    vec4 env = envMap;\n    if(envMapTexType != 0) {\n        vec2 texCoord = dirToSphOctUv(normalize(v_worldDir));\n        env = texture2D(envMapTex, texCoord);\n    }\n\n    vec3 irradiance = texture2D(lightmap, v_lightmapCoord).rgb * ShadowMultiplier;\n    float irradianceLum = clamp(luminanceFromRGB(irradiance), 0.0, 1.0);\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    fragColor = vec4(env.rgb/env.a, 1.0);\n    fragColor.rgb = mix(fragColor.rgb * irradiance, fragColor.rgb, irradianceLum);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"ProjectionCenter",defaultValue:new d(0,0,1.7)}),e.push({name:"ShadowMultiplier",defaultValue:1}),e}static isTransparent(){return !0}bind(e,t){return "ADD"==e.pass&&super.bind(e,t)}});C.registerClass("FloatingShadowCatcherShader",class extends Pi{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("FloatingShadowCatcherShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="pragmatic-pbr/envmap-octahedral.glsl"/>\n\n/* VS Outputs */\nvarying vec2 v_lightmapCoord;\nvarying vec3 v_worldDir;\n\nuniform sampler2D lightmap;\n\nuniform float ShadowMultiplier;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    \n    float shadow = luminanceFromRGB(texture2D(lightmap, v_lightmapCoord).rgb) * ShadowMultiplier;\n\n    // This material works by multiplying the image buffer values by the luminance in the lightmap.\n    fragColor.rgb = vec3(pow(shadow, 1.0/ShadowMultiplier));\n    fragColor.a = 1.0;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n');}bind(e,t){return "MULTIPLY"==e.pass&&super.bind(e,t)}static isTransparent(){return !0}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"ShadowMultiplier",defaultValue:1}),e}});class Ei extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("LinesShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\n\nvoid main(void) {\n    int drawItemId = getDrawItemId();\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("LinesShader.fragmentShader","\nprecision highp float;\n\nuniform color BaseColor;\nuniform float Opacity;\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    fragColor = BaseColor;\n    fragColor.a *= Opacity;\n    \n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n"),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e.push({name:"Opacity",defaultValue:1}),e}static getGeomDataShaderName(){return "StandardSurfaceGeomDataShader"}static getSelectedShaderName(){return "StandardSurfaceSelectedGeomsShader"}static isTransparent(){return !0}bind(e,t){return "ADD"==e.pass&&super.bind(e,t)}}C.registerClass("LinesShader",Ei);class Hi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("NormalsShader.vertexShader",'\nprecision highp float;\n\ninstancedattribute vec3 positions;\ninstancedattribute vec3 normals;\nattribute vec2 vertexIDs;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform float normalLength;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n\n/* VS Outputs */\nvarying float v_weight;\n\nvoid main(void) {\n  mat4 modelMatrix = getModelMatrix(transformIndex);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n  if(vertexIDs.x == 0.0){\n    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);\n    v_weight = 1.0;\n  }\n  else{\n    gl_Position = modelViewProjectionMatrix * vec4(positions+(normals*normalLength), 1.0);\n    v_weight = 0.0;\n  }\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("NormalsShader.fragmentShader","\nprecision highp float;\n\nuniform color normalColor;\n\n/* VS Outputs */\nvarying float v_weight;\n\n\nvoid main(void) {\n  gl_FragColor = normalColor;\n  gl_FragColor.a = v_weight;\n}\n");}}class ki extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("PointsShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n  gl_Position = modelViewProjectionMatrix * vec4(positions, 1.);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("PointsShader.fragmentShader","\nprecision highp float;\n\nuniform color BaseColor;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = BaseColor;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e}}C.registerClass("PointsShader",ki);class Bi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("FatPointsShader.vertexShader",'\nprecision highp float;\n\ninstancedattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n<%include file="utils/quadVertexFromID.glsl"/>\n\nuniform float PointSize;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_drawItemId;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  vec2 quadPointPos = getQuadVertexPositionFromID();\n  v_texCoord = quadPointPos + 0.5;\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  \n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.);\n\n  viewPos += vec4(vec3(quadPointPos, 0.0) * PointSize, 0.);\n\n  // Generate a quad which is 0.5 * PointSize closer towards\n  // us. This allows points to be visualized even if snug on \n  // a surface. (else they get fully clipped)\n  viewPos.z += 0.5 * PointSize;\n\n  v_drawItemId = float(getDrawItemId());\n  v_viewPos = -viewPos.xyz;\n  \n  gl_Position = projectionMatrix * viewPos;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("FatPointsShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n\nuniform color BaseColor;\nuniform float Rounded;\nuniform float BorderWidth;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_drawItemId;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  float dist = length(v_texCoord - 0.5);\n  if(dist > 0.5)\n    discard;\n  if(dist > 0.5 - (BorderWidth * 0.5))\n    fragColor = vec4(0.,0.,0.,1.);\n  else {\n    // Modulate the lighting using the texture coord so the point looks round.\n    float NdotV = cos(dist * PI);\n\n    fragColor = BaseColor * mix(1.0, NdotV, Rounded);\n  }\n  \n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n');}bind(e){return !!super.bind(e)&&(e.supportsInstancing=!1,!0)}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e.push({name:"PointSize",defaultValue:.05}),e.push({name:"Rounded",defaultValue:1}),e.push({name:"BorderWidth",defaultValue:.2}),e}static getGeomDataShaderName(){return "FatPointsGeomDataShader"}static getSelectedShaderName(){return "FatPointsSelectedShader"}}class Di extends Bi{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("FatPointsGeomDataShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLBits.glsl"/>\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_drawItemId;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  float dist = length(v_texCoord - 0.5);\n  if(dist > 0.5)\n    discard;\n    \n\n  float viewDist = length(v_viewPos);\n\n  if(floatGeomBuffer != 0) {\n    fragColor.r = float(passId); \n    fragColor.g = float(v_drawItemId);\n    fragColor.b = 0.0;// TODO: store poly-id or something.\n    fragColor.a = viewDist;\n  }\n  else {\n    ///////////////////////////////////\n    // UInt8 buffer\n    fragColor.r = (mod(v_drawItemId, 256.) + 0.5) / 255.;\n    fragColor.g = (floor(v_drawItemId / 256.) + 0.5) / 255.;\n\n    // encode the dist as a 16 bit float\n    vec2 float16bits = encode16BitFloatInto2xUInt8(viewDist);\n    fragColor.b = float16bits.x;\n    fragColor.a = float16bits.y;\n  }\n\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n');}}class Oi extends Bi{constructor(e){super(e),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("FatPointsSelectedShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLBits.glsl"/>\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_drawItemId;\n\n\n<%include file="drawItemTexture.glsl"/>\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n    return highlightColor;\n}\n\n#endif\n\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  float dist = length(v_texCoord - 0.5);\n  if(dist > 0.5)\n    discard;\n  \n  int drawItemId = int(v_drawItemId + 0.5);\n  fragColor = getHighlightColor(drawItemId);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n');}}C.registerClass("FatPointsShader",Bi),C.registerClass("FatPointsGeomDataShader",Di),C.registerClass("FatPointsSelectedShader",Oi),Ja.setShaderModule("pragmatic-pbr/exposure.glsl","\n\n/*\n* Get an exposure using the Saturation-based Speed method.\n*/\nfloat getSaturationBasedExposure(float aperture,\n                                 float shutterSpeed,\n                                 float iso)\n{\n    float l_max = (7800.0 / 65.0) * sqrt(aperture) / (iso * shutterSpeed);\n    return 1.0 / l_max;\n}\n\n//White balance middle grey we are targetting for a good scene exposure\n//https://en.wikipedia.org/wiki/Middle_gray\nconst float MIDDLE_GREY = 0.18;\n\n/*\n* Get an exposure using the Standard Output Sensitivity method.\n* Accepts an additional parameter of the target middle grey.\n*/\nfloat getStandardOutputBasedExposure(float aperture,\n                                     float shutterSpeed,\n                                     float iso)\n{\n    //https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n    //https://en.wikipedia.org/wiki/Film_speed#Standard_output_sensitivity_.28SOS.29\n    //photometric exposure magic\n    //represents the properties of lens\n    float q = 0.65;\n\n    //float l_avg = (1000.0f / 65.0f) * sqrt(aperture) / (iso * shutterSpeed);\n    float l_avg = (1.0 / q) * sqrt(aperture) / (iso * shutterSpeed);\n    //float l_avg = sqrt(aperture) / (iso * shutterSpeed);\n    return MIDDLE_GREY / l_avg;\n}\n\n"),Ja.setShaderModule("pragmatic-pbr/tonemap-filmic.glsl","\n\n//Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75\nvec3 tonemapFilmic(vec3 color) {\n    vec3 x = max(vec3(0.0), color - 0.004);\n    return (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\n"),Ja.setShaderModule("mattdesl/fxaa-texcoords.glsl","\n//To save 9 dependent texture reads, you can compute\n//these in the vertex shader and use the optimized\n//frag.glsl function in your frag shader. \n\n//This is best suited for mobile devices, like iOS.\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\n            out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\n"),Ja.setShaderModule("mattdesl/fxaa.glsl",'\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it\'s\nunsupported by WebGL.\n--\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\nCopyright (c) 2011 by Armin Ronacher.\nSome rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n'),Ja.setShaderModule("mattdesl/fxaa-apply.glsl",'\n\n<%include file="mattdesl/fxaa.glsl"/>\n\nvec4 apply(sampler2D tex, vec2 fragCoord, vec2 resolution) {\n    mediump vec2 v_rgbNW;\n    mediump vec2 v_rgbNE;\n    mediump vec2 v_rgbSW;\n    mediump vec2 v_rgbSE;\n    mediump vec2 v_rgbM;\n\n    //compute the texture coords\n    texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n    \n    //compute FXAA\n    return fxaa(tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n\n');class Qi extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("PostProcessing.vertexShader",'\nprecision highp float;\n\n<%include file="utils/quadVertexFromID.glsl"/>\n<%include file="mattdesl/fxaa-texcoords.glsl"/>\n\nuniform vec2 textureSize;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\n \nvoid main()\n{\n    vec2 position = getQuadVertexPositionFromID();\n    v_texCoord = position+0.5;\n    gl_Position = vec4(position*2.0, 0.0, 1.0);\n\n    vec2 fragCoord = v_texCoord * textureSize;\n    texcoords(fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("PostProcessing.fragmentShader",'\nprecision highp float;\n\n<%include file="pragmatic-pbr/exposure.glsl"/>\n<%include file="pragmatic-pbr/tonemap-filmic.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n\n<%include file="mattdesl/fxaa.glsl"/>\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform sampler2D texture;\nuniform vec2 textureSize;\n\nuniform bool antialiase;\nuniform bool tonemap;\nuniform float exposure;\nuniform float gamma;\n\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n    //can also use gl_FragCoord.xy\n    mediump vec2 fragCoord = v_texCoord * textureSize; \n\n    if (antialiase) {\n        fragColor = fxaa(texture, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n    } else {\n        fragColor = texture2D(texture, v_texCoord);\n    }\n    \n    //fragColor.rgb *= getStandardOutputBasedExposure(aperture, shutterSpeed, iso);\n    fragColor.rgb *= exposure;\n    \n    if (tonemap) \n        fragColor.rgb = tonemapFilmic(fragColor.rgb);\n    else\n        fragColor.rgb = toGamma(fragColor.rgb, gamma);\n\n    \n    //fragColor.rgb = toGamma(fragColor.rgb, gamma);\n    \n    fragColor.a = 1.0;\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}'),this.finalize();}}class Ai extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("SimpleSurfaceShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n    int drawItemId = getDrawItemId();\n    v_drawItemId = float(drawItemId);\n    v_geomItemData  = getInstanceData(drawItemId);\n\n    vec4 pos = vec4(positions, 1.);\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    vec4 viewPos    = modelViewMatrix * pos;\n    gl_Position     = projectionMatrix * viewPos;\n\n    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n    v_viewPos       = -viewPos.xyz;\n    v_viewNormal    = normalMatrix * normals;\n\n#ifdef ENABLE_TEXTURES\n    v_textureCoord  = texCoords;\n    // v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n    v_worldPos      = (modelMatrix * pos).xyz;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("SimpleSurfaceShader.fragmentShader",'\nprecision highp float;\n\n<%include file="drawItemTexture.glsl"/>\n<%include file="cutaways.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nuniform mat4 cameraMatrix;\n\nuniform color BaseColor;\nuniform float Opacity;\n\n#ifdef ENABLE_TEXTURES\n\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\nuniform sampler2D OpacityTex;\nuniform int OpacityTexType;\n\nuniform color cutColor;\nvec4 getCutaway(int id) {\n    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n}\n\n#endif\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\n\nvoid main(void) {\n    int drawItemId = int(v_drawItemId + 0.5);\n\n    int flags = int(v_geomItemData.r + 0.5);\n    // Cutaways\n    if(testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n    {\n        vec4 cutAwayData   = getCutaway(drawItemId);\n        vec3 planeNormal = cutAwayData.xyz;\n        float planeDist = cutAwayData.w;\n        if(cutaway(v_worldPos, planeNormal, planeDist)){\n            discard;\n            return;\n        }\n        else if(!gl_FrontFacing){\n            fragColor = cutColor;\n#ifndef ENABLE_ES3\n            gl_FragColor = fragColor;\n#endif\n            return;\n        }\n    }\n\n#ifndef ENABLE_TEXTURES\n    vec4 baseColor      = BaseColor;\n    float opacity       = baseColor.a * Opacity;\n#else\n    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n    float opacity       = baseColor.a * getLuminanceParamValue(Opacity, OpacityTex, OpacityTexType, v_textureCoord);\n#endif\n\n    // Hacky simple irradiance. \n    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n    vec3 normal = normalize(mat3(cameraMatrix) * v_viewNormal);\n    float ndotv = dot(normal, viewVector);\n    if(ndotv < 0.0){\n        normal = -normal;\n        ndotv = dot(normal, viewVector);\n\n        // Note: these 2 lines can be used to debug inverted meshes.\n        //baseColor = vec4(1.0, 0.0, 0.0, 1.0);\n        //ndotv = 1.0;\n    }\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    fragColor = vec4(ndotv * baseColor.rgb, opacity);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e.push({name:"Opacity",defaultValue:1,range:[0,1]}),e}static getGeomDataShaderName(){return "StandardSurfaceGeomDataShader"}static getSelectedShaderName(){return "StandardSurfaceSelectedGeomsShader"}}C.registerClass("SimpleSurfaceShader",Ai),Ja.setShaderModule("cutaways.glsl","\n\n\nconst int GEOMITEM_FLAG_CUTAWAY =  1; // 1<<0;\n\n#define RAY_EPS 0.0000001\nstruct Ray {\n    vec3 start;\n    vec3 dir;\n};\n\nfloat intersectRayPlane(Ray ray, Ray plane) {\n    vec3 w = ray.start - plane.start;\n    float D = dot(plane.dir, ray.dir);\n    float N = dot(-plane.dir, w);\n\n    if (abs(D) < RAY_EPS) {\n        // segment is parallel to plane\n        if (N == 0.0)\n            return -1.0; // segment lies in plane\n        else\n            return -1.0; // no intersection\n    }\n    // they are not parallel\n    // compute intersect param\n    float sI = N / D;\n    if (sI < -RAY_EPS) {\n        return -1.0; // no intersection\n    }\n    return sI;\n}\n\n\nbool cutaway(vec3 worldPos, vec3 planeNormal, float planeDist) {\n\n    vec3 planePos = planeNormal * planeDist;\n    vec3 planeDir = worldPos + planePos;\n    float planeOffset = dot(planeDir, planeNormal);\n    if(planeOffset > 0.0){\n        return true;\n    }\n    return  false;\n}\n");class ji extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("StandardSurfaceShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\nattribute vec2 lightmapCoords;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n// attribute float clusterIDs;\n// uniform vec2 lightmapSize;\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n// varying vec2 v_lightmapCoord;\n// #ifdef ENABLE_DEBUGGING_LIGHTMAPS\n// varying float v_clusterID;\n// #endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n\nvoid main(void) {\n    int drawItemId = getDrawItemId();\n    v_drawItemId = float(drawItemId);\n    v_geomItemData = getInstanceData(drawItemId);\n\n    vec4 pos = vec4(positions, 1.);\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    vec4 viewPos    = modelViewMatrix * pos;\n    gl_Position     = projectionMatrix * viewPos;\n\n    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n    v_viewPos       = -viewPos.xyz;\n    v_viewNormal    = normalMatrix * normals;\n\n#ifdef ENABLE_TEXTURES\n    v_textureCoord  = texCoords;\n#endif\n\n    // v_lightmapCoord = (lightmapCoords + v_geomItemData.zw) / lightmapSize;\n\n    // mat4 mvp = projectionMatrix * viewMatrix * modelMatrix;\n    // gl_Position = mvp * vec4((lightmapCoords + v_geomItemData.zw), 0., 1.);\n#ifdef ENABLE_DEBUGGING_LIGHTMAPS\n    v_clusterID = clusterIDs;\n#endif\n\n    v_worldPos      = (modelMatrix * pos).xyz;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("StandardSurfaceShader.fragmentShader",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="cutaways.glsl"/>\n\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n\n<%include file="GGX_Specular.glsl"/>\n<%include file="PBRSurfaceRadiance.glsl"/>\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n// varying vec2 v_lightmapCoord;\n// #ifdef ENABLE_DEBUGGING_LIGHTMAPS\n// varying float v_clusterID;\n// #endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n\n// uniform sampler2D lightmap;\n// uniform bool lightmapConnected;\n// #ifdef ENABLE_DEBUGGING_LIGHTMAPS\n// <%include file="debugColors.glsl"/>\n// uniform vec2 lightmapSize;\n// uniform bool debugLightmapTexelSize;\n// #endif\n\nuniform color cutColor;\nvec4 getCutaway(int id) {\n    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n}\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nuniform mat4 cameraMatrix;\n\nuniform color BaseColor;\nuniform float EmissiveStrength;\n\n\n#ifdef ENABLE_SPECULAR\nuniform float Roughness;\nuniform float Metallic;\nuniform float Reflectance;\n#endif\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n\n#ifdef ENABLE_SPECULAR\nuniform sampler2D RoughnessTex;\nuniform int RoughnessTexType;\n\nuniform sampler2D MetallicTex;\nuniform int MetallicTexType;\n\nuniform sampler2D ReflectanceTex;\nuniform int ReflectanceTexType;\n\nuniform sampler2D NormalTex;\nuniform int NormalTexType;\n// uniform float NormalScale;\n#endif\n\nuniform sampler2D EmissiveStrengthTex;\nuniform int EmissiveStrengthTexType;\n\n\n#endif\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n\n#endif\n\nvoid main(void) {\n    int drawItemId = int(v_drawItemId + 0.5);\n\n    int flags = int(v_geomItemData.r + 0.5);\n    // Cutaways\n    if(testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n        vec4 cutAwayData   = getCutaway(drawItemId);\n        vec3 planeNormal = cutAwayData.xyz;\n        float planeDist = cutAwayData.w;\n        if(cutaway(v_worldPos, planeNormal, planeDist)){\n            discard;\n            return;\n        }\n        else if(!gl_FrontFacing){\n            fragColor = cutColor;\n#ifndef ENABLE_ES3\n            gl_FragColor = fragColor;\n#endif\n            return;\n        }\n    }\n\n\n    MaterialParams material;\n\n#ifndef ENABLE_TEXTURES\n    material.BaseColor     = BaseColor.rgb;\n    float emission         = EmissiveStrength;\n\n#ifdef ENABLE_SPECULAR\n    material.roughness     = Roughness;\n    material.metallic      = Metallic;\n    material.reflectance   = Reflectance;\n#endif\n\n#else\n    // Planar YZ projection for texturing, repeating every meter.\n    // vec2 texCoord       = v_worldPos.xz * 0.2;\n    vec2 texCoord          = vec2(v_textureCoord.x, 1.0 - v_textureCoord.y);\n    material.baseColor     = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, texCoord).rgb;\n\n#ifdef ENABLE_SPECULAR\n    material.roughness     = getLuminanceParamValue(Roughness, RoughnessTex, RoughnessTexType, texCoord);\n    material.metallic      = getLuminanceParamValue(Metallic, MetallicTex, MetallicTexType, texCoord);\n    material.reflectance   = getLuminanceParamValue(Reflectance, ReflectanceTex, ReflectanceTexType, texCoord);\n#endif\n    float emission         = getLuminanceParamValue(EmissiveStrength, EmissiveStrengthTex, EmissiveStrengthTexType, texCoord);\n#endif\n\n    vec3 viewNormal = normalize(v_viewNormal);\n    //vec3 surfacePos = -v_viewPos;\n\n#ifdef ENABLE_TEXTURES\n#ifdef ENABLE_SPECULAR\n    if(NormalTexType != 0){\n        vec3 textureNormal_tangentspace = normalize(texture2D(NormalTex, texCoord).rgb * 2.0 - 1.0);\n        viewNormal = normalize(mix(viewNormal, textureNormal_tangentspace, 0.3));\n    }\n#endif\n#endif\n\n    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n    vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n    if(dot(normal, viewVector) < 0.0){\n        normal = -normal;\n        // Note: this line can be used to debug inverted meshes.\n        //material.baseColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    vec3 irradiance;\n    // if(lightmapConnected){\n    //     irradiance = texture2D(lightmap, v_lightmapCoord).rgb;\n    // }\n    // else{\n#ifndef ENABLE_SPECULAR\n        irradiance = sampleEnvMap(normal, 1.0);\n#else\n        irradiance = vec3(dot(normal, viewVector));\n#endif\n        \n    // }\n\n// #ifdef ENABLE_DEBUGGING_LIGHTMAPS\n//     if(debugLightmapTexelSize)\n//     {\n//         vec2 coord_texelSpace = (v_lightmapCoord * lightmapSize) - v_geomItemData.zw;\n//         //vec2 coord_texelSpace = (v_textureCoord * lightmapSize);\n//         float total = floor(coord_texelSpace.x) +\n//                       floor(coord_texelSpace.y);\n                      \n//         vec3 clustercolor = getDebugColor(v_clusterID);\n\n//         material.metallic = 0.0;\n//         material.reflectance = 0.0;\n//         if(mod(total,2.0)==0.0){\n//             material.baseColor = clustercolor;\n//             irradiance = vec3(1.0);\n//         }\n//         else{\n//             material.baseColor = material.baseColor * 1.5;\n//         }\n//     }\n// #endif\n\n#ifndef ENABLE_SPECULAR\n    vec3 radiance = material.baseColor * irradiance;\n#else\n    vec3 radiance = pbrSurfaceRadiance(material, irradiance, normal, viewVector);\n#endif\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    // fragColor = vec4(material.baseColor, 1.0);\n    // fragColor = vec4(material.baseColor * irradiance, 1.0);\n    fragColor = vec4(radiance + (emission * material.baseColor), 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e.push({name:"Metallic",defaultValue:0,range:[0,1]}),e.push({name:"Roughness",defaultValue:.85,range:[0,1]}),e.push({name:"Reflectance",defaultValue:.1,range:[0,1]}),e.push({name:"EmissiveStrength",defaultValue:0,range:[0,1]}),e}static getGeomDataShaderName(){return "StandardSurfaceGeomDataShader"}static getSelectedShaderName(){return "StandardSurfaceSelectedGeomsShader"}}C.registerClass("StandardSurfaceShader",ji),Ja.setShaderModule("GLSLBits.glsl",'\n    \n/////////////////////////////////////////////////////////////////\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\nfloat shift_right(float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\nfloat shift_left(float v, float amt) {\n  return floor(v * exp2(amt) + 0.5);\n}\n\nfloat mask_last(float v, float bits) {\n  return mod(v, shift_left(1.0, bits));\n}\nfloat extract_bits(float num, float from, float to) {\n  from = floor(from + 0.5);\n  to = floor(to + 0.5);\n  return mask_last(shift_right(num, from), to - from);\n}\n\n/////////////////////////////////////////////////////////////////\n// https://stackoverflow.com/questions/18453302/how-do-you-pack-one-32bit-int-into-4-8bit-ints-in-glsl-webgl\n\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\nvec4 EncodeFloatRGBA (float v) {\n    vec4 enc = bitEnc * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec2(1./255., 0.).xxxy;\n    return enc;\n}\nfloat DecodeFloatRGBA (vec4 v) {\n    return dot(v, bitDec);\n}\n\n\n\n/////////////////////////////////////////////////////////////////\n// https://gist.github.com/Flexi23/1713774\n// \nvec2 encode16BitFloatInto2xUInt8(float v){\n    vec2 c = vec2(0.);\n\n    int signum = (v >= 0.) ? 128 : 0;\n    v = abs(v);\n    int exponent = 15;\n    float limit = 1024.; // considering the bias from 2^-5 to 2^10 (==1024)\n    for(int exp = 15; exp > 0; exp--){\n        if( v < limit){\n            limit /= 2.;\n            exponent--;\n        }\n    }\n\n    float rest;\n    if(exponent == 0){\n        rest = v / limit / 2.;      // "subnormalize" implicite preceding 0. \n    }else{\n        rest = (v - limit)/limit;   // normalize accordingly to implicite preceding 1.\n    }\n\n    int mantissa = int(rest * 2048.);   // 2048 = 2^11 for the (split) 11 bit mantissa\n    int msb = mantissa / 256;           // the most significant 3 bits go into the lower part of the first byte\n    int lsb = mantissa - msb * 256;     // there go the other 8 bit of the lower significance\n\n    c.x = float(signum + exponent * 8 + msb) / 255.;    // color normalization for texture2D\n    c.y = float(lsb) / 255.;\n\n    if(v >= 2048.){\n        c.y = 1.;\n    }\n\n    return c;\n}\n\nfloat decode16BitFloatFrom2xUInt8(vec2 c){\n    float v = 0.;\n\n    int ix = int(c.x*255.); // 1st byte: 1 bit signum, 4 bits exponent, 3 bits mantissa (MSB)\n    int iy = int(c.y*255.); // 2nd byte: 8 bit mantissa (LSB)\n\n    int s = (c.x >= 0.5) ? 1 : -1;\n    ix = (s > 0) ? ix - 128 : ix;   // remove the signum bit from exponent\n    int iexp = ix / 8;              // cut off the last 3 bits of the mantissa to select the 4 exponent bits\n    int msb = ix - iexp * 8;        // subtract the exponent bits to select the 3 most significant bits of the mantissa\n\n    int norm = (iexp == 0) ? 0 : 2048;          // distinguish between normalized and subnormalized numbers\n    int mantissa = norm + msb * 256 + iy;       // implicite preceding 1 or 0 added here\n    norm = (iexp == 0) ? 1 : 0;                 // normalization toggle\n    float exponent = pow( 2., float(iexp + norm) - 16.); // -5 for the the exponent bias from 2^-5 to 2^10 plus another -11 for the normalized 12 bit mantissa \n    v = float( s * mantissa ) * exponent;\n\n    return v;\n}\n\n\n// TODO : Encoding Float32 to 4x UInt8\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\n// http://ultraist.hatenablog.com/entry/20110608/1307539319\n\n');class qi extends Pa{constructor(e,t){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("StandardSurfaceGeomDataShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData = getInstanceData(drawItemId);\n\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec4 viewPos = modelViewMatrix * pos;\n  gl_Position = projectionMatrix * viewPos;\n\n  v_viewPos = -viewPos.xyz;\n\n  v_drawItemID = float(getDrawItemId());\n  \n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("StandardSurfaceGeomDataShader.fragmentShader",'\nprecision highp float;\n\n<%include file="drawItemTexture.glsl"/>\n<%include file="cutaways.glsl"/>\n<%include file="GLSLBits.glsl"/>\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\nuniform color cutColor;\nvec4 getCutaway(int id) {\n    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n}\n\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n  int drawItemId = int(v_drawItemId + 0.5);\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n  int flags = int(v_geomItemData.r + 0.5);\n  // Cutaways\n  if(testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n      vec4 cutAwayData   = getCutaway(drawItemId);\n      vec3 planeNormal = cutAwayData.xyz;\n      float planeDist = cutAwayData.w;\n      if(cutaway(v_worldPos, planeNormal, planeDist)){\n          discard;\n          return;\n      }\n      else if(!gl_FrontFacing){\n          fragColor = cutColor;\n  #ifndef ENABLE_ES3\n          gl_FragColor = fragColor;\n  #endif\n          return;\n      }\n  }\n\n    float dist = length(v_viewPos);\n\n    if(floatGeomBuffer != 0) {\n        fragColor.r = float(passId); \n        fragColor.g = float(v_drawItemID);\n        fragColor.b = 0.0;// TODO: store poly-id or something.\n        fragColor.a = dist;\n    }\n    else {\n        ///////////////////////////////////\n        // UInt8 buffer\n        fragColor.r = (mod(v_drawItemID, 256.) + 0.5) / 255.;\n        fragColor.g = (floor(v_drawItemID / 256.) + 0.5) / 255.;\n\n\n        // encode the dist as a 16 bit float\n        vec2 float16bits = encode16BitFloatInto2xUInt8(dist);\n        fragColor.b = float16bits.x;\n        fragColor.a = float16bits.y;\n    }\n\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n');}}C.registerClass("StandardSurfaceGeomDataShader",qi);class $i extends Pa{constructor(e,t){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("StandardSurfaceSelectedGeomsShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\nvarying float v_drawItemId;\n\nvoid main(void) {\n    int drawItemId = getDrawItemId();\n    v_drawItemId = float(drawItemId);\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);\n    gl_Position = projectionMatrix * viewPos;\n\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("StandardSurfaceSelectedGeomsShader.fragmentShader",'\nprecision highp float;\n\nvarying float v_drawItemId;\n\n\n<%include file="drawItemTexture.glsl"/>\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n    return highlightColor;\n}\n\n#endif\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    int drawItemId = int(v_drawItemId + 0.5);\n    fragColor = getHighlightColor(drawItemId);\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n');}}C.registerClass("StandardSurfaceSelectedGeomsShader",$i);class es extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("HandleShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int maintainScreenSize;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  if(maintainScreenSize != 0) {\n    float dist = modelViewMatrix[3][2];\n    float sc = dist;\n    mat4 scmat = mat4(\n      sc, 0.0, 0.0, 0.0,\n      0.0, sc, 0.0, 0.0,\n      0.0, 0.0, sc, 0.0,\n      0.0, 0.0, 0.0, 1.0\n    );\n    modelViewMatrix = modelViewMatrix * scmat;\n  }\n\n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);\n  gl_Position = projectionMatrix * viewPos;\n\n  v_viewPos = viewPos.xyz;\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("HandleShader.fragmentShader",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n\nuniform color BaseColor;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n#endif\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_TEXTURES\n    vec4 baseColor = BaseColor;\n#else\n    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n#endif\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    fragColor = baseColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e.push({name:"maintainScreenSize",defaultValue:0}),e}static isOverlay(){return !0}static getGeomDataShaderName(){return "HandleGeomDataShader"}}C.registerClass("HandleShader",es);class ts extends qi{constructor(e,t){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("HandleGeomDataShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int maintainScreenSize;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  \n  if(maintainScreenSize != 0) {\n    float dist = modelViewMatrix[3][2];\n    float sc = dist;\n    mat4 scmat = mat4(\n      sc, 0.0, 0.0, 0.0,\n      0.0, sc, 0.0, 0.0,\n      0.0, 0.0, sc, 0.0,\n      0.0, 0.0, 0.0, 1.0\n    );\n    modelViewMatrix = modelViewMatrix * scmat;\n  }\n\n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);\n  gl_Position = projectionMatrix * viewPos;\n\n  v_viewPos = -viewPos.xyz;\n\n  v_drawItemID = float(getDrawItemId());\n}\n');}}C.registerClass("HandleGeomDataShader",ts);class as extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("TransparentSurfaceShader.vertexShader",'\nprecision highp float;\n\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\nvoid main(void) {\n    int drawItemId = getDrawItemId();\n\n    vec4 geomItemData = getInstanceData(drawItemId);\n\n    vec4 pos = vec4(positions, 1.);\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    vec4 viewPos    = modelViewMatrix * pos;\n    gl_Position     = projectionMatrix * viewPos;\n\n    // mat4 mvp = projectionMatrix * viewMatrix * modelMatrix;\n    // gl_Position = mvp * vec4((lightmapCoords + geomItemData.xy), 0., 1.);\n\n    v_worldPos      = (modelMatrix * pos).xyz;\n\n    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n    v_viewPos       = -viewPos.xyz;\n    v_viewNormal    = normalMatrix * normals;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("TransparentSurfaceShader.fragmentShader",'\nprecision highp float;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n<%include file="stack-gl/gamma.glsl"/>\n#endif\n<%include file="GLSLUtils.glsl"/>\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nuniform mat4 cameraMatrix;\nuniform float planeDist;\nuniform float planeAngle;\n\nuniform color BaseColor;\nuniform float Opacity;\n\n#ifdef ENABLE_SPECULAR\n<%include file="math/constants.glsl"/>\n<%include file="GGX_Specular.glsl"/>\n<%include file="PBRSurfaceRadiance.glsl"/>\nuniform float Roughness;\nuniform float Metallic;\nuniform float Reflectance;\n#endif\n\n#ifdef __ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform bool BaseColorTexType;\n\nuniform sampler2D OpacityTex;\nuniform bool OpacityTexType;\n\nuniform sampler2D RoughnessTex;\nuniform bool RoughnessTexType;\n\nuniform sampler2D ReflectanceTex;\nuniform bool ReflectanceTexType;\n\nuniform sampler2D NormalTex;\nuniform bool NormalTexType;\nuniform float NormalScale;\n\n\n#endif\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n    MaterialParams material;\n\n#ifndef __ENABLE_TEXTURES\n    material.baseColor      = BaseColor.rgb;\n    float opacity           = Opacity;\n\n#ifdef ENABLE_SPECULAR\n    material.roughness      = Roughness;\n    material.metallic       = Metallic;\n    material.reflectance    = Reflectance;\n#endif\n\n#else\n    // Planar YZ projection for texturing, repeating every meter.\n    // vec2 texCoord        = v_worldPos.xz * 0.2;\n    vec2 texCoord           = vec2(v_textureCoord.x, 1.0 - v_textureCoord.y);\n    material.baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, texCoord).rgb;\n    material.roughness      = getLuminanceParamValue(Roughness, RoughnessTex, RoughnessTexType, texCoord);\n    material.metallic       = getLuminanceParamValue(Metallic, MetallicTex, MetallicTexType, texCoord);\n    material.reflectance    = Reflectance;//getLuminanceParamValue(Reflectance, ReflectanceTex, ReflectanceTexType, texCoord);\n\n    float opacity           = getLuminanceParamValue(Opacity, OpacityTex, OpacityTexType, texCoords);\n#endif\n\n#ifndef ENABLE_SPECULAR\n    gl_FragColor = vec4(material.baseColor.rgb, opacity);\n#else\n\n    vec3 viewNormal = normalize(v_viewNormal);\n    //vec3 surfacePos = -v_viewPos;\n\n#ifdef __ENABLE_TEXTURES\n    if(NormalTexType != 0){\n        vec3 textureNormal_tangentspace = normalize(texture2D(NormalTex, texCoord).rgb * 2.0 - 1.0);\n        viewNormal = normalize(mix(viewNormal, textureNormal_tangentspace, 0.3));\n    }\n#endif\n\n    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n    vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n    if(dot(normal, viewVector) < 0.0){\n        normal = -normal;\n        // Note: this line can be used to debug inverted meshes.\n        //material.baseColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    vec4 specularReflectance = pbrSpecularReflectance(material, normal, viewVector);\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    fragColor = vec4(specularReflectance.rgb, mix(opacity, 1.0, specularReflectance.a));\n\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e.push({name:"Opacity",defaultValue:1,range:[0,1]}),e.push({name:"Roughness",defaultValue:.85}),e.push({name:"Reflectance",defaultValue:1e-4}),e}static getGeomDataShaderName(){return "StandardSurfaceGeomDataShader"}static getSelectedShaderName(){return "StandardSurfaceSelectedGeomsShader"}static isTransparent(){return !0}bind(e,t){return "ADD"==e.pass&&super.bind(e,t)}}C.registerClass("TransparentSurfaceShader",as);class is extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("ScreenSpaceShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\n/* VS Outputs */\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n    mat4 modelMatrix = getModelMatrix(drawItemId);\n\n    gl_Position = (modelMatrix * vec4(positions, 1.0));\n\n    v_textureCoord = texCoords;\n    v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("ScreenSpaceShader.fragmentShader",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n\nuniform color BaseColor;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n#endif\n\n/* VS Outputs */\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_TEXTURES\n    vec4 baseColor = BaseColor;\n#else\n    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n#endif\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    fragColor = baseColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.finalize();}static isOverlay(){return !0}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new u(1,1,.5)}),e}static getGeomDataShaderName(){return null}static getSelectedShaderName(){return null}}C.registerClass("ScreenSpaceShader",is);class ss extends zi{constructor(e){super(e),this.invisibleToGeomBuffer=!0;}}C.registerClass("ToolIconShader",ss);class ns extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("UnpackLDRAlphaImageShader.vertexShader",'\nprecision highp float;\n\n<%include file="utils/quadVertexFromID.glsl"/>\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    vec2 position = getQuadVertexPositionFromID();\n    v_texCoord = position+0.5;\n    gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("UnpackLDRAlphaImageShader.fragmentShader","\nprecision highp float;\n\nvarying vec2 v_texCoord;\nuniform sampler2D ldrSampler;\nuniform sampler2D alphaSampler;\n\nfloat luminanceFromRGB(vec3 rgb) {\n    return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    fragColor = vec4(texture2D(ldrSampler, v_texCoord).rgb, luminanceFromRGB(texture2D(alphaSampler, v_texCoord).rgb));\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n\n");}}class ls extends Pa{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=Ja.parseShader("WireShader.vertexShader","\nprecision highp float;\n\nattribute vec3 positions;    //(location = 0)\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n/* VS Outputs */\n\nvoid main(void) {\n    mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);\n\n    // Apply the perspective transform, and then move the vertices\n    //  towards the camera by a tiny little bit...\n    gl_Position.z -= 0.001 / gl_Position.w;\n    //gl_Position.z *= 0.999;\n}\n"),this.__shaderStages.FRAGMENT_SHADER=Ja.parseShader("WireShader.fragmentShader","\nprecision highp float;\n\nuniform color wireColor;\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifdef ENABLE_ES3\n    gl_FragColor = color;\n#else\n    fragColor = color;\n#endif  \n}\n");}}const rs=0,os=1,ds=2,hs=3;class cs{constructor(e,t,a,i,s=null){this.gl=e,this.geomItem=t,this.glGeom=a,this.id=i,this.flags=s,this.visible=this.geomItem.getVisible(),this.culled=!1,this.lightmapName=t.getLightmapName(),this.updated=new S,this.visibilityChanged=new S,this.highlightChanged=t.highlightChanged,this.updateVisibility=this.updateVisibility.bind(this),this.updateVisibility=this.updateVisibility.bind(this),this.destroy=this.destroy.bind(this),e.floatTexturesSupported?this.updateXfo=e=>{this.updated.emit(rs);}:this.updateXfo=e=>{this.updateGeomMatrix();},this.geomItem.geomXfoChanged.connect(this.updateXfo),this.geomItem.visibilityChanged.connect(this.updateVisibility),this.geomItem.cutAwayChanged.connect(()=>{this.updated.emit(rs);}),this.highlightChangedId=this.geomItem.highlightChanged.connect(()=>{this.updated.emit(hs);}),this.glGeom.updated.connect(()=>{this.updated.emit(os);});const n=this.geomItem.getLightmapCoordsOffset();this.geomData=[n.x,n.y,0,0];}getGeomItem(){return this.geomItem}getGLGeom(){return this.glGeom}getVisible(){return this.geomItem.getVisible()}getId(){return this.id}getFlags(){return this.flags}updateVisibility(){const e=this.geomItem.getVisible()&&!this.culled;this.visible!=e&&(this.visible=e,this.visibilityChanged.emit(e),this.updated.emit());}setCullState(e){this.culled=e,this.updateVisibility();}updateGeomMatrix(){this.modelMatrixArray=this.geomItem.getGeomMat4().asArray();}getGeomMatrixArray(){return this.modelMatrixArray}bind(e){const t=this.gl,a=e.unifs;if(!t.floatTexturesSupported){const e=a.modelMatrix;e&&t.uniformMatrix4fv(e.location,!1,this.modelMatrixArray);const i=a.drawItemData;i&&t.uniform4f(i.location,this.geomData);}const i=a.transformIndex;if(i&&t.uniform1i(i.location,this.id),e.lightmaps&&a.lightmap&&e.boundLightmap!=this.lightmapName){const i=e.lightmaps[this.lightmapName];i&&i.glimage.isLoaded()?(i.glimage.bindToUniform(e,a.lightmap),t.uniform2fv(a.lightmapSize.location,i.atlasSize.asArray()),a.lightmapConnected&&t.uniform1i(a.lightmapConnected.location,!0),e.boundLightmap=this.lightmapName):a.lightmapConnected&&t.uniform1i(a.lightmapConnected.location,!1);}return !0}destroy(){this.geomItem.visibilityChanged.disconnect(this.updateVisibility),this.geomItem.geomXfoChanged.disconnect(this.updateXfo),this.geomItem.highlightChanged.disconnectId(this.highlightChangedId);}}class ms extends Li{constructor(){super(),this.__drawItems=[void 0],this.__drawItemsIndexFreeList=[],this.__dirtyItemIndices=[];}init(e,t){super.init(e,t),this.__renderer.registerPass(e=>{if(e instanceof sa){if(e.getMetadata("glgeomItem"))return !1;{const t=t=>!!this.filterGeomItem(t)&&(null==e.getGeometry()?e.geomAssigned.connect(()=>{this.addGeomItem(t);}):this.addGeomItem(t),!0);return null==e.getMaterial()?(console.warn("Scene item :"+e.getPath()+" has no material"),!1):t(e)}}return !1},e=>!!(e instanceof sa&&e.getMetadata("glgeomItem"))&&this.removeGeomItem(e));}filterGeomItem(e){return !0}addShader(e){return this.__renderer.getOrCreateShader(e.getShaderName())}constructShaders(e){let t,a;const i=this.__renderer.getOrCreateShader(e);return i.constructor.getGeomDataShaderName()&&(t=this.__renderer.getOrCreateShader(i.constructor.getGeomDataShaderName())),i.constructor.getSelectedShaderName()&&(a=this.__renderer.getOrCreateShader(i.constructor.getSelectedShaderName())),{glshader:i,glgeomdatashader:t,glselectedshader:a}}addMaterial(e){let t=e.getMetadata("glmaterial");if(t)return t;const a=this.__renderer.getOrCreateShader(e.getShaderName());return t=new $a(this.__gl,e,a),t.updated.connect(()=>{this.__renderer.requestRedraw();}),e.setMetadata("glmaterial",t),t}addGeom(e){let t=e.getMetadata("glgeom");if(t)return t.addRef(this),t;const a=this.__gl;if(e instanceof Ft||e instanceof Nt)t=new Ka(a,e);else if(e instanceof Mt||e instanceof Yt)t=new wa(a,e);else {if(!(e instanceof vt||e instanceof Ct))throw new Error("Unsupported geom type:"+e.constructor.name);t=new za(a,e);}return e.setMetadata("glgeom",t),t.addRef(this),t}removeGeom(e){let t=e.getMetadata("glgeom");if(t)return t.removeRef(this),t}addGeomItem(e){const t=this.addGeom(e.getGeometry());let a;this.__drawItemsIndexFreeList.length>0?a=this.__drawItemsIndexFreeList.pop():(a=this.__drawItems.length,this.__drawItems.push(null)),this.__dirtyItemIndices.push(a);const i=this.__gl,s=new cs(i,e,t,a,1);e.setMetadata("glgeomItem",s);s.updated.connect(e=>{switch(e){case rs:if(-1!=this.__dirtyItemIndices.indexOf(a))return;this.__dirtyItemIndices.push(a);break;case os:case ds:break;case hs:if(-1!=this.__dirtyItemIndices.indexOf(a))return;return this.__dirtyItemIndices.push(a),void this.__renderer.requestRedraw()}this.__renderer.drawItemChanged();});return this.__drawItems[a]=s,this.__renderer.requestRedraw(),e.setMetadata("glpass",this),s}removeGeomItem(e){if(e.getMetadata("glpass")!=this)return;const t=e.getMetadata("glgeomItem"),a=t.getId();return this.__drawItems[a]=null,this.__drawItemsIndexFreeList.push(a),this.__renderer.requestRedraw(),e.getMetadata("glpass"),e.deleteMetadata("glgeomItem"),t}removeGLGeom(e,t){const a=t.geomItemMappings.indexOf(e);t.geomItemMappings.splice(a,1);}getGeomItem(e){if(!(e>=this.__drawItems.length))return this.__drawItems[e];console.warn("Invalid Draw Item id:"+e+" NumItems:"+(this.__drawItems.length-1));}__populateDrawItemDataArray(e,t,a){const i=24*t;let s=0;if(e.isCutawayEnabled()){s|=1;}const n=e.getLightmapCoordsOffset();h.createFromFloat32Buffer(a.buffer,i+0).set(s,0,n.x,n.y);const l=e.getGeomMat4(),r=h.createFromFloat32Buffer(a.buffer,i+4),o=h.createFromFloat32Buffer(a.buffer,i+8),d=h.createFromFloat32Buffer(a.buffer,i+12);r.set(l.xAxis.x,l.yAxis.x,l.zAxis.x,l.translation.x),o.set(l.xAxis.y,l.yAxis.y,l.zAxis.y,l.translation.y),d.set(l.xAxis.z,l.yAxis.z,l.zAxis.z,l.translation.z);const c=h.createFromFloat32Buffer(a.buffer,i+16);if(e.isHighlighted()){const t=e.getHighlight();c.set(t.r,t.g,t.b,t.a);}const m=h.createFromFloat32Buffer(a.buffer,i+20);if(e.isCutawayEnabled()){const t=e.getCutVector(),a=e.getCutDist();m.set(t.x,t.y,t.z,a);}}newItemsReadyForLoading(){return this.__dirtyItemIndices.length>0}uploadGeomItems(){const e=this.__gl;if(!e.floatTexturesSupported){const e=this.__dirtyItemIndices.length;for(let t=0;t<e;t++){const e=this.__drawItems[this.__dirtyItemIndices[t]];e&&e.updateGeomMatrix();}return void(this.__dirtyItemIndices=[])}let t=Math.round(Math.sqrt(6*this.__drawItems.length)+.5);t=Math.nextPow2(t),t%6!=0&&(t+=6-t%6),this.__drawItemsTexture?this.__drawItemsTexture.width!=t&&(this.__drawItemsTexture.resize(t,t),this.__dirtyItemIndices=Array(t*t/6).fill().map((e,t)=>t)):(this.__drawItemsTexture=new Fa(e,{format:"RGBA",type:"FLOAT",width:t,height:t,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__drawItemsTexture.clear()),e.bindTexture(e.TEXTURE_2D,this.__drawItemsTexture.glTex);const a=this.__drawItemsTexture.getTypeID();for(let i=0;i<this.__dirtyItemIndices.length;i++){const s=this.__dirtyItemIndices[i],n=Math.floor(6*s/t);let l=s+1;for(let e=i+1;e<this.__dirtyItemIndices.length;e++){const a=this.__dirtyItemIndices[e];if(Math.floor(6*a/t)!=n)break;if(a!=l)break;l++;}const r=l-s,o=6*s%t,d=6*r,h=1,c=new Float32Array(24*r);for(let e=s;e<l;e++){const t=this.__drawItems[e];t&&this.__populateDrawItemDataArray(t.getGeomItem(),e-s,c);}if(a==e.FLOAT)this.__drawItemsTexture.populate(c,d,h,o,n,!1);else {const e=Math.convertFloat32ArrayToUInt16Array(c);this.__drawItemsTexture.populate(e,d,h,o,n,!1);}i+=r-1;}this.__dirtyItemIndices=[];}finalize(){0!=this.__dirtyItemIndices.length&&this.uploadGeomItems();}bind(e){const t=this.__gl,a=e.unifs;return this.__drawItemsTexture&&a.instancesTexture&&(this.__drawItemsTexture.bindToUniform(e,a.instancesTexture),t.uniform1i(a.instancesTextureSize.location,this.__drawItemsTexture.width)),!0}bindShader(e,t){return !!t.bind(e,this.constructor.name)&&!!this.bind(e)}bindMaterial(e,t,a){return t.bind(e,a)}}class us{constructor(e,t){this.gl=e,this.glgeom=t,this.glgeomItems=[],this.glgeomItems_freeIndices=[],this.glgeomItemSignalIds=[],this.drawIdsArray=null,this.drawIdsBuffer=null,this.drawIdsBufferDirty=!0,this.highlightedIdsArray=null,this.highlightedIdsBuffer=null,this.highlightedIdsBufferDirty=!0,this.lightmapName=void 0,this.drawCountChanged=new S,this.visibleItems=[],this.highlightedItems=[];}getGLGeom(){return this.glgeom}getLightmapName(){return this.lightmapName}getDrawCount(){return this.visibleItems.length}addGeomItem(e){let t;this.glgeomItems_freeIndices.length>0?t=this.glgeomItems_freeIndices.pop():(t=this.glgeomItems.length,this.glgeomItems.push(null)),e.visible&&(this.visibleItems.push(t),this.drawCountChanged.emit(1)),e.getGeomItem().isHighlighted()&&(this.highlightedItems.push(t),this.highlightedIdsBufferDirty=!0),1==this.glgeomItems.length&&(this.lightmapName=e.getGeomItem().getLightmapName());const a={};a.sel=e.highlightChanged.connect(()=>{if(e.getGeomItem().isHighlighted()){if(-1!=this.highlightedItems.indexOf(t))return;this.highlightedItems.push(t);}else this.highlightedItems.splice(this.highlightedItems.indexOf(t),1);this.highlightedIdsBufferDirty=!0;}),a.vis=e.visibilityChanged.connect(e=>{e?(this.visibleItems.push(t),this.drawCountChanged.emit(1)):(this.visibleItems.splice(this.visibleItems.indexOf(t),1),this.drawCountChanged.emit(-1)),this.drawIdsBufferDirty=!0;}),this.glgeomItems[t]=e,this.glgeomItemSignalIds[t]=a,this.drawIdsBufferDirty=!0;}removeGeomItem(e){const t=this.glgeomItems.indexOf(e),a=this.glgeomItemSignalIds[t];e.highlightChanged.disconnectId(a.sel),e.visibilityChanged.disconnectId(a.vis),this.glgeomItems[t]=null,this.glgeomItemSignalIds[t]=null,this.glgeomItems_freeIndices.push(t),e.visible&&(this.visibleItems.splice(this.visibleItems.indexOf(t),1),this.drawCountChanged.emit(-1)),e.getGeomItem().isHighlighted()&&this.highlightedItems.splice(this.highlightedItems.indexOf(t),1),this.drawIdsBufferDirty=!0,0==this.glgeomItems.length&&this.destroy();}updateDrawIDsBuffer(){const e=this.gl;e.floatTexturesSupported?(this.drawIdsBuffer&&this.glgeomItems.length!=this.drawIdsArray.length&&(this.gl.deleteBuffer(this.drawIdsBuffer),this.drawIdsBuffer=null),this.drawIdsBuffer||(this.drawIdsArray=new Float32Array(this.glgeomItems.length),this.drawIdsBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.drawIdsBuffer)),this.visibleItems.forEach((e,t)=>{this.drawIdsArray[t]=this.glgeomItems[e].getId();}),e.bindBuffer(e.ARRAY_BUFFER,this.drawIdsBuffer),e.bufferData(e.ARRAY_BUFFER,this.drawIdsArray,e.STATIC_DRAW),this.drawIdsBufferDirty=!1):this.drawIdsBufferDirty=!1;}updateHighlightedIDsBuffer(){const e=this.gl;e.floatTexturesSupported?(this.highlightedIdsBuffer&&this.glgeomItems.length!=this.highlightedIdsArray.length&&(this.gl.deleteBuffer(this.highlightedIdsBuffer),this.highlightedIdsBuffer=null),(!this.highlightedIdsArray||this.highlightedItems.length>this.highlightedIdsArray.length)&&(this.highlightedIdsArray=new Float32Array(this.highlightedItems.length),this.highlightedIdsBuffer&&(e.deleteBuffer(this.highlightedIdsBuffer),this.highlightedIdsBuffer=null)),this.highlightedItems.forEach((e,t)=>{this.highlightedIdsArray[t]=this.glgeomItems[e].getId();}),this.highlightedIdsBuffer||(this.highlightedIdsBuffer=e.createBuffer()),e.bindBuffer(e.ARRAY_BUFFER,this.highlightedIdsBuffer),e.bufferData(e.ARRAY_BUFFER,this.highlightedIdsArray,e.STATIC_DRAW),this.highlightedIdsBufferDirty=!1):this.highlightedIdsBufferDirty=!1;}draw(e){if(0==this.visibleItems.length)return;this.drawIdsBufferDirty&&this.updateDrawIDsBuffer();const t=this.gl,a=e.unifs;if(e.lightmaps&&a.lightmap&&e.boundLightmap!=this.lightmapName){const i=e.lightmaps[this.lightmapName];i&&i.glimage.isLoaded()?(i.glimage.bindToUniform(e,a.lightmap),t.uniform2fv(a.lightmapSize.location,i.atlasSize.asArray()),a.lightmapConnected&&t.uniform1i(a.lightmapConnected.location,!0),e.boundLightmap=this.lightmapName):a.lightmapConnected&&t.uniform1i(a.lightmapConnected.location,!1);}this.__bindAndRender(e,this.visibleItems,this.drawIdsBuffer);}drawHighlighted(e){0!=this.highlightedItems.length&&(this.highlightedIdsBufferDirty&&this.updateHighlightedIDsBuffer(),this.__bindAndRender(e,this.highlightedItems,this.highlightedIdsBuffer));}__bindAndRender(e,t,a){const i=this.gl,s=e.unifs;if(e.glgeom!=this.glgeom&&(this.glgeom.bind(e),e.glgeom=this.glgeom),i.floatTexturesSupported&&i.drawElementsInstanced&&e.supportsInstancing){i.uniform1i(e.unifs.instancedDraw.location,1);const n=e.attrs.instancedIds.location;i.enableVertexAttribArray(n),i.bindBuffer(i.ARRAY_BUFFER,a),i.vertexAttribPointer(n,1,i.FLOAT,!1,4,0),i.vertexAttribDivisor(n,1),e.bindViewports(s,()=>{this.glgeom.drawInstanced(t.length);});}else e.unifs.instancedDraw&&i.uniform1i(e.unifs.instancedDraw.location,0),t.forEach(t=>{this.glgeomItems[t].bind(e),e.bindViewports(s,()=>{this.glgeom.draw(e);});});}destroy(){}}class bs{constructor(e){this.glshader=e.glshader,this.glgeomdatashader=e.glgeomdatashader,this.glselectedshader=e.glselectedshader,this.glmaterialGeomItemSets=[];}findMaterialGeomItemSets(e){for(const t of this.glmaterialGeomItemSets)if(t.glmaterial==e)return t}addMaterialGeomItemSets(e){this.glmaterialGeomItemSets.push(e);}removeMaterialGeomItemSets(e){const t=this.glmaterialGeomItemSets.indexOf(e);this.glmaterialGeomItemSets.splice(t,1);}getMaterialGeomItemSets(){return this.glmaterialGeomItemSets}}class ps{constructor(e){this.glmaterial=e,this.geomItemSets=[],this.drawCount=0,this.visibleInGeomDataBuffer=e.getMaterial().visibleInGeomDataBuffer,this.__drawCountChanged=this.__drawCountChanged.bind(this);}getGLMaterial(){return this.glmaterial}__drawCountChanged(e){this.drawCount+=e;}addGeomItemSet(e){-1==this.geomItemSets.indexOf(e)?(this.geomItemSets.push(e),this.drawCount+=e.drawCount,e.drawCountChanged.connect(this.__drawCountChanged)):console.warn("geomItemSet already added to GLMaterialGeomItemSets");}removeGeomItemSet(e){const t=this.geomItemSets.indexOf(e);this.geomItemSets.splice(t,1),e.drawCountChanged.disconnect(this.__drawCountChanged),e.destroy();}findGeomItemSet(e){for(const t of this.geomItemSets)if(t.getGLGeom()==e)return t;return null}getGeomItemSets(){return this.geomItemSets}}class gs extends ms{constructor(){super(),this.__glshadermaterials={};}init(e,t){super.init(e,t);}filterGeomItem(e){const t=e.getMaterial().getShaderClass();if(t){if(t.isTransparent())return !1;if(t.isOverlay())return !1;const a=e.getMaterial().getParameter("BaseColor");return !(a&&a.getValue().a<1)}return !1}addGeomItem(e){const t=e.getMaterial(),a=t.getShaderName(),i=this.constructShaders(a);const s=this.addMaterial(t),n=super.addGeomItem(e);let l=this.__glshadermaterials[a];l||(l=new bs(i),this.__glshadermaterials[a]=l);let r=l.findMaterialGeomItemSets(s);r||(r=new ps(s),l.addMaterialGeomItemSets(r));let o=r.findGeomItemSet(n.glGeom);return o||(o=new us(this.__gl,n.glGeom),r.addGeomItemSet(o)),e.setMetadata("geomItemSet",o),o.addGeomItem(n),!0}removeGeomItem(e){const t=super.removeGeomItem(e);if(!t)return !1;const a=e.getMetadata("geomItemSet");return a&&(a.removeGeomItem(t),e.deleteMetadata("geomItemSet")),!0}removeMaterial(e){const t=this.__glshadermaterials[e.hash];if(!t||t!=e.getMetadata("glshaderMaterials"))return void console.warn("Material not found in pass");const a=e.getMetadata("glmaterialGeomItemSets");t.removeMaterialGeomItemSets(a);}__traverseTreeAndDraw(e){for(const t in this.__glshadermaterials){const a=this.__glshadermaterials[t],i=a.glshader;if(this.bindShader(e,i)){const t=a.getMaterialGeomItemSets();for(const a of t)if(0!=a.drawCount&&this.bindMaterial(e,a.getGLMaterial(),!0)){const t=a.getGeomItemSets();for(const a of t)a.draw(e);}}i.unbind(e);}e.glgeom&&e.glgeom.unbind(e);}draw(e){this.newItemsReadyForLoading()&&this.finalize();const t=this.__gl;t.disable(t.BLEND),t.disable(t.CULL_FACE),t.enable(t.DEPTH_TEST),t.depthFunc(t.LESS),t.depthMask(!0),this.__traverseTreeAndDraw(e);}drawHighlightedGeoms(e){const t=this.__gl;t.disable(t.CULL_FACE);for(const t in this.__glshadermaterials){const a=this.__glshadermaterials[t];if(!a.glselectedshader)continue;if(!this.bindShader(e,a.glselectedshader))continue;const i=a.getMaterialGeomItemSets();for(const t of i){const a=t.getGeomItemSets();for(const t of a)t.drawHighlighted(e);}}e.glgeom&&e.glgeom.unbind(e);}getGeomItemAndDist(e){let t,a;this.__gl.floatGeomBuffer?(t=Math.round(e[1]),a=e[3]):(t=e[0]+(e[1]<<8),a=Math.decode16BitFloatFrom2xUInt8([e[2],e[3]]));const i=this.__drawItems[t];if(i)return {geomItem:i.getGeomItem(),dist:a}}drawGeomData(e){this.newItemsReadyForLoading()&&this.finalize();const t=this.__gl;t.disable(t.BLEND),t.disable(t.CULL_FACE),t.enable(t.DEPTH_TEST),t.depthFunc(t.LESS),t.depthMask(!0);for(const a in this.__glshadermaterials){const i=this.__glshadermaterials[a];if(!i.glgeomdatashader)continue;if(!this.bindShader(e,i.glgeomdatashader))continue;{const a=e.unifs.floatGeomBuffer;a&&t.uniform1i(a.location,t.floatGeomBuffer?1:0);}{const a=e.unifs.passId;a&&t.uniform1i(a.location,this.__passIndex);}const s=i.getMaterialGeomItemSets();for(const t of s)if(0!=t.drawCount&&t.visibleInGeomDataBuffer&&this.bindMaterial(e,t.getGLMaterial(),!1)){const a=t.getGeomItemSets();for(const t of a)t.draw(e);}}e.glgeom&&e.glgeom.unbind(e);}}Fi.registerPass(gs,Wi.OPAQUE);class _s extends ms{constructor(){super();}init(e,t){super.init(e,t),this.transparentItems=[],this.freeList=[],this.visibleItems=[],this.prevSortCameraPos=new d(999,999,999),this.resort=!1;}filterGeomItem(e){const t=e.getMaterial().getShaderClass();if(t){if(t.isTransparent())return !0;if(t.isOverlay())return !1;const a=e.getMaterial().getParameter("BaseColor");if(a&&a.getValue().a<.999)return !0}return !1}addGeomItem(e){const t=e.getMaterial(),a=t.getShaderName(),i=this.constructShaders(a),s=this.addMaterial(t),n=super.addGeomItem(e),l=e.visibilityChanged.connect(e=>{if(e)this.visibleItems.push(o);else {const e=this.visibleItems.indexOf(o);this.visibleItems.splice(e,1);}}),r=e.geomXfoChanged.connect(()=>{this.resort=!0;}),o={geomItem:e,shaders:i,glmaterial:s,glgeomitem:n,visibilityChangedId:l,geomXfoChangedId:r};let d;d=this.freeList.length>0?this.freeList.pop():this.transparentItems.length,this.transparentItems[d]=o,e.setMetadata("itemIndex",d),e.getVisible()&&this.visibleItems.push(o),this.resort=!0;}removeGeomItem(e){if(!super.removeGeomItem(e))return;const t=e.getMetadata("itemIndex"),a=this.transparentItems[t];this.transparentItems[t]=null,this.freeList.push(t);const i=this.visibleItems.indexOf(a);-1!=i&&this.visibleItems.splice(i,1);}sortItems(e){for(const t of this.visibleItems){const a=t.glgeomitem.geomItem.getGeomMat4();t.dist=a.translation.distanceTo(e);}this.visibleItems.sort((e,t)=>e.dist>t.dist?-1:e.dist<t.dist?1:0),this.prevSortCameraPos=e,this.resort=!1;}_drawItem(e,t,a){if(a.currentglMaterial!=t.glmaterial&&(a.currentglMaterial=t.glmaterial,!a.currentglMaterial.bind(e)))return;const i=t.glgeomitem;if((a.currentglGeom==i.glGeom||(a.currentglGeom=i.glGeom,a.currentglGeom.bind(e)))&&i.bind(e)){if(e.unifs.instancedDraw){const t=this.__gl;t.uniform1i(e.unifs.instancedDraw.location,0),t.disableVertexAttribArray(e.attrs.instancedIds.location);}e.bindViewports(e.unifs,()=>{a.currentglGeom.draw(e);});}}_drawItems(e){const t={currentglShader:null,currentglMaterial:null,currentglGeom:null};for(const a of this.visibleItems){if(t.currentglShader!=a.shaders.glshader){if(!this.bindShader(e,a.shaders.glshader))continue;t.currentglShader=a.shaders.glshader;}this._drawItem(e,a,t);}t.currentglGeom&&t.currentglGeom.unbind(e);}draw(e){if(0==this.visibleItems.length)return;this.newItemsReadyForLoading()&&this.finalize();const t=this.__gl,a=e.viewXfo.tr;(this.resort||a.distanceTo(this.prevSortCameraPos)>.3)&&this.sortItems(a),t.enable(t.DEPTH_TEST),t.depthFunc(t.LESS),t.depthMask(!0),t.enable(t.BLEND),t.blendEquation(t.FUNC_ADD),e.pass="MULTIPLY",t.blendFunc(t.DST_COLOR,t.ZERO),this._drawItems(e),e.pass="ADD",t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),this._drawItems(e),t.disable(t.BLEND);}drawHighlightedGeoms(e){const t=this.__gl;t.disable(t.CULL_FACE);const a={currentglShader:null,currentglMaterial:null,currentglGeom:null};for(const t of this.visibleItems){if(!t.geomItem.isHighlighted())continue;if(!t.shaders.glselectedshader)continue;const i=t.shaders;if(a.currentglShader!=i.glselectedshader){if(!this.bindShader(e,i.glselectedshader))continue;a.currentglShader=i.glselectedshader;}this._drawItem(e,t,a);}a.currentglGeom&&a.currentglGeom.unbind(e);}getGeomItemAndDist(e){let t,a;this.__gl.floatGeomBuffer?(t=Math.round(e[1]),a=e[3]):(t=e[0]+(e[1]<<8),a=Math.decode16BitFloatFrom2xUInt8([e[2],e[3]]));const i=this.__drawItems[t];if(i)return {geomItem:i.getGeomItem(),dist:a}}drawGeomData(e){this.newItemsReadyForLoading()&&this.finalize();const t=this.__gl;t.disable(t.BLEND),t.disable(t.CULL_FACE),t.enable(t.DEPTH_TEST),t.depthFunc(t.LESS),t.depthMask(!0);const a={currentglShader:null,currentglMaterial:null,currentglGeom:null};for(const i of this.visibleItems){const s=i.shaders;if(a.currentglShader!=s.glgeomdatashader){if(!this.bindShader(e,s.glgeomdatashader))continue;a.currentglShader=s.glgeomdatashader;}{const a=e.unifs.floatGeomBuffer;a&&t.uniform1i(a.location,t.floatGeomBuffer?1:0);}{const a=e.unifs.passId;a&&t.uniform1i(a.location,this.__passIndex);}this._drawItem(e,i,a);}a.currentglGeom&&a.currentglGeom.unbind(e);}}Fi.registerPass(_s,Wi.TRANSPARENT);class Zs extends Li{constructor(){super();}init(e,t){super.init(e,t),this.__billboards=[],this.__freeIndices=[],this.__drawCount=0,this.__threshold=0,this.__updateRequested=!1,this.__prevSortCameraPos=new d,this.__atlas=new ni(this.__renderer.gl,"Billboards","RGBA","UNSIGNED_BYTE",[1,1,1,0]),this.__atlas.loaded.connect(this.updated.emit),this.__atlas.updated.connect(this.updated.emit),this.__renderer.registerPass(e=>e instanceof ha&&(this.addBillboard(e),!0),e=>e instanceof ha&&(this.removeBillboard(e),!0));}filterRenderTree(){}addBillboard(e){const t=e.getParameter("image"),a=t.getValue();if(!a)return void t.valueChanged.connect(()=>this.addBillboard(e));let i;i=this.__freeIndices.length>0?this.__freeIndices.pop():this.__billboards.length;const s=this.__atlas.addSubImage(a);e.setMetadata("GLBillboardsPass_Index",i);const n=e.visibilityChanged.connect(()=>{e.getVisible()?(this.__drawCount++,this.__updateBillboard(i)):this.__drawCount--,this.__reqUpdateIndexArray();}),l=e.getParameter("GlobalXfo").valueChanged.connect(()=>{e.getVisible()&&(this.__updateBillboard(i),this.updated.emit());}),r=e.getParameter("alpha").valueChanged.connect(()=>{e.getVisible()&&(this.__updateBillboard(i),this.updated.emit());});e.getVisible()&&this.__drawCount++,this.__billboards[i]={billboard:e,imageIndex:s,visibilityChangedId:n,xfoChangedId:l,alphaChangedId:r},this.indexArrayUpdateNeeded=!0,this.__requestUpdate();}removeBillboard(e){const t=e.getMetadata("GLBillboardsPass_Index");if(-1==t)return void console.warn("Billboard already removed.");const a=this.__billboards[t],i=a.billboard.getParameter("image").getValue();this.__atlas.removeSubImage(i),e.visibilityChanged.disconnectId(a.visibilityChangedId),e.getParameter("GlobalXfo").valueChanged.disconnectId(a.xfoChangedId),e.getParameter("alpha").valueChanged.disconnectId(a.alphaChangedId),this.__billboards[t]=null,this.__freeIndices.push(t),e.getVisible()&&this.__drawCount--,this.indexArrayUpdateNeeded=!0,this.__requestUpdate();}__populateBillboardDataArray(e,t,a){const i=e.billboard,s=i.getGlobalXfo().toMat4(),n=i.getParameter("scale").getValue();let l=0;i.getParameter("alignedToCamera").getValue()&&(l|=4);const r=i.getParameter("alpha").getValue(),o=i.getParameter("color").getValue(),d=5*t*4,c=h.createFromFloat32Buffer(a.buffer,d),m=h.createFromFloat32Buffer(a.buffer,d+4),u=h.createFromFloat32Buffer(a.buffer,d+8),b=h.createFromFloat32Buffer(a.buffer,d+12);c.set(s.xAxis.x,s.yAxis.x,s.zAxis.x,s.translation.x),m.set(s.xAxis.y,s.yAxis.y,s.zAxis.y,s.translation.y),u.set(s.xAxis.z,s.yAxis.z,s.zAxis.z,s.translation.z),b.set(n,l,e.imageIndex,r),h.createFromFloat32Buffer(a.buffer,d+16).set(o.r,o.g,o.b,o.a);}__requestUpdate(){this.__updateRequested||(this.__updateRequested=!0,setTimeout(()=>{this.__updateBillboards();},100));}__reqUpdateIndexArray(){this.indexArrayUpdateNeeded||(this.indexArrayUpdateNeeded=!0,this.updateIndexArrayId=setTimeout(()=>{this.indexArrayUpdateNeeded&&(this.__updateIndexArray(),this.updated.emit());},1));}__updateIndexArray(){const e=this.__gl;this.__indexArray&&this.__indexArray.length!=this.__drawCount&&(e.deleteBuffer(this.__instanceIdsBuffer),this.__instanceIdsBuffer=null),this.__indexArray=new Float32Array(this.__drawCount);let t=0;for(let e=0;e<this.__billboards.length;e++)this.__billboards[e]&&this.__billboards[e].billboard.getVisible()&&(this.__indexArray[t]=e,t++);this.__instanceIdsBuffer||(this.__instanceIdsBuffer=e.createBuffer()),e.bindBuffer(e.ARRAY_BUFFER,this.__instanceIdsBuffer),e.bufferData(e.ARRAY_BUFFER,this.__indexArray,e.STATIC_DRAW),this.indexArrayUpdateNeeded=!1;}__updateBillboards(){this.indexArrayUpdateNeeded&&this.__updateIndexArray();const e=this.__gl;if(!this.__glshader){e.__quadVertexIdsBuffer||e.setupInstancedQuad(),this.__glshader=new Ti(e);const t=this.__glshader.compileForTarget("GLBillboardsPass",this.__renderer.getShaderPreproc());this.__shaderBinding=Ya(e,t.attrs,e.__quadattrbuffers,e.__quadIndexBuffer);}const t=()=>{if(this.__atlas.renderAtlas(),!e.floatTexturesSupported||!e.drawElementsInstanced)return this.__modelMatrixArray=[],this.__billboardDataArray=[],this.__tintColorArray=[],this.__indexArray.forEach(e=>{const t=this.__billboards[e],a=t.billboard,i=a.getGlobalXfo().toMat4(),s=a.getParameter("scale").getValue(),n=a.getParameter("flags").getValue(),l=a.getParameter("alpha").getValue(),r=a.getParameter("color").getValue();this.__modelMatrixArray[e]=i.asArray(),this.__billboardDataArray[e]=[s,n,t.imageIndex,l],this.__tintColorArray[e]=[r.r,r.g,r.b,r.a];}),void(this.__updateRequested=!1);let t=Math.round(Math.sqrt(5*(this.__billboards.length-this.__freeIndices.length))+.5);t%5!=0&&(t+=5-t%5),this.__width=t,this.__drawItemsTexture?this.__drawItemsTexture.resize(t,t):(this.__drawItemsTexture=new Fa(e,{format:"RGBA",type:"FLOAT",width:t,height:t,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__drawItemsTexture.clear()),this.__indexArray.forEach(e=>{-1!=e&&this.__updateBillboard(e);}),this.__updateRequested=!1;};this.__atlas.isLoaded()?t():this.__atlas.loaded.connect(t);}__updateBillboard(e){if(0==this.__drawCount||!this.__drawItemsTexture)return;const t=this.__billboards[e];if(!t.billboard.getVisible())return;const a=this.__gl,i=new Float32Array(20);this.__populateBillboardDataArray(t,0,i),a.bindTexture(a.TEXTURE_2D,this.__drawItemsTexture.glTex);const s=5*e%this.__width,n=Math.floor(5*e/this.__width),l=this.__drawItemsTexture.getType(),r=this.__drawItemsTexture.getFormat();if("FLOAT"==l)a.texSubImage2D(a.TEXTURE_2D,0,s,n,5,1,a[r],a[l],i);else {const e=Math.convertFloat32ArrayToUInt16Array(i);a.texSubImage2D(a.TEXTURE_2D,0,s,n,5,1,a[r],a[l],e);}}sort(e){for(const t of this.__billboards)t&&t.billboard.getVisible()&&(t.dist=t.billboard.getGlobalXfo().tr.distanceTo(e));this.__indexArray.sort((e,t)=>-1==e?1:-1==t||this.__billboards[e].dist>this.__billboards[t].dist?-1:this.__billboards[e].dist<this.__billboards[t].dist?1:0);const t=this.__gl;t.floatTexturesSupported&&this.__instanceIdsBuffer&&(t.bindBuffer(t.ARRAY_BUFFER,this.__instanceIdsBuffer),t.bufferData(t.ARRAY_BUFFER,this.__indexArray,t.STATIC_DRAW));}draw(e){if(0==this.__drawCount||!this.__atlas.isReady()||this.__updateRequested)return;this.indexArrayUpdateNeeded&&this.__updateIndexArray();const t=this.__gl;t.disable(t.CULL_FACE),t.enable(t.BLEND),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA);const a=e.viewXfo.tr;if(a.distanceTo(this.__prevSortCameraPos)>this.__threshold)if(this.sort(a),this.__prevSortCameraPos=a.clone(),this.__drawCount>1){const e=this.__billboards[this.__indexArray[0]].billboard.getGlobalXfo().tr,t=this.__billboards[this.__indexArray[1]].billboard.getGlobalXfo().tr;this.__threshold=e.distanceTo(t);}else this.__threshold=9999;this.__glshader.bind(e),this.__shaderBinding.bind(e);const i=e.unifs;if(this.__atlas.bindToUniform(e,i.atlasBillboards),t.floatTexturesSupported&&t.drawElementsInstanced){this.__drawItemsTexture.bindToUniform(e,i.instancesTexture),t.uniform1i(i.instancesTextureSize.location,this.__width);{const a=e.attrs.instanceIds.location;t.enableVertexAttribArray(a),t.bindBuffer(t.ARRAY_BUFFER,this.__instanceIdsBuffer),t.vertexAttribPointer(a,1,t.FLOAT,!1,4,0),t.vertexAttribDivisor(a,1);}e.bindViewports(i,()=>{t.drawElementsInstanced(t.TRIANGLES,6,t.UNSIGNED_SHORT,0,this.__drawCount);});}else {const a=this.__indexArray.length;for(let s=0;s<a;s++)t.uniformMatrix4fv(i.modelMatrix.location,!1,this.__modelMatrixArray[s]),t.uniform4fv(i.billboardData.location,this.__billboardDataArray[s]),t.uniform4fv(i.tintColor.location,this.__tintColorArray[s]),t.uniform4fv(i.layoutData.location,this.__atlas.getLayoutData(this.__billboards[s].imageIndex)),e.bindViewports(i,()=>{t.drawQuad();});}t.disable(t.BLEND);}}Fi.registerPass(Zs,Wi.TRANSPARENT);class Gs extends gs{constructor(){super();}init(e,t){super.init(e,t);}filterGeomItem(e){if(e.isOverlay())return !0;const t=e.getMaterial().getShaderClass();return !(!t||!t.isOverlay())}draw(e){this.newItemsReadyForLoading()&&this.finalize();const t=this.__gl;t.clear(t.DEPTH_BUFFER_BIT),t.enable(t.CULL_FACE),t.cullFace(t.BACK),t.enable(t.BLEND),t.blendEquation(t.FUNC_ADD),e.pass="ADD",t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),this.__traverseTreeAndDraw(e),t.disable(t.BLEND);}drawGeomData(e){const t=this.__gl;t.clear(t.DEPTH_BUFFER_BIT),t.enable(t.BLEND),t.blendEquation(t.FUNC_ADD),e.pass="ADD",t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),super.drawGeomData(e),t.disable(t.BLEND),t.enable(t.DEPTH_TEST);}}Fi.registerPass(Gs,Wi.OVERLAY);const Xs=window.AudioContext||window.webkitAudioContext||!1;Xs?exports.audioCtx=new Xs:alert("Sorry, but the Web Audio API is not supported by your browser. Please, consider upgrading to the latest version or downloading Google Chrome or Mozilla Firefox");class ys extends Li{constructor(){super(),this.__audioItems=[];}init(e,t){super.init(e,t),exports.audioCtx&&this.__renderer.registerPass(e=>{if(e instanceof ta)return e.audioSourceCreated.connect(t=>{this.addAudioSource(e,t,e);}),!0;if(e instanceof sa){const t=e.getMaterial();if(t){const a=t.getParameter("BaseColor");if(a&&a.getImage&&a.getImage()){const t=a.getImage();t.loaded.connect(()=>{if(t.getAudioSource){const a=t.getAudioSource();(a instanceof HTMLMediaElement||a instanceof AudioBufferSourceNode)&&this.addAudioSource(e,a,t);}});}}return !1}},e=>{});}addAudioSource(e,t,a){if(t.addedToCollector)return;let i;i=t instanceof HTMLMediaElement?exports.audioCtx.createMediaElementSource(t):t instanceof AudioBufferSourceNode?t:exports.audioCtx.createMediaStreamSource(t);const s=exports.audioCtx.createGain(),n=a.getParameter("Gain");var l,r;n&&(l=n,r=s.gain,l&&(r.setValueAtTime(l.getValue(),0),r.setValueAtTime(l.getValue(),5),l.valueChanged.connect(()=>{r.value=l.getValue();}))),i.connect(s);const o=a.getParameter("SpatializeAudio");if(o&&0==o.getValue())i.connect(exports.audioCtx.destination);else {const t=exports.audioCtx.createPanner();t.panningModel="HRTF",t.distanceModel="inverse",i.connect(t),t.connect(exports.audioCtx.destination);const s=e=>{const i=a.getParameter(e);i&&(t[e]=i.getValue(),i.valueChanged.connect(()=>{t[e]=i.getValue();}));};s("coneInnerAngle"),s("coneOuterAngle"),s("coneOuterGain");const n=()=>{let a;a=e instanceof sa?e.getGeomMat4():e.getGlobalXfo().toMat4();const i=a.translation;t.setPosition(i.x,i.y,i.z);const s=a.zAxis;t.setOrientation(s.x,s.y,s.z);};n(),e.globalXfoChanged.connect(e=>{n();});}t.addedToCollector=!0,this.__audioItems.push({treeItem:e,audioSource:t,parameterOwner:a}),this.updated.emit();}__updateListenerPosition(e){if(!exports.audioCtx)return;const t=exports.audioCtx.listener;t.setPosition(e.tr.x,e.tr.y,e.tr.z);const a=e.ori.getYaxis(),i=e.ori.getZaxis().negate();t.setOrientation(i.x,i.y,i.z,a.x,a.y,a.z);}draw(e){0!=this.__audioItems.length&&this.__updateListenerPosition(e.viewXfo);}}Fi.registerPass(ys,Wi.OVERLAY),window&&(window.ZeaAudioaudioCtx=exports.audioCtx);var fs=Object.freeze({__proto__:null,create3DContext:Ma,GLTexture2D:Fa,GLMesh:Ka,GLLines:wa,GLPoints:za,GLMaterial:$a,GLShader:Pa,GLFbo:Ha,GLRenderTarget:ei,GLRenderer:Fi,GLBaseViewport:Gi,GLViewport:Xi,shaderLibrary:Ja,generateShaderGeomBinding:Ya,BillboardShader:Ti,ConvolverShader:li,DepthMapShader:Ci,EnvMapShader:di,BackgroundImageShader:hi,OctahedralEnvMapShader:ci,LatLongEnvMapShader:mi,SterioLatLongEnvMapShader:ui,DualFishEyeEnvMapShader:bi,DualFishEyeToLatLongBackgroundShader:pi,EnvProjectionShader:Yi,OctahedralEnvProjectionShader:Ni,LatLongEnvProjectionShader:Ki,FatLinesShader:wi,FlatSurfaceShader:zi,FlatAlphaSurfaceShader:Ui,LayeredCarPaintShader:Ji,LinesShader:Ei,NormalsShader:Hi,PointsShader:ki,FatPointsShader:Bi,FatPointsGeomDataShader:Di,FatPointsSelectedShader:Oi,PostProcessing:Qi,ScreenQuadShader:_i,SimpleSurfaceShader:Ai,StandardSurfaceShader:ji,StandardSurfaceGeomDataShader:qi,StandardSurfaceSelectedGeomsShader:$i,HandleShader:es,HandleGeomDataShader:ts,TransparentSurfaceShader:as,ScreenSpaceShader:is,ToolIconShader:ss,UnpackHDRShader:Ea,UnpackLDRAlphaImageShader:ns,WireShader:ls,GLPass:Li,PassType:Wi,GLStandardGeomsPass:ms,GLOpaqueGeomsPass:gs,GLTransparentGeomsPass:_s,GLBillboardsPass:Zs,GLOverlayPass:Gs,GLAudioItemsPass:ys,get audioCtx(){return exports.audioCtx},VRViewport:Vi});class Vs{constructor(e){this.__name=e||this.constructor.name,this.__stateEvents=[],this.__activationActions=[],this.__deactivationActions=[];}getName(){return this.__name}setName(e){this.__name=e;}setStateMachine(e){this.__stateMachine=e;}getStateMachine(){return this.__stateMachine}activate(){this.__stateEvents.forEach(e=>{e.activate();}),this.__activationActions.forEach(e=>{e.activate();});}deactivate(){this.__stateEvents.forEach(e=>{e.deactivate();}),this.__deactivationActions.forEach(e=>{e.activate();});}addStateEvent(e){e.setState(this),this.__stateEvents.push(e);}getStateEvent(e){return this.__stateEvents[e]}addActivationAction(e){e.setState(this),this.__activationActions.push(e);}getActivationAction(e){return this.__activationActions[e]}addDeactivationAction(e){e.setState(this),this.__deactivationActions.push(e);}toJSON(e,t){const a={name:this.__name,type:this.constructor.name},i=[];for(const a of this.__stateEvents)i.push(a.toJSON(e,t));a.stateEvents=i;const s=[];for(const a of this.__activationActions)s.push(a.toJSON(e,t));a.activationActions=s;const n=[];for(const a of this.__deactivationActions)n.push(a.toJSON(e,t));return a.deactivationActions=n,a}fromJSON(e,t,a){this.__name=e.name;for(const a of e.stateEvents){const e=C.constructClass(a.type);e.fromJSON(a,t),this.addStateEvent(e);}for(const a of e.activationActions){const e=C.constructClass(a.type);e.fromJSON(a,t),this.addActivationAction(e);}for(const a of e.deactivationActions){const e=C.constructClass(a.type);e.fromJSON(a,t),this.addDeactivationAction(e);}}}C.registerClass("State",Vs);class xs extends H{constructor(e){super(),this.__name=e,this.__childActions=[],this.__outputs={};}addOutput(e){return this.__outputs[e.getName()]=e,e}getOutput(e){return this.__outputs[e]}setState(e){this.__state=e,this.__childActions.forEach(t=>{t.setState(e);});}addChild(e){this.__childActions.push(e),e.setState(this.__state);}getChild(e){return this.__childActions[e]}activate(){console.warn("activate must be implmented by each action. this:"+this.constructor.name);}addChild(e){this.__childActions.push(e),e.setState(this.__state);}deactivate(){}__onDone(){this.__childActions.forEach(e=>{e.activate();});}toJSON(e,t){let a=super.toJSON(e,t);a||(a={}),a.type=C.getClassName(this);const i=[];for(const a of this.__childActions)i.push(a.toJSON(e,t));a.childActions=i;const s={};for(const a in this.__outputs)s[a]=this.__outputs[a].toJSON(e,t);return a.outputs=s,a}fromJSON(e,t,a){super.fromJSON(e,t,a);for(const a of e.childActions){const e=C.constructClass(a.type);if(!e)throw new Error("Invalid type:"+a.type);e.fromJSON(a,t),this.addChild(e);}for(const a in e.outputs)this.__outputs[a].fromJSON(e.outputs[a],t);}destroy(){super.destroy(),this.__outputs=[];}}class Is extends xs{constructor(e){super(),this.__name=e,this.__onEvent=this.__onEvent.bind(this);}__onEvent(){this.__childActions.forEach(e=>{e.activate();});}}class Rs extends D{constructor(e){super(e),this.__states={},this.stateChanged=new S,this.setFlag(k.USER_EDITED),C.isConstructing()||C.invokeCallbacks(this);}addState(e){e.setStateMachine(this),this.__states[e.getName()]=e,1==Object.keys(this.__states).length&&null==this.__initialStateName&&(this.__initialStateName=e.getName());}getState(e){return this.__states[e]}activateState(e){if(!this.__states[e])throw new Error("Invalid state transtion:"+e);this.__currentState!=this.__states[e]&&(this.__currentState&&this.__currentState.deactivate(),this.__currentState=this.__states[e],this.__currentState.activate(),this.stateChanged.emit(e));}getActiveState(){return this.__currentState}getActiveStateName(){return this.__currentState.constructor.name}getInitialState(){return this.__initialStateName}setInitialState(e){this.__initialStateName=e;}toJSON(e,t){const a=super.toJSON(e,t);a.initialStateName=this.__initialStateName;const i={};for(const a in this.__states)i[a]=this.__states[a].toJSON(e,t);return a.states=i,a}fromJSON(e,t,a){super.fromJSON(e,t,a),this.__initialStateName=e.initialStateName,t.stateMachine=this;for(const a in e.states){const i=e.states[a],s=C.constructClass(i.type);if(!s)throw new Error("Invalid type:"+i.type);s.fromJSON(i,t),this.addState(s);}t.addPLCB(()=>{});}}C.registerClass("StateMachine",Rs);class Ss extends xs{constructor(){super(),this.__targetStateParam=this.addParameter(new xe("TargetState",""));}activate(){this.__state.getStateMachine().activateState(this.__targetStateParam.getValue());}}C.registerClass("SwitchState",Ss);class Ws extends xs{constructor(){super(),this.addParameter(new Le("Camera",e=>e instanceof ca)),this.addParameter(new _e("cameraPos")),this.addParameter(new _e("cameraTarget")),this.addParameter(new ue("interpTime",1)),this.addParameter(new ue("updateFrequency",30));}SetCameraPositionAndTarget(e,t){this.getParameter("cameraPos").setValue(e),this.getParameter("cameraTarget").setValue(t);}activate(){const e=this.getParameter("Camera").getValue();if(!e)return void console.warn("Camera not assigned to SetCameraPositionAndTarget state action");const t=this.getParameter("cameraPos").getValue(),a=this.getParameter("cameraTarget").getValue(),i=this.getParameter("interpTime").getValue();if(i>0){const s=e.getGlobalXfo().tr,n=e.getTargetPostion(),l=(s.subtract(n).length(),this.getParameter("updateFrequency").getValue()),r=t.subtract(a).length();let o=!0,d=0,h=0;const c=Math.round(i*l);let m=!1;const u=()=>{m||(o=!1);};e.globalXfoChanged.connect(u);const b=()=>{if(h++,h<c){const i=h/c,s=Math.smoothStep(0,1,i),n=(s-d)/(1-i);d=s;const u=e.getGlobalXfo().tr,p=e.getTargetPostion(),g=u.subtract(p).length();let _=u;const Z=p.lerp(a,n);o&&(_=u.lerp(t,n));const G=_.subtract(Z),X=(G.length(),Math.lerp(g,r,n));G.scaleInPlace(X/G.length()),m=!0,e.setPositionAndTarget(Z.add(G),Z),m=!1,this.__timeoutId=window.setTimeout(b,1e3/l);}else e.globalXfoChanged.disconnect(u),e.movementFinished.emit(),this.__timeoutId=void 0,this.__onDone();};b();}else e.setPositionAndTarget(t,a);}cancel(){this.__timeoutId&&(clearTimeout(this.__timeoutId),this.__timeoutId=void 0);}}C.registerClass("SetCameraPositionAndTarget",Ws);class Ls extends xs{constructor(){super(),this.__interpTimeParam=this.addParameter(new ue("InterpTime",1)),this.__updateFrequencyParam=this.addParameter(new ue("UpdateFrequency",30)),this.__outParam=this.addOutput(new Za("Param")),this.__outParam.paramSet.connect(()=>{if(!this.__valueParam||this.__outParam.getParam().getDataType()!=this.__valueParam.getDataType()){const e=this.__outParam.getParam().clone();e.setName("Value"),this.__outParam.getInitialValue?e.setValue(this.__outParam.getInitialValue()):e.setValue(this.__outParam.getParam().getValue()),this.__valueParam=this.addParameter(e);}});}activate(){if(this.__outParam.isConnected()){const e=this.__interpTimeParam.getValue();if(e>0){const t=this.__updateFrequencyParam.getValue(),a=this.__outParam.getValue(),i=this.__valueParam.getValue();let s=0;const n=Math.round(e/(1/t)),l=()=>{if(s++,s<n){const e=s/n,r=Math.smoothStep(0,1,e),o=Math.lerp(a,i,r);this.__outParam.setValue(o,N.GENERATED_VALUE),this.__timeoutId=window.setTimeout(l,1e3/t);}else this.__outParam.setValue(this.__valueParam.getValue(),N.GENERATED_VALUE),this.__timeoutId=void 0,this.__onDone();};l();}else this.__outParam.setValue(this.__valueParam.getValue(),N.GENERATED_VALUE),this.__onDone();}}cancel(){this.__timeoutId&&(clearTimeout(this.__timeoutId),this.__timeoutId=void 0);}toJSON(e,t){const a=super.toJSON(e,t);return this.__valueParam&&(a.valueParamType=this.__valueParam.constructor.name),a}fromJSON(e,t,a){if(e.valueParamType){const t=C.constructClass(e.valueParamType,"Value");t&&(this.__valueParam=this.addParameter(t));}super.fromJSON(e,t,a);}}C.registerClass("SetParameterValue",Ls);class vs extends Is{constructor(e){super(e),this.__geomParam=this.addParameter(new Le("TreeItem")),this.__geomParam.valueChanged.connect(()=>{this.__geom=this.__geomParam.getValue();});}__geomClicked(e){e.stopPropagation(),this.__onEvent();}activate(){this.__geom&&this.__geom.mouseDown.connect(this.__geomClicked.bind(this));}deactivate(){this.__geom&&this.__geom.mouseDown.disconnect(this.__geomClicked.bind(this));}}C.registerClass("GeomClicked",vs);class Ms extends Is{constructor(e){super(e),this.onKeyPressed=this.onKeyPressed.bind(this),this.__keyParam=this.addParameter(new xe("Key",""));}onKeyPressed(e){console.log(e.key),e.key==this.__keyParam.getValue()&&this.__onEvent();}activate(){document.addEventListener("keydown",this.onKeyPressed);}deactivate(){document.removeEventListener("keydown",this.onKeyPressed);}}C.registerClass("KeyPressedEvent",Ms);class Fs extends Is{constructor(e){super(e),this.__waitTimeParam=this.addParameter(new ue("WaitTime",1));}activate(){this.__timeoutId=window.setTimeout(()=>{delete this.__timeoutId,this.__onEvent();},1e3*this.__waitTimeParam.getValue());}deactivate(){this.__timeoutId&&window.clearTimeout(this.__timeoutId);}}C.registerClass("TimedWait",Fs);const Ts={onResize:e,...a,...R,...M,...va,...fs,...Object.freeze({__proto__:null,State:Vs,StateAction:xs,StateEvent:Is,StateMachine:Rs,SwitchState:Ss,SetCameraPositionAndTarget:Ws,SetParameterValue:Ls,GeomClicked:vs,KeyPressedEvent:Ms,TimedWait:Fs})};exports.AimOperator=Wa,exports.AssetItem=da,exports.Async=L,exports.AttrValue=l,exports.Attribute=St,exports.AudioItem=ta,exports.BackgroundImageShader=hi,exports.BaseGeom=Wt,exports.BaseGeomItem=ia,exports.BaseImage=Te,exports.BaseItem=D,exports.BaseParameter=J,exports.BillboardItem=ha,exports.BillboardShader=Ti,exports.BinReader=de,exports.BinWriter=he,exports.BooleanParameter=pe,exports.Box2=y,exports.Box3=V,exports.CalcGlobalXfoOperator=Xa,exports.Camera=ca,exports.CameraMouseAndKeyboard=La,exports.Circle=zt,exports.CloneFlags=qt,exports.CodeParameter=Ie,exports.Color=u,exports.ColorParameter=Ge,exports.Command=me,exports.Cone=Et,exports.ConvolverShader=li,exports.Cross=Ut,exports.Cuboid=Ht,exports.Cylinder=kt,exports.DataImage=we,exports.DepthMapShader=Ci,exports.Disc=Bt,exports.DualFishEyeEnvMapShader=bi,exports.DualFishEyeToLatLongBackgroundShader=pi,exports.EnvMap=Zt,exports.EnvMapShader=di,exports.EnvProjectionShader=Yi,exports.EulerAngles=p,exports.ExplodePartsOperator=fa,exports.FatLinesShader=wi,exports.FatPointsGeomDataShader=Di,exports.FatPointsSelectedShader=Oi,exports.FatPointsShader=Bi,exports.FileAudioItem=aa,exports.FileImage=it,exports.FileImage2D=st,exports.FilePathParameter=Re,exports.FlatAlphaSurfaceShader=Ui,exports.FlatSurfaceShader=zi,exports.Float32=6,exports.Frustum=I,exports.GIFImage=ot,exports.GLAudioItemsPass=ys,exports.GLBaseViewport=Gi,exports.GLBillboardsPass=Zs,exports.GLFbo=Ha,exports.GLLines=wa,exports.GLMaterial=$a,exports.GLMesh=Ka,exports.GLOpaqueGeomsPass=gs,exports.GLOverlayPass=Gs,exports.GLPass=Li,exports.GLPoints=za,exports.GLRenderTarget=ei,exports.GLRenderer=Fi,exports.GLShader=Pa,exports.GLStandardGeomsPass=ms,exports.GLTexture2D=Fa,exports.GLTransparentGeomsPass=_s,exports.GLViewport=Xi,exports.GearsOperator=xa,exports.GeomClicked=vs,exports.GeomItem=sa,exports.GeomLibrary=oa,exports.GeometryParameter=Fe,exports.Grid=Pt,exports.Group=la,exports.GrowingPacker=W,exports.HandleGeomDataShader=ts,exports.HandleShader=es,exports.ImageParameter=Ve,exports.InstanceItem=ea,exports.ItemFlags=k,exports.ItemSetParameter=ve,exports.JSON_stringify_fixedPrecision=n,exports.KeyPressedEvent=Ms,exports.LDRImage=lt,exports.LDRVideo=rt,exports.Label=ft,exports.LatLongEnvMapShader=mi,exports.LatLongEnvProjectionShader=Ki,exports.LayeredCarPaintShader=Ji,exports.Lightmap=Gt,exports.LightmapMixer=Xt,exports.Lines=Mt,exports.LinesCuboid=Jt,exports.LinesProxy=Yt,exports.LinesShader=Ei,exports.ListParameter=Se,exports.LoadFlags=jt,exports.Mat3=g,exports.Mat3Parameter=Xe,exports.Mat4=_,exports.Mat4Parameter=ye,exports.Material=Ke,exports.MaterialColorParam=Ye,exports.MaterialFloatParam=Ce,exports.MaterialLibrary=xt,exports.MaterialParameter=Rt,exports.Mesh=Ft,exports.MeshProxy=Nt,exports.MultiChoiceParameter=be,exports.NormalsShader=Hi,exports.NumberParameter=ue,exports.ObjAsset=ga,exports.OctahedralEnvMapShader=ci,exports.OctahedralEnvProjectionShader=Ni,exports.Operator=_a,exports.OperatorOutput=Za,exports.ParamFlags=K,exports.Parameter=P,exports.ParameterOwner=H,exports.PassType=Wi,exports.PistonOperator=Ra,exports.Plane=Dt,exports.PlaneType=x,exports.PointGrid=Kt,exports.Points=vt,exports.PointsProxy=Ct,exports.PointsShader=ki,exports.PostProcessing=Qi,exports.ProxyParameter=Me,exports.Quat=Z,exports.RGBA=m,exports.Ray=G,exports.Rect=wt,exports.RefCounted=T,exports.RouterOperator=Sa,exports.SAVE_FLAG_SKIP_GEOMDATA=1024,exports.SInt16=3,exports.SInt32=5,exports.SInt8=1,exports.SaveFlags=At,exports.Scene=pa,exports.ScreenQuadShader=_i,exports.ScreenSpaceShader=is,exports.SetCameraPositionAndTarget=Ws,exports.SetParameterValue=Ls,exports.Signal=S,exports.SimpleSurfaceShader=Ai,exports.Sphere=Ot,exports.SphereType=f,exports.StandardSurfaceGeomDataShader=qi,exports.StandardSurfaceSelectedGeomsShader=$i,exports.StandardSurfaceShader=ji,exports.State=Vs,exports.StateAction=xs,exports.StateEvent=Is,exports.StateMachine=Rs,exports.SterioLatLongEnvMapShader=ui,exports.StringParameter=xe,exports.StructParameter=We,exports.SwitchState=Ss,exports.SystemDesc=t,exports.TimedWait=Fs,exports.ToolIconShader=ss,exports.Torus=Qt,exports.TransparentSurfaceShader=as,exports.TreeItem=$t,exports.TreeItemParameter=Le,exports.UInt16=2,exports.UInt32=4,exports.UInt8=0,exports.UnpackHDRShader=Ea,exports.UnpackLDRAlphaImageShader=ns,exports.VLAAsset=ua,exports.VRViewport=Vi,exports.ValueGetMode=Y,exports.ValueSetMode=N,exports.Vec2=o,exports.Vec2Parameter=ge,exports.Vec3=d,exports.Vec3Parameter=_e,exports.Vec4=h,exports.Vec4Parameter=Ze,exports.Version=oe,exports.VertexAttribute=Lt,exports.VideoStreamImage2D=Vt,exports.WireShader=ls,exports.Xfo=X,exports.XfoOperatorOutput=Ga,exports.XfoParameter=fe,exports.create3DContext=Ma,exports.decodeText=v,exports.default=Ts,exports.generateShaderGeomBinding=Ya,exports.getFileFolder=O,exports.hashStr=s,exports.isObject=ne,exports.labelManager=yt,exports.loadBinfile=ee,exports.loadJSONfile=q,exports.loadTextfile=A,exports.loadXMLfile=$,exports.materialLibraryManager=It,exports.mergeDeep=le,exports.onResize=e,exports.resourceLoader=re,exports.sgFactory=C,exports.shaderLibrary=Ja,exports.typeRegistry=r;
});

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

var parseuri = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

/**
 * Helpers.
 */

var s$1 = 1000;
var m$1 = s$1 * 60;
var h$1 = m$1 * 60;
var d$1 = h$1 * 24;
var w$1 = d$1 * 7;
var y$1 = d$1 * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$1;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w$1;
    case 'days':
    case 'day':
    case 'd':
      return n * d$1;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$1;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$1) {
    return Math.round(ms / d$1) + 'd';
  }
  if (msAbs >= h$1) {
    return Math.round(ms / h$1) + 'h';
  }
  if (msAbs >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }
  if (msAbs >= s$1) {
    return Math.round(ms / s$1) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$1) {
    return plural(ms, msAbs, d$1, 'day');
  }
  if (msAbs >= h$1) {
    return plural(ms, msAbs, h$1, 'hour');
  }
  if (msAbs >= m$1) {
    return plural(ms, msAbs, m$1, 'minute');
  }
  if (msAbs >= s$1) {
    return plural(ms, msAbs, s$1, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common = setup;

var browser$1 = createCommonjsModule(function (module, exports) {
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = common(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};
});

/**
 * Module dependencies.
 */


var debug = browser$1('socket.io-client:url');

/**
 * Module exports.
 */

var url_1 = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

/**
 * Helpers.
 */

var s$2 = 1000;
var m$2 = s$2 * 60;
var h$2 = m$2 * 60;
var d$2 = h$2 * 24;
var y$2 = d$2 * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$1 = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong$1(val) : fmtShort$1(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$1(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$2;
    case 'days':
    case 'day':
    case 'd':
      return n * d$2;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$2;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$2;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$2;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort$1(ms) {
  if (ms >= d$2) {
    return Math.round(ms / d$2) + 'd';
  }
  if (ms >= h$2) {
    return Math.round(ms / h$2) + 'h';
  }
  if (ms >= m$2) {
    return Math.round(ms / m$2) + 'm';
  }
  if (ms >= s$2) {
    return Math.round(ms / s$2) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong$1(ms) {
  return plural$1(ms, d$2, 'day') ||
    plural$1(ms, h$2, 'hour') ||
    plural$1(ms, m$2, 'minute') ||
    plural$1(ms, s$2, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural$1(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

var debug$1 = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms$1;

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});

var browser$2 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$1;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});

var componentEmitter = createCommonjsModule(function (module) {
/**
 * Expose `Emitter`.
 */

{
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};
});

var toString$2 = {}.toString;

var isarray$1 = Array.isArray || function (arr) {
  return toString$2.call(arr) == '[object Array]';
};

var isBuffer$1 = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

/*global Blob,File*/

/**
 * Module requirements
 */



var toString$3 = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString$3.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString$3.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

var deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuffer$1(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isarray$1(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

var reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isarray$1(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

var removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isarray$1(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuffer$1(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

var binary = {
	deconstructPacket: deconstructPacket,
	reconstructPacket: reconstructPacket,
	removeBlobs: removeBlobs
};

var socket_ioParser = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */

var debug = browser$2('socket.io-parser');





/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

componentEmitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuffer$1(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isarray$1(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}
});

var hasCors = createCommonjsModule(function (module) {
/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}
});

var globalThis_browser = (function () {
  if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')(); // eslint-disable-line no-new-func
  }
})();

// browser shim for xmlhttprequest module




var xmlhttprequest = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCors)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new globalThis_browser[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

var keys = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

var toString$4 = {}.toString;

var isarray$2 = Array.isArray || function (arr) {
  return toString$4.call(arr) == '[object Array]';
};

/* global Blob File */

/*
 * Module requirements.
 */



var toString$5 = Object.prototype.toString;
var withNativeBlob$1 = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString$5.call(Blob) === '[object BlobConstructor]';
var withNativeFile$1 = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString$5.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

var hasBinary2 = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isarray$2(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob$1 && obj instanceof Blob) ||
    (withNativeFile$1 && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

var arraybuffer_slice = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

var after_1 = after;

function after(count, callback, err_cb) {
    var bail = false;
    err_cb = err_cb || noop;
    proxy.count = count;

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count;

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true;
            callback(err);
            // future error callbacks will go to error handler
            callback = err_cb;
        } else if (proxy.count === 0 && !bail) {
            callback(null, result);
        }
    }
}

function noop() {}

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, its not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

var utf8 = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};

var base64Arraybuffer = createCommonjsModule(function (module, exports) {
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();
});

/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
}
function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
}
if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

var blob = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

var browser$3 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */







var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = base64Arraybuffer;
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */



/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof blob !== 'undefined' && data instanceof blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob$1 = new blob([length.buffer, packet.data]);

  return callback(blob$1);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof blob !== 'undefined' && packet.data instanceof blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = arraybuffer_slice(data, 1);
  if (blob && binaryType === 'blob') {
    rest = new blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && blob) {
    data = new blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary2(packets);

  if (supportsBinary && isBinary) {
    if (blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after_1(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (blob) {
        var blob$1 = new blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob$1);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = arraybuffer_slice(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = arraybuffer_slice(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = arraybuffer_slice(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};
});

var componentEmitter$1 = createCommonjsModule(function (module) {
/**
 * Expose `Emitter`.
 */

{
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};
});

/**
 * Module dependencies.
 */




/**
 * Module exports.
 */

var transport = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

componentEmitter$1(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = browser$3.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

var encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

var decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

var parseqs = {
	encode: encode,
	decode: decode
};

var componentInherit = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i$2 = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode$1(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode$1(str) {
  var decoded = 0;

  for (i$2 = 0; i$2 < str.length; i$2++) {
    decoded = decoded * length + map[str.charAt(i$2)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode$1(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode$1(seed++);
}

//
// Map each character to its index.
//
for (; i$2 < length; i$2++) map[alphabet[i$2]] = i$2;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode$1;
yeast.decode = decode$1;
var yeast_1 = yeast;

/**
 * Helpers.
 */

var s$3 = 1000;
var m$3 = s$3 * 60;
var h$3 = m$3 * 60;
var d$3 = h$3 * 24;
var w$2 = d$3 * 7;
var y$3 = d$3 * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$2 = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$2(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong$2(val) : fmtShort$2(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$2(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$3;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w$2;
    case 'days':
    case 'day':
    case 'd':
      return n * d$3;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$3;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$3;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$3;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort$2(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$3) {
    return Math.round(ms / d$3) + 'd';
  }
  if (msAbs >= h$3) {
    return Math.round(ms / h$3) + 'h';
  }
  if (msAbs >= m$3) {
    return Math.round(ms / m$3) + 'm';
  }
  if (msAbs >= s$3) {
    return Math.round(ms / s$3) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong$2(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$3) {
    return plural$2(ms, msAbs, d$3, 'day');
  }
  if (msAbs >= h$3) {
    return plural$2(ms, msAbs, h$3, 'hour');
  }
  if (msAbs >= m$3) {
    return plural$2(ms, msAbs, m$3, 'minute');
  }
  if (msAbs >= s$3) {
    return plural$2(ms, msAbs, s$3, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural$2(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup$1(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms$2;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common$1 = setup$1;

var browser$4 = createCommonjsModule(function (module, exports) {
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = common$1(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};
});

/**
 * Module dependencies.
 */






var debug$2 = browser$4('engine.io-client:polling');

/**
 * Module exports.
 */

var polling = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = xmlhttprequest;
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

componentInherit(Polling, transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug$2('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug$2('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug$2('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug$2('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug$2('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug$2('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug$2('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  browser$3.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug$2('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug$2('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug$2('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug$2('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  browser$3.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/* global attachEvent */

/**
 * Module requirements.
 */





var debug$3 = browser$4('engine.io-client:polling-xhr');


/**
 * Module exports.
 */

var pollingXhr = XHR;
var Request_1 = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

componentInherit(XHR, polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug$3('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

componentEmitter$1(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new xmlhttprequest(opts);
  var self = this;

  try {
    debug$3('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = this.withCredentials;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
          }, 0);
        }
      };
    }

    debug$3('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in globalThis_browser ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
pollingXhr.Request = Request_1;

/**
 * Module requirements.
 */





/**
 * Module exports.
 */

var pollingJsonp = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks$1;

/**
 * Noop.
 */

function empty$1 () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks$1) {
    // we need to consider multiple engines in the same page
    callbacks$1 = globalThis_browser.___eio = (globalThis_browser.___eio || []);
  }

  // callback identifier
  this.index = callbacks$1.length;

  // add callback to jsonp global
  var self = this;
  callbacks$1.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty$1;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

componentInherit(JSONPPolling, polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

const _nodeResolve_empty = {};

const _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
});

/**
 * Module dependencies.
 */






var debug$4 = browser$4('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}

if (typeof window === 'undefined') {
  try {
    NodeWebSocket = _nodeResolve_empty$1;
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

var websocket = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

componentInherit(WS, transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      browser$3.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug$4('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast_1();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

/**
 * Module dependencies
 */






/**
 * Export transports.
 */

var polling_1 = polling$1;
var websocket_1 = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling$1 (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new xmlhttprequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new pollingXhr(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new pollingJsonp(opts);
  }
}

var transports = {
	polling: polling_1,
	websocket: websocket_1
};

var indexOf = [].indexOf;

var indexof = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/**
 * Module dependencies.
 */



var debug$5 = browser$4('engine.io-client:socket');





/**
 * Module exports.
 */

var socket = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

componentEmitter$1(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = browser$3.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = transport;
Socket.transports = transports;
Socket.parser = browser$3;

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug$5('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = browser$3.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    withCredentials: options.withCredentials || this.withCredentials,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug$5('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug$5('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug$5('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug$5('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug$5('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug$5('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug$5('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug$5('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug$5('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug$5('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug$5('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug$5('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug$5('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug$5('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug$5('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug$5('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug$5('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug$5('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug$5('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~indexof(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

var lib = socket;

/**
 * Exports parser
 *
 * @api public
 *
 */
var parser = browser$3;
lib.parser = parser;

var componentEmitter$2 = createCommonjsModule(function (module) {
/**
 * Expose `Emitter`.
 */

{
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};
});

var toArray_1 = toArray;

function toArray(list, index) {
    var array = [];

    index = index || 0;

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i];
    }

    return array
}

/**
 * Module exports.
 */

var on_1 = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

var componentBind = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

var socket$1 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */






var debug = browser$1('socket.io-client:socket');



/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = componentEmitter$2.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

componentEmitter$2(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on_1(io, 'open', componentBind(this, 'onopen')),
    on_1(io, 'packet', componentBind(this, 'onpacket')),
    on_1(io, 'close', componentBind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray_1(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray_1(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBinary2(args)) ? socket_ioParser.BINARY_EVENT : socket_ioParser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: socket_ioParser.CONNECT, query: query});
    } else {
      this.packet({type: socket_ioParser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === socket_ioParser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case socket_ioParser.CONNECT:
      this.onconnect();
      break;

    case socket_ioParser.EVENT:
      this.onevent(packet);
      break;

    case socket_ioParser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case socket_ioParser.ACK:
      this.onack(packet);
      break;

    case socket_ioParser.BINARY_ACK:
      this.onack(packet);
      break;

    case socket_ioParser.DISCONNECT:
      this.ondisconnect();
      break;

    case socket_ioParser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray_1(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBinary2(args) ? socket_ioParser.BINARY_ACK : socket_ioParser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: socket_ioParser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};
});

/**
 * Expose `Backoff`.
 */

var backo2 = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};

/**
 * Module dependencies.
 */







var debug$6 = browser$1('socket.io-client:manager');



/**
 * IE6+ hasOwnProperty
 */

var has$1 = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

var manager = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new backo2({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || socket_ioParser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has$1.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has$1.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

componentEmitter$2(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug$6('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug$6('opening %s', this.uri);
  this.engine = lib(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on_1(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on_1(socket, 'error', function (data) {
    debug$6('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug$6('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug$6('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug$6('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on_1(socket, 'data', componentBind(this, 'ondata')));
  this.subs.push(on_1(socket, 'ping', componentBind(this, 'onping')));
  this.subs.push(on_1(socket, 'pong', componentBind(this, 'onpong')));
  this.subs.push(on_1(socket, 'error', componentBind(this, 'onerror')));
  this.subs.push(on_1(socket, 'close', componentBind(this, 'onclose')));
  this.subs.push(on_1(this.decoder, 'decoded', componentBind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug$6('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new socket$1(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexof(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexof(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug$6('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug$6('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug$6('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug$6('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug$6('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug$6('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug$6('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug$6('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug$6('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

var lib$1 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




var debug = browser$1('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url_1(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = socket_ioParser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = manager;
exports.Socket = socket$1;
});

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

const events$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': EventEmitter,
    EventEmitter: EventEmitter
});

var BuiltInEmitter = events$1.EventEmitter;

var socketioWildcard = function (CustomEmitter) {
  var Emitter = CustomEmitter || BuiltInEmitter;
  var emit = Emitter.prototype.emit;

  function onevent (packet) {
    var args = packet.data || [];
    if (packet.id != null) {
      args.push(this.ack(packet.id));
    }
    emit.call(this, '*', packet);
    return emit.apply(this, args)
  }

  return function (socket, next) {
    if (socket.onevent !== onevent) {
      socket.onevent = onevent;
    }
    return next ? next() : null
  }
};

const t$1={JOIN_ROOM:"join-room",PING_ROOM:"ping-room",LEAVE_ROOM:"leave-room"};class i$3{constructor(s,e){this.userData=s,this.socketUrl=e,this.users={},this.userStreams={},this.callbacks={},this.envIsBrowser="undefined"!=typeof window;}stopCamera(s=!0){this.stream&&(this.stream.getVideoTracks()[0].enabled=!1,s&&this.pub(i$3.actions.USER_VIDEO_STOPPED,{}));}startCamera(s=!0){this.stream&&(this.stream.getVideoTracks()[0].enabled=!0,s&&this.pub(i$3.actions.USER_VIDEO_STARTED,{}));}muteAudio(s=!0){this.stream&&(this.stream.getAudioTracks()[0].enabled=!1,s&&this.pub(i$3.actions.USER_VIDEO_STOPPED,{}));}unmuteAudio(s=!0){this.stream&&(this.stream.getAudioTracks()[0].enabled=!0,s&&this.pub(i$3.actions.USER_AUDIO_STARTED,{}));}getVideoStream(s){return this.userStreams[s]}setVideoStream(s,e){if(this.userStreams[e])return;const t=document.createElement("video");t.srcObject=s,this.userStreams[e]=t,t.onloadedmetadata=()=>{t.play();},document.body.appendChild(t);}static concatFullRoomId(s,e,t){return s+(e||"_ALL_FILES_")+(t||"_ALL_ROOMS_")}isJoiningTheSameRoom(s,e,t){return this.fullRoomId===i$3.concatFullRoomId(s,e,t)}joinRoom(o,r,a){this.projectId=o,this.fileId=r,this.roomId=a,this.fullRoomId=i$3.concatFullRoomId(this.projectId,this.fileId,this.roomId),this.leaveRoom(),this.socket=lib$1(this.socketUrl,{"sync disconnect on unload":!0,query:`userId=${this.userData.id}&roomId=${this.fullRoomId}`}),socketioWildcard(lib$1.Manager)(this.socket),this.socket.on("*",s=>{const[e,i]=s.data;e in t$1||this._emit(e,i.payload,i.userId);}),this.envIsBrowser&&window.addEventListener("beforeunload",()=>{this.leaveRoom();}),this.pub(t$1.JOIN_ROOM),this.socket.on(t$1.JOIN_ROOM,s=>{console.info(`${t$1.JOIN_ROOM}:`,s);const e=s.userData;this._addUserIfNew(e),this.pub(t$1.PING_ROOM);}),this.socket.on(t$1.LEAVE_ROOM,s=>{console.info(`${t$1.LEAVE_ROOM}:`,s);const e=s.userData,o=e.id;if(o in this.users)return delete this.users[o],void this._emit(i$3.actions.USER_LEFT,e);console.warn("Outgoing user was not found in room.");}),this.socket.on(t$1.PING_ROOM,s=>{console.info(`${t$1.PING_ROOM}:`,s);const e=s.userData;this._addUserIfNew(e);});}_prepareMediaStream(){return this.__streamPromise||(this.__streamPromise=new window.Promise((s,e)=>{this.stream?s():navigator.mediaDevices.getUserMedia({audio:!0,video:{width:400,height:300}}).then(e=>{this.stream=e,this.stopCamera(!1),this.muteAudio(!1),s();}).catch(s=>{e(s);});})),this.__streamPromise}leaveRoom(){this._emit(i$3.actions.LEFT_ROOM),this.users={},this.socket&&this.pub(t$1.LEAVE_ROOM,void 0,()=>{this.socket.close();});}_addUserIfNew(s){s.id in this.users||(this.users[s.id]=s,this._emit(i$3.actions.USER_JOINED,s));}createRoom(){return this.roomId=shortid.generate(),this.joinRoom(this.projectId,this.fileId,this.roomId),this.envIsBrowser&&window.history.pushState(null,null,`?project-id=${this.projectId}&file-id=${this.fileId}&room-id=${this.roomId}`),this.roomId}getUsers(){return this.users}getUser(s){return this.users[s]}pub(s,e,t){if(!s)throw new Error("Missing messageType");this.socket.emit(s,{userData:this.userData,userId:this.userData.id,payload:e},t);}_emit(s,e,t){const i=this.callbacks[s];i&&i.forEach(s=>s(e,t));}sub(s,e){if(!s)throw new Error("Missing messageType");if(!e)throw new Error("Missing callback");this.callbacks[s]=this.callbacks[s]||[],this.callbacks[s].push(e);return ()=>{this.callbacks[s].splice(this.callbacks[s].indexOf(e),1);}}}i$3.actions={USER_JOINED:"user-joined",USER_VIDEO_STARTED:"user-video-started",USER_VIDEO_STOPPED:"user-video-stopped",USER_AUDIO_STARTED:"user-audio-started",USER_AUDIO_STOPPED:"user-audio-stopped",USER_LEFT:"user-left",LEFT_ROOM:"left-room",TEXT_MESSAGE:"text-message",POSE_CHANGED:"pose-message",COMMAND_ADDED:"command-added",COMMAND_UPDATED:"command-updated",FILE_WITH_PROGRESS:"file-with-progress"};class o$1{static setSocketURL(s){this.socketUrl=s;}static getInstance(s,e,t,o){if(!this.session){if(!this.socketUrl)throw new Error("Missing #socketUrl. Call #setSocketURL first.");this.session=new i$3(s,this.socketUrl);}return this.session.isJoiningTheSameRoom(e,t,o)||this.session.joinRoom(e,t,o),this.session}static getCurrentSession(){return this.session}}class r$1{constructor(s){if(this.actionRegistry=s,this.__recordings={},self.origin.startsWith("https://localhost")){const e=["https://upload.wikimedia.org/wikipedia/commons/7/7c/Profile_avatar_placeholder_large.png"],t={};let i,o,r;const a=()=>{const s=(a=e.length,Math.floor(Math.random()*Math.floor(a)));var a;i={id:"_"+Math.random().toString(36).substr(2,9),picture:e[s],name:"Presenter"+Object.keys(t).length},r=[];let n={messageType:"user-joined",payload:i},c=performance.now();o=this.session.pub,this.session.pub=(s,e)=>{const t=performance.now();n.ms=t-c,r.push(n),n={messageType:s,payload:e},c=t,o.call(this.session,s,e);};},n=()=>{r.push({messageType:"user-left",payload:i}),t[i.id]=r,this.session.pub=o,this.__playRecording(t);};let c=!1;s.registerAction({path:["Sessions"],name:"Toggle Recording",callback:()=>{c?(n(),c=!1):(a(),c=!0);},availableInVR:!0}),s.registerAction({path:["Sessions"],name:"Stop Recording",callback:()=>{n();},availableInVR:!0}),s.registerAction({path:["Sessions"],name:"Save",callback:()=>{this.save(t);}});}}setSession(s){this.session=s;}setResourceLoader(s){this.resourceLoader=s;const e=s=>{this.__recordings[s.name]=s,this.actionRegistry.registerAction({path:["Sessions","Recordings"],name:s.name,callback:()=>{this.playRecording(s.name);},availableInVR:!0});};this.resourceLoader.registerResourceCallback(".rec",s=>{e(s);});}save(s){!function(s,e,t){var i=new Blob([s],{type:t});if(window.navigator.msSaveOrOpenBlob)window.navigator.msSaveOrOpenBlob(i,e);else {var o=document.createElement("a"),r=URL.createObjectURL(i);o.href=r,o.download=e,document.body.appendChild(o),o.click(),setTimeout((function(){document.body.removeChild(o),window.URL.revokeObjectURL(r);}),0);}}(JSON.stringify(s),"MyRec.rec","application/json");}__stopPlayback(){for(let s in this.__timeoutIds)clearTimeout(this.__timeoutIds[s]);this.__timeoutIds={};}__play(s,e,t){let i=0;const o=()=>{const r=e[i];this.session._emit(r.messageType,r.payload,s),i++,i<e.length?this.__timeoutIds[s]=setTimeout(o,r.ms):t();};this.__timeoutIds[s]=setTimeout(o,1e3);}__playRecording(s){this.__stopPlayback();let e=0;this.__timeoutIds={};for(let t in s)e++,this.__play(t,s[t],()=>{e--,0==e&&this.__playRecording(s);});}playRecording(s){const e=this.__recordings[s];this.resourceLoader.loadResource(e.id,s=>{const e=JSON.parse(session.decodeText(s.rec));this.__playRecording(e);});}}

const zeaCollab_esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Session: i$3,
    SessionFactory: o$1,
    SessionRecorder: r$1
});

var zeaUx_cjs = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports,"__esModule",{value:!0});var e=zeaEngine_cjs,t=zeaCollab_esm;const s={},i={},n=[];class o{constructor(){this.__undoStack=[],this.__redoStack=[],this.changeAdded=new e.Signal,this.changeUpdated=new e.Signal,this.changeUndone=new e.Signal,this.changeRedone=new e.Signal,this.__currChangeUpdated=this.__currChangeUpdated.bind(this);}flush(){for(const e of this.__undoStack)e.destroy();this.__undoStack=[];for(const e of this.__redoStack)e.destroy();this.__redoStack=[];}addChange(e){this.getCurrentChange()&&this.getCurrentChange().updated.disconnect(this.__currChangeUpdated),this.__undoStack.push(e),e.updated.connect(this.__currChangeUpdated);for(const e of this.__redoStack)e.destroy();this.__redoStack=[],this.changeAdded.emit(e);}getCurrentChange(){return this.__undoStack[this.__undoStack.length-1]}__currChangeUpdated(e){this.changeUpdated.emit(e);}undo(e=!0){if(this.__undoStack.length>0){const t=this.__undoStack.pop();t.undo(),e&&(this.__redoStack.push(t),this.changeUndone.emit());}}redo(){if(this.__redoStack.length>0){const e=this.__redoStack.pop();e.redo(),this.__undoStack.push(e),this.changeRedone.emit();}}constructChange(e){return new s[e]}static getChangeClassName(e){const t=n.indexOf(e.constructor);return i[t]?i[t]:(console.warn("Change not registered:",e.constructor.name),e.constructor.name)}static registerChange(e,t){-1!=n.indexOf(t)&&console.warn("Class already registered:",e);const o=n.length;n.push(t),s[e]=t,i[o]=e;}}class a{constructor(t){this.name=t||o.getChangeClassName(this),this.updated=new e.Signal;}undo(){throw new Error("Implement me")}redo(){throw new Error("Implement me")}update(e){throw new Error("Implement me")}toJSON(e){return {}}fromJSON(e,t){}changeFromJSON(e){this.update(e);}destroy(){}}class r extends e.TreeItem{constructor(e){super(e),this.captured=!1;}highlight(){}unhighlight(){}getManipulationPlane(){const t=this.getGlobalXfo();return new e.Ray(t.tr,t.ori.getZaxis())}onMouseEnter(e){this.highlight();}onMouseLeave(e){this.unhighlight();}onMouseDown(e){e.setCapture(this),e.stopPropagation(),this.captured=!0,e.viewport?this.handleMouseDown(e):e.vrviewport&&this.onVRControllerButtonDown(e);}onMouseMove(e){this.captured&&(e.stopPropagation(),e.viewport?this.handleMouseMove(e):e.vrviewport&&this.onVRPoseChanged(e));}onMouseUp(e){this.captured&&(e.releaseCapture(),e.stopPropagation(),this.captured=!1,e.viewport?this.handleMouseUp(e):e.vrviewport&&this.onVRControllerButtonUp(e));}onWheel(e){}handleMouseDown(e){this.gizmoRay=this.getManipulationPlane();const t=e.mouseRay.intersectRayPlane(this.gizmoRay);return e.grabPos=e.mouseRay.pointAtDist(t),this.onDragStart(e),!0}handleMouseMove(e){const t=e.mouseRay.intersectRayPlane(this.gizmoRay);return e.holdPos=e.mouseRay.pointAtDist(t),this.onDrag(e),!0}handleMouseUp(e){const t=e.mouseRay.intersectRayPlane(this.gizmoRay);return e.releasePos=e.mouseRay.pointAtDist(t),this.onDragEnd(e),!0}onVRControllerButtonDown(e){this.activeController=e.controller;const t=this.activeController.getTipXfo().clone(),s=this.getManipulationPlane(),i=t.tr.subtract(s.start),n=t.tr.subtract(s.dir.scale(i.dot(s.dir)));return e.grabPos=n,this.onDragStart(e),!0}onVRPoseChanged(e){if(this.activeController){const t=this.activeController.getTipXfo(),s=this.getManipulationPlane(),i=t.tr.subtract(s.start),n=t.tr.subtract(s.dir.scale(i.dot(s.dir)));return e.holdPos=n,this.onDrag(e),!0}}onVRControllerButtonUp(e){if(this.activeController==e.controller){const t=this.activeController.getTipXfo();return this.onDragEnd(e,t.tr),this.activeController=void 0,!0}}onDragStart(e){console.log("onDragStart",e);}onDrag(e){console.log("onDrag",e);}onDragEnd(e){console.log("onDragEnd",e);}}class l extends r{constructor(e){super(e);}handleMouseDown(e){this.gizmoRay=this.getManipulationPlane(),this.grabDist=e.mouseRay.intersectRayVector(this.gizmoRay)[1];const t=this.gizmoRay.pointAtDist(this.grabDist);return e.grabDist=this.grabDist,e.grabPos=t,this.onDragStart(e),!0}handleMouseMove(e){const t=e.mouseRay.intersectRayVector(this.gizmoRay)[1],s=this.gizmoRay.pointAtDist(t);e.holdDist=t,e.holdPos=s,e.value=t,e.delta=t-this.grabDist,this.onDrag(e);}handleMouseUp(e){const t=e.mouseRay.intersectRayVector(this.gizmoRay)[1],s=this.gizmoRay.pointAtDist(t);return e.releasePos=s,this.onDragEnd(e),!0}onVRControllerButtonDown(e){this.gizmoRay=this.getManipulationPlane(),this.activeController=e.controller;const t=this.activeController.getTipXfo();this.grabDist=t.tr.subtract(this.gizmoRay.start).dot(this.gizmoRay.dir);const s=this.gizmoRay.start.add(this.gizmoRay.dir.scale(this.grabDist));return e.grabPos=s,this.onDragStart(e),!0}onVRPoseChanged(e){const t=this.activeController.getTipXfo().tr.subtract(this.gizmoRay.start).dot(this.gizmoRay.dir),s=this.gizmoRay.start.add(this.gizmoRay.dir.scale(t));return e.value=t,e.holdPos=s,e.delta=t-this.grabDist,this.onDrag(e),!0}onVRControllerButtonUp(e){if(this.activeController==e.controller)return this.onDragEnd(),this.activeController=void 0,!0}}class h extends a{constructor(t,s,i=e.ValueSetMode.USER_SETVALUE){t?(super(t?t.getName()+" Changed":"ParameterValueChange"),this.__prevValue=t.getValue(),this.__param=t,this.__mode=i,null!=s&&(this.__nextValue=s,this.__param.setValue(this.__nextValue,i))):super();}undo(){this.__param&&this.__param.setValue(this.__prevValue,this.__mode);}redo(){this.__param&&this.__param.setValue(this.__nextValue,this.__mode);}update(e){if(!this.__param)return;this.__nextValue=e.value;const t=e.mode?e.mode:this.__mode;this.__param.setValue(this.__nextValue,t),this.updated.emit(e);}toJSON(e){const t={name:this.name,paramPath:this.__param.getPath()};return null!=this.__nextValue&&(this.__nextValue.toJSON?t.value=this.__nextValue.toJSON():t.value=this.__nextValue),t}fromJSON(t,s){const i=s.appData.scene.getRoot().resolvePath(t.paramPath,1);i&&i instanceof e.Parameter?(this.__param=i,this.__prevValue=this.__param.getValue(),this.__prevValue.clone?this.__nextValue=this.__prevValue.clone():this.__nextValue=this.__prevValue,this.name=t.name,null!=t.value&&this.changeFromJSON(t)):console.warn("resolvePath is unable to resolve",t.paramPath);}changeFromJSON(t){this.__param&&(this.__nextValue.fromJSON?this.__nextValue.fromJSON(t.value):this.__nextValue=t.value,this.__param.setValue(this.__nextValue,e.ValueSetMode.REMOTEUSER_SETVALUE));}}o.registerChange("ParameterValueChange",h);class c extends l{constructor(t,s,i,n){super(t),this.__color=n,this.__hilightedColor=new e.Color(1,1,1),this.colorParam=this.addParameter(new e.ColorParameter("BaseColor",n));const o=new e.Material("handle","HandleShader");o.getParameter("maintainScreenSize").setValue(1),o.replaceParameter(this.colorParam);const a=new e.Cylinder(i,s,64);a.getParameter("baseZAtZero").setValue(!0);const r=new e.Cone(4*i,10*i,64,!0),l=new e.GeomItem("handle",a,o),h=new e.GeomItem("tip",r,o),c=new e.Xfo;c.tr.set(0,0,s),r.transformVertices(c),this.addChild(l),this.addChild(h);}highlight(){this.colorParam.setValue(this.__hilightedColor);}unhighlight(){this.colorParam.setValue(this.__color);}setTargetParam(e,t=!0){if(this.param=e,t){const t=()=>{this.setGlobalXfo(e.getValue());};t(),e.valueChanged.connect(t);}}getTargetParam(){return this.param?this.param:this.getParameter("GlobalXfo")}onDragStart(e){this.grabPos=e.grabPos;const t=this.getTargetParam();this.baseXfo=t.getValue(),e.undoRedoManager&&(this.change=new h(t),e.undoRedoManager.addChange(this.change));}onDrag(e){const t=e.holdPos.subtract(this.grabPos),s=this.baseXfo.clone();s.tr.addInPlace(t),this.change?this.change.update({value:s}):this.param.setValue(s);}onDragEnd(e){this.change=null;}}class d extends r{constructor(e){super(e),this.fullXfoManipulationInVR=!0;}setTargetParam(e,t=!0){if(this.param=e,t){const t=()=>{this.setGlobalXfo(e.getValue());};t(),e.valueChanged.connect(t);}}getTargetParam(){return this.param?this.param:this.getParameter("GlobalXfo")}onDragStart(e){this.grabPos=e.grabPos;const t=this.getTargetParam();this.baseXfo=t.getValue(),e.undoRedoManager&&(this.change=new h(t),e.undoRedoManager.addChange(this.change));}onDrag(e){const t=e.holdPos.subtract(this.grabPos),s=this.baseXfo.clone();if(s.tr.addInPlace(t),this.change)this.change.update({value:s});else {this.getTargetParam().setValue(s);}}onDragEnd(e){this.change=null;}onVRControllerButtonDown(e){if(this.fullXfoManipulationInVR){this.activeController=e.controller;const t=this.activeController.getTipXfo(),s=this.getGlobalXfo();this.grabOffset=t.inverse().multiply(s);}else super.onVRControllerButtonDown(e);return !0}onVRPoseChanged(e){if(this.fullXfoManipulationInVR){const e=this.activeController.getTipXfo().multiply(this.grabOffset);if(this.change)this.change.update({value:e});else {this.getTargetParam().setValue(e);}}else super.onVRPoseChanged(e);}onVRControllerButtonUp(e){this.fullXfoManipulationInVR?this.change=null:super.onVRControllerButtonUp(e);}}class m extends r{constructor(e){super(e);}setTargetParam(e,t=!0){if(this.param=e,t){const t=()=>{this.setGlobalXfo(e.getValue());};t(),e.valueChanged.connect(t);}}getTargetParam(){return this.param?this.param:this.getParameter("GlobalXfo")}onDragStart(t){this.baseXfo=this.getGlobalXfo().clone(),this.baseXfo.sc.set(1,1,1),this.deltaXfo=new e.Xfo;const s=this.getTargetParam(),i=s.getValue();this.offsetXfo=this.baseXfo.inverse().multiply(i),this.vec0=t.grabPos.subtract(this.baseXfo.tr),this.grabCircleRadius=this.vec0.length(),this.vec0.normalizeInPlace(),t.undoRedoManager&&(this.change=new h(s),t.undoRedoManager.addChange(this.change));}onDrag(t){const s=t.holdPos.subtract(this.baseXfo.tr),i=s.length();s.normalizeInPlace();const n=i/this.grabCircleRadius;let o=this.vec0.angleTo(s)*n;if(this.vec0.cross(s).dot(this.baseXfo.ori.getZaxis())<0&&(o=-o),this.range&&(o=Math.clamp(o,this.range[0],this.range[1])),t.shiftKey){const e=Math.degToRad(22.5);o=Math.floor(o/e)*e;}this.deltaXfo.ori.setFromAxisAndAngle(new e.Vec3(0,0,1),o);const a=this.baseXfo.multiply(this.deltaXfo).multiply(this.offsetXfo);if(this.change)this.change.update({value:a});else {this.getTargetParam().setValue(a);}}onDragEnd(e){this.change=null;}}class u extends m{constructor(t,s,i,n){super(t),this.__color=n,this.__hilightedColor=new e.Color(1,1,1),this.radiusParam=this.addParameter(new e.NumberParameter("radius",s)),this.colorParam=this.addParameter(new e.ColorParameter("BaseColor",n));const o=new e.Material("handle","HandleShader");o.getParameter("maintainScreenSize").setValue(1),o.replaceParameter(this.colorParam);const a=new e.Torus(i,s,64);this.handle=new e.GeomItem("handle",a,o),this.handleXfo=new e.Xfo,this.radiusParam.valueChanged.connect(()=>{s=this.radiusParam.getValue(),a.getParameter("radius").setValue(s),a.getParameter("height").setValue(.02*s);}),this.addChild(this.handle);}highlight(){this.colorParam.setValue(this.__hilightedColor);}unhighlight(){this.colorParam.setValue(this.__color);}getBaseXfo(){return this.getParameter("GlobalXfo").getValue()}onDragStart(t){super.onDragStart(t),this.colorParam.setValue(new e.Color(1,1,1));}onDrag(e){super.onDrag(e);}onDragEnd(e){super.onDragEnd(e),this.colorParam.setValue(this.__color);}}class g extends l{constructor(t,s,i,n){super(t),this.__color=n,this.__hilightedColor=new e.Color(1,1,1),this.colorParam=this.addParameter(new e.ColorParameter("BaseColor",n));const o=new e.Material("handle","HandleShader");o.getParameter("maintainScreenSize").setValue(1),o.replaceParameter(this.colorParam);const a=new e.Cylinder(i,s-10*i,64);a.getParameter("baseZAtZero").setValue(!0);const r=new e.Cuboid(10*i,10*i,10*i),l=new e.GeomItem("handle",a,o),h=new e.GeomItem("tip",r,o),c=new e.Xfo;c.tr.set(0,0,s-10*i),r.transformVertices(c),this.addChild(l),this.addChild(h);}highlight(){this.colorParam.setValue(this.__hilightedColor);}unhighlight(){this.colorParam.setValue(this.__color);}setTargetParam(e,t=!0){if(this.param=e,t){const t=()=>{this.setGlobalXfo(e.getValue());};t(),e.valueChanged.connect(t);}}getTargetParam(){return this.param?this.param:this.getParameter("GlobalXfo")}onDragStart(e){this.grabDist=e.grabDist,this.oriXfo=this.getGlobalXfo(),this.tmplocalXfo=this.getLocalXfo();const t=this.getTargetParam();this.baseXfo=t.getValue(),e.undoRedoManager&&(this.change=new h(t),e.undoRedoManager.addChange(this.change));}onDrag(e){const t=this.baseXfo.clone(),s=e.holdDist/this.grabDist;s<1e-4||(t.sc.set(this.baseXfo.sc.x*s,this.baseXfo.sc.y*s,this.baseXfo.sc.z*s),this.tmplocalXfo.sc.set(1,1,s),this.setLocalXfo(this.tmplocalXfo),this.change?this.change.update({value:t}):this.param.setValue(t));}onDragEnd(e){this.change=null,this.tmplocalXfo.sc.set(1,1,1),this.setLocalXfo(this.tmplocalXfo);const t=this.getChildByName("tip"),s=t.getLocalXfo();s.sc.set(1,1,1),t.setLocalXfo(s);}}class p extends r{constructor(t,s,i){super(t),this.radius=s;const n=new e.Material("mask","HandleShader");n.getParameter("maintainScreenSize").setValue(1),n.getParameter("BaseColor").setValue(i);const o=new e.Sphere(s,64),a=new e.GeomItem("mask",o,n);this.addChild(a);}highlight(){}unhighlight(){}setTargetParam(e,t=!0){if(this.param=e,t){const t=()=>{this.setGlobalXfo(e.getValue());};t(),e.valueChanged.connect(t);}}getTargetParam(){return this.param?this.param:this.getParameter("GlobalXfo")}handleMouseDown(e){return !0}handleMouseMove(e){return !0}handleMouseUp(e){return !0}onDragStart(t){this.baseXfo=this.getGlobalXfo(),this.baseXfo.sc.set(1,1,1),this.deltaXfo=new e.Xfo;const s=this.getTargetParam();this.offsetXfo=this.baseXfo.inverse().multiply(s.getValue()),this.vec0=t.grabPos.subtract(this.baseXfo.tr),this.vec0.normalizeInPlace(),this.colorParam.setValue(new e.Color(1,1,1)),t.undoRedoManager&&(this.change=new ParameterValueChange(s),t.undoRedoManager.addChange(this.change));}onDrag(e){const t=e.holdPos.subtract(this.baseXfo.tr);t.normalizeInPlace();const s=this.vec0.angleTo(t)*modulator,i=this.vec0.cross(t).normalize();this.deltaXfo.ori.setFromAxisAndAngle(i,s);const n=this.baseXfo.multiply(this.deltaXfo),o=n.multiply(this.offsetXfo);if(this.change)this.change.update({value:o});else {this.getTargetParam().setValue(n);}}onDragEnd(e){this.change=null,this.colorParam.setValue(this.__color);}}class _ extends d{constructor(t,s,i,n){super(t),this.__color=i,this.__hilightedColor=new e.Color(1,1,1),this.sizeParam=this.addParameter(new e.NumberParameter("size",s)),this.colorParam=this.addParameter(new e.ColorParameter("BaseColor",i));const o=new e.Material("handle","HandleShader");o.getParameter("maintainScreenSize").setValue(1),o.replaceParameter(this.colorParam);const a=new e.Cuboid(s,s,.02*s),r=new e.Xfo;r.tr=n,a.transformVertices(r),this.handle=new e.GeomItem("handle",a,o),this.sizeParam.valueChanged.connect(()=>{s=this.sizeParam.getValue(),a.getParameter("size").setValue(s),a.getParameter("height").setValue(.02*s);}),this.addChild(this.handle);}highlight(){this.colorParam.setValue(this.__hilightedColor);}unhighlight(){this.colorParam.setValue(this.__color);}}class f extends e.TreeItem{constructor(t,s){super("XfoHandle");const i=new e.TreeItem("Translate");i.setVisible(!1),this.addChild(i);const n=new e.Color(1,.1,.1),o=new e.Color("#32CD32"),a=new e.Color("#1E90FF");n.a=.8,o.a=.8,a.a=.8;{const o=new c("linearX",t,s,n),a=new e.Xfo;a.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),.5*Math.PI),o.getParameter("LocalXfo").setValue(a),i.addChild(o);}{const n=new c("linearY",t,s,o),a=new e.Xfo;a.ori.setFromAxisAndAngle(new e.Vec3(1,0,0),-.5*Math.PI),n.getParameter("LocalXfo").setValue(a),i.addChild(n);}{const e=new c("linearZ",t,s,a);i.addChild(e);}const r=.35*t;{const t=new _("planarXY",r,o,new e.Vec3(.5*r,.5*r,0)),s=new e.Xfo;t.getParameter("LocalXfo").setValue(s),i.addChild(t);}{const t=new _("planarYZ",r,n,new e.Vec3(-.5*r,.5*r,0)),s=new e.Xfo;s.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),.5*Math.PI),t.getParameter("LocalXfo").setValue(s),i.addChild(t);}{const t=new _("planarXZ",r,a,new e.Vec3(.5*r,.5*r,0)),s=new e.Xfo;s.ori.setFromAxisAndAngle(new e.Vec3(1,0,0),.5*Math.PI),t.getParameter("LocalXfo").setValue(s),i.addChild(t);}const l=new e.TreeItem("Rotate");l.setVisible(!1),this.addChild(l);{const i=new p("rotation",t-s,new e.Color(1,1,1,.4));l.addChild(i);}{const i=new u("rotationX",t,s,n),o=new e.Xfo;o.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),.5*Math.PI),i.getParameter("LocalXfo").setValue(o),l.addChild(i);}{const i=new u("rotationY",t,s,o),n=new e.Xfo;n.ori.setFromAxisAndAngle(new e.Vec3(1,0,0),.5*Math.PI),i.getParameter("LocalXfo").setValue(n),l.addChild(i);}{const e=new u("rotationZ",t,s,a);l.addChild(e);}const h=new e.TreeItem("Scale");h.setVisible(!1),this.addChild(h);const d=.95*t;{const t=new g("scaleX",d,s,n),i=new e.Xfo;i.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),.5*Math.PI),t.getParameter("LocalXfo").setValue(i),h.addChild(t);}{const t=new g("scaleY",d,s,o),i=new e.Xfo;i.ori.setFromAxisAndAngle(new e.Vec3(1,0,0),-.5*Math.PI),t.getParameter("LocalXfo").setValue(i),h.addChild(t);}{const e=new g("scaleZ",d,s,a);h.addChild(e);}}_cleanGlobalXfo(e){const t=this.getParentItem();if(void 0!==t){const e=t.getGlobalXfo().clone();return e.sc.set(1,1,1),e.multiply(this.__localXfoParam.getValue())}return this.__localXfoParam.getValue()}showHandles(e){this.traverse(e=>{if(e!=this)return e.setVisible(!1),!1});const t=this.getChildByName(e);t&&t.setVisible(!0);}setTargetParam(e){this.param=e,this.traverse(t=>{t instanceof r&&t.setTargetParam(e,!1);});}}class v extends e.Group{constructor(t){let s,i;super(),t.selectionOutlineColor?s=t.selectionOutlineColor:(s=new e.Color("#03E3AC"),s.a=.1),t.branchSelectionOutlineColor?i=t.branchSelectionOutlineColor:(i=s.lerp(new e.Color("white"),.5),i.a=.1),this.getParameter("HighlightColor").setValue(s),this.addParameter(new e.ColorParameter("SubtreeHighlightColor",i)),this.propagatingSelectionToItems=0!=t.setItemsSelected,this.getParameter("InitialXfoMode").setValue(e.Group.INITIAL_XFO_MODES.average),this.__itemsParam.setFilterFn(t=>t instanceof e.BaseItem);}clone(e){const t=new v;return t.copyFrom(this,e),t}rebindInitialXfos(){Array.from(this.__itemsParam.getValue()).forEach((t,s)=>{t instanceof e.TreeItem&&(this.__initialXfos[s]=t.getGlobalXfo());});}__bindItem(t,s){this.propagatingSelectionToItems&&t.setSelected(this);const i={};if(t instanceof e.TreeItem){const n=this.getParameter("HighlightColor").getValue();n.a=this.getParameter("HighlightFill").getValue();const o=this.getParameter("SubtreeHighlightColor").getValue();t.addHighlight("selected"+this.getId(),n,!1),t.getChildren().forEach(t=>{t instanceof e.TreeItem&&t.addHighlight("branchselected"+this.getId(),o,!0);}),i.globalXfoChangedIndex=t.globalXfoChanged.connect(e=>{this.calculatingGroupXfo||this.propagatingXfoToItems||(this.__initialXfos[s]=t.getGlobalXfo(),this._setGlobalXfoDirty());}),this.__initialXfos[s]=t.getGlobalXfo();}this.__signalIndices[s]=i;}__unbindItem(t,s){this.propagatingSelectionToItems&&t.setSelected(!1),t instanceof e.TreeItem&&(t.removeHighlight("selected"+this.getId()),t.getChildren().forEach(t=>{t instanceof e.TreeItem&&t.removeHighlight("branchselected"+this.getId(),!0);}),t.globalXfoChanged.disconnectId(this.__signalIndices[s].globalXfoChangedIndex),this.__initialXfos.splice(s,1)),this.__signalIndices.splice(s,1);}_propagateDirtyXfoToItems(){if(this.calculatingGroupXfo)return;const t=Array.from(this.__itemsParam.getValue());if(!this.calculatingGroupXfo&&t.length>0&&this.invGroupXfo&&!this.dirty){const s=this.__globalXfoParam.getValue().multiply(this.invGroupXfo);this.propagatingXfoToItems=!0;const i=(e,t)=>{const i=e.getParameter("GlobalXfo"),n=s.multiply(t);i.setValue(n);};t.forEach((t,s)=>{t instanceof e.TreeItem&&i(t,this.__initialXfos[s]);}),this.propagatingXfoToItems=!1;}}}class C extends a{constructor(e,t,s){super("SelectionChange"),this.__selectionManager=e,this.__prevSelection=t,this.__newSelection=s;}undo(){this.__selectionManager.setSelection(this.__prevSelection,!1);}redo(){this.__selectionManager.setSelection(this.__newSelection,!1);}toJSON(e){const t=super.toJSON(e),s=[];for(const e of this.__newSelection)s.push(e.getPath());return t.itemPaths=s,t}fromJSON(e,t){super.fromJSON(e,t),this.__selectionManager=t.appData.selectionManager,this.__prevSelection=new Set(this.__selectionManager.getSelection());const s=t.appData.scene.getRoot(),i=new Set;for(const t of e.itemPaths)i.add(s.resolvePath(t,1));this.__newSelection=i,this.__selectionManager.setSelection(this.__newSelection,!1);}}o.registerChange("SelectionChange",C);class b extends a{constructor(e,t){super("Selection Visibility Change"),this.selection=e,this.state=t,this.do(this.state);}undo(){this.do(!this.state);}redo(){this.do(this.state);}do(e){for(const t of this.selection)t.getParameter("Visible").setValue(e);}}o.registerChange("ToggleSelectionVisibility",b);class I{constructor(t,s={}){if(this.appData=t,this.leadSelection=void 0,this.selectionChanged=new e.Signal,this.leadSelectionChanged=new e.Signal,this.selectionGroup=new v(s),!0===s.enableXfoHandles){const s=.1,i=.02*s;this.xfoHandle=new f(s,i),this.xfoHandle.setTargetParam(this.selectionGroup.getParameter("GlobalXfo"),!1),this.xfoHandle.setVisible(!1),this.selectionGroup.addChild(this.xfoHandle),this.handleGroup={Translate:new e.Signal,Rotate:new e.Signal,Scale:new e.Signal},this.currMode="",t.actionRegistry.registerAction({name:"Translate",path:["Edit"],callback:()=>{this.showHandles("Translate");},key:"w",activatedChanged:this.handleGroup.Translate}),t.actionRegistry.registerAction({name:"Rotate",path:["Edit"],callback:()=>{this.showHandles("Rotate");},key:"e",activatedChanged:this.handleGroup.Rotate}),t.actionRegistry.registerAction({name:"Scale",path:["Edit"],callback:()=>{this.showHandles("Scale");},key:"r",activatedChanged:this.handleGroup.Scale}),t.actionRegistry.registerAction({name:"Local",path:["Edit","Coords"],callback:()=>{this.setXfoMode(ZeaEngine.Group.INITIAL_XFO_MODES.average);},key:"k",activatedChanged:this.handleGroup.Translate}),t.actionRegistry.registerAction({name:"Global",path:["Edit","Coords"],callback:()=>{this.setXfoMode(ZeaEngine.Group.INITIAL_XFO_MODES.globalOri);},key:"l",activatedChanged:this.handleGroup.Rotate});}this.appData.renderer&&this.setRenderer(this.appData.renderer);}setRenderer(e){this.__renderer=e,this.__renderer.addTreeItem(this.selectionGroup);}setXfoMode(e){this.xfoHandle&&(this.selectionGroup.rebindInitialXfos(),this.selectionGroup.getParameter("InitialXfoMode").setValue(e));}showHandles(e){if(this.xfoHandle&&this.currMode!=e){this.currMode=e;for(const t in this.handleGroup)this.handleGroup[t].emit(e==t);this.xfoHandle.showHandles(e);}}updateHandleVisiblity(){if(!this.xfoHandle)return;const e=this.selectionGroup.getItems(),t=Array.from(e).length>0;this.xfoHandle.setVisible(t),this.__renderer.requestRedraw();}getSelection(){return this.selectionGroup.getItems()}setSelection(e,t=!0){const s=new Set(this.selectionGroup.getItems()),i=new Set(s);for(const t of e)s.has(t)||s.add(t);for(const t of s)e.has(t)||s.delete(t);if(this.selectionGroup.setItems(s),s.size>0?this.__setLeadSelection(s.values().next().value):this.__setLeadSelection(),this.updateHandleVisiblity(),t){const e=new C(this,i,s);this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(e);}}__setLeadSelection(e){this.leadSelection!=e&&(this.leadSelection=e,this.leadSelectionChanged.emit(e));}toggleItemSelection(e,t=!0){const s=new Set(this.selectionGroup.getItems()),i=new Set(s);if(t&&(1!=s.size||!s.has(e))){let t=!0;if(s.has(e)){let i=1;e.traverse(e=>{s.has(e)&&i++;}),t=i!=s.size;}t&&s.clear();}let n;s.has(e)?(s.delete(e),n=!1):(s.add(e),n=!0),this.selectionGroup.setItems(s),n&&1===s.size?this.__setLeadSelection(e):n||(1===s.size?this.__setLeadSelection(s.values().next().value):0===s.size&&this.__setLeadSelection());const o=new C(this,i,s);this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(o),this.updateHandleVisiblity(),this.selectionChanged.emit(i);}clearSelection(e=!0){const t=new Set(this.selectionGroup.getItems());if(0==t.size)return !1;let s;if(e&&(s=new Set(t)),t.clear(),this.selectionGroup.setItems(t),this.updateHandleVisiblity(),e){const e=new C(this,s,t);this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(e),this.selectionChanged.emit(t);}return !0}selectItems(e,t=!0){const s=new Set(this.selectionGroup.getItems()),i=new Set(s);t&&s.clear();for(const t of e)t.getSelected()||s.add(t);const n=new C(this,i,s);this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(n),this.selectionGroup.setItems(s),1===s.size?this.__setLeadSelection(s.values().next().value):0===s.size&&this.__setLeadSelection(),this.updateHandleVisiblity(),this.selectionChanged.emit(s);}deselectItems(e){const t=this.selectionGroup.getItems(),s=new Set(t);for(const s of e)s.getSelected()&&t.delete(selectedParam);this.selectionGroup.setItems(t);const i=new C(this,s,t);this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(i),1===t.size?this.__setLeadSelection(t.values().next().value):0===t.size&&this.__setLeadSelection(),this.updateHandleVisiblity(),this.selectionChanged.emit(t);}toggleSelectionVisiblity(){if(this.leadSelection){const e=this.selectionGroup.getItems(),t=!this.leadSelection.getVisible(),s=new b(e,t);this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(s);}}startPickingMode(e,t,s,i){console.log(e),this.__pickCB=t,this.__pickFilter=s,this.__pickCount=i,this.__picked=[];}pickingFilter(e){return this.__pickFilter(e)}pickingModeActive(){return null!=this.__pickCB}cancelPickingMode(){this.__pickCB=void 0;}pick(e){if(this.__pickCB){if(Array.isArray(e))this.__pickFilter?this.__picked=this.__picked.concat(e.filter(this.__pickFilter)):this.__picked=this.__picked.concat(e);else {if(this.__pickFilter&&!this.__pickFilter(e))return;this.__picked.push(e);}this.__picked.length==this.__pickCount&&(this.__pickCB(this.__picked),this.__pickCB=void 0);}}}const w=new e.Vec3(0,0,1);class P{constructor(t,s,i=!1){if(this.__appData=t,this.__userData=s,this.__currentUserAvatar=i,this.__treeItem=new e.TreeItem(this.__userData.id),this.__treeItem.addRef(this),this.__appData.renderer.addTreeItem(this.__treeItem),this.__avatarColor=new e.Color(.3,.3,.3),this.__hilightPointerColor=new e.Color(1.2,0,0),this.__plane=new e.Plane(1,1),this.__uiGeomIndex=-1,!this.__currentUserAvatar){let t,s;if(this.__camera=new e.Camera,this.__camera.addRef(this),this.__cameraBound=!1,this.__userData.picture&&""!=this.__userData.picture)t=new e.LDRImage("user"+this.__userData.id+"AvatarImage"),t.setImageURL(this.__userData.picture),s=new e.Disc(.5,64);else {t=new e.Label(name);const i=new e.Color(.84,.84,.84);t.getParameter("backgroundColor").setValue(i),t.getParameter("fontSize").setValue(48),t.getParameter("borderRadius").setValue(15),t.getParameter("margin").setValue(8),t.getParameter("text").setValue(this.__userData.name),s=new e.Plane(2,.5),t.labelRendered.connect(e=>{const t=e.width/e.height;s.getParameter("SizeX").setValue(.5*t);});}const i=new e.Material("user"+this.__userData.id+"AvatarImageMaterial","FlatSurfaceShader");i.getParameter("BaseColor").setValue(this.__avatarColor),i.getParameter("BaseColor").setImage(t),i.visibleInGeomDataBuffer=!1,this.__avatarImageGeomItem=new e.GeomItem("avatarImage",s,i),this.__avatarImageXfo=new e.Xfo,this.__avatarImageXfo.sc.set(.2,.2,1),this.__avatarImageXfo.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),Math.PI),this.__avatarImageGeomItem.setLocalXfo(this.__avatarImageXfo),this.__avatarImageGeomItem.addRef(this);}}attachRTCStream(t){if(!this.__avatarCamGeomItem){const s=new e.VideoStreamImage2D("webcamStream");s.setVideoStream(t),this.__avatarCamMaterial=new e.Material("user"+this.__userData.id+"AvatarImageMaterial","FlatSurfaceShader"),this.__avatarCamMaterial.getParameter("BaseColor").setValue(this.__avatarColor),this.__avatarCamMaterial.getParameter("BaseColor").setImage(s),this.__avatarCamMaterial.visibleInGeomDataBuffer=!1,this.__avatarCamGeomItem=new e.GeomItem("avatarImage",this.__plane,this.__avatarCamMaterial),this.__avatarCamGeomItem.addRef(this);const i=.02;this.__avatarCamXfo=new e.Xfo,this.__avatarCamXfo.sc.set(16*i,9*i,1),this.__avatarCamXfo.tr.set(0,0,-.1*i),this.__avatarCamGeomItem.setLocalXfo(this.__avatarCamXfo);const n=t.videoWidth/t.videoHeight;this.__avatarCamXfo.sc.x=this.__avatarCamXfo.sc.y*n,this.__avatarImageGeomItem.setLocalXfo(this.__avatarCamXfo);}"CameraAndPointer"==this.__currentViewMode&&(this.__treeItem.getChild(0).removeAllChildren(),this.__treeItem.getChild(0).addChild(this.__avatarCamGeomItem,!1));}detachRTCStream(){if("CameraAndPointer"==this.__currentViewMode){this.__treeItem.getChild(0).removeAllChildren();const e=.02;this.__avatarImageXfo.sc.set(9*e,9*e,1),this.__avatarImageXfo.tr.set(0,0,-.1*e),this.__avatarImageGeomItem.setLocalXfo(this.__avatarImageXfo),this.__treeItem.getChild(0).addChild(this.__avatarImageGeomItem,!1);}}getCamera(){return this.__camera}bindCamera(){this.__cameraBound=!0;const e=this.__camera.getOwner();e&&e.traverse(e=>{e!=this.__camera&&e.setVisible(!1);});}unbindCamera(){this.__cameraBound=!1;const e=this.__camera.getOwner();e&&e.traverse(e=>{e!=this.__camera&&e.setVisible(!0);});}setCameraAndPointerRepresentation(){if(this.__treeItem.removeAllChildren(),this.__currentViewMode="CameraAndPointer",this.__currentUserAvatar)return;const t=new e.Cuboid(.32,.18,.06,!0),s=new e.Vec3(.1,.1,1);t.getVertex(0).multiplyInPlace(s),t.getVertex(1).multiplyInPlace(s),t.getVertex(2).multiplyInPlace(s),t.getVertex(3).multiplyInPlace(s),t.computeVertexNormals();const i=new e.Material("user"+this.__userData.id+"Material","SimpleSurfaceShader");i.visibleInGeomDataBuffer=!1,i.getParameter("BaseColor").setValue(this.__avatarColor);const n=new e.GeomItem("camera",t,i),o=new e.Xfo;n.setGeomOffsetXfo(o);const a=new e.Lines;a.setNumVertices(2),a.setNumSegments(1),a.setSegment(0,0,1),a.getVertex(0).set(0,0,0),a.getVertex(1).set(0,0,1),a.setBoundingBoxDirty(),this.pointerXfo=new e.Xfo,this.pointerXfo.sc.set(1,1,0),this.__pointermat=new e.Material("pointermat","LinesShader"),this.__pointermat.getParameter("Color").setValue(this.__avatarColor),this.__pointerItem=new e.GeomItem("Pointer",a,this.__pointermat),this.__pointerItem.addRef(this),this.__pointerItem.setLocalXfo(this.pointerXfo),this.__avatarCamGeomItem?n.addChild(this.__avatarCamGeomItem,!1):this.__avatarImageGeomItem&&(this.__avatarImageXfo.sc.set(.18,.18,1),this.__avatarImageXfo.tr.set(0,0,-.002),this.__avatarImageGeomItem.setLocalXfo(this.__avatarImageXfo),n.addChild(this.__avatarImageGeomItem,!1)),this.__audioItem&&n.addChild(this.__audioItem,!1),this.__treeItem.addChild(n,!1),this.__treeItem.addChild(this.__pointerItem,!1),this.__treeItem.addChild(this.__camera,!1),this.__cameraBound&&n.setVisible(!1);}updateCameraAndPointerPose(e){if(!this.__currentUserAvatar)if(e.viewXfo){if(e.focalDistance){const t=e.focalDistance/5;t>1&&e.viewXfo.sc.set(t,t,t);}this.__treeItem.getChild(0).setLocalXfo(e.viewXfo),this.pointerXfo.sc.z=0,this.__treeItem.getChild(1).setLocalXfo(this.pointerXfo);}else e.movePointer?(this.pointerXfo.tr=e.movePointer.start,this.pointerXfo.ori.setFromDirectionAndUpvector(e.movePointer.dir,w),this.pointerXfo.sc.z=e.movePointer.length,this.__treeItem.getChild(1).setLocalXfo(this.pointerXfo)):e.hilightPointer?this.__pointermat.getParameter("Color").setValue(this.__hilightPointerColor):e.unhilightPointer?this.__pointermat.getParameter("Color").setValue(this.__avatarColor):e.hidePointer&&(this.pointerXfo.sc.z=0,this.__treeItem.getChild(1).setLocalXfo(this.pointerXfo));}setVRRepresentation(t){this.__treeItem.removeAllChildren(),this.__currentViewMode="VR";const s=new e.TreeItem("hmdHolder");if(this.__audioItem&&s.addChild(this.__audioItem),this.__avatarImageGeomItem&&(this.__avatarImageXfo.sc.set(.12,.12,1),this.__avatarImageXfo.tr.set(0,-.04,-.135),this.__avatarImageGeomItem.setLocalXfo(this.__avatarImageXfo),s.addChild(this.__avatarImageGeomItem,!1)),this.__treeItem.addChild(s),this.__camera&&s.addChild(this.__camera,!1),this.__hmdGeomItem)this.__currentUserAvatar||s.addChild(this.__hmdGeomItem,!1),this.__cameraBound&&this.__hmdGeomItem.setVisible(!1);else {const i=this.__appData.scene.getResourceLoader();let n;switch(t.hmd){case"Vive":n="ZeaEngine/Vive.vla";break;case"Oculus":n="ZeaEngine/Oculus.vla";break;default:n="ZeaEngine/Vive.vla";}if(!this.__vrAsset){const t=i.resolveFilePathToId(n);t&&(this.__vrAsset=this.__appData.scene.loadCommonAssetResource(t),this.__vrAsset.geomsLoaded.connect(()=>{const t=this.__vrAsset.getMaterialLibrary(),i=t.getMaterialNames();for(const e of i){const s=t.getMaterial(e,!1);s&&(s.visibleInGeomDataBuffer=!1,s.setShaderName("SimpleSurfaceShader"));}if(!this.__currentUserAvatar){const t=this.__vrAsset.getChildByName("HMD").clone(),i=t.getLocalXfo();i.tr.set(0,-.03,-.03),i.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),Math.PI),i.sc.set(.001),t.setLocalXfo(i),this.__hmdGeomItem=t,this.__hmdGeomItem.addRef(this),this.__cameraBound&&this.__hmdGeomItem.setVisible(!1),s.addChild(this.__hmdGeomItem,!1);}}));}}this.__controllerTrees=[];}updateVRPose(t){const s=t=>{if(this.__controllerTrees[t])this.__treeItem.addChild(this.__controllerTrees[t],!1);else {const s=new e.TreeItem("handleHolder"+t);s.addRef(this),this.__controllerTrees[t]=s,this.__treeItem.addChild(this.__controllerTrees[t],!1);const i=()=>{let i;0==t?i=this.__vrAsset.getChildByName("LeftController"):1==t&&(i=this.__vrAsset.getChildByName("RightController")),i||(i=this.__vrAsset.getChildByName("Controller"));const n=i.clone(),o=new e.Xfo(new e.Vec3(0,-.035,-.085),new e.Quat({setFromAxisAndAngle:[new e.Vec3(0,1,0),Math.PI]}),new e.Vec3(.001,.001,.001));n.setLocalXfo(o),s.addChild(n,!1);};this.__vrAsset.geomsLoaded.connect(()=>{i();});}};if(t.viewXfo&&this.__treeItem.getChild(0).setGlobalXfo(t.viewXfo),t.controllers)for(let e=0;e<t.controllers.length;e++)t.controllers[e]&&!this.__controllerTrees[e]&&s(e),this.__controllerTrees[e].setGlobalXfo(t.controllers[e].xfo);if(t.showUIPanel){if(!this.__uiGeomItem){const s=new e.Material("uimat","FlatSurfaceShader");s.getParameter("BaseColor").setValue(this.__avatarColor),this.__uiGeomOffsetXfo=new e.Xfo,this.__uiGeomOffsetXfo.sc.set(t.showUIPanel.size.x,t.showUIPanel.size.y,1),this.__uiGeomOffsetXfo.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),Math.PI),this.__uiGeomItem=new e.GeomItem("VRControllerUI",this.__plane,s),this.__uiGeomItem.addRef(this),this.__uiGeomItem.setGeomOffsetXfo(this.__uiGeomOffsetXfo);const i=new e.Xfo;i.fromJSON(t.showUIPanel.localXfo),this.__uiGeomItem.setLocalXfo(i);}this.__uiGeomIndex=this.__controllerTrees[t.showUIPanel.controllerId].addChild(this.__uiGeomItem,!1);}else t.updateUIPanel?this.__uiGeomItem&&(this.__uiGeomOffsetXfo.sc.set(t.updateUIPanel.size.x,t.updateUIPanel.size.y,1),this.__uiGeomItem.setGeomOffsetXfo(this.__uiGeomOffsetXfo)):t.hideUIPanel&&this.__uiGeomIndex>=0&&(this.__controllerTrees[t.hideUIPanel.controllerId].removeChild(this.__uiGeomIndex),this.__uiGeomIndex=-1);}updatePose(e){switch(e.interfaceType){case"CameraAndPointer":"CameraAndPointer"!==this.__currentViewMode&&this.setCameraAndPointerRepresentation(),this.updateCameraAndPointerPose(e);break;case"Vive":case"VR":"VR"!==this.__currentViewMode&&this.setVRRepresentation(e),this.updateVRPose(e);}}destroy(){this.__appData.renderer.removeTreeItem(this.__treeItem),this.__treeItem.removeRef(this),this.__camera||this.__camera.removeRef(this);}}const T=t=>{if(null!=t){if(t instanceof e.BaseItem)return "::"+t.getPath();if(t.toJSON){const s=t.toJSON();return s.typeName=e.typeRegistry.getTypeName(t.constructor),s}if(Array.isArray(t)){const e=[];for(const s of t)e.push(T(s));return e}if("object"==typeof t){const e={};for(const s in t)e[s]=T(t[s]);return e}return t}},E=(t,s)=>{if(null!=t){if("string"==typeof t&&t.startsWith("::"))return s.getRoot().resolvePath(t,1);if(t.typeName){const s=e.typeRegistry.getType(t.typeName).create();return s.fromJSON(t),s}if(Array.isArray(t)){const e=[];for(const i of t)e.push(E(i,s));return e}if("object"==typeof t){const e={};for(const i in t)e[i]=E(t[i],s);return e}return t}};class y extends a{constructor(e,t,s){e?(super(e.getName()+" Added"),this.treeItem=e,this.owner=t,this.selectionManager=s,this.prevSelection=new Set(this.selectionManager.getSelection()),this.treeItemIndex=this.owner.addChild(this.treeItem),this.selectionManager.setSelection(new Set([this.treeItem]),!1),this.treeItem.addRef(this)):super();}undo(){if(this.treeItem instanceof e.Operator){this.treeItem.detach();}else this.treeItem instanceof e.TreeItem&&this.treeItem.traverse(t=>{if(t instanceof e.Operator){t.detach();}},!1);this.owner.removeChild(this.treeItemIndex),this.selectionManager&&this.selectionManager.setSelection(this.prevSelection,!1);}redo(){if(this.treeItem instanceof e.Operator){this.treeItem.reattach();}else subTreeItem instanceof e.TreeItem&&this.treeItem.traverse(t=>{if(t instanceof e.Operator){t.reattach();}},!1);this.owner.addChild(this.treeItem),this.selectionManager&&this.selectionManager.setSelection(new Set([this.treeItem]),!1);}toJSON(e){return {name:this.name,treeItem:this.treeItem.toJSON(e),treeItemPath:this.treeItem.getPath(),treeItemIndex:this.treeItemIndex}}fromJSON(t,s){const i=e.sgFactory.constructClass(t.treeItem.type);i?(this.name=t.name,this.treeItem=i,this.treeItem.addRef(this),this.treeItem.fromJSON(t.treeItem,s),this.treeItemIndex=this.owner.addChild(this.treeItem,!1,!1)):console.warn("resolvePath is unable to conostruct",t.treeItem);}destroy(){this.treeItem.removeRef(this);}}o.registerChange("TreeItemAddChange",y);class S extends a{constructor(t,s){if(super(),this.items=[],this.itemOwners=[],this.itemPaths=[],this.itemIndices=[],t){this.selectionManager=s.selectionManager,this.prevSelection=new Set(this.selectionManager.getSelection()),this.items=t,this.newSelection=new Set(this.prevSelection);const i=[];this.items.forEach(t=>{const s=t.getOwner(),n=s.getChildIndex(t);if(i.push(t.getName()),t.addRef(this),this.itemOwners.push(s),this.itemPaths.push(t.getPath()),this.itemIndices.push(n),this.selectionManager&&this.newSelection.has(t)&&this.newSelection.delete(t),t instanceof e.Operator){t.detach();}else t instanceof e.TreeItem&&t.traverse(t=>{if(t instanceof e.Operator){t.detach();}this.selectionManager&&this.newSelection.has(t)&&this.newSelection.delete(t);},!1);s.removeChild(n);}),this.selectionManager.setSelection(this.newSelection,!1),this.name=i+" Deleted";}}undo(){this.items.forEach((t,s)=>{if(this.itemOwners[s].insertChild(t,this.itemIndices[s],!1,!1),t instanceof e.Operator){t.reattach();}else subTreeItem instanceof e.TreeItem&&t.traverse(t=>{if(t instanceof e.Operator){t.reattach();}},!1);}),this.selectionManager&&this.selectionManager.setSelection(this.prevSelection,!1);}redo(){this.selectionManager&&this.selectionManager.setSelection(this.newSelection,!1),this.items.forEach((t,s)=>{if(this.itemOwners[s].removeChild(this.itemIndices[s]),t instanceof e.Operator){t.detach();}else subTreeItem instanceof e.TreeItem&&t.traverse(t=>{if(t instanceof e.Operator){t.detach();}},!1);});}toJSON(e){const t={name:this.name,items:[],itemPaths:this.itemPaths,itemIndices:this.itemIndices};return this.items.forEach(e=>{t.items.push(e.toJSON());}),t}fromJSON(e,t){this.name=e.name,e.itemPaths.forEach(e=>{const s=t.scene.getRoot().resolvePath(e,1);if(!s)return void console.warn("resolvePath is unable to resolve",e);const i=s.getOwner();this.itemOwners.push(i),this.itemPaths.push(s.getPath()),this.itemIndices.push(i.getChildIndex(s));});}destroy(){this.items.forEach(e=>e.removeRef(this));}}o.registerChange("TreeItemsRemoveChange",S);class M extends a{constructor(e,t){e?(console.log("TreeItemMoveChange"),super(e.getName()+" Added"),this.treeItem=e,this.oldOwner=this.treeItem.getOwner(),this.oldOwnerIndex=this.oldOwner.getChildIndex(this.treeItem),this.newOwner=t,this.newOwner.addChild(this.treeItem,!0)):super();}undo(){this.oldOwner.insertChild(this.treeItem,this.oldOwnerIndex,!0);}redo(){this.newOwner.addChild(this.treeItem,!0);}toJSON(e){return {name:this.name,treeItemPath:this.treeItem.getPath(),newOwnerPath:this.newOwner.getPath()}}fromJSON(e,t){const s=appData.scene.getRoot().resolvePath(e.treeItemPath,1);if(!s)return void console.warn("resolvePath is unable to resolve",e.treeItemPath);const i=appData.scene.getRoot().resolvePath(e.newOwnerPath,1);i?(this.name=e.name,this.treeItem=s,this.newOwner=i,this.oldOwner=this.treeItem.getOwner(),this.oldOwnerIndex=this.oldOwner.getChildIndex(this.treeItem),this.newOwner.addChild(this.treeItem,!0)):console.warn("resolvePath is unable to resolve",e.newOwnerPath);}}o.registerChange("TreeItemMoveChange",M);class D{constructor(e){}}const V=new class{constructor(){this.treeItemFactories=[],this.widgetFactories=[],this.inspectorFactories=[];}registerInpector(e,t){this.inspectorFactories.push({inspector:e,rule:t});}constructInspector(...e){const t=e[0];for(let s=this.inspectorFactories.length;s-- >0;){const i=this.inspectorFactories[s];if(i.rule(t))return new i.inspector(...e)}console.warn(`Inspector factory not found for parameter '${t.getName()}' of class '${t.constructor.name}'`);}registerTreeItemElement(e,t){this.treeItemFactories.push({treeItemElement:e,rule:t});}constructTreeItemElement(...e){const t=e[0];for(let s=this.treeItemFactories.length;s-- >0;){const i=this.treeItemFactories[s];if(i.rule(t))return new i.treeItemElement(...e)}console.warn(`Tree item factory not found for parameter '${t.getName()}' of class '${t.constructor.name}'`);}registerWidget(e,t){this.widgetFactories.push({widget:e,rule:t});}findWidgetReg(e){for(let t=this.widgetFactories.length;t-- >0;){const s=this.widgetFactories[t];if(s.rule(e))return s}}constructWidget(...e){const t=e[0];for(let s=this.widgetFactories.length;s-- >0;){const i=this.widgetFactories[s];if(i.rule(t))return new i.widget(...e)}console.warn(`Widget factory not found for parameter '${t.getName()}' of class '${t.constructor.name}'`);}};V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("input");let o,a;n.setAttribute("id",t.getName()),n.setAttribute("type","checkbox"),n.setAttribute("tabindex",0),n.checked=t.getValue(),s.appendChild(n),t.valueChanged.connect(s=>{o||(n.checked=t.getValue(),s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),a&&clearTimeout(a),a=setTimeout(()=>{n.classList.remove("user-edited"),a=null;},1500)));}),n.addEventListener("input",()=>{o=new h(t,n.checked),i.undoRedoManager.addChange(o),o=void 0;});}},t=>t instanceof e.BooleanParameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=new iro.ColorPicker(s,{width:200,height:200,color:t.getValue().getAsRGBDict(),anticlockwise:!0,borderWidth:1,borderColor:"#fff"});let o,a=void 0,r=!1;t.valueChanged.connect(s=>{a||(r=!0,n.color.rgb=t.getValue().getAsRGBDict(),r=!1,s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.el.classList.add("user-edited"),o&&clearTimeout(o),o=setTimeout(()=>{n.el.classList.remove("user-edited"),o=null;},1500)));}),n.on("input:start",()=>{console.log("input:start",t.getValue().getAsRGBDict()),a=new h(t),i.undoRedoManager.addChange(a);}),n.on("input:end",()=>{console.log("input:end"),a=void 0;}),n.on("color:change",(s,o)=>{if(r)return;const l=new e.Color;l.setFromRGBDict(n.color.rgb),a?a.update({value:l}):(a=new h(t,l),i.undoRedoManager.addChange(a));});}setParentDomElem(e){}},t=>t instanceof e.ColorParameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=t.getRange(),o=document.createElement("input"),a=[];if(n){a.push("mdl-slider"),a.push("mdl-js-slider"),o.className=a.join(" "),o.setAttribute("id",t.getName()),o.setAttribute("type","range"),o.setAttribute("min",0),o.setAttribute("max",200);const e=(t.getValue()-n[0])/(n[1]-n[0])*200;o.setAttribute("value",e);const s=t.getStep();s?o.setAttribute("step",s):o.setAttribute("step",1),o.setAttribute("tabindex",0);}else o.className=a.join(" "),o.setAttribute("id",t.getName()),o.setAttribute("type","number"),o.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),o.setAttribute("value",t.getValue()),o.setAttribute("tabindex",0);s.appendChild(o);let r,l=void 0;function c(e,t=6){return Number(Math.round(e+"e"+t)+"e-"+t)}t.valueChanged.connect(s=>{l||(o.value=n?(t.getValue()-n[0])/(n[1]-n[0])*200:t.getValue(),s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(o.classList.add("user-edited"),r&&clearTimeout(r),r=setTimeout(()=>{o.classList.remove("user-edited"),r=null;},1500)));});const d=()=>{let e=c(o.valueAsNumber);n&&(e=n[0]+e/200*(n[1]-n[0]),e=Math.clamp(e,n[0],n[1])),l?l.update({value:e}):(l=new h(t,e),i.undoRedoManager.addChange(l));},m=()=>{l&&(t.setValueDone(),l=void 0);};o.addEventListener("input",()=>{d();}),o.addEventListener("change",m),o.addEventListener("keydown",(function(e){38!==e.which&&40!==e.which||(38===e.which&&(o.valueAsNumber=c(o.valueAsNumber+.1)),40===e.which&&(o.valueAsNumber=c(o.valueAsNumber-.1)),d(),e.preventDefault());})),o.addEventListener("focusout",m);}},t=>t instanceof e.NumberParameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("input");let o,a;n.className="mdl-textfield__input",n.setAttribute("id",t.getName()),n.setAttribute("type","text"),n.setAttribute("value",t.getValue()),n.setAttribute("tabindex",0),s.appendChild(n),t.valueChanged.connect(s=>{o||(n.value=t.getValue(),s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),a&&clearTimeout(a),a=setTimeout(()=>{n.classList.remove("user-edited"),a=null;},1500)));});const r=()=>{const e=n.value;o?o.update({value:e}):(o=new h(t,e),i.undoRedoManager.addChange(o));};n.addEventListener("input",r),n.addEventListener("change",()=>{r(),o=void 0;});}},t=>t instanceof e.StringParameter);function x(e,t=6){return Math.abs(e)<Number("1e-6")?0:Number(Math.round(e+"e"+t)+"e-"+t)}V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("div");n.setAttribute("id",t.getName()),n.textContent=t.getValue(),n.style.width="100%";const o=Math.min(50,t.getValue().split("\n").length);n.style.height=14*Math.max(8,o+2)+"px",s.appendChild(n);const a=ace.edit(n);let r,l;a.setTheme("ace/theme/chrome"),a.session.setMode("ace/mode/javascript"),t.valueChanged.connect(s=>{r||(a.session.setValue(t.getValue()),s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),l&&clearTimeout(l),l=setTimeout(()=>{n.classList.remove("user-edited"),l=null;},1500)));});const c=()=>{(()=>{const e=a.getValue();r?r.update({value:e}):(r=new h(t,e),i.undoRedoManager.addChange(r));})(),t.setValueDone(),r=void 0;};n.addEventListener("keydown",e=>{e.ctrlKey&&"s"==e.key&&(c(),e.preventDefault()),e.stopPropagation();});}},t=>t instanceof e.CodeParameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("div");n.className="container";const o=document.createElement("ul");o.className="flex-editvalues",n.appendChild(o);const a=document.createElement("input");a.setAttribute("id",t.getName()),a.setAttribute("type","number"),a.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),a.setAttribute("value",t.getValue().x),a.setAttribute("tabindex",0),a.style.width="100%";const r=document.createElement("li");r.appendChild(a),o.appendChild(r);const l=document.createElement("input");l.setAttribute("id",t.getName()),l.setAttribute("type","number"),l.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),l.setAttribute("value",t.getValue().y),l.setAttribute("tabindex",0),l.style.width="100%";const c=document.createElement("li");c.appendChild(l),o.appendChild(c),s.appendChild(n);let d,m=void 0;t.valueChanged.connect(()=>{if(!m){const s=t.getValue();a.value=x(s.x),l.value=x(s.y),mode==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),d&&clearTimeout(d),d=setTimeout(()=>{n.classList.remove("user-edited"),d=null;},1500));}});const u=()=>{const s=new e.Vec2(a.valueAsNumber,l.valueAsNumber);m?m.update({value:s}):(m=new h(t,s),i.undoRedoManager.addChange(m));},g=()=>{u(),m=void 0;};a.addEventListener("input",u),l.addEventListener("input",u),a.addEventListener("change",g),l.addEventListener("change",g);}},t=>t instanceof e.Vec2Parameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("div");n.className="container";const o=document.createElement("ul");o.className="flex-editvalues",n.appendChild(o);const a=document.createElement("input");a.setAttribute("id",t.getName()),a.setAttribute("type","number"),a.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),a.setAttribute("value",t.getValue().x),a.setAttribute("tabindex",0),a.style.width="100%";const r=document.createElement("li");r.appendChild(a),o.appendChild(r);const l=document.createElement("input");l.setAttribute("id",t.getName()),l.setAttribute("type","number"),l.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),l.setAttribute("value",t.getValue().y),l.setAttribute("tabindex",0),l.style.width="100%";const c=document.createElement("li");c.appendChild(l),o.appendChild(c);const d=document.createElement("input");d.setAttribute("id",t.getName()),d.setAttribute("type","number"),d.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),d.setAttribute("value",t.getValue().z),d.setAttribute("tabindex",0),d.style.width="100%";const m=document.createElement("li");m.appendChild(d),o.appendChild(m),s.appendChild(n);let u,g=void 0;t.valueChanged.connect(()=>{if(!g){const s=t.getValue();a.value=x(s.x),l.value=x(s.y),d.value=x(s.z),mode==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),u&&clearTimeout(u),u=setTimeout(()=>{n.classList.remove("user-edited"),u=null;},1500));}});const p=()=>{const s=new e.Vec3(a.valueAsNumber,l.valueAsNumber,d.valueAsNumber);g?g.update({value:s}):(g=new h(t,s),i.undoRedoManager.addChange(g));},_=()=>{p(),g=void 0;};a.addEventListener("input",p),l.addEventListener("input",p),d.addEventListener("input",p),a.addEventListener("change",_),l.addEventListener("change",_),d.addEventListener("change",_);}},t=>t instanceof e.Vec3Parameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("div");n.className="container";const o=document.createElement("ul");o.className="flex-editvalues",n.appendChild(o);const a=document.createElement("input");a.setAttribute("id",t.getName()),a.setAttribute("type","number"),a.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),a.setAttribute("value",t.getValue().x),a.setAttribute("tabindex",0),a.style.width="100%";const r=document.createElement("li");r.appendChild(a),o.appendChild(r);const l=document.createElement("input");l.setAttribute("id",t.getName()),l.setAttribute("type","number"),l.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),l.setAttribute("value",t.getValue().y),l.setAttribute("tabindex",0),l.style.width="100%";const c=document.createElement("li");c.appendChild(l),o.appendChild(c);const d=document.createElement("input");d.setAttribute("id",t.getName()),d.setAttribute("type","number"),d.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),d.setAttribute("value",t.getValue().z),d.setAttribute("tabindex",0),d.style.width="100%";const m=document.createElement("li");m.appendChild(d),o.appendChild(m);const u=document.createElement("input");u.setAttribute("id",t.getName()),u.setAttribute("type","number"),u.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),u.setAttribute("value",t.getValue().t),u.setAttribute("tabindex",0),u.style.width="100%";const g=document.createElement("li");g.appendChild(u),o.appendChild(g),s.appendChild(n);let p,_=void 0;t.valueChanged.connect(()=>{if(!_){const s=t.getValue();a.value=x(s.x),l.value=x(s.y),d.value=x(s.z),u.value=x(s.t),mode==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),p&&clearTimeout(p),p=setTimeout(()=>{n.classList.remove("user-edited"),p=null;},1500));}});const f=()=>{const s=new e.Vec4(a.valueAsNumber,l.valueAsNumber,d.valueAsNumber,u.valueAsNumber);_?_.update({value:s}):(_=new h(t,s),i.undoRedoManager.addChange(_));},v=()=>{f(),_=void 0;};a.addEventListener("input",f),l.addEventListener("input",f),d.addEventListener("input",f),u.addEventListener("input",f),a.addEventListener("change",v),l.addEventListener("change",v),d.addEventListener("change",v),u.addEventListener("change",v);}},t=>t instanceof e.Vec4Parameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("div");n.className="container";const o=document.createElement("ul");o.className="flex-editvalues",n.appendChild(o);let a,r=void 0,l=!1;const c=s=>{if(!l){function i(e,t=6){return Number(Math.round(e+"e"+t)+"e-"+t)}const o=t.getValue();p.value=i(o.m00),_.value=i(o.m01),f.value=i(o.m02),v.value=i(o.m03),C.value=i(o.m10),b.value=i(o.m11),I.value=i(o.m12),w.value=i(o.m13),P.value=i(o.m20),T.value=i(o.m21),E.value=i(o.m22),y.value=i(o.m23),S.value=i(o.m30),M.value=i(o.m31),D.value=i(o.m32),V.value=i(o.m33),s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),a&&clearTimeout(a),a=setTimeout(()=>{n.classList.remove("user-edited"),a=null;},1500));}};t.valueChanged.connect(c);const d=()=>{l=!0;const s=new e.Mat4;s.set(p.valueAsNumber,_.valueAsNumber,f.valueAsNumber,v.valueAsNumber,C.valueAsNumber,b.valueAsNumber,I.valueAsNumber,w.valueAsNumber,P.valueAsNumber,T.valueAsNumber,E.valueAsNumber,y.valueAsNumber,S.valueAsNumber,M.valueAsNumber,D.valueAsNumber,V.valueAsNumber),r?r.update({value:s}):(r=new h(t,xfo),i.undoRedoManager.addChange(r));},m=()=>{d(),r=void 0,l=!1,c();};function u(e,s,i,n){const o=document.createElement("li"),a=document.createElement("input");return a.setAttribute("id",t.getName()),a.setAttribute("type","number"),a.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),a.setAttribute("value",i),a.setAttribute("tabindex",n),a.style.width="100%",o.appendChild(a),s.appendChild(o),a.addEventListener("input",d),a.addEventListener("change",m),a}const g=t.getValue(),p=u(0,o,g.m00,0),_=u(0,o,g.m01,1),f=u(0,o,g.m02,2),v=u(0,o,g.m03,3),C=u(0,o,g.m10,4),b=u(0,o,g.m11,5),I=u(0,o,g.m12,6),w=u(0,o,g.m13,7),P=u(0,o,g.m20,8),T=u(0,o,g.m21,9),E=u(0,o,g.m22,10),y=u(0,o,g.m23,11),S=u(0,o,g.m30,12),M=u(0,o,g.m31,13),D=u(0,o,g.m32,14),V=u(0,o,g.m33,15);s.appendChild(n);}},t=>t instanceof e.Mat4Parameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("div");n.className="container";const o=document.createElement("ul");o.className="flex-editvalues",n.appendChild(o);const a=t.getValue();let r,l=void 0,c=!1;const d=s=>{if(!c){const i=t.getValue();p.value=x(i.tr.x),_.value=x(i.tr.y),f.value=x(i.tr.z),v.value=x(i.ori.x),C.value=x(i.ori.y),b.value=x(i.ori.z),I.value=x(i.ori.w),w.value=x(i.sc.x),P.value=x(i.sc.y),T.value=x(i.sc.z),s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),r&&clearTimeout(r),r=setTimeout(()=>{n.classList.remove("user-edited"),r=null;},1500));}};t.valueChanged.connect(d);const m=()=>{c=!0;const s=new e.Xfo;s.tr.set(p.valueAsNumber,_.valueAsNumber,f.valueAsNumber),s.ori.set(v.valueAsNumber,C.valueAsNumber,b.valueAsNumber,I.valueAsNumber),s.ori.normalizeInPlace(),s.sc.set(w.valueAsNumber,P.valueAsNumber,T.valueAsNumber),l?l.update({value:s}):(l=new h(t,s),i.undoRedoManager.addChange(l));},u=()=>{m(),l=void 0,c=!1,d();};function g(e,s,i,n){const o=document.createElement("li"),a=document.createElement("input");return a.setAttribute("id",t.getName()),a.setAttribute("type","number"),a.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),a.setAttribute("value",i),a.setAttribute("tabindex",n),a.style.width="100%",o.appendChild(a),s.appendChild(o),a.addEventListener("input",m),a.addEventListener("change",u),a}const p=g(0,o,a.tr.x,0),_=g(0,o,a.tr.y,1),f=g(0,o,a.tr.z,2),v=g(0,o,a.ori.x,3),C=g(0,o,a.ori.y,4),b=g(0,o,a.ori.z,5),I=g(0,o,a.ori.w,6),w=g(0,o,a.sc.x,7),P=g(0,o,a.sc.y,8),T=g(0,o,a.sc.z,9);s.appendChild(n);}},t=>t instanceof e.XfoParameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("div");n.className="container";const o=document.createElement("ul");o.className="flex-editvalues",n.appendChild(o);const a=t.getValue();let r=void 0;const l=()=>{if(!r){const e=t.getValue();e.isValid()&&(u.value=e.p0.x,g.value=e.p0.y,p.value=e.p0.z,_.value=e.p1.x,f.value=e.p1.y,v.value=e.p1.z);}};t.valueChanged.connect(l);const c=()=>{const s=new e.Box3;s.p0.set(u.valueAsNumber,g.valueAsNumber,p.valueAsNumber),s.p1.set(_.valueAsNumber,f.valueAsNumber,v.valueAsNumber),r?r.update({value:s}):(r=new h(t,s),i.undoRedoManager.addChange(r)),l();},d=()=>{c(),r=void 0;};function m(e,s,i,n){const o=document.createElement("li"),a=document.createElement("input");return a.setAttribute("id",t.getName()),a.setAttribute("type","number"),a.setAttribute("pattern","-?[0-9]*(.[0-9]+)?"),a.setAttribute("value",i),a.setAttribute("tabindex",n),a.style.width="100%",o.appendChild(a),s.appendChild(o),a.addEventListener("input",c),a.addEventListener("change",d),a}const u=m(0,o,a.p0.x,0),g=m(0,o,a.p0.y,1),p=m(0,o,a.p0.z,2),_=m(0,o,a.p1.x,3),f=m(0,o,a.p1.y,4),v=m(0,o,a.p1.z,5);s.appendChild(n);}},t=>t.getValue()instanceof e.Box3);class R extends a{constructor(e,t){e?(super(e?e.getName()+" Name Changed":"NameValueChange"),this.__prevName=e.getName(),this.__item=e,null!=t&&(this.__nextName=t,this.__item.setName(this.__nextName))):super();}undo(){this.__item&&this.__item.setName(this.__prevName);}redo(){this.__item&&this.__item.setName(this.__nextName);}update(e){this.__item&&(this.__nextName=e.value,this.__item.setName(this.__nextName),this.updated.emit(e));}toJSON(e){const t=this.__item.getPath().slice();return t.pop(),t.push(this.__prevName),{name:this.name,nextName:this.__nextName,itemPath:t}}fromJSON(t,s){const i=s.appData.scene.getRoot().resolvePath(t.itemPath,1);i&&i instanceof e.BaseItem?(this.__item=i,this.__prevName=this.__item.getName(),this.__nextName=t.nextName,this.__item.setName(this.__nextName,e.ValueSetMode.REMOTEUSER_SETVALUE),this.name=this.__item.getName()+" Changed"):console.warn("resolvePath is unable to resolve",t.itemPath);}changeFromJSON(t){this.__item&&(this.__nextName=t.value,this.__item.setName(this.__nextName,e.ValueSetMode.REMOTEUSER_SETVALUE));}}o.registerChange("NameValueChange",R);class A{constructor(t,s,i){const n=document.createElement("input");let o,a;n.className="mdl-textfield__input",n.setAttribute("type","text"),n.setAttribute("value",t.getName()),n.setAttribute("tabindex",0),s.appendChild(n),t.nameChanged.connect((s,i,r)=>{o||(n.value=t.getName(),r==e.ValueSetMode.REMOTEUSER_SETVALUE&&(n.classList.add("user-edited"),a&&clearTimeout(a),a=setTimeout(()=>{n.classList.remove("user-edited"),a=null;},1500)));});const r=()=>{const e=n.value;o?o.update({value:e}):(o=new R(t,e),i.undoRedoManager.addChange(o));};n.addEventListener("input",r),n.addEventListener("change",()=>{r(),o=void 0;});}}class X{constructor(e,t,s){this.domElement=t,this.clean(),this.appData=s,this.container=document.createElement("div"),this.container.className="container",this.domElement.appendChild(this.container),this.ul=document.createElement("ul"),this.ul.className="flex-outer",this.container.appendChild(this.ul),e&&this.setParameterOwner(e);}clean(){for(;this.domElement.firstChild;)this.domElement.removeChild(this.domElement.firstChild);}destroy(){this.clean();}getDomElement(){return this.container}setParameterOwner(e){if(this.parameterOwner=e,this.widgets=[],e)for(const t of e.getParameters())this.addParameterWidget(t);}addParameterWidget(e){const t=e.getName(),s=V.findWidgetReg(e);if(!s)return void console.warn(`Unable to display parameter '${t}', value:${e.getValue()}`);const i=document.createElement("li");this.ul.appendChild(i);const n=document.createElement("label");n.setAttribute("for",t),n.appendChild(document.createTextNode(t)),i.appendChild(n);const o=new s.widget(e,i,this.appData);this.widgets.push(o);}}class N extends D{constructor(t,s,i){super(t);const n=document.createElement("ul");n.className="list pa0";const o=document.createElement("li"),a=document.createElement("li");s.appendChild(n),n.appendChild(o),n.appendChild(a);const r=t=>{t instanceof e.BaseItem&&(this.nameWidget=new A(t,o,i)),this.parameterContainer=new X(t,a,i);},l=t.getValue();l&&r(l),t.valueChanged.connect(()=>{for(;o.firstChild;)o.removeChild(o.firstChild);for(;a.firstChild;)a.removeChild(a.firstChild);r(t.getValue());});}}V.registerWidget(N,t=>t.getValue()instanceof e.ParameterOwner);V.registerWidget(class extends N{constructor(e,t,s){let i=e.getValue();{const s=document.createElement("ul");s.style.width="100%",s.style["padding-inline-start"]="0px";{const t=document.createElement("input");t.className="mdl-textfield__input",t.setAttribute("id",e.getName()),t.setAttribute("type","text"),t.setAttribute("value",i?i.getPath():"<NONE>"),t.setAttribute("tabindex",0);const n=document.createElement("li");n.style.display="block",n.appendChild(t),s.appendChild(n);}t.appendChild(s);}super(e,t,s),e.valueChanged.connect(()=>{i||t.removeChild(void 0);});}setParentDomElem(e){}},t=>t instanceof e.ImageParameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=new iro.ColorPicker(s,{width:200,height:200,color:t.getValue().getAsRGBDict(),anticlockwise:!0,borderWidth:1,borderColor:"#fff"});let o=void 0,a=!1;t.valueChanged.connect(()=>{o||(a=!0,n.color.rgb=t.getValue().getAsRGBDict(),a=!1);}),n.on("input:start",()=>{o=new h(t),i.undoRedoManager.addChange(o);}),n.on("input:end",()=>{o=void 0;}),n.on("color:change",(s,r)=>{if(a)return;const l=new e.Color;l.setFromRGBDict(n.color.rgb),o?o.update({value:l}):(o=new h(t,l),i.undoRedoManager.addChange(o));});}setParentDomElem(e){}},t=>t instanceof e.MaterialColorParam);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=t.getChoices(),o=document.createElement("select");for(let e=0;e<n.length;e++){const t=n[e],s=document.createElement("option");s.appendChild(document.createTextNode(t)),o.appendChild(s);}o.selectedIndex=t.getValue(),s.appendChild(o);let a,r=!1;t.valueChanged.connect(s=>{r||(o.selectedIndex=t.getValue(),s==e.ValueSetMode.REMOTEUSER_SETVALUE&&(o.classList.add("user-edited"),a&&clearTimeout(a),a=setTimeout(()=>{o.classList.remove("user-edited"),a=null;},1500)));});o.addEventListener("change",e=>{r=!0;const s=new h(t,o.selectedIndex);i.undoRedoManager.addChange(s),t.setValueDone(),r=!1;});}},t=>t instanceof e.MultiChoiceParameter);V.registerWidget(class extends D{constructor(e,t,s){super(e);const i=e.getValue(),n=document.createElement("input");n.className="mdl-textfield__input",n.setAttribute("id",e.getName()),n.setAttribute("type","text"),n.setAttribute("value",i?i.getPath().join("/"):"<none>"),n.style["outline-color"]="grey",n.style["outline-width"]="1px",n.style["outline-style"]="solid";const o=document.createElement("button");o.appendChild(document.createTextNode("Pick")),o.addEventListener("click",t=>{s.selectionManager.startPickingMode(`Pick ${e.getName()} item.`,t=>{const i=new h(e,t[0]);s.undoRedoManager.addChange(i);},e.getFilterFn(),1);}),o.style.margin="2px",t.appendChild(n),t.appendChild(o),e.valueChanged.connect(()=>{{const t=e.getValue();n.setAttribute("value",t?t.getPath().join("/"):"<none>");}});}},t=>t instanceof e.TreeItemParameter);V.registerWidget(class extends D{constructor(t,s,i){super(t);const n=document.createElement("select");n.classList.add("itemset-items");const o=()=>{const e=Array.from(t.getValue());n.setAttribute("size",e.length+1);for(let t=0;t<e.length;t++){const s=e[t],i=document.createElement("option");i.appendChild(document.createTextNode(s.getPath())),n.appendChild(i);}};t.valueChanged.connect(()=>{for(;n.firstChild;)n.removeChild(n.firstChild);o();}),o(),n.selectedIndex=-1,n.style.width="100%";const a=document.createElement("ul");a.style.width="100%",a.style["padding-inline-start"]="0px";const r=document.createElement("li");r.style.display="block",a.appendChild(r),r.appendChild(n),s.appendChild(a),this.selectionChanged=new e.Signal,this.selectionDoubleClicked=new e.Signal;let l=-1;if(n.addEventListener("change",e=>{console.log("valueChange",n.selectedIndex),this.selectionChanged.emit(n.selectedIndex,l),l=n.selectedIndex;}),n.addEventListener("dblclick",e=>{console.log("dblclick",n.selectedIndex);const s=t.getItem(n.selectedIndex);i.selectionManager.setSelection(new Set([s])),this.selectionDoubleClicked.emit(n.selectedIndex);}),null!=t.getFilterFn()){const e=document.createElement("button");e.appendChild(document.createTextNode("Add")),e.addEventListener("click",e=>{i.selectionManager.startPickingMode("Pick a new item.",e=>{t.addItems(e);},t.getFilterFn(),1);});const s=document.createElement("button");s.appendChild(document.createTextNode("Remove")),s.addEventListener("click",e=>{t.removeItem(n.selectedIndex);});const o=document.createElement("li");o.style.display="block",e.style.margin="2px",s.style.margin="2px",o.appendChild(e),o.appendChild(s),a.appendChild(o);}}},t=>t instanceof e.ItemSetParameter);V.registerWidget(class extends D{constructor(e,t,s){super(e);const i=[],n=()=>{e.getMemberNames().forEach((t,n)=>{const o=e.getMember(t),a=V.findWidgetReg(o);if(!a)return void console.warn(`StructWidget Unable to display item '${o.getNam()}'`);const l=document.createElement("li"),h=document.createElement("label");h.setAttribute("for",t),h.appendChild(document.createTextNode(t)),l.appendChild(h);const c=new a.widget(o,l,s);i[n]=c,r.appendChild(l);});};e.valueChanged.connect(()=>{for(;r.firstChild;)r.removeChild(r.firstChild);n();});const o=document.createElement("ul");o.style.width="100%",o.style["padding-inline-start"]="0px";const a=document.createElement("li");a.style.display="block",o.appendChild(a);const r=document.createElement("ul");r.style.display="block",o.appendChild(r),n(),t.appendChild(o);}},t=>t instanceof e.StructParameter);V.registerWidget(class extends D{constructor(e,t,s){super(e);const i=[],n=()=>{Array.from(e.getValue()).forEach((t,n)=>{const o=V.findWidgetReg(t);if(!o)return void console.warn(`ListWidget Unable to display list item '${t.getNam()}'`);const a=document.createElement("li"),l=new o.widget(t,a,s);i[n]=l;const h=document.createElement("button");h.appendChild(document.createTextNode("Remove")),h.addEventListener("click",t=>{e.removeElement(n);}),h.style.margin="2px",a.appendChild(h),r.appendChild(a);});};e.valueChanged.connect(()=>{for(;r.firstChild;)r.removeChild(r.firstChild);n();});const o=document.createElement("ul");o.style.width="100%",o.style["padding-inline-start"]="0px";const a=document.createElement("li");a.style.display="block",o.appendChild(a);const r=document.createElement("ul");r.style.display="block",o.appendChild(r),n(),t.appendChild(o);{const t=document.createElement("li");t.style.display="block";const s=document.createElement("button");s.appendChild(document.createTextNode("Add")),s.addEventListener("click",t=>{e.addElement();}),s.style.margin="2px",t.appendChild(s),o.appendChild(t);}}},t=>t instanceof e.ListParameter);class L{constructor(t,s){this.userPressed=new e.Signal,this.domElement=t,this.clean(),this.userDiv=document.createElement("div"),this.userDiv.className="user-chip pa1 br2",this.domElement.appendChild(this.userDiv),this.userImage=document.createElement("img"),this.userImage.className="user-image br-100 ba b--black-10",this.userImage.alt="Avatar",this.userImage.src=s.picture,this.userImage.addEventListener("mousedown",()=>{this.userPressed.emit(this.userData),this.userImage.classList.add("user-image--selected");},!0),this.userImage.addEventListener("mouseup",()=>{this.userImage.classList.remove("user-image--selected");},!0),this.userDiv.appendChild(this.userImage),this.userToolTip=document.createElement("span"),this.userToolTip.className="tooltiptext",this.userDiv.appendChild(this.userToolTip),s&&this.setUserData(s);}setUserData(e){this.userData=e,this.userNameSpan&&(this.userNameSpan.innerHTML=e.name),this.userToolTip.innerHTML=e.name;}clean(){for(;this.domElement.firstChild;)this.domElement.removeChild(this.domElement.firstChild);}unmount(){this.clean();}}class k{constructor(t){let s,i;this.panelSide=t,0==t?(this.domElement=document.createElement("div"),this.domElement.className="SidePanel SidePanel--left overflow-auto pa2",this.handleElement=document.createElement("div"),this.handleElement.className="PanelHandler bg-center"):(this.handleElement=document.createElement("div"),this.handleElement.className="PanelHandler bg-center",this.domElement=document.createElement("div"),this.domElement.className="SidePanel SidePanel--right overflow-auto pa2"),this.domElement.style.width="0px";const n=e=>{const n=(e.clientX-s)*window.devicePixelRatio,o=0==t?i+n:i-n;o<40?(this.domElement.style.display="none",this.domElement.style.width="0px"):(this.domElement.style.display="block",this.domElement.style.width=`${o}px`);},o=e=>{document.removeEventListener("mousemove",n,!1),document.removeEventListener("mouseup",o,!1);};this.handleElement.addEventListener("mousedown",e=>{s=e.clientX,i=parseInt(document.defaultView.getComputedStyle(this.domElement).width,10)*window.devicePixelRatio,document.addEventListener("mousemove",n,!1),document.addEventListener("mouseup",o,!1);},!1);const a={},r=(e,t)=>{delete a[e.identifier];};this.handleElement.addEventListener("touchstart",t=>{t.preventDefault(),t.stopPropagation(),i=parseInt(document.defaultView.getComputedStyle(this.domElement).width,10)*window.devicePixelRatio;const n=t.changedTouches;if(1==n.length){s=n[0].clientX;for(let t=0;t<n.length;t++)o=n[t],a[o.identifier]={identifier:o.identifier,pos:new e.Vec2(o.pageX,o.pageY)};t.stopPropagation();}var o;},!1),this.handleElement.addEventListener("touchmove",e=>{const n=e.changedTouches;if(1==n.length){const o=(n[0].clientX-s)*window.devicePixelRatio,a=0==t?i+o:i-o;a<40?(this.domElement.style.display="none",this.domElement.style.width="0px"):(this.domElement.style.display="block",this.domElement.style.width=`${a}px`),e.stopPropagation();}},!1),this.handleElement.addEventListener("touchend",e=>{e.preventDefault(),e.stopPropagation();const t=e.changedTouches;for(let e=0;e<t.length;e++)r(t[e]);e.stopPropagation();},!1),this.handleElement.addEventListener("touchcancel",e=>{const t=e.changedTouches;for(let e=0;e<t.length;e++)r(t[e]);e.stopPropagation();},!1);}getPanelWidget(){return this.widget}setPanelWidget(e){if(this.widget)for(this.widget.unMount(this.domElement);this.domElement.firstChild;)this.domElement.removeChild(this.domElement.firstChild);this.widget=e,this.widget?(this.domElement.style.display="block",this.domElement.style.width=(e.getDefaultWidth?e.getDefaultWidth():300)+"px",this.widget.mount?this.widget.mount(this.domElement):this.domElement.appendChild(this.widget)):(this.domElement.style.display="none",this.domElement.style.width="0px");}mount(e){this.parentDomElement=e,0==this.panelSide?(this.parentDomElement.appendChild(this.domElement),this.parentDomElement.appendChild(this.handleElement)):(this.parentDomElement.appendChild(this.handleElement),this.parentDomElement.appendChild(this.domElement));}unMount(e){this.parentDomElement.removeChild(this.domElement);}}class G{constructor(){let e,t;this.handleElement=document.createElement("div"),this.handleElement.className="BottomPanelHandler bg-center z-1 bt",this.domElement=document.createElement("div"),this.domElement.className="BottomPanel overflow-auto pa2",this.domElement.style.height="0px",this.closedHeight=0;const s=s=>{const i=s.clientY-e;let n=t-i;n<this.closedHeight+40&&(n=this.closedHeight),this.domElement.style.height=`${n}px`;},i=e=>{document.removeEventListener("mousemove",s,!1),document.removeEventListener("mouseup",i,!1);};this.handleElement.addEventListener("mousedown",n=>{e=n.clientY,t=parseInt(document.defaultView.getComputedStyle(this.domElement).height,10),document.addEventListener("mousemove",s,!1),document.addEventListener("mouseup",i,!1);},!1);}getPanelWidget(){return this.widget}setPanelWidget(e){if(this.widget)for(this.widget.unMount(this.domElement);this.domElement.firstChild;)this.domElement.removeChild(this.domElement.firstChild);this.widget=e,this.widget?(this.domElement.style.display="block",this.domElement.style.height=(e.getDefaultHeight?e.getDefaultHeight():180)+"px",this.widget.mount?this.widget.mount(this.domElement):this.domElement.appendChild(this.widget)):(this.domElement.style.display="none",this.domElement.style.height="0px");}mount(e){this.parentDomElement=e,this.parentDomElement.appendChild(this.handleElement),this.parentDomElement.appendChild(this.domElement);}unMount(e){this.parentDomElement.removeChild(this.domElement);}}V.registerTreeItemElement(class{constructor(t,s,i,n=!1){this.treeItem=t,this.appData=s,this.options=i,this.li=document.createElement("li"),this.li.className="TreeNodesListItem",this.li.treeItem=t,this.expandBtn=document.createElement("button"),this.expandBtn.className="TreeNodesListItem__ToggleExpanded",this.li.appendChild(this.expandBtn),t instanceof e.TreeItem&&(this.toggleVisibilityBtn=document.createElement("button"),this.toggleVisibilityBtn.className="TreeNodesListItem__ToggleVisibility",this.li.appendChild(this.toggleVisibilityBtn),this.toggleVisibilityBtn.innerHTML='<i class="material-icons md-15">visibility</i>',this.toggleVisibilityBtn.addEventListener("click",()=>{const e=this.treeItem.getParameter("Visible"),t=new h(e,!e.getValue());this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(t);}),this.updateVisibilityId=this.treeItem.visibilityChanged.connect(this.updateVisibility.bind(this)),this.updateVisibility()),this.titleElement=document.createElement("span"),this.titleElement.className="TreeNodesListItem__Title",this.titleElement.textContent=t.getName();if(this.treeItem.nameChanged.connect(()=>{this.titleElement.textContent=t.getName();}),this.li.appendChild(this.titleElement),this.titleElement.addEventListener("click",e=>{s.selectionManager&&(s.selectionManager.pickingModeActive()?s.selectionManager.pick(this.treeItem):s.selectionManager.toggleItemSelection(this.treeItem,!e.ctrlKey));}),this.updateSelectedId=this.treeItem.selectedChanged.connect(this.updateSelected.bind(this)),this.updateSelected(),t instanceof e.TreeItem&&(this.updateHighlightId=this.treeItem.highlightChanged.connect(this.updateHighlight.bind(this)),this.updateHighlight()),this.ul=document.createElement("ul"),this.ul.className="TreeNodesList",this.li.appendChild(this.ul),this.childElements=[],this.expanded=!1,t instanceof e.TreeItem){if(n)this.expand();else {this.treeItem.getChildren().length>0&&this.collapse();}this.expandBtn.addEventListener("click",()=>{this.treeItem.getNumChildren()>0&&(this.expanded?this.collapse():this.expand());}),this.childAddedId=this.treeItem.childAdded.connect(this.childAdded.bind(this)),this.childRemovedId=this.treeItem.childRemoved.connect(this.childRemoved.bind(this)),this.titleElement.onmousedown=t=>{if(i.allowDragNDrop){t.stopPropagation(),t.preventDefault();const s=t.clientX,i=t.clientY;let n,o,a=s-this.li.getBoundingClientRect().left,r=i-this.li.getBoundingClientRect().top,l=!1;const h=t=>{if(!l){const e=t.clientX-s,o=t.clientY-i;Math.abs(e)>10&&Math.abs(o)>10&&(n=document.createElement("li"),n.className="TreeNodesListItem",n.classList.add("TreeNodesListItem--isHighlighted"),n.classList.add("TreeNodesListItem--isSelected"),n.classList.add("TreeNodesListItem__Dragging"),n.appendChild(this.titleElement.cloneNode(!0)),n.style.position="absolute",n.style.zIndex=1e3,document.body.append(n),l=!0);}if(l){n.style.left=t.pageX-a+"px",n.style.top=t.pageY-r+"px",n.hidden=!0;const s=document.elementFromPoint(t.clientX,t.clientY);if("TreeNodesListItem__Title"==s.className&&s.parentElement.treeItem instanceof e.TreeItem){const e=s.parentElement;o&&o!=e&&o.classList.remove("TreeNodesListItem--isHighlighted"),e==this.li?o=null:e&&o!=e&&(o=e,o.classList.add("TreeNodesListItem--isHighlighted"));}n.hidden=!1;}},c=e=>{if(n&&document.body.removeChild(n),o){const e=new M(this.treeItem,o.treeItem);this.appData.undoRedoManager&&this.appData.undoRedoManager.addChange(e);}document.removeEventListener("mousemove",h),document.removeEventListener("mouseup",c);};document.addEventListener("mousemove",h),document.addEventListener("mouseup",c);}};}this.li.ondragstart=function(){return !1};}updateVisibility(){this.treeItem.getVisible()?this.li.classList.remove("TreeNodesListItem--isHidden"):this.li.classList.add("TreeNodesListItem--isHidden");}updateSelected(){this.treeItem.getSelected()?this.li.classList.add("TreeNodesListItem--isSelected"):this.li.classList.remove("TreeNodesListItem--isSelected");}updateHighlight(){const e=this.treeItem.isHighlighted();e?this.li.classList.add("TreeNodesListItem--isHighlighted"):this.li.classList.remove("TreeNodesListItem--isHighlighted"),e&&(this.titleElement.style["border-color"]=this.treeItem.getHighlight().toHex());}childAdded(e,t){this.addChild(e,t);}childRemoved(e,t){this.expanded&&(this.li.removeChild(this.childElements[t].li),this.childElements[t].destroy(),this.childElements.splice(t,1));}addComponent(e){this.subul||(this.subul=document.createElement("ul"),this.titleElement.appendChild(this.subul));const t=document.createElement("li");t.className="TreeNodesListItem";const s=document.createElement("span");s.className="TreeNodesListItem__Title",s.textContent=e,t.appendChild(s),this.subul.appendChild(t);}addChild(e,t){if(this.expanded){const s=V.constructTreeItemElement(e,this.appData,this.options);t==this.childElements.length?this.ul.appendChild(s.li):this.ul.insertBefore(s.li,this.childElements[t].li),this.childElements.splice(t,0,s);}else this.collapse();}getChild(e){return this.childElements[e]}expand(){if(this.expanded=!0,this.ul.classList.remove("TreeNodesList--collapsed"),this.expandBtn.innerHTML='<i class="material-icons md-24">arrow_drop_down</i>',!this.childrenAlreadyCreated){this.treeItem.getChildren().forEach((e,t)=>{this.addChild(e,t);}),this.childrenAlreadyCreated=!0;}}collapse(){this.ul.classList.add("TreeNodesList--collapsed"),this.expandBtn.innerHTML='<i class="material-icons md-24">arrow_right</i>',this.expanded=!1;}destroy(){this.treeItem.selectedChanged.disconnectId(this.updateSelectedId),this.treeItem instanceof e.TreeItem&&(this.treeItem.highlightChanged.disconnectId(this.updateHighlightId),this.treeItem.visibilityChanged.disconnectId(this.updateVisibilityId),this.treeItem.childAdded.disconnectId(this.childAddedId),this.treeItem.childRemoved.disconnectId(this.childRemovedId));}},t=>t instanceof e.BaseItem);V.registerInpector(class{constructor(e,t,s){const i=document.createElement("ul");i.className="list pa0 pr3";const n=document.createElement("li"),o=document.createElement("li");t.appendChild(i),i.appendChild(n),i.appendChild(o),this.nameWidget=new A(e,n,s),this.parameterContainer=new X(e,o,s);}destroy(){this.parameterContainer.destroy();}},t=>t instanceof e.BaseItem);class O extends e.ParameterOwner{constructor(t){super(),t||console.error("App data not provided to tool"),this.appData=t,this.installChanged=new e.Signal,this.activatedChanged=new e.Signal,this.actionFinished=new e.Signal,this.__params=[],this.__installed=!1,this.__activated=!1;}getName(){return this.constructor.name}isPrimaryTool(){return !1}installed(){return this.__installed}install(e){if(this.__installed)throw new Error("Tool already installed");this.index=e,this.__installed=!0,this.installChanged.emit(!0);}uninstall(){this.__installed=!1,this.installChanged.emit(!1);}activateTool(){if(this.__activated)throw new Error("Tool already activate");this.__activated=!0,this.activatedChanged.emit(!0);}deactivateTool(){this.__activated=!1,this.activatedChanged.emit(!1);}onMouseDown(e){}onMouseMove(e){}onMouseUp(e){}onDoubleClick(e){}onWheel(e){}onKeyPressed(e,t){}onKeyDown(e,t){}onKeyUp(e,t){}onTouchStart(e){}onTouchMove(e){}onTouchEnd(e){}onTouchCancel(e){}onDoubleTap(e){}onVRControllerButtonDown(e){}onVRControllerButtonUp(e){}onVRControllerDoubleClicked(e){}onVRPoseChanged(e){}}const U={VIEWER:0,DCC:1};class H extends O{constructor(t){super(t),this.dragging=!1,this.selectionRect=new e.Rect(1,1),this.selectionRectMat=new e.Material("marker","ScreenSpaceShader"),this.selectionRectMat.getParameter("BaseColor").setValue(new e.Color("#03E3AC")),this.selectionRectXfo=new e.Xfo,this.selectionRectXfo.tr.set(.5,.5,0),this.selectionRectXfo.sc.set(0,0,0);}activateTool(){super.activateTool(),this.rectItem||(this.rectItem=new e.GeomItem("selectionRect",this.selectionRect,this.selectionRectMat),this.rectItem.getParameter("Visible").setValue(!1),this.appData.renderer.addTreeItem(this.rectItem));}deactivateTool(){super.deactivateTool(),this.selectionRectXfo.sc.set(0,0,0),this.rectItem.setGlobalXfo(this.selectionRectXfo);}onMouseDown(e){return 0==e.button&&!e.altKey&&(console.log("onMouseDown"),this.mouseDownPos=e.mousePos,this.dragging=!1,!0)}__resizeRect(t,s){const i=new e.Vec2(1/t.getWidth()*2,1/t.getHeight()*2),n=s.multiply(i);this.selectionRectXfo.sc.set(Math.abs(n.x),Math.abs(n.y),1);const o=this.mouseDownPos.subtract(s.scale(.5)).multiply(i).subtract(new e.Vec2(1,1));this.selectionRectXfo.tr.x=o.x,this.selectionRectXfo.tr.y=-o.y,this.rectItem.setGlobalXfo(this.selectionRectXfo);}onMouseMove(e){if(this.mouseDownPos){const t=this.mouseDownPos.subtract(e.mousePos);this.dragging&&this.__resizeRect(e.viewport,t),t.length()>4&&(this.dragging=!0,this.rectItem.getParameter("Visible").setValue(!0),this.__resizeRect(e.viewport,t));}return !0}onMouseUp(t){if(this.mouseDownPos){if(this.dragging){this.rectItem.getParameter("Visible").setValue(!1);const s=t.mousePos,i=new e.Vec2(Math.min(this.mouseDownPos.x,s.x),Math.min(this.mouseDownPos.y,s.y)),n=new e.Vec2(Math.max(this.mouseDownPos.x,s.x),Math.max(this.mouseDownPos.y,s.y)),o=t.viewport.getGeomItemsInRect(i,n);if(this.appData.selectionManager.pickingModeActive())this.appData.selectionManager.pick(o);else {const e=new Set([...o].filter(e=>!(e.getOwner()instanceof r)));t.shiftKey?this.appData.selectionManager.deselectItems(e):this.appData.selectionManager.selectItems(e,!t.ctrlKey),this.selectionRectXfo.sc.set(0,0,0),this.rectItem.setGlobalXfo(this.selectionRectXfo);}}else {const e=t.viewport.getGeomDataAtPos(t.mousePos);if(null==e||e.geomItem.getOwner()instanceof r)this.appData.selectionManager.clearSelection();else if(this.appData.selectionManager.pickingModeActive())this.appData.selectionManager.pick(e.geomItem);else if(t.shiftKey){const t=new Set;t.add(e.geomItem),this.appData.selectionManager.deselectItems(t);}else this.appData.selectionManager.toggleItemSelection(e.geomItem,!t.ctrlKey);}return this.mouseDownPos=void 0,!0}}onVRControllerButtonDown(e){if(1==e.button){const t=e.controller.getGeomItemAtTip();if(null!=t&&!(t.geomItem.getOwner()instanceof r))return this.appData.selectionManager.toggleItemSelection(t.geomItem),!0}}}o.registerChange("SelectionTool",H);const B=function(){return {escape:function(e){return e.replace(/([.*+?^${}()|\[\]\/\\])/g,"\\$1")},parseExtension:e,mimeType:function(t){const s=e(t).toLowerCase();return function(){const e="application/font-woff";return {woff:e,woff2:e,ttf:"application/font-truetype",eot:"application/vnd.ms-fontobject",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif",tiff:"image/tiff",svg:"image/svg+xml"}}()[s]||""},dataAsUrl:function(e,t){return "data:"+t+";base64,"+e},isDataUrl:function(e){return -1!==e.search(/^(data:)/)},canvasToBlob:function(e){return e.toBlob?new Promise((function(t){e.toBlob(t);})):function(e){return new Promise((function(t){const s=window.atob(e.toDataURL().split(",")[1]),i=s.length,n=new Uint8Array(i);for(let e=0;e<i;e++)n[e]=s.charCodeAt(e);t(new Blob([n],{type:"image/png"}));}))}(e)},resolveUrl:function(e,t){const s=document.implementation.createHTMLDocument(),i=s.createElement("base");s.head.appendChild(i);const n=s.createElement("a");return s.body.appendChild(n),i.href=t,n.href=e,n.href},getAndEncode:function(e){Z.impl.options.cacheBust&&(e+=(/\?/.test(e)?"&":"?")+(new Date).getTime());return new Promise((function(t){const s=new XMLHttpRequest;let i;if(s.onreadystatechange=function(){if(4!==s.readyState)return;if(200!==s.status)return void(i?t(i):n("cannot fetch resource: "+e+", status: "+s.status));const o=new FileReader;o.onloadend=function(){const e=o.result.split(/,/)[1];t(e);},o.readAsDataURL(s.response);},s.ontimeout=function(){i?t(i):n("timeout of 30000ms occured while fetching resource: "+e);},s.responseType="blob",s.timeout=3e4,s.open("GET",e,!0),s.send(),Z.impl.options.imagePlaceholder){const e=Z.impl.options.imagePlaceholder.split(/,/);e&&e[1]&&(i=e[1]);}function n(e){console.error(e),t("");}}))},uid:function(){let e=0;return function(){return "u"+("0000"+(Math.random()*Math.pow(36,4)<<0).toString(36)).slice(-4)+e++}}(),delay:function(e){return function(t){return new Promise((function(s){setTimeout((function(){s(t);}),e);}))}},asArray:function(e){const t=[],s=e.length;for(let i=0;i<s;i++)t.push(e[i]);return t},escapeXhtml:function(e){return e.replace(/#/g,"%23").replace(/\n/g,"%0A")},makeImage:function(e){return new Promise((function(t,s){const i=new Image;i.onload=function(){t(i);},i.onerror=s,i.src=e;}))},width:function(e){const s=t(e,"border-left-width"),i=t(e,"border-right-width");return e.scrollWidth+s+i},height:function(e){const s=t(e,"border-top-width"),i=t(e,"border-bottom-width");return e.scrollHeight+s+i}};function e(e){const t=/\.([^\.\/]*?)$/g.exec(e);return t?t[1]:""}function t(e,t){const s=window.getComputedStyle(e).getPropertyValue(t);return parseFloat(s.replace("px",""))}}(),F=function(){const e=/url\(['"]?([^'"]+?)['"]?\)/g;return {inlineAll:function(e,n,o){return function(){return !t(e)}()?Promise.resolve(e):Promise.resolve(e).then(s).then((function(t){let s=Promise.resolve(e);return t.forEach((function(e){s=s.then((function(t){return i(t,e,n,o)}));})),s}))},shouldProcess:t,impl:{readUrls:s,inline:i}};function t(t){return -1!==t.search(e)}function s(t){const s=[];let i;for(;null!==(i=e.exec(t));)s.push(i[1]);return s.filter((function(e){return !B.isDataUrl(e)}))}function i(e,t,s,i){return Promise.resolve(t).then((function(e){return s?B.resolveUrl(e,s):e})).then(i||B.getAndEncode).then((function(e){return B.dataAsUrl(e,B.mimeType(t))})).then((function(s){return e.replace(function(e){return new RegExp("(url\\(['\"]?)("+B.escape(e)+")(['\"]?\\))","g")}(t),"$1"+s+"$3")}))}}(),z=function(){return {resolveAll:function(){return e().then((function(e){return Promise.all(e.map((function(e){return e.resolve()})))})).then((function(e){return e.join("\n")}))},impl:{readAll:e}};function e(){return Promise.resolve(B.asArray(document.styleSheets)).then((function(e){const t=[];return e.forEach((function(e){try{B.asArray(e.cssRules||[]).forEach(t.push.bind(t));}catch(t){console.log("Error while reading CSS rules from "+e.href,t.toString());}})),t})).then((function(e){return e.filter((function(e){return e.type===CSSRule.FONT_FACE_RULE})).filter((function(e){return F.shouldProcess(e.style.getPropertyValue("src"))}))})).then((function(t){return t.map(e)}));function e(e){return {resolve:function(){const t=(e.parentStyleSheet||{}).href;return F.inlineAll(e.cssText,t)},src:function(){return e.style.getPropertyValue("src")}}}}}(),W=function(){return {inlineAll:function t(s){return s instanceof Element?function(e){const t=e.style.getPropertyValue("background");return t?F.inlineAll(t).then((function(t){e.style.setProperty("background",t,e.style.getPropertyPriority("background"));})).then((function(){return e})):Promise.resolve(e)}(s).then((function(){return s instanceof HTMLImageElement?e(s).inline():Promise.all(B.asArray(s.childNodes).map((function(e){return t(e)})))})):Promise.resolve(s)},impl:{newImage:e}};function e(e){return {inline:function(t){return B.isDataUrl(e.src)?Promise.resolve():Promise.resolve(e.src).then(t||B.getAndEncode).then((function(t){return B.dataAsUrl(t,B.mimeType(e.src))})).then((function(t){return new Promise((function(s,i){e.onload=s,e.onerror=i,e.src=t;}))}))}}}}(),J={imagePlaceholder:void 0,cacheBust:!1},Z={toSvg:K,toPng:function(e,t){return j(e,t||{}).then((function(e){return e.toDataURL()}))},toJpeg:function(e,t){return j(e,t=t||{}).then((function(e){return e.toDataURL("image/jpeg",t.quality||1)}))},toBlob:function(e,t){return j(e,t||{}).then(B.canvasToBlob)},toPixelData:function(e,t){return j(e,t||{}).then((function(t){return t.getContext("2d").getImageData(0,0,B.width(e),B.height(e)).data}))},toCanvas:function(e,t){return j(e,t||{}).then((function(e){return e}))},impl:{fontFaces:z,images:W,util:B,inliner:F,options:{}}};function K(e,t){return function(e){void 0===e.imagePlaceholder?Z.impl.options.imagePlaceholder=J.imagePlaceholder:Z.impl.options.imagePlaceholder=e.imagePlaceholder;void 0===e.cacheBust?Z.impl.options.cacheBust=J.cacheBust:Z.impl.options.cacheBust=e.cacheBust;}(t=t||{}),Promise.resolve(e).then((function(e){return function e(t,s,i){return i||!s||s(t)?Promise.resolve(t).then((function(e){return e instanceof HTMLCanvasElement?B.makeImage(e.toDataURL()):e.cloneNode(!1)})).then((function(e){return n(t,e,s)})).then((function(e){return function(e,t){return t instanceof Element?Promise.resolve().then(s).then(i).then(n).then(o).then((function(){return t})):t;function s(){var s,i;s=window.getComputedStyle(e),i=t.style,s.cssText?i.cssText=s.cssText:function(e,t){B.asArray(e).forEach((function(s){t.setProperty(s,e.getPropertyValue(s),e.getPropertyPriority(s));}));}(s,i);}function i(){[":before",":after"].forEach((function(s){!function(s){const i=window.getComputedStyle(e,s),n=i.getPropertyValue("content");if(""===n||"none"===n)return;const o=B.uid();t.className=t.className+" "+o;const a=document.createElement("style");a.appendChild(function(e,t,s){const i="."+e+":"+t,n=s.cssText?function(e){const t=e.getPropertyValue("content");return e.cssText+" content: "+t+";"}(s):function(e){return B.asArray(e).map((function(t){return t+": "+e.getPropertyValue(t)+(e.getPropertyPriority(t)?" !important":"")})).join("; ")+";"}(s);return document.createTextNode(i+"{"+n+"}")}(o,s,i)),t.appendChild(a);}(s);}));}function n(){e instanceof HTMLTextAreaElement&&(t.innerHTML=e.value),e instanceof HTMLInputElement&&t.setAttribute("value",e.value);}function o(){t instanceof SVGElement&&(t.setAttribute("xmlns","http://www.w3.org/2000/svg"),t instanceof SVGRectElement&&["width","height"].forEach((function(e){const s=t.getAttribute(e);s&&t.style.setProperty(e,s);})));}}(t,e)})):Promise.resolve();function n(t,s,i){const n=t.childNodes;return 0===n.length?Promise.resolve(s):o(s,B.asArray(n),i).then((function(){return s}));function o(t,s,i){let n=Promise.resolve();return s.forEach((function(s){n=n.then((function(){return e(s,i)})).then((function(e){e&&t.appendChild(e);}));})),n}}}(e,t.filter,!0)})).then(Y).then($).then((function(e){t.bgcolor&&(e.style.backgroundColor=t.bgcolor);t.width&&(e.style.width=t.width+"px");t.height&&(e.style.height=t.height+"px");t.style&&Object.keys(t.style).forEach((function(s){e.style[s]=t.style[s];}));return e})).then((function(s){return function(e,t,s){return Promise.resolve(e).then((function(e){return e.setAttribute("xmlns","http://www.w3.org/1999/xhtml"),(new XMLSerializer).serializeToString(e)})).then(B.escapeXhtml).then((function(e){return '<foreignObject x="0" y="0" width="100%" height="100%">'+e+"</foreignObject>"})).then((function(e){return '<svg xmlns="http://www.w3.org/2000/svg" width="'+t+'" height="'+s+'">'+e+"</svg>"})).then((function(e){return "data:image/svg+xml;charset=utf-8,"+e}))}(s,t.width||B.width(e),t.height||B.height(e))}))}function j(e,t){return K(e,t).then(B.makeImage).then(B.delay(100)).then((function(s){const i=function(e){const s=document.createElement("canvas");if(s.width=t.width||B.width(e),s.height=t.height||B.height(e),t.bgcolor){const e=s.getContext("2d");e.fillStyle=t.bgcolor,e.fillRect(0,0,s.width,s.height);}return s}(e);return i.getContext("2d").drawImage(s,0,0),i}))}function Y(e){return z.resolveAll().then((function(t){const s=document.createElement("style");return e.appendChild(s),s.appendChild(document.createTextNode(t)),e}))}function $(e){return W.inlineAll(e).then((function(){return e}))}class Q extends e.GeomItem{constructor(t,s,i){const n=new e.Material("uimat","FlatSurfaceShader");let o;n.visibleInGeomDataBuffer=!1,super("VRControllerUI",new e.Plane(1,1),n),this.appData=t,this.__vrUIDOMHolderElement=s,this.__vrUIDOMElement=i,this.__uiimage=new e.DataImage,n.getParameter("BaseColor").setValue(this.__uiimage),this.__uiGeomOffsetXfo=new e.Xfo,this.__uiGeomOffsetXfo.sc.set(0,0,1),this.__rect={width:0,height:0},this.__uiGeomOffsetXfo.ori.setFromAxisAndAngle(new e.Vec3(0,1,0),Math.PI),this.setGeomOffsetXfo(this.__uiGeomOffsetXfo);let a=[];const r=()=>{o=null;const e=a.map(e=>this.updateElemInAtlas(e));Promise.all(e).then(()=>{this.updateUIImage(),a=[];});};this.__mutationObserver=new MutationObserver(e=>{this.mainCtx?(e.some(e=>{let t=e.target;for(;t.parentNode;){if(t==this.__vrUIDOMElement)return this.renderUIToImage(),a=[],!1;if(t.classList.contains("VRUIElement")||t==this.__vrUIDOMElement){-1==a.indexOf(t)&&a.push(t);break}t=t.parentNode;}return !0}),o&&clearTimeout(o),o=setTimeout(r,50)):this.renderUIToImage();}),this.__active=!1,this.__renderRequested=!1;}activate(){this.__vrUIDOMHolderElement.style.display="block",this.__active=!0,this.__mutationObserver.observe(this.__vrUIDOMElement,{attributes:!0,characterData:!0,childList:!0,subtree:!0}),this.renderUIToImage();}deactivate(){this.__vrUIDOMHolderElement.style.display="none",this.__active=!0,this.__mutationObserver.disconnect();}updateElemInAtlas(e){return new Promise((t,s)=>{Z.toCanvas(e).then(s=>{const i=e.getBoundingClientRect();i.width*i.height!=0?(this.mainCtx.fillRect(i.x,i.y,i.width,i.height),this.mainCtx.drawImage(s,i.x,i.y),t()):t();});})}updateUIImage(){const e=this.mainCtx.getImageData(0,0,this.__rect.width,this.__rect.height);this.__uiimage.setData(this.__rect.width,this.__rect.height,new Uint8Array(e.data.buffer));}renderUIToImage(){Z.toCanvas(this.__vrUIDOMElement).then(e=>{this.mainCtx=e.getContext("2d"),this.mainCtx.fillStyle="#FFFFFF";const t=this.__vrUIDOMElement.getBoundingClientRect();if(t.width*t.height!=0){if(t.width!=this.__rect.width||t.height!=this.__rect.height){this.__rect=t;const e=7e-4;this.__uiGeomOffsetXfo.sc.set(this.__rect.width*e,this.__rect.height*e,1),this.setGeomOffsetXfo(this.__uiGeomOffsetXfo),this.appData.session.pub("pose-message",{interfaceType:"VR",updateUIPanel:{size:this.__uiGeomOffsetXfo.sc.toJSON()}});}this.updateUIImage();}});}sendMouseEvent(e,t,s){const i=new MouseEvent(e,Object.assign({target:s,view:window,bubbles:!0,cancelable:!0},t));return s.dispatchEvent(i),i}}class q extends a{constructor(e){super("HoldObjectsChange"),this.__selection=[],this.__prevXfos=[],this.__newXfos=[],e&&this.update(e);}undo(){for(let e=0;e<this.__selection.length;e++)this.__selection[e]&&this.__selection[e].setGlobalXfo(this.__prevXfos[e]);}redo(){for(let e=0;e<this.__selection.length;e++)this.__selection[e]&&this.__selection[e].setGlobalXfo(this.__newXfos[e]);}update(e){if(e.newItem)this.__selection[e.newItemId]=e.newItem,this.__prevXfos[e.newItemId]=e.newItem.getGlobalXfo();else if(e.changeXfos)for(let t=0;t<e.changeXfoIds.length;t++){const s=e.changeXfoIds[t];this.__selection[s]&&(this.__selection[s].setGlobalXfo(e.changeXfos[t]),this.__newXfos[s]=e.changeXfos[t]);}this.updated.emit(e);}toJSON(e){const t=super.toJSON(e),s=[];for(let e=0;e<this.__selection.length;e++)this.__selection[e]?s[e]=this.__selection[e].getPath():s.push(null);return t.itemPaths=s,t}fromJSON(e,t){super.fromJSON(e,t);const s=t.appData.scene.getRoot(),i=[];for(let t=0;t<e.itemPaths.length;t++){const n=e.itemPaths[t];n&&(i[t]=s.resolvePath(n,1));}this.__selection=i;}}o.registerChange("HoldObjectsChange",q);class ee extends O{constructor(e){super(e);}isPrimaryTool(){return !0}}class te extends a{constructor(e){super(e);}setParentAndXfo(e,t){this.parentItem=e;const s=this.parentItem.generateUniqueName(this.geomItem.getName());this.geomItem.setName(s),this.geomItem.setGlobalXfo(t),this.childIndex=this.parentItem.addChild(this.geomItem,!0),this.geomItem.addRef(this);}undo(){this.parentItem.removeChild(this.childIndex);}redo(){this.parentItem.addChild(this.geomItem,!1,!1);}toJSON(e){const t=super.toJSON(e);return t.parentItemPath=this.parentItem.getPath(),t.geomItemName=this.geomItem.getName(),t.geomItemXfo=this.geomItem.getParameter("LocalXfo").getValue(),t}fromJSON(t,s){const i=s.appData.scene.getRoot();this.parentItem=i.resolvePath(t.parentItemPath,1),this.geomItem.setName(this.parentItem.generateUniqueName(t.geomItemName));const n=new e.Xfo;n.fromJSON(t.geomItemXfo),this.geomItem.setLocalXfo(n),this.childIndex=this.parentItem.addChild(this.geomItem,!1);}destroy(){this.geomItem.removeRef(this);}}class se extends ee{constructor(t){super(t),this.stage=0,this.removeToolOnRightClick=!0,this.cp=this.addParameter(new e.ColorParameter("Line Color",new e.Color(.7,.2,.2)));}activateTool(){super.activateTool(),this.appData.renderer.getDiv().style.cursor="crosshair",this.appData.renderer.getXRViewport().then(t=>{this.vrControllerToolTip||(this.vrControllerToolTip=new e.Cross(.05),this.vrControllerToolTipMat=new e.Material("VRController Cross","LinesShader"),this.vrControllerToolTipMat.getParameter("Color").setValue(this.cp.getValue()),this.vrControllerToolTipMat.visibleInGeomDataBuffer=!1);const s=t=>{const s=new e.GeomItem("CreateGeomToolTip",this.vrControllerToolTip,this.vrControllerToolTipMat);t.getTipItem().removeAllChildren(),t.getTipItem().addChild(s,!1);};for(const e of t.getControllers())s(e);this.addIconToControllerId=t.controllerAdded.connect(s);});}deactivateTool(){super.deactivateTool(),this.appData.renderer.getDiv().style.cursor="pointer",this.appData.renderer.getXRViewport().then(e=>{e.controllerAdded.disconnectId(this.addIconToControllerId);});}screenPosToXfo(t,s){const i=s.calcRayFromScreenPos(t),n=new e.Ray(this.constructionPlane.tr,this.constructionPlane.ori.getZaxis()),o=i.intersectRayPlane(n);if(o>0){const e=this.constructionPlane.clone();return e.tr=i.pointAtDist(o),e}const a=s.getCamera(),r=a.getGlobalXfo().clone();return r.tr=i.pointAtDist(a.getFocalDistance()),r}createStart(e,t){this.stage=1;}createPoint(e){}createMove(e){}createRelease(e){}onMouseDown(t){if(0==this.stage){if(0==t.button){this.constructionPlane=new e.Xfo;const s=this.screenPosToXfo(t.mousePos,t.viewport);this.createStart(s,this.appData.scene.getRoot());}else 2==t.button&&this.removeToolOnRightClick&&this.appData.toolManager.removeTool(this.index);return !0}return 2!=t.button||(this.appData.undoRedoManager.undo(!1),this.stage=0,!0)}onMouseMove(e){if(this.stage>0){const t=this.screenPosToXfo(e.mousePos,e.viewport);return this.createMove(t.tr),!0}}onMouseUp(e){if(this.stage>0){const t=this.screenPosToXfo(e.mousePos,e.viewport);return this.createRelease(t.tr),!0}}onWheel(e){}onKeyPressed(e,t){}onKeyDown(e,t){}onKeyUp(e,t){}onTouchStart(e){}onTouchMove(e){}onTouchEnd(e){}onTouchCancel(e){}onVRControllerButtonDown(t){if(!this.__activeController){this.__activeController=t.controller,this.constructionPlane=new e.Xfo;const s=this.constructionPlane.clone();s.tr=this.__activeController.getTipXfo().tr,this.createStart(s,this.appData.scene.getRoot());}return !0}onVRPoseChanged(e){if(this.__activeController&&this.stage>0){const e=this.__activeController.getTipXfo();return this.createMove(e.tr),!0}}onVRControllerButtonUp(e){if(this.stage>0&&this.__activeController==e.controller){const e=this.__activeController.getTipXfo();return this.createRelease(e.tr),0==this.stage&&(this.__activeController=void 0),!0}}}class ie extends te{constructor(t,s,i,n){super("Create Line"),this.line=new e.Lines(0),this.line.setNumVertices(2),this.line.setNumSegments(1),this.line.setSegment(0,0,1);const o=new e.Material("Line","LinesShader");o.getParameter("Color").setValue(new e.Color(.7,.2,.2)),this.geomItem=new e.GeomItem("Line"),this.geomItem.setGeometry(this.line),this.geomItem.setMaterial(o),i&&o.getParameter("Color").setValue(i),n&&(this.line.lineThickness=n),t&&s&&this.setParentAndXfo(t,s);}update(e){e.p1&&(this.line.getVertex(1).setFromOther(e.p1),this.line.geomDataChanged.emit()),this.updated.emit(e);}fromJSON(t,s){if(super.fromJSON(t,s),t.color){const s=new e.Color;s.fromJSON(t.color),material.getParameter("Color").setValue(s);}t.thickness&&(this.line.lineThickness=t.thickness);}}o.registerChange("CreateLineChange",ie);class ne extends se{constructor(t){super(t),this.tp=this.addParameter(new e.NumberParameter("Line Thickness",.06,[0,.1]));}createStart(e,t){this.change=new ie(t,e),this.appData.undoRedoManager.addChange(this.change),this.xfo=e.inverse(),this.stage=1,this.length=0;}createMove(e){const t=this.xfo.transformVec3(e);this.length=t.length(),this.change.update({p1:t});}createRelease(e){0==this.length&&this.appData.undoRedoManager.undo(!1),this.stage=0,this.actionFinished.emit();}}class oe extends te{constructor(t,s){super("Create Circle",t),this.circle=new e.Circle(0,64),this.circle.lineThickness=.05;const i=new e.Material("circle","FatLinesShader");i.getParameter("Color").setValue(new e.Color(.7,.2,.2)),this.geomItem=new e.GeomItem("Circle"),this.geomItem.setGeometry(this.circle),this.geomItem.setMaterial(i),t&&s&&this.setParentAndXfo(t,s);}update(e){this.circle.getParameter("Radius").setValue(e.radius),this.updated.emit(e);}toJSON(){const e=super.toJSON();return e.radius=this.circle.getParameter("Radius").getValue(),e}changeFromJSON(e){console.log("CreateCircleChange:",e),e.radius&&this.circle.getParameter("Radius").setValue(e.radius);}}o.registerChange("CreateCircleChange",oe);class ae extends te{constructor(t,s){super("Create Rect"),this.rect=new e.Rect(0,0),this.rect.lineThickness=.05;const i=new e.Material("circle","FatLinesShader");i.getParameter("Color").setValue(new e.Color(.7,.2,.2)),this.geomItem=new e.GeomItem("Rect"),this.geomItem.setGeometry(this.rect),this.geomItem.setMaterial(i),t&&s&&this.setParentAndXfo(t,s);}update(e){if(e.baseSize&&this.rect.setSize(e.baseSize[0],e.baseSize[1]),e.tr){const t=this.geomItem.getParameter("LocalXfo").getValue();t.tr.fromJSON(e.tr),this.geomItem.getParameter("LocalXfo").setValue(t);}this.updated.emit(e);}}o.registerChange("CreateRectChange",ae);class re extends te{constructor(t,s,i,n){super("Create Freehand Line"),this.used=0,this.vertexCount=100,this.line=new e.Lines,this.line.setNumVertices(this.vertexCount),this.line.setNumSegments(this.vertexCount-1),this.line.vertices.setValue(0,new e.Vec3);const o=new e.Material("freeHandLine","FatLinesShader");this.geomItem=new e.GeomItem("freeHandLine"),this.geomItem.setGeometry(this.line),this.geomItem.setMaterial(o),i&&o.getParameter("Color").setValue(i),n&&(this.line.lineThickness=n),t&&s&&this.setParentAndXfo(t,s);}update(e){this.used++;let t=!1;this.used>=this.line.getNumSegments()&&(this.vertexCount=this.vertexCount+100,this.line.setNumVertices(this.vertexCount),this.line.setNumSegments(this.vertexCount-1),t=!0),this.line.vertices.setValue(this.used,e.point),this.line.setSegment(this.used-1,this.used-1,this.used),t?this.line.geomDataTopologyChanged.emit({indicesChanged:!0}):this.line.geomDataChanged.emit({indicesChanged:!0}),this.updated.emit(e);}toJSON(e){const t=super.toJSON(e);return t.lineThickness=this.line.lineThickness,t.color=this.geomItem.getMaterial().getParameter("Color").getValue(),t}fromJSON(t,s){t.lineThickness&&(this.line.lineThickness=t.lineThickness);const i=new e.Color(.7,.2,.2);t.color&&i.fromJSON(t.color),this.geomItem.getMaterial().getParameter("Color").setValue(i),super.fromJSON(t,s);}}o.registerChange("CreateFreehandLineChange",re);class le extends te{constructor(t,s){super("Create Sphere",t),this.sphere=new e.Sphere(0,64,32);const i=new e.Material("Sphere","SimpleSurfaceShader");this.geomItem=new e.GeomItem("Sphere"),this.geomItem.setGeometry(this.sphere),this.geomItem.setMaterial(i),t&&s&&this.setParentAndXfo(t,s);}update(e){this.sphere.radius=e.radius,this.updated.emit(e);}toJSON(){const e=super.toJSON();return e.radius=this.geomItem.getGeometry().radius,e}changeFromJSON(e){e.radius&&(this.geomItem.getGeometry().radius=e.radius);}}o.registerChange("CreateSphereChange",le);class he extends te{constructor(t,s){super("Create Cuboid"),this.cuboid=new e.Cuboid(0,0,0,!0);const i=new e.Material("Cuboid","SimpleSurfaceShader");this.geomItem=new e.GeomItem("Cuboid"),this.geomItem.setGeometry(this.cuboid),this.geomItem.setMaterial(i),t&&s&&this.setParentAndXfo(t,s);}update(e){if(e.baseSize&&this.cuboid.setBaseSize(e.baseSize[0],e.baseSize[1]),e.tr){const t=this.geomItem.getParameter("LocalXfo").getValue();t.tr.fromJSON(e.tr),this.geomItem.getParameter("LocalXfo").setValue(t);}e.height&&(this.cuboid.z=e.height),this.updated.emit(e);}}o.registerChange("CreateCuboidChange",he);class ce extends l{constructor(t,s=.5,i=.02,n=new e.Color(1,1,0)){super(t),this.lengthParam=this.addParameter(new e.NumberParameter("Length",s)),this.handleRadiusParam=this.addParameter(new e.NumberParameter("Handle Radius",i)),this.barRadiusParam=this.addParameter(new e.NumberParameter("Bar Radius",.25*i)),this.colorParam=this.addParameter(new e.ColorParameter("Color",n)),this.hilghlightColorParam=this.addParameter(new e.ColorParameter("Highlight Color",new e.Color(1,1,1))),this.handleMat=new e.Material("handle","FlatSurfaceShader"),this.handleMat.getParameter("BaseColor").setValue(this.colorParam.getValue());const o=new e.Material("topBar","FlatSurfaceShader");o.getParameter("BaseColor").setValue(new e.Color(.5,.5,.5));const a=new e.Cylinder(.25*i,1,64,2,!0,!0),r=new e.Sphere(i,64);this.handle=new e.GeomItem("handle",r,this.handleMat),this.baseBar=new e.GeomItem("baseBar",a,this.handleMat),this.topBar=new e.GeomItem("topBar",a,o),this.handleXfo=new e.Xfo,this.baseBarXfo=new e.Xfo,this.topBarXfo=new e.Xfo,this.barRadiusParam.valueChanged.connect(()=>{a.getParameter("radius").setValue(this.barRadiusParam.getValue());}),this.handleRadiusParam.valueChanged.connect(()=>{r.getParameter("radius").setValue(this.handleRadiusParam.getValue());}),this.lengthParam.valueChanged.connect(()=>{this.__updateSlider(this.value);}),this.colorParam.valueChanged.connect(()=>{this.handleMat.getParameter("BaseColor").setValue(this.colorParam.getValue());}),this.addChild(this.handle),this.addChild(this.baseBar),this.addChild(this.topBar),this.__updateSlider(0);}highlight(){this.handleMat.getParameter("BaseColor").setValue(this.hilghlightColorParam.getValue());}unhighlight(){this.handleMat.getParameter("BaseColor").setValue(this.colorParam.getValue());}setTargetParam(e){this.param=e;const t=()=>{this.__updateSlider(e.getValue());};t(),e.valueChanged.connect(t);}__updateSlider(t){this.value=t;const s=this.param&&this.param.getRange()?this.param.getRange():[0,1],i=Math.remap(t,s[0],s[1],0,1),n=this.lengthParam.getValue();this.baseBarXfo.sc.z=i*n,this.handleXfo.tr.z=i*n,this.topBarXfo.tr.z=i*n,this.topBarXfo.sc.z=(1-i)*n,this.handle.setLocalXfo(this.handleXfo,e.ValueSetMode.GENERATED_VALUE),this.baseBar.setLocalXfo(this.baseBarXfo,e.ValueSetMode.GENERATED_VALUE),this.topBar.setLocalXfo(this.topBarXfo,e.ValueSetMode.GENERATED_VALUE);}onDragStart(t){this.handleXfo.sc.x=this.handleXfo.sc.y=this.handleXfo.sc.z=1.2,this.handle.setLocalXfo(this.handleXfo,e.ValueSetMode.GENERATED_VALUE),this.param&&t.undoRedoManager&&(this.change=new h(this.param),t.undoRedoManager.addChange(this.change));}onDrag(e){const t=this.lengthParam.getValue(),s=this.param&&this.param.getRange()?this.param.getRange():[0,1],i=Math.clamp(Math.remap(e.value,0,t,s[0],s[1]),s[0],s[1]);if(!this.param)return this.__updateSlider(i),void(this.value=i);this.change?this.change.update({value:i}):this.param.setValue(i);}onDragEnd(t){this.change=null,this.handleXfo.sc.x=this.handleXfo.sc.y=this.handleXfo.sc.z=1,this.handle.setLocalXfo(this.handleXfo,e.ValueSetMode.GENERATED_VALUE);}toJSON(e,t=0){const s=super.toJSON(e,t|SAVE_FLAG_SKIP_CHILDREN);return this.param&&(s.targetParam=this.param.getPath()),s}fromJSON(e,t,s){super.fromJSON(e,t,s),e.targetParam&&t.resolvePath(e.targetParam).then(e=>{this.setTargetParam(e);});}}e.sgFactory.registerClass("SliderHandle",ce);class de extends m{constructor(t,s=1,i=1,n=.02,o=new e.Color(1,1,0)){super(t),this.arcRadiusParam=this.addParameter(new e.NumberParameter("Arc Radius",s)),this.arcAngleParam=this.addParameter(new e.NumberParameter("Arc Angle",i)),this.handleRadiusParam=this.addParameter(new e.NumberParameter("Handle Radius",n)),this.colorParam=this.addParameter(new e.ColorParameter("Color",o)),this.hilghlightColorParam=this.addParameter(new e.ColorParameter("Highlight Color",new e.Color(1,1,1))),this.handleMat=new e.Material("handleMat","HandleShader");const a=new e.Circle(s,i,64),r=new e.Sphere(n,64);this.handle=new e.GeomItem("handle",r,this.handleMat),this.arc=new e.GeomItem("arc",a,this.handleMat),this.handleXfo=new e.Xfo,this.handleGeomOffsetXfo=new e.Xfo,this.handleGeomOffsetXfo.tr.x=s,this.handle.getParameter("GeomOffsetXfo").setValue(this.handleGeomOffsetXfo),this.range=[0,i],this.arcAngleParam.valueChanged.connect(()=>{const e=this.arcAngleParam.getValue();a.getParameter("Angle").setValue(e),this.range=[0,e];}),this.arcRadiusParam.valueChanged.connect(()=>{const e=this.arcRadiusParam.getValue();a.getParameter("Radius").setValue(e),this.handleGeomOffsetXfo.tr.x=e,this.handle.getParameter("GeomOffsetXfo").setValue(this.handleGeomOffsetXfo);}),this.handleRadiusParam.valueChanged.connect(()=>{r.getParameter("radius").setValue(this.handleRadiusParam.getValue());}),this.colorParam.valueChanged.connect(()=>{this.handleMat.getParameter("BaseColor").setValue(this.colorParam.getValue());}),this.addChild(this.handle),this.addChild(this.arc),this.setTargetParam(this.handle.getParameter("GlobalXfo"),!1),this.dragStart=new e.Signal,this.dragEnd=new e.Signal;}onMouseEnter(e){e.intersectionData&&e.intersectionData.geomItem==this.handle&&this.highlight();}onMouseLeave(e){this.unhighlight();}onMouseDown(e){e.intersectionData&&e.intersectionData.geomItem==this.handle&&super.onMouseDown(e);}highlight(){this.handleMat.getParameter("BaseColor").setValue(this.hilghlightColorParam.getValue());}unhighlight(){this.handleMat.getParameter("BaseColor").setValue(this.colorParam.getValue());}getBaseXfo(){return this.handle.getParameter("GlobalXfo").getValue()}onDragStart(t){this.baseXfo=this.getGlobalXfo().clone(),this.baseXfo.sc.set(1,1,1),this.deltaXfo=new e.Xfo,this.vec0=this.getGlobalXfo().ori.getXaxis(),this.vec0.normalizeInPlace(),t.undoRedoManager&&(this.change=new h(this.param),t.undoRedoManager.addChange(this.change)),this.handleGeomOffsetXfo.sc.x=this.handleGeomOffsetXfo.sc.y=this.handleGeomOffsetXfo.sc.z=1.2,this.handle.getParameter("GeomOffsetXfo").setValue(this.handleGeomOffsetXfo),this.dragStart.emit();}onDrag(e){const t=e.holdPos.subtract(this.baseXfo.tr);t.normalizeInPlace();let s=this.vec0.angleTo(t);if(this.vec0.cross(t).dot(this.baseXfo.ori.getZaxis())<0&&(s=-s),this.range&&(s=Math.clamp(s,this.range[0],this.range[1])),e.shiftKey){const e=Math.degToRad(22.5);s=Math.floor(s/e)*e;}this.deltaXfo.ori.setFromAxisAndAngle(new Vec3(0,0,1),s);const i=this.baseXfo.multiply(this.deltaXfo);if(this.change)this.change.update({value:i});else {(this.param?this.param:this.getParameter("GlobalXfo")).setValue(i);}}onDragEnd(e){this.change=null,this.handleGeomOffsetXfo.sc.x=this.handleGeomOffsetXfo.sc.y=this.handleGeomOffsetXfo.sc.z=1,this.handle.getParameter("GeomOffsetXfo").setValue(this.handleGeomOffsetXfo),this.dragEnd.emit();}toJSON(e,t=0){const s=super.toJSON(e,t|SAVE_FLAG_SKIP_CHILDREN);return this.param&&(s.targetParam=this.param.getPath()),s}fromJSON(e,t,s){super.fromJSON(e,t,s),e.targetParam&&t.resolvePath(e.targetParam).then(e=>{this.setTargetParam(e);});}}e.sgFactory.registerClass("ArcSlider",de);class me extends HTMLElement{constructor(){super();const e=this.attachShadow({mode:"open"}),t=document.createElement("style");t.appendChild(document.createTextNode(me.css)),e.appendChild(t),this.itemContainer=document.createElement("div"),this.itemHeader=document.createElement("div"),this.itemHeader.className="TreeNodeHeader",this.itemContainer.appendChild(this.itemHeader),this.itemChildren=document.createElement("div"),this.itemChildren.className="TreeNodesList",this.itemContainer.appendChild(this.itemChildren),this.expandBtn=document.createElement("button"),this.expandBtn.className="TreeNodesListItem__ToggleExpanded",this.itemHeader.appendChild(this.expandBtn),this.expanded=!1,this.childrenAlreadyCreated=!1,this.expandBtn.addEventListener("click",()=>{this.treeItem.getNumChildren()>0&&(this.expanded?this.collapse():this.expand());}),this.titleElement=document.createElement("span"),this.titleElement.className="TreeNodesListItem__Title",this.titleElement.addEventListener("click",e=>{this.appData&&this.appData.selectionManager?this.appData.selectionManager.pickingModeActive()?this.appData.selectionManager.pick(this.treeItem):this.appData.selectionManager.toggleItemSelection(this.treeItem,!e.ctrlKey):this.treeItem.setSelected(!this.treeItem.getSelected());}),this.itemHeader.appendChild(this.titleElement),e.appendChild(this.itemContainer);}setTreeItem(t,s){this.treeItem=t,this.appData=s,this.titleElement.textContent=t.getName();this.treeItem.nameChanged.connect(()=>{this.titleElement.textContent=t.getName();}),this.updateSelectedId=this.treeItem.selectedChanged.connect(this.updateSelected.bind(this)),this.updateSelected(),t instanceof e.TreeItem&&(this.toggleVisibilityBtn=document.createElement("button"),this.toggleVisibilityBtn.className="TreeNodesListItem__ToggleVisibility",this.itemHeader.insertBefore(this.toggleVisibilityBtn,this.titleElement),this.toggleVisibilityBtn.innerHTML='<i class="material-icons-outlined md-15">visibility</i>',this.toggleVisibilityBtn.addEventListener("click",()=>{const e=this.treeItem.getParameter("Visible");if(this.appData&&this.appData.undoRedoManager){const t=new ParameterValueChange(e,!e.getValue());this.appData.undoRedoManager.addChange(t);}else e.setValue(!e.getValue());}),this.updateVisibilityId=this.treeItem.visibilityChanged.connect(this.updateVisibility.bind(this)),this.updateVisibility(),this.updateHighlightId=this.treeItem.highlightChanged.connect(this.updateHighlight.bind(this)),this.updateHighlight(),this.treeItem.getChildren().length&&this.collapse(),this.childAddedId=this.treeItem.childAdded.connect(this.childAdded.bind(this)),this.childRemovedId=this.treeItem.childRemoved.connect(this.childRemoved.bind(this)));}updateVisibility(){const e=this.treeItem.getVisible();e?this.itemContainer.classList.remove("TreeNodesListItem--isHidden"):this.itemContainer.classList.add("TreeNodesListItem--isHidden"),this.toggleVisibilityBtn.innerHTML=e?'<i class="material-icons-outlined md-15">visibility</i>':'<i class="material-icons-outlined md-15">visibility_off</i>';}updateSelected(){this.treeItem.getSelected()?this.itemContainer.classList.add("TreeNodesListItem--isSelected"):this.itemContainer.classList.remove("TreeNodesListItem--isSelected");}updateHighlight(){const t=this.treeItem.isHighlighted();if(t?this.itemContainer.classList.add("TreeNodesListItem--isHighlighted"):this.itemContainer.classList.remove("TreeNodesListItem--isHighlighted"),t){const t=this.treeItem.getHighlight(),s=t.lerp(new e.Color(.75,.75,.75,0),.5);this.titleElement.style.setProperty("border-color",t.toHex()),this.titleElement.style.setProperty("background-color",s.toHex());}else this.titleElement.style.removeProperty("border-color"),this.titleElement.style.removeProperty("background-color");}expand(){if(this.expanded=!0,this.itemChildren.classList.remove("TreeNodesList--collapsed"),this.expandBtn.innerHTML='<i class="material-icons md-24">arrow_drop_down</i>',!this.childrenAlreadyCreated){this.treeItem.getChildren().forEach((e,t)=>{this.addChild(e,t);}),this.childrenAlreadyCreated=!0;}}collapse(){this.itemChildren.classList.add("TreeNodesList--collapsed"),this.expandBtn.innerHTML='<i class="material-icons md-24">arrow_right</i>',this.expanded=!1;}addChild(e,t){if(this.expanded){const s=document.createElement("tree-item-view");s.setTreeItem(e,this.appData),t==this.itemChildren.childElementCount?this.itemChildren.appendChild(s):this.itemChildren.insertBefore(s,this.itemChildren.children[t]);}else this.collapse();}childAdded(e,t){this.addChild(e,t);}childRemoved(e,t){this.expanded&&(this.itemChildren.children[t].destroy(),this.itemChildren.removeChild(this.itemChildren.children[t]));}destroy(){this.treeItem.selectedChanged.disconnectId(this.updateSelectedId),this.treeItem instanceof e.TreeItem&&(this.treeItem.highlightChanged.disconnectId(this.updateHighlightId),this.treeItem.visibilityChanged.disconnectId(this.updateVisibilityId),this.treeItem.childAdded.disconnectId(this.childAddedId),this.treeItem.childRemoved.disconnectId(this.childRemovedId));}}me.css="\n  /* tree-view.css */\n\n  ////\n  /// From https://fonts.googleapis.com/icon?family=Material+Icons|Material+Icons+Outlined\n\n  /* fallback */\n  @font-face {\n    font-family: 'Material Icons';\n    font-style: normal;\n    font-weight: 400;\n    src: url(https://fonts.gstatic.com/s/materialicons/v48/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format('woff2');\n  }\n  /* fallback */\n  @font-face {\n    font-family: 'Material Icons Outlined';\n    font-style: normal;\n    font-weight: 400;\n    src: url(https://fonts.gstatic.com/s/materialiconsoutlined/v14/gok-H7zzDkdnRel8-DQ6KAXJ69wP1tGnf4ZGhUce.woff2) format('woff2');\n  }\n\n  .material-icons {\n    font-family: 'Material Icons';\n    font-weight: normal;\n    font-style: normal;\n    font-size: 24px;\n    line-height: 1;\n    letter-spacing: normal;\n    text-transform: none;\n    display: inline-block;\n    white-space: nowrap;\n    word-wrap: normal;\n    direction: ltr;\n    -webkit-font-feature-settings: 'liga';\n    -webkit-font-smoothing: antialiased;\n  }\n\n  .material-icons-outlined {\n    font-family: 'Material Icons Outlined';\n    font-weight: normal;\n    font-style: normal;\n    font-size: 24px;\n    line-height: 1;\n    letter-spacing: normal;\n    text-transform: none;\n    display: inline-block;\n    white-space: nowrap;\n    word-wrap: normal;\n    direction: ltr;\n    -webkit-font-feature-settings: 'liga';\n    -webkit-font-smoothing: antialiased;\n  }\n  .TreeNodesList {\n    border-left: 1px dotted;\n    list-style-type: none;\n    padding: 0 0 0 15px;\n    margin: 0 0 0 10px;\n  }\n\n  .TreeNodesList--collapsed {\n    display: none;\n  }\n\n  .TreeNodesList--root {\n    border: none;\n    margin: 0;\n    padding: 0;\n    width: max-content;\n  }\n\n  .TreeNodesListItem{\n    display: flex;\n  }\n\n  .TreeNodesListItem__ToggleVisibility {\n    border: none;\n    color: #333;\n    height: 24px;\n    padding: 0;\n    width: 25px;\n  }\n\n  .TreeNodesListItem__ToggleVisibility:focus {\n    outline: none;\n  }\n\n  .TreeNodesListItem__ToggleExpanded {\n    border: none;\n    height: 24px;\n    width: 24px;\n    padding: 0;\n    background-color: #0000;\n    outline: none;\n  }\n\n  .TreeNodesListItem::before {\n    border-bottom: 1px dotted;\n    content: '';\n    display: inline-block;\n    left: -15px;\n    position: relative;\n    top: -5px;\n    width: 10px;\n  }\n\n  .TreeNodesListItem__Toggle:focus {\n    outline: none;\n  }\n\n  .TreeNodeHeader{\n    display: flex;\n    margin: 0.4em auto;\n  }\n\n  .TreeNodesListItem__Title {\n    cursor: default;\n    padding: 2px 4px;\n    border-radius: 5px;\n  }\n\n  .TreeNodesListItem__Title:hover {\n    background-color: #e1f5fe;\n  }\n  .TreeNodesListItem__Hover {\n    background-color: #e1f5fe;\n  }\n\n  .TreeNodesListItem__Dragging {\n    background-color: #e1f5fe;\n  }\n\n  .TreeNodesListItem--isSelected > .TreeNodeHeader > .TreeNodesListItem__Title {\n    background-color: #76d2bb;\n    color: #3B3B3B;\n  }\n\n  .TreeNodesListItem--isHidden > .TreeNodeHeader >  .TreeNodesListItem__Title {\n    color: #9e9e9e;\n  }\n\n  .TreeNodesListItem--isHighlighted > .TreeNodeHeader >  .TreeNodesListItem__Title {\n    border-style: solid;\n    border-width: thin;\n  }\n\n  /* Rules for sizing the icon. */\n  .material-icons-outlined.md-15,\n  .material-icons.md-15 {\n    font-size: 15px;\n  }\n  .material-icons.md-18 {\n    font-size: 18px;\n  }\n  .material-icons.md-24 {\n    font-size: 24px;\n  }\n  .material-icons.md-36 {\n    font-size: 36px;\n  }\n  .material-icons.md-48 {\n    font-size: 48px;\n  }\n\n  /* Rules for using icons as black on a light background. */\n  .material-icons.md-dark {\n    color: rgba(0, 0, 0, 0.54);\n  }\n  .material-icons.md-dark.md-inactive {\n    color: rgba(0, 0, 0, 0.26);\n  }\n\n  /* Rules for using icons as white on a dark background. */\n  .material-icons.md-light {\n    color: rgba(255, 255, 255, 1);\n  }\n  .material-icons.md-light.md-inactive {\n    color: rgba(255, 255, 255, 0.3);\n  }\n\n  ";customElements.get("tree-item-view")||customElements.define("tree-item-view",me);class ue extends HTMLElement{constructor(){super();const e=this.attachShadow({mode:"open"});this.treeContainer=document.createElement("div"),e.appendChild(this.treeContainer),this.treeItemView=document.createElement("tree-item-view");const t=new CSSStyleSheet;t.replaceSync("@font-face {\n      font-family: \"Material Icons\";\n      font-style: normal;\n      font-weight: 400;\n      src: url('https://fonts.gstatic.com/s/materialicons/v48/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2') format('woff');\n    }");const s=new CSSStyleSheet;s.replaceSync("@font-face {\n      font-family: \"Material Icons Outlined\";\n      font-style: normal;\n      font-weight: 400;\n      src: url('https://fonts.gstatic.com/s/materialiconsoutlined/v14/gok-H7zzDkdnRel8-DQ6KAXJ69wP1tGnf4ZGhUce.woff2') format('woff');\n    }"),document.adoptedStyleSheets=[...document.adoptedStyleSheets,t,s];}setTreeItem(e,t){this.treeItemView.setTreeItem(e,t),this.treeContainer.appendChild(this.treeItemView);}}customElements.get("scene-tree-view")||customElements.define("scene-tree-view",ue),exports.ActionRegistry=class{constructor(){this.actions=[],this.actionAdded=new e.Signal;}registerAction(e){const{name:t}=e;t?this._addAction(e):console.warn("A action is missing its name.");}_addAction(e){this.actions.push(e),this.actionAdded.emit(e);}getActions(){return this.actions}},exports.ActionTreeView=class{constructor(e){this.actionRegistry=e,this.__existingItems={};const t=document.createElement("div");document.body.appendChild(t);const s=this._addUlTo(t,"pure-menu-list");this.actionRegistry.getActions().forEach(e=>{1==e.availableInVR&&this._addMenuItem(s,e);}),this.actionRegistry.actionAdded.connect(e=>{1==e.availableInVR&&this._addMenuItem(s,e);});}_addSpanTo(e,t,s){const i=document.createElement("span");return i.className=t,s&&(i.innerHTML=s),e.appendChild(i),i}_addMenuItem(e,t){const s=document.createElement("a");s.href="#";const i="pure-menu-link VRUIElement";let n=!1;return s.className=i,s.addEventListener("mouseenter",e=>{n||(s.className=i+" HighlightedMenu");}),s.addEventListener("mouseleave",e=>{s.className=n?i+" ActionedMenu":i;}),t.activatedChanged?t.activatedChanged.connect(e=>{s.className=e?i+" ActionedMenu":i,n=e;}):(s.addEventListener("mousedown",e=>{s.className=i+" ActionedMenu";}),s.addEventListener("mouseup",e=>{s.className=i+" HighlightedMenu";})),t.callback&&s.addEventListener("click",e=>{e.preventDefault(),t.callback();}),e.appendChild(s),this._addSpanTo(s,"ActionTitle",t.name),s}_addUlTo(e,t,s){const i=document.createElement("ul");return i.className=t,s&&(i.innerHTML=s),e.appendChild(i),i}_addLiTo(e,t,s){const i=document.createElement("li");return i.className=t,s&&(i.innerHTML=s),e.appendChild(i),i}},exports.ArcSlider=de,exports.AxialRotationHandle=u,exports.Change=a,exports.CollabPanel=class{constructor(t){this.userSelected=new e.Signal,this.session=t;}mount(e){e.innerHTML='\n      <div class="ba b--light-blue br2 pa2 h4 overflow-y-auto mb2">\n        <ul id="userChips" class="list pa0 ma0"></ul>\n      </div>\n      <div class="ba b--light-blue br2 pa2 h5 overflow-y-auto mb2" id="receivedMessages"></div>\n\n      <form autocomplete="off" name="formSendMessage">\n        <div class="mb2 flex">\n          <input class="w-100 mr1" name="messageToSend" required type="text">\n          <button class="pure-button">\n            <i class="material-icons f4">send</i>\n          </button>\n        </div>\n      </form>\n\n      <div class="btn-group">\n        <button class="pure-button AudioButton" disabled id="toggleMic">\n          <i class="material-icons">mic</i>\n        </button>\n\n        <button class="pure-button CameraButton" disabled id="toggleCam">\n          <i class="material-icons">videocam</i>\n        </button>\n      </div>\n      \x3c!--\n      <form class="pure-form pure-form-aligned" name="formCreateRoom">\n        <legend>Create Room</legend>\n        <fieldset>\n          <div class="pure-control-group">\n            <label for="roomId">Room ID</label>\n            <input name="roomId" disabled type="text">\n            <button class="pure-button" disabled type="button">\n              <i class="material-icons f4">file_copy</i>\n            </button>\n          </div>\n        </fieldset>\n      </form>\n\n      <form class="pure-form pure-form-aligned" name="formJoinRoom">\n        <legend>Join Room</legend>\n        <fieldset>\n          <div class="pure-control-group">\n            <label for="roomId">Room ID</label>\n            <input name="roomId" type="text">\n          </div>\n        </fieldset>\n        <div class="flex justify-center">\n          <button class="pure-button pure-button-primary">\n            Join Room\n          </button>\n        </div>\n      </form>\n      --!>\n      <div class="btn-group tc">\n        <button class="pure-button pure-button-primary ma2" disabled>\n          Create Room\n        </button>\n        <button class="pure-button pure-button-primary ma0" disabled>\n          Join Room\n        </button>\n      </div>\n    ';const s=document.getElementById("userChips"),i=document.getElementById("receivedMessages"),n=document.getElementById("toggleMic");let o=!1;n.addEventListener("click",e=>{o?(this.session.muteAudio(),n.classList.remove("AudioButton--on"),o=!1):(this.session.unmuteAudio(),n.classList.add("AudioButton--on"),o=!0);});const a=document.getElementById("toggleCam");let r=!1;a.addEventListener("click",e=>{r?(this.session.stopCamera(),a.classList.remove("CameraButton--on"),r=!1):(this.session.startCamera(),a.classList.add("CameraButton--on"),r=!0);});const l=(e,t)=>{const s=document.createElement("p");s.innerHTML=`<strong>${e}:</strong> ${t}`,i.appendChild(s),i.scrollTop=i.scrollHeight;};document.formSendMessage.addEventListener("submit",e=>{const s=e.target;l("Me",s.messageToSend.value),this.session.pub(t.Session.actions.TEXT_MESSAGE,{text:s.messageToSend.value}),e.preventDefault(),s.reset();}),this.session.sub(t.Session.actions.TEXT_MESSAGE,(e,t)=>{const s=this.session.getUser(t);l(s.given_name,e.text);});const h={},c=e=>{const t=document.createElement("p");t.innerHTML=`<strong>(${e.name} has joined)</strong>`,i.appendChild(t),i.scrollTop=i.scrollHeight;const n=document.createElement("li");s.appendChild(n),new L(n,e).userSelected.connect(e=>{this.userSelected.emit(e);}),h[e.id]=n;},d=e=>{const t=document.createElement("p");t.innerHTML=`<strong>(${e.name} has left)</strong>`,i.appendChild(t),i.scrollTop=i.scrollHeight,s.removeChild(h[e.id]);};this.session.sub(t.Session.actions.USER_JOINED,(e,t)=>{c(e);}),this.session.sub(t.Session.actions.USER_LEFT,(e,t)=>{d(e);}),this.session.sub(t.Session.actions.LEFT_ROOM,()=>{const e=this.session.getUsers();for(const t in e)d(e[t]);i.innerHTML="";});const m=this.session.getUsers();for(const e in m)c(m[e]);}unMount(e){}},exports.CreateCircleTool=class extends se{constructor(e){super(e);}createStart(e,t){this.change=new oe(t,e),this.appData.undoRedoManager.addChange(this.change),this.xfo=e,this.stage=1,this.radius=0;}createMove(e){this.radius=e.distanceTo(this.xfo.tr),this.change.update({radius:this.radius});}createRelease(e){0==this.radius&&this.appData.undoRedoManager.undo(!1),this.change=null,this.stage=0,this.actionFinished.emit();}},exports.CreateCuboidTool=class extends se{constructor(e){super(e);}createStart(e,t){this.change=new he(t,e),this.appData.undoRedoManager.addChange(this.change),this.xfo=e,this.invxfo=e.inverse(),this.stage=1,this._height=0;}createMove(e){if(1==this.stage){const t=this.invxfo.transformVec3(e);this.change.update({baseSize:[Math.abs(t.x),Math.abs(t.y)],tr:this.xfo.tr.add(t.scale(.5))});}else {const t=this.invxfo.transformVec3(e);this.change.update({height:t.y});}}createRelease(t,s){if(1==this.stage){this.stage=2,this.pt1=t;const s=new e.Quat;s.setFromAxisAndAngle(new e.Vec3(1,0,0),.5*Math.PI),this.constructionPlane.ori=this.constructionPlane.ori.multiply(s),this.constructionPlane.tr=t,this.invxfo=this.constructionPlane.inverse();}else 2==this.stage&&(this.stage=0,this.actionFinished.emit());}},exports.CreateFreehandLineTool=class extends ne{constructor(t){super(t),this.mp=this.addParameter(new e.BooleanParameter("Modulate Thickness By Stroke Speed",!1));}createStart(e,t){const s=this.cp.getValue(),i=this.tp.getValue();this.change=new re(t,e,s,i),this.appData.undoRedoManager.addChange(this.change),this.xfo=e,this.invxfo=e.inverse(),this.stage=1,this.prevP=e.tr,this.length=0;}createMove(e){const t=this.invxfo.transformVec3(e),s=t.subtract(this.prevP).length();s>.001&&this.change.update({point:t}),this.length+=s,this.prevP=t;}createRelease(e){0==this.length&&this.appData.undoRedoManager.undo(!1),this.stage=0,this.actionFinished.emit();}},exports.CreateLineTool=ne,exports.CreateRectTool=class extends se{constructor(e){super(e);}createStart(e,t){this.change=new ae(t,e),this.appData.undoRedoManager.addChange(this.change),this.xfo=e,this.invxfo=e.inverse(),this.stage=1,this._size=0;}createMove(e){if(1==this.stage){const t=this.invxfo.transformVec3(e);this._size=Math.abs(t.x),this.change.update({baseSize:[Math.abs(t.x),Math.abs(t.y)],tr:this.xfo.tr.add(t.scale(.5))});}else {const t=this.invxfo.transformVec3(e);this.change.update({height:t.y});}}createRelease(e,t){0==this._size&&this.appData.undoRedoManager.undo(!1),this.stage=0,this.actionFinished.emit();}},exports.CreateSphereTool=class extends se{constructor(e){super(e);}createStart(e,t){this.change=new le(t,e),this.appData.undoRedoManager.addChange(this.change),this.xfo=e,this.stage=1,this.radius=0;}createMove(e){this.radius=e.distanceTo(this.xfo.tr),this.change.update({radius:this.radius});}createRelease(e){0==this.radius&&this.appData.undoRedoManager.undo(!1),this.stage=0,this.actionFinished.emit();}},exports.HandleTool=class extends O{constructor(e){super(e),this.activeHandle=void 0,this.capturedItems=[],this.mouseOverItems=[];}activateTool(){super.activateTool(),console.log("activateTool.HandleTool"),this.appData.renderer.getDiv().style.cursor="crosshair";const t=t=>{if(!this.__activated)return;const s=new e.Sphere(.015),i=new e.Material("Cross","FlatSurfaceShader");i.getParameter("BaseColor").setValue(new e.Color("#03E3AC")),i.visibleInGeomDataBuffer=!1;const n=new e.GeomItem("HandleToolTip",s,i);t.getTipItem().removeAllChildren(),t.getTipItem().addChild(n,!1);},s=e=>{for(const s of e.getControllers())t(s);this.addIconToControllerId=e.controllerAdded.connect(t);};this.appData.renderer.getXRViewport().then(e=>{s(e);});}deactivateTool(){super.deactivateTool(),this.appData.renderer.getXRViewport().then(e=>{e.controllerAdded.disconnectId(this.addIconToControllerId);});}onMouseDown(e){if(!this.activeHandle){const t=e.viewport.getGeomDataAtPos(e.mousePos);if(null==t)return;if(t.geomItem.getOwner()instanceof r)return this.activeHandle=t.geomItem.getOwner(),this.activeHandle.handleMouseDown(Object.assign(e,{intersectionData:t})),!0}}onMouseMove(e){if(this.activeHandle)return this.activeHandle.handleMouseMove(e),!0;{if(0==e.button&&1==e.buttons)return !1;const t=e.viewport.getGeomDataAtPos(e.mousePos);if(null!=t&&t.geomItem.getOwner()instanceof r){const e=t.geomItem.getOwner();return this.__highlightedHandle&&this.__highlightedHandle.unhighlight(),this.__highlightedHandle=e,this.__highlightedHandle.highlight(),!0}this.__highlightedHandle&&(this.__highlightedHandle.unhighlight(),this.__highlightedHandle=void 0);}}onMouseUp(e){if(this.activeHandle)return this.activeHandle.handleMouseUp(e),this.activeHandle=void 0,!0}onWheel(e){this.activeHandle&&this.activeHandle.onWheel(e);}onTouchStart(e){}onTouchMove(e){}onTouchEnd(e){}onTouchCancel(e){}__prepareVREvent(e){const t=e.controller.getId();e.setCapture=e=>{this.capturedItems[t]=e;},e.getCapture=()=>this.capturedItems[t],e.releaseCapture=()=>{this.capturedItems[t]=null;};}onVRControllerButtonDown(e){const t=e.controller.getId();if(this.capturedItems[t])this.__prepareVREvent(e),this.capturedItems[t].onMouseDown(e);else {const t=e.controller.getGeomItemAtTip();null!=t&&(e.intersectionData=t,e.geomItem=t.geomItem,this.__prepareVREvent(e),t.geomItem.onMouseDown(e));}}onVRPoseChanged(e){for(const t of e.controllers){const s=t.getId();if(this.capturedItems[s])this.capturedItems[s].onMouseMove(e);else {const i=t.getGeomItemAtTip();null!=i?(e.intersectionData=i,e.geomItem=i.geomItem,i.geomItem!=this.mouseOverItems[s]&&(this.mouseOverItems[s]&&this.mouseOverItems[s].onMouseLeave(e),this.mouseOverItems[s]=i.geomItem,this.mouseOverItems[s].onMouseEnter(e)),i.geomItem.onMouseMove(e)):this.mouseOverItems[s]&&(this.mouseOverItems[s].onMouseLeave(e),this.mouseOverItems[s]=null);}}}onVRControllerButtonUp(e){this.__prepareVREvent(e);const t=e.controller.getId();if(this.capturedItems[t])this.capturedItems[t].onMouseUp(e);else {const t=e.controller.getGeomItemAtTip();null!=t&&(e.intersectionData=t,e.geomItem=t.geomItem,t.geomItem.onMouseUp(e));}}},exports.InspectorContainer=class{constructor(e){this.appData=e,this.pinned=!1;}inspect(e){this.inspectedItem=e,this.domElement&&(this.inspector&&(this.inspector.destroy&&this.inspector.destroy(),this.domElement.innerHTML=""),this.inspectedItem&&(this.inspector=V.constructInspector(e,this.domElement,this.appData)));}mount(e){this.parentElement=e;const t=document.createElement("ul");t.className="list pa0 pr3";const s=document.createElement("li"),i=document.createElement("input");i.setAttribute("id","pinned"),i.setAttribute("type","checkbox"),i.setAttribute("tabindex",0),i.checked=this.pinned,i.style.margin="5px",i.addEventListener("input",()=>{this.pinned=i.checked;});const n=document.createElement("label");n.setAttribute("for","pinned"),n.appendChild(document.createTextNode("Pinned")),s.appendChild(n),s.appendChild(i),t.appendChild(s);const o=document.createElement("li");this.domElement=document.createElement("div"),o.appendChild(this.domElement),t.appendChild(o),this.parentElement.appendChild(t),this.domElement.innerHTML="",this.inspectedItem&&this.inspect(this.inspectedItem);const a=this.appData.selectionManager;this._selChangedId=a.leadSelectionChanged.connect(e=>{this.inspectedItem&&this.pinned||this.inspect(e);});}unMount(){this.appData.selectionManager.leadSelectionChanged.disconnectId(this._selChangedId),this.parentElement.innerHTML="";}},exports.LinearMovementHandle=c,exports.OpenVRUITool=class extends O{constructor(e,t){super(e),this.vrUITool=t,this.uiToolIndex=-1,this.__stayClosed=!1;}uninstall(){super.uninstall(),this.uiToolIndex>0&&this.appData.toolManager.removeToolByHandle(this.vrUITool);}onVRControllerButtonDown(e){}onVRControllerButtonUp(e){}stayClosed(){this.__stayClosed=!0;}onVRPoseChanged(e){if(this.vrUITool.installed())return;const t=e.viewXfo,s=(e,s)=>{if(!e)return !1;const i=e.getTreeItem().getGlobalXfo(),n=i.tr.subtract(t.tr);return n.normalizeInPlace(),n.angleTo(i.ori.getYaxis())<.25*Math.PI?(this.__stayClosed||(this.vrUITool.setUIControllers(this,e,s,t),this.uiToolIndex=this.appData.toolManager.pushTool(this.vrUITool)),!0):void 0};if(e.controllers.length>0){if(s(e.controllers[0],e.controllers[1]))return !0;if(s(e.controllers[1],e.controllers[0]))return !0}this.uiToolIndex=-1,this.__stayClosed=!1;}},exports.Panels=class{constructor(e,t){this.options=t||{},e&&this.mount(e);}mount(e){this.sidePanelsWrapper=document.createElement("div"),this.sidePanelsWrapper.className="PanelsWrapper flex overflow-hidden",e.appendChild(this.sidePanelsWrapper),1==this.options.leftPanel&&(this.leftPanel=new k(0),this.leftPanel.mount(this.sidePanelsWrapper)),this.centerDomElement=document.createElement("div"),this.centerDomElement.className="PanelsCenter flex-grow-1 overflow-hidden",this.centerDomElement.id="viewport",this.sidePanelsWrapper.appendChild(this.centerDomElement),1==this.options.rightPanel&&(this.rightPanel=new k(1),this.rightPanel.mount(this.sidePanelsWrapper)),1==this.options.bottomPanel&&(this.bottomPanel=new G,this.bottomPanel.mount(e));}unMount(e){}},exports.ParameterContainer=X,exports.ParameterValueChange=h,exports.PlanarMovementHandle=d,exports.PublishDialog=class{constructor(){this.__publishDialogHolder=document.createElement("div"),this.__publishDialogHolder.className="publish-dialog-bg",this.__publishDialogHolder.addEventListener("mousedown",e=>{e.target==this.__publishDialogHolder&&this.hide();});const e=document.createElement("div");e.className="publish-dialog";const t=new URLSearchParams(window.location.search),s=new URLSearchParams;t.forEach((function(e,t){t.startsWith("room-id")||s.set(t,e);})),s.set("published",!0);const i=`${window.location.origin}?${s.toString()}`,n=document.createElement("div");n.className="publicToggle",n.className="publish-dialog-toggle";const o=document.createElement("input");o.setAttribute("type","checkbox"),o.setAttribute("is","isPublicCheckbox"),o.value=i,o.addEventListener("change",e=>{l.disabled=!o.checked,r.disabled=!o.checked;}),n.appendChild(o);const a=document.createElement("label");a.className="publish-dialog-label",a.setAttribute("type","checkbox"),a.setAttribute("for","isPublicCheckbox"),a.textContent="Is Published",n.appendChild(a),e.appendChild(n);const r=document.createElement("textarea");r.className="embedcode",r.className="publish-dialog-link",r.setAttribute("rows",2),r.setAttribute("cols",30),r.setAttribute("readonly","readonly"),r.value=i,r.disabled=!0,e.appendChild(r);const l=document.createElement("textarea");l.className="embedcode",l.className="publish-dialog-embedcode",l.setAttribute("rows",5),l.setAttribute("cols",30),l.setAttribute("readonly","readonly"),l.disabled=!0,l.value=`<iframe src="${i}" width="640" height="360" frameborder="0" allow="webvr;webxr;fullscreen" allowfullscreen></iframe>`,e.appendChild(l);const h=document.createElement("button");h.appendChild(document.createTextNode("Generate SCORM Package")),h.addEventListener("click",e=>{}),h.style.margin="2px",e.appendChild(h),this.__publishDialogHolder.appendChild(e),document.body.appendChild(this.__publishDialogHolder),this.visible=!1;}show(){this.__publishDialogHolder.style.display="block",this.visible=!0;}hide(){this.__publishDialogHolder.style.display="none",this.visible=!1;}},exports.SceneTreeView=ue,exports.ScreenSpaceMovementHandle=class extends r{constructor(e){super(e);}setTargetParam(e,t=!0){if(this.param=e,t){const t=()=>{this.setGlobalXfo(e.getValue());};t(),e.valueChanged.connect(t);}}getTargetParam(){return this.param?this.param:this.getParameter("GlobalXfo")}handleMouseDown(t){this.gizmoRay=new e.Ray,this.gizmoRay.dir=t.mouseRay.dir.negate();const s=this.getTargetParam().getValue();this.gizmoRay.pos=s.tr;const i=t.mouseRay.intersectRayPlane(this.gizmoRay);return t.grabPos=t.mouseRay.pointAtDist(i),this.onDragStart(t),!0}handleMouseMove(e){const t=e.mouseRay.intersectRayPlane(this.gizmoRay);return e.holdPos=e.mouseRay.pointAtDist(t),this.onDrag(e),!0}handleMouseUp(e){const t=e.mouseRay.intersectRayPlane(this.gizmoRay);return e.releasePos=e.mouseRay.pointAtDist(t),this.onDragEnd(e),!0}onDragStart(e){this.grabPos=e.grabPos;const t=this.getTargetParam();this.baseXfo=t.getValue(),e.undoRedoManager&&(this.change=new h(t),e.undoRedoManager.addChange(this.change));}onDrag(e){const t=e.holdPos.subtract(this.grabPos),s=this.baseXfo.clone();if(s.tr.addInPlace(t),this.change)this.change.update({value:s});else {this.getTargetParam().setValue(s);}}onDragEnd(e){this.change=null;}},exports.SelectionManager=I,exports.SelectionTool=H,exports.SessionSync=class{constructor(s,i,n,a){const r={};s.sub(t.Session.actions.USER_JOINED,e=>{e.id in r||(r[e.id]={undoRedoManager:new o,avatar:new P(i,e),selectionManager:new I(i,{...a,enableXfoHandles:!1,setItemsSelected:!1})});}),s.sub(t.Session.actions.USER_LEFT,e=>{r[e.id]?(r[e.id].avatar.destroy(),delete r[e.id]):console.warn("User id not in session:",e.id);}),s.sub(t.Session.actions.USER_VIDEO_STARTED,(e,t)=>{if(!r[t])return void console.warn("User id not in session:",t);const i=s.getVideoStream(t);i&&r[t].avatar.attachRTCStream(i);}),s.sub(t.Session.actions.USER_VIDEO_STOPPED,(e,t)=>{r[t]?(console.log("USER_VIDEO_STOPPED:",t," us:",n.id),r[t].avatar&&r[t].avatar.detachRTCStream(s.getVideoStream(t))):console.warn("User id not in session:",t);}),i.toolManager.movePointer.connect(e=>{const i=e.viewport.getGeomDataAtPos(e.mousePos,e.mouseRay),n=i?i.dist:5,o={interfaceType:"CameraAndPointer",movePointer:{start:e.mouseRay.start,dir:e.mouseRay.dir,length:n}};s.pub(t.Session.actions.POSE_CHANGED,T(o));}),i.toolManager.hidePointer.connect(e=>{s.pub(t.Session.actions.POSE_CHANGED,{interfaceType:"CameraAndPointer",hidePointer:{}});}),i.toolManager.hilightPointer.connect(e=>{s.pub(t.Session.actions.POSE_CHANGED,{interfaceType:"CameraAndPointer",hilightPointer:{}});}),i.toolManager.unhilightPointer.connect(e=>{s.pub(t.Session.actions.POSE_CHANGED,T({interfaceType:"CameraAndPointer",unhilightPointer:{}}));});let l=0;i.renderer.viewChanged.connect(e=>{l++;const i="VR"==e.interfaceType;if(i&&l%2!=0)return;const n={interfaceType:e.interfaceType,viewXfo:e.viewXfo};if(e.focalDistance)n.focalDistance=e.focalDistance;else if(i){n.controllers=[];for(const t of e.controllers)n.controllers.push({xfo:t.getTreeItem().getGlobalXfo()});}s.pub(t.Session.actions.POSE_CHANGED,T(n));}),s.sub(t.Session.actions.POSE_CHANGED,(e,t)=>{if(!r[t])return void console.warn("User id not in session:",t);const s=E(e,i.scene);r[t].avatar.updatePose(s);}),s.pub(t.Session.actions.POSE_CHANGED,T({interfaceType:"CameraAndPointer",viewXfo:i.renderer.getViewport().getCamera().getGlobalXfo()}));const h=i.scene.getRoot();i.undoRedoManager.changeAdded.connect(e=>{const n={appData:i,makeRelative:e=>e,resolvePath:(e,t)=>{if(!e)throw "Path not spcecified";const s=h.resolvePath(e);s?t(s):console.warn("Path unable to be resolved:"+e);}},a={changeData:e.toJSON(n),changeClass:o.getChangeClassName(e)};s.pub(t.Session.actions.COMMAND_ADDED,a);}),i.undoRedoManager.changeUpdated.connect(e=>{const i=T(e);s.pub(t.Session.actions.COMMAND_UPDATED,i);}),s.sub(t.Session.actions.COMMAND_ADDED,(e,t)=>{if(!r[t])return void console.warn("User id not in session:",t);const s=r[t].undoRedoManager,n=s.constructChange(e.changeClass),o={appData:{selectionManager:r[t].selectionManager,scene:i.scene}};n.fromJSON(e.changeData,o),s.addChange(n);}),s.sub(t.Session.actions.COMMAND_UPDATED,(e,t)=>{if(!r[t])return void console.warn("User id not in session:",t);const s=r[t].undoRedoManager,n=E(e,i.scene);s.getCurrentChange().update(n);}),i.undoRedoManager.changeUndone.connect(()=>{s.pub("UndoRedoManager_changeUndone",{});}),s.sub("UndoRedoManager_changeUndone",(e,t)=>{r[t].undoRedoManager.undo();}),i.undoRedoManager.changeRedone.connect(()=>{s.pub("UndoRedoManager_changeRedone",{});}),s.sub("UndoRedoManager_changeRedone",(e,t)=>{r[t].undoRedoManager.redo();}),e.sgFactory.registerCallback("StateMachine",e=>{e.stateChanged.connect(t=>{s.pub("StateMachine_stateChanged",{stateMachine:e.getPath(),stateName:t});});}),s.sub("StateMachine_stateChanged",(e,t)=>{i.scene.getRoot().resolvePath(e.stateMachine,1).activateState(e.stateName);});}},exports.SliderHandle=ce,exports.ToolAction=class extends class{constructor(e,t,s=!1){this.name=e,this.path=t,this.availableInVR=s,this.callback=this.callback.bind(this);}callback(){}}{constructor(t,s,i,n,o){super(t,s,i),this.toolManager=n,this.tool=o,this.state=!1,this.activatedChanged=new e.Signal,o.installChanged.connect(e=>{this.activatedChanged.emit(e);});}callback(){if(this.tool.installed())this.toolManager.removeToolByHandle(this.tool);else {const e=this.toolManager.currTool();"VRUITool"==e.getName()?this.toolManager.insertToolBefore(this.tool,e):e.isPrimaryTool()?this.toolManager.replaceCurrentTool(this.tool):this.toolManager.pushTool(this.tool);}}},exports.ToolManager=class{constructor(t){this.__toolStack=[],this.appData=t,this.movePointer=new e.Signal,this.hilightPointer=new e.Signal,this.unhilightPointer=new e.Signal,this.hidePointer=new e.Signal,this.avatarPointerVisible=!1,this.avatarPointerHighlighted=!1;}insertTool(e,t){this.__toolStack.splice(t,0,e),e.install(t);}insertToolBefore(e,t){const s=this.__toolStack.indexOf(t)+1;return this.__toolStack.splice(s-1,0,e),e.install(s),s}insertToolAfter(e,t){const s=this.__toolStack.indexOf(t)+1;return this.__toolStack.splice(s,0,e),e.install(s),s==this.__toolStack.length&&e.activateTool(),s}getToolIndex(e){return this.__toolStack.indexOf(e)}removeTool(e){const t=this.__toolStack[e];if(this.__toolStack.splice(e,1),t.uninstall(),e==this.__toolStack.length){t.deactivateTool();const e=this.currTool();e?e.activateTool():this.appData.renderer.getDiv().style.cursor="pointer";}}removeToolByHandle(e){this.removeTool(this.getToolIndex(e));}pushTool(e){const t=this.currTool();if(t){if(e==t)return void console.warn("Tool Already Pushed on the stack:",e.constructor.name);t.deactivateTool();}return this.__toolStack.push(e),e.install(this.__toolStack.length-1),e.activateTool(),console.log("ToolManager.pushTool:",e.constructor.name),this.__toolStack.length-1}__removeCurrTool(){if(this.__toolStack.length>0){const e=this.__toolStack.pop();e.deactivateTool(),e.uninstall();}}popTool(){this.__removeCurrTool();const e=this.currTool();e&&e.activateTool();}replaceCurrentTool(e){this.__removeCurrTool(),this.__toolStack.push(e),e.install(this.__toolStack.length-1),e.activateTool();}currTool(){return this.__toolStack[this.__toolStack.length-1]}currToolName(){return this.__toolStack[this.__toolStack.length-1].getName()}bind(e){const t=e.getViewport();this.mouseDownId=t.mouseDown.connect(this.onMouseDown.bind(this)),this.mouseMoveId=t.mouseMove.connect(this.onMouseMove.bind(this)),this.mouseUpId=t.mouseUp.connect(this.onMouseUp.bind(this)),this.mouseLeaveId=t.mouseLeave.connect(this.onMouseLeave.bind(this)),this.mouseDoubleClickedId=t.mouseDoubleClicked.connect(this.onDoubleClick.bind(this)),this.mouseWheelId=t.mouseWheel.connect(this.onWheel.bind(this)),this.keyDownId=t.keyDown.connect(this.onKeyDown.bind(this)),this.keyUpId=t.keyUp.connect(this.onKeyUp.bind(this)),this.keyPressedId=t.keyPressed.connect(this.onKeyPressed.bind(this)),this.touchStartId=t.touchStart.connect(this.onTouchStart.bind(this)),this.touchMoveId=t.touchMove.connect(this.onTouchMove.bind(this)),this.touchEndId=t.touchEnd.connect(this.onTouchEnd.bind(this)),this.touchCancelId=t.touchCancel.connect(this.onTouchCancel.bind(this)),this.doubleTappedId=t.doubleTapped.connect(this.onDoubleTap.bind(this)),this.appData.renderer.getXRViewport().then(e=>{this.controllerDownId=e.controllerButtonDown.connect(this.onVRControllerButtonDown.bind(this)),this.controllerUpId=e.controllerButtonUp.connect(this.onVRControllerButtonUp.bind(this)),this.controllerDoubleClickId=e.controllerDoubleClicked.connect(this.onVRControllerDoubleClicked.bind(this)),this.onVRPoseChangedId=e.viewChanged.connect(this.onVRPoseChanged.bind(this));});}onMouseDown(e){e.undoRedoManager=this.appData.undoRedoManager,e.showPointerOnAvatar=!0;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onMouseDown(e))break}1==e.showPointerOnAvatar?(this.avatarPointerVisible||(this.movePointer.emit(e),this.avatarPointerVisible=!0),this.avatarPointerHighlighted||(this.hilightPointer.emit(e),this.avatarPointerHighlighted=!0)):this.avatarPointerVisible&&(this.avatarPointerVisible=!1,this.hidePointer.emit());}onMouseMove(e){e.undoRedoManager=this.appData.undoRedoManager,e.showPointerOnAvatar=!0;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onMouseMove(e))break}1==e.showPointerOnAvatar?(this.movePointer.emit(e),this.avatarPointerVisible=!0):this.avatarPointerVisible&&(this.avatarPointerVisible=!1,this.hidePointer.emit());}onMouseUp(e){e.undoRedoManager=this.appData.undoRedoManager,e.showPointerOnAvatar=!0;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onMouseUp(e))break}1==e.showPointerOnAvatar?this.avatarPointerHighlighted&&(this.unhilightPointer.emit(e),this.avatarPointerHighlighted=!1):this.avatarPointerVisible&&(this.avatarPointerVisible=!1,this.hidePointer.emit());}onMouseLeave(e){let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&s.onMouseLeave&&1==s.onMouseLeave(e))break}this.avatarPointerVisible&&(this.avatarPointerVisible=!1,this.hidePointer.emit());}onDoubleClick(e){let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onDoubleClick(e))break}}onWheel(e){e.undoRedoManager=this.appData.undoRedoManager;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onWheel(e))break}}onKeyPressed(e,t){t.undoRedoManager=this.appData.undoRedoManager;let s=this.__toolStack.length;for(;s--;){const e=this.__toolStack[s];if(e&&1==e.onKeyPressed(t,t,viewport))break}}onKeyDown(e,t){t.undoRedoManager=this.appData.undoRedoManager;let s=this.__toolStack.length;for(;s--;){const i=this.__toolStack[s];if(i&&1==i.onKeyDown(e,t))break}}onKeyUp(e,t){t.undoRedoManager=this.appData.undoRedoManager;let s=this.__toolStack.length;for(;s--;){const i=this.__toolStack[s];if(i&&1==i.onKeyUp(e,t))break}}onTouchStart(e){e.undoRedoManager=this.appData.undoRedoManager;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onTouchStart(e))break}}onTouchMove(e){e.undoRedoManager=this.appData.undoRedoManager;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onTouchMove(e))break}}onTouchEnd(e){e.undoRedoManager=this.appData.undoRedoManager;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onTouchEnd(e))break}}onTouchCancel(e){e.undoRedoManager=this.appData.undoRedoManager;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onTouchCancel(e))break}}onDoubleTap(e){e.undoRedoManager=this.appData.undoRedoManager;let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onDoubleTap(e))break}}__prepareEvent(e){e.undoRedoManager=this.appData.undoRedoManager,e.propagating=!0,e.stopPropagation=()=>{e.propagating=!1;};}onVRControllerButtonDown(e){this.__prepareEvent(e);let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onVRControllerButtonDown(e))break;if(!e.propagating)break}}onVRControllerButtonUp(e){this.__prepareEvent(e);let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onVRControllerButtonUp(e))break;if(!e.propagating)break}}onVRControllerDoubleClicked(e){this.__prepareEvent(e);let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onVRControllerDoubleClicked(e))break;if(!e.propagating)break}}onVRPoseChanged(e){this.__prepareEvent(e);let t=this.__toolStack.length;for(;t--;){const s=this.__toolStack[t];if(s&&1==s.onVRPoseChanged(e))break;if(!e.propagating)break}}destroy(){const e=this.appData.renderer.getViewport();e.mouseDown.disconnectId(this.mouseDownId),e.mouseMove.disconnectId(this.mouseMoveId),e.mouseUp.disconnectId(this.mouseUpId),e.mouseLeave.disconnectId(this.mouseUpId),e.mouseWheel.disconnectId(this.mouseWheelId),e.keyDown.disconnectId(this.keyDownId),e.keyUp.disconnectId(this.keyUpId),e.keyPressed.disconnectId(this.keyPressedId),e.touchStart.disconnectId(this.touchStartId),e.touchMove.disconnectId(this.touchMoveId),e.touchEnd.disconnectId(this.touchEndId),e.touchCancel.disconnectId(this.touchCancelId),this.appData.renderer.getXRViewport().then(t=>{e.controllerDown.disconnectId(this.controllerDownId),e.controllerUp.disconnectId(this.controllerUpId),e.viewChanged.disconnectId(this.onVRPoseChangedId);});}},exports.TopMenuBar=class{constructor(e,t,s){this.appData=t;const i=document.createElement("div");if(i.className="HeaderWrapper pa0 bb",e.appendChild(i),s||(this.logo=document.createElement("img"),this.logo.className="Header__logo pl2",this.logo.src="./img/logo.png",i.appendChild(this.logo)),this.topMenuItems=document.createElement("div"),this.topMenuItems.id="TopMenuWrapper",this.topMenuItems.className="pure-menu pure-menu-horizontal ml3",i.appendChild(this.topMenuItems),!s&&t.currentUser){const e=document.createElement("div");i.appendChild(e),this.currentUserChip=new L(e,this.appData.currentUser);}this.__existingItems={},this.__hotkeysToActions={},this._buildTopBar(),this._addKeyListener();}_buildTopBar(){this.topMenuItems.innerHTML="";const e=this._addUlTo(this.topMenuItems,"pure-menu-list");this.appData.actionRegistry.getActions().forEach(t=>{this._addMenuItem(e,t);}),this.appData.actionRegistry.actionAdded.connect(t=>{this._addMenuItem(e,t);});}_addMenuItem(e,t){let s=e;for(let e=0;e<t.path.length;e++){const i=t.path[e];if(!this.__existingItems[i]){const e=this._addLiTo(s,"pure-menu-item");e.classList.add("pure-menu-has-children","pure-menu-allow-hover"),this._addATo(e,"pure-menu-link",i);const t=this._addUlTo(e,"pure-menu-children shadow-3");this.__existingItems[i]=t;}s=this.__existingItems[i];}const i=this._addATo(s,"pure-menu-link",null,t.callback);if(this._addSpanTo(i,"ActionTitle",t.name),this._addSpanTo(i,"ActionShortcut",this._keyComboAsText(t)),t.key||t.metaKeys){const e=t.metaKeys||{},s=(this._comboFragment(e.alt,"A")+this._comboFragment(e.control,"C")+this._comboFragment(e.shift,"S")+(t.key||"")).toLowerCase();this.__hotkeysToActions[s]=t;}t.callback&&i.addEventListener("click",e=>{e.preventDefault(),t.callback.call(t);}),t.activatedChanged&&t.activatedChanged.connect(e=>{i.className=e?"pure-menu-link ActionedMenu":"pure-menu-link";});}_addKeyListener(){let e;document.addEventListener("keypress",e=>{}),document.addEventListener("keydown",t=>{if(e)return;if(t.target instanceof HTMLInputElement)return;const s=(this._comboFragment(t.altKey,"A")+this._comboFragment(t.metaKey||t.ctrlKey,"C")+this._comboFragment(t.shiftKey,"S")+("Alt"!=t.key&&"Ctrl"!=t.key?t.key:"")).toLowerCase();if(s in this.__hotkeysToActions){this.__hotkeysToActions[s].callback(event),e=s,event.preventDefault();}}),document.addEventListener("keyup",t=>{if(e&&e in this.__hotkeysToActions){const t=this.__hotkeysToActions[e];t.hotkeyReleaseCallback&&(t.hotkeyReleaseCallback(event),event.preventDefault()),e=void 0;}});}_addSpanTo(e,t,s){const i=document.createElement("span");return i.className=t,s&&(i.innerHTML=s),e.appendChild(i),i}_addATo(e,t,s){const i=document.createElement("a");return i.href="#",i.className=t,s&&(i.innerHTML=s),e.appendChild(i),i}_addUlTo(e,t,s){const i=document.createElement("ul");return i.className=t,s&&(i.innerHTML=s),e.appendChild(i),i}_addLiTo(e,t,s){const i=document.createElement("li");return i.className=t,s&&(i.innerHTML=s),e.appendChild(i),i}_comboFragment(e,t){return e?t+"+":""}_keyComboAsText(e){const{metaKeys:t,key:s}=e;return s||t?t?(t.shift?this._comboFragment(t.shift,"Shift"):"")+(t.alt?this._comboFragment(t.alt,"Alt"):"")+(t.control?this._comboFragment(t.control,"Ctrl"):"")+s:s:""}},exports.TreeItemAddChange=y,exports.TreeItemMoveChange=M,exports.TreeItemView=me,exports.TreeItemsRemoveChange=S,exports.UndoRedoManager=o,exports.UserChip=L,exports.VIEW_TOOL_MODELS=U,exports.VRHoldObjectsTool=class extends O{constructor(e){super(e),this.__pressedButtonCount=0,this.__freeIndices=[],this.__vrControllers=[],this.__heldObjectCount=0,this.__heldGeomItems=[],this.__heldGeomItemIds=[],this.__heldGeomItemRefs=[],this.__heldGeomItemOffsets=[];}activateTool(){super.activateTool(),console.log("activateTool.VRHoldObjectsTool"),this.appData.renderer.getDiv().style.cursor="crosshair";const t=t=>{if(!this.__activated)return;const s=new e.Cross(.03),i=new e.Material("Cross","FlatSurfaceShader");i.getParameter("BaseColor").setValue(new e.Color("#03E3AC")),i.visibleInGeomDataBuffer=!1;const n=new e.GeomItem("HandleToolTip",s,i);t.getTipItem().removeAllChildren(),t.getTipItem().addChild(n,!1);};this.appData.renderer.getXRViewport().then(e=>{for(const s of e.getControllers())t(s);this.addIconToControllerId=e.controllerAdded.connect(t);});}deactivateTool(){super.deactivateTool(),this.appData.renderer.getXRViewport().then(e=>{e.controllerAdded.disconnectId(this.addIconToControllerId);});}computeGrabXfo(t){let s;if(1==t.length)s=this.__vrControllers[t[0]].getTipXfo();else if(2==t.length){const i=this.__vrControllers[t[0]].getTipXfo(),n=this.__vrControllers[t[1]].getTipXfo();i.ori.alignWith(n.ori),s=new e.Xfo,s.tr=i.tr.lerp(n.tr,.5),s.ori=i.ori.lerp(n.ori,.5);let o=n.tr.subtract(i.tr);o.normalizeInPlace();const a=s.ori.getXaxis();o.dot(a)<0&&(o=o.negate());const r=o.angleTo(a);if(r>0){const t=a.cross(o);t.normalizeInPlace();const i=new e.Quat;i.setFromAxisAndAngle(t,r),s.ori=i.multiply(s.ori);}}return s}initAction(){for(let e=0;e<this.__heldGeomItems.length;e++){const t=this.__heldGeomItems[e];if(!t)continue;const s=this.computeGrabXfo(this.__heldGeomItemRefs[e]);this.__heldGeomItemOffsets[e]=s.inverse().multiply(t.getGlobalXfo());}}onVRControllerButtonDown(e){const t=e.controller.getId();this.__vrControllers[t]=e.controller;const s=e.controller.getGeomItemAtTip();if(s){if(s.geomItem.getOwner()instanceof r)return !1;if(e.intersectionData=s,s.geomItem.onMouseDown(e,s),!e.propagating)return !1;let i=this.__heldGeomItems.indexOf(s.geomItem);if(-1==i){i=this.__heldGeomItems.length,this.__heldObjectCount++,this.__heldGeomItems.push(s.geomItem),this.__heldGeomItemRefs[i]=[t],this.__heldGeomItemIds[t]=i;const e={newItem:s.geomItem,newItemId:i};this.change?this.change.update(e):(this.change=new q(e),this.appData.undoRedoManager.addChange(this.change));}else this.__heldGeomItemIds[t]=i,this.__heldGeomItemRefs[i].push(t);return this.initAction(),!0}}onVRControllerButtonUp(e){const t=e.controller.getId();if(this.__pressedButtonCount--,void 0!==this.__heldGeomItemIds[t]){const e=this.__heldGeomItemIds[t],s=this.__heldGeomItemRefs[e];return s.splice(s.indexOf(t),1),0==s.length&&(this.__heldObjectCount--,this.__heldGeomItems[e]=void 0,this.change=void 0),this.__heldGeomItemIds[t]=void 0,this.initAction(),!0}}onVRPoseChanged(e){if(!this.change)return !1;const t=[],s=[];for(let e=0;e<this.__heldGeomItems.length;e++){if(!this.__heldGeomItems[e])continue;const i=this.computeGrabXfo(this.__heldGeomItemRefs[e]);t.push(i.multiply(this.__heldGeomItemOffsets[e])),s.push(e);}return this.change.update({changeXfos:t,changeXfoIds:s}),!0}},exports.VRUITool=class extends O{constructor(t){super(t),this.__vrUIDOMHolderElement=document.createElement("div"),this.__vrUIDOMHolderElement.className="vrUIHolder",this.__vrUIDOMElement=document.createElement("div"),this.__vrUIDOMElement.className="vrUI",document.body.appendChild(this.__vrUIDOMHolderElement),this.controllerUI=new Q(t,this.__vrUIDOMHolderElement,this.__vrUIDOMElement),this.controllerUI.addRef(this),t.renderer.addTreeItem(this.controllerUI),this.__uiLocalXfo=new e.Xfo,this.__uiLocalXfo.ori.setFromAxisAndAngle(new e.Vec3(1,0,0),-.6*Math.PI);const s=new e.Material("pointermat","LinesShader");s.visibleInGeomDataBuffer=!1,s.getParameter("Color").setValue(new e.Color(1.2,0,0));const i=new e.Lines;i.setNumVertices(2),i.setNumSegments(1),i.setSegment(0,0,1),i.getVertex(0).set(0,0,0),i.getVertex(1).set(0,0,-1),i.setBoundingBoxDirty(),this.__pointerLocalXfo=new e.Xfo,this.__pointerLocalXfo.sc.set(1,1,.1),this.__pointerLocalXfo.ori.setFromAxisAndAngle(new e.Vec3(1,0,0),-.2*Math.PI),this.__uiPointerItem=new e.GeomItem("VRControllerPointer",i,s),this.__uiPointerItem.addRef(this),this.__triggerHeld=!1;}getName(){return "VRUITool"}setUIControllers(e,t,s,i){this.openUITool=e,this.uiController=t,this.pointerController=s;const n=this.uiController.getTreeItem().getGlobalXfo();if(this.pointerController){const e=this.pointerController.getTreeItem().getGlobalXfo(),t=n.tr.subtract(i.tr),s=e.tr.subtract(i.tr);t.cross(s).dot(i.ori.getYaxis())>0?this.__uiLocalXfo.tr.set(.05,-.05,.08):this.__uiLocalXfo.tr.set(-.05,-.05,.08);}else this.__uiLocalXfo.tr.set(0,-.05,.08);this.controllerUI.setLocalXfo(this.__uiLocalXfo);}activateTool(){super.activateTool(),this.controllerUI.activate(),this.uiController&&(this.uiController.getTipItem().addChild(this.controllerUI,!1),this.pointerController&&this.pointerController.getTipItem().addChild(this.__uiPointerItem,!1),this.appData.session.pub("pose-message",{interfaceType:"VR",showUIPanel:{controllerId:this.uiController.getId(),localXfo:this.__uiLocalXfo.toJSON(),size:this.controllerUI.getGeomOffsetXfo().sc.toJSON()}}));}deactivateTool(){super.deactivateTool(),this.controllerUI.deactivate(),this.uiController&&(this.uiController.getTipItem().removeChildByHandle(this.controllerUI),this.pointerController&&this.pointerController.getTipItem().removeChildByHandle(this.__uiPointerItem),this.appData.session.pub("pose-message",{interfaceType:"VR",hideUIPanel:{controllerId:this.uiController.getId()}}));}setPointerLength(e){this.__pointerLocalXfo.sc.set(1,1,e),this.__uiPointerItem.setLocalXfo(this.__pointerLocalXfo);}calcUIIntersection(){const t=this.__uiPointerItem.getGlobalXfo(),s=t.ori.getZaxis().negate(),i=new e.Ray(t.tr,s),n=this.controllerUI.getGlobalXfo(),o=this.controllerUI.getGeomOffsetXfo().sc,a=new e.Ray(n.tr,n.ori.getZaxis().negate()),r=i.intersectRayPlane(a);if(r<=0)return void this.setPointerLength(.5);const l=t.tr.add(s.scale(r)).subtract(a.start),h=l.dot(n.ori.getXaxis())/o.x,c=l.dot(n.ori.getYaxis())/o.y;if(Math.abs(h)>.5||Math.abs(c)>.5)return void this.setPointerLength(.5);this.setPointerLength(r);const d=this.__vrUIDOMElement.getBoundingClientRect();return {clientX:Math.round(h*d.width+d.width/2),clientY:Math.round(c*-d.height+d.height/2)}}sendEventToUI(e,t){const s=this.calcUIIntersection();if(s){s.offsetX=s.pageX=s.pageX=s.screenX=s.clientX,s.offsetY=s.pageY=s.pageY=s.screenY=s.clientY;const i=document.elementFromPoint(s.clientX,s.clientY);return i!=this._element&&(this._element&&this.controllerUI.sendMouseEvent("mouseleave",Object.assign(t,s),this._element),this._element=i,this.controllerUI.sendMouseEvent("mouseenter",Object.assign(t,s),this._element)),this.controllerUI.sendMouseEvent(e,Object.assign(t,s),this._element),this._element}this._element&&(this.controllerUI.sendMouseEvent("mouseleave",Object.assign(t,s),this._element),this._element=null);}onVRControllerButtonDown(e){if(e.controller==this.pointerController){this.__triggerHeld=!0;const t=this.sendEventToUI("mousedown",{button:e.button-1});this.__triggerDownElem=t||null;}return !0}onVRControllerButtonUp(e){if(e.controller==this.pointerController){this.__triggerHeld=!1;const t=this.sendEventToUI("mouseup",{button:e.button-1});t&&this.__triggerDownElem==t&&this.sendEventToUI("click",{button:e.button-1}),this.__triggerDownElem=null;}return !0}onVRPoseChanged(e){const t=e.viewXfo;return (()=>{const e=this.uiController.getTreeItem().getGlobalXfo(),s=e.tr.subtract(t.tr);return s.normalizeInPlace(),!(s.angleTo(e.ori.getYaxis())>.5*Math.PI)||(this.appData.toolManager.removeToolByHandle(this),!1)})()&&this.sendEventToUI("mousemove",{}),!0}},exports.ViewTool=class extends O{constructor(t,s=U.VIEWER){super(t),console.log("ViewTool:",s),this.__maipulationModel=s,this.__defaultMode="orbit",this.__mode=this.__defaultMode,this.__mouseDragDelta=new e.Vec2,this.__keyboardMovement=!1,this.__keysPressed=[],this.__maxVel=.002,this.__velocity=new e.Vec3,this.__ongoingTouches={},this.__orbitRateParam=this.addParameter(new e.NumberParameter("orbitRate",1)),this.__dollySpeedParam=this.addParameter(new e.NumberParameter("dollySpeed",.02)),this.__mouseWheelDollySpeedParam=this.addParameter(new e.NumberParameter("mouseWheelDollySpeed",.002)),this.__controllerTriggersHeld=[],this.movementFinished=new e.Signal;}activateTool(){super.activateTool(),console.log("activateTool.ViewTool"),this.appData.renderer.getDiv().style.cursor="default",this.appData.renderer.getXRViewport().then(t=>{this.vrControllerToolTip||(this.vrControllerToolTip=new e.Sphere(.015),this.vrControllerToolTipMat=new e.Material("Cross","FlatSurfaceShader"),this.vrControllerToolTipMat.getParameter("BaseColor").setValue(new e.Color("#03E3AC")),this.vrControllerToolTipMat.visibleInGeomDataBuffer=!1);const s=t=>{const s=new e.GeomItem("HandleToolTip",this.vrControllerToolTip,this.vrControllerToolTipMat);t.getTipItem().removeAllChildren(),t.getTipItem().addChild(s,!1);};for(const e of t.getControllers())s(e);this.addIconToControllerId=t.controllerAdded.connect(s);});}deactivateTool(){super.deactivateTool(),this.appData.renderer.getXRViewport().then(e=>{e.controllerAdded.disconnectId(this.addIconToControllerId);});}setDefaultMode(e){this.__defaultMode=e;}look(t,s){const i=s.getCamera().getFocalDistance(),n=this.__orbitRateParam.getValue()*e.SystemDesc.isMobileDevice?-1:1;if(this.__keyboardMovement){const e=s.getCamera().getGlobalXfo();this.__mouseDownCameraXfo=e.clone(),this.__mouseDownZaxis=e.ori.getZaxis();const t=this.__mouseDownZaxis.scale(-i);this.__mouseDownCameraTarget=e.tr.add(t);}const o=this.__mouseDownCameraXfo.clone(),a=new e.Quat;a.rotateZ(t.x/s.getWidth()*Math.PI*n),o.ori=a.multiply(o.ori);const r=new e.Quat;r.rotateX(t.y/s.getHeight()*Math.PI*n),o.ori.multiplyInPlace(r),s.getCamera().setGlobalXfo(o);}orbit(t,s){const i=s.getCamera().getFocalDistance(),n=this.__orbitRateParam.getValue()*e.SystemDesc.isMobileDevice?-1:1;if(this.__keyboardMovement){const e=s.getCamera().getGlobalXfo();this.__mouseDownCameraXfo=e.clone(),this.__mouseDownZaxis=e.ori.getZaxis();const t=this.__mouseDownZaxis.scale(-i);this.__mouseDownCameraTarget=e.tr.add(t);}const o=this.__mouseDownCameraXfo.clone(),a=new e.Quat;a.rotateZ(t.x/s.getWidth()*2*Math.PI*-n),o.ori=a.multiply(o.ori);const r=new e.Quat;r.rotateX(t.y/s.getHeight()*Math.PI*-n),o.ori.multiplyInPlace(r),o.tr=this.__mouseDownCameraTarget.add(o.ori.getZaxis().scale(i)),s.getCamera().setGlobalXfo(o);}pan(t,s){const i=s.getCamera().getFocalDistance(),n=s.getCamera().getFov(),o=new e.Vec3(1,0,0),a=new e.Vec3(0,1,0),r=2*i*Math.tan(.5*n),l=r*(s.getWidth()/s.getHeight()),h=new e.Xfo;h.tr=o.scale(-t.x/s.getWidth()*l),h.tr.addInPlace(a.scale(t.y/s.getHeight()*r)),s.getCamera().setGlobalXfo(this.__mouseDownCameraXfo.multiply(h));}dolly(t,s){const i=t.x*this.__dollySpeedParam.getValue(),n=new e.Xfo;n.tr.set(0,0,i),s.getCamera().setGlobalXfo(this.__mouseDownCameraXfo.multiply(n));}panAndZoom(t,s,i){const n=i.getCamera().getFocalDistance(),o=i.getCamera().getFov(),a=new e.Vec3(1,0,0),r=new e.Vec3(0,1,0),l=2*n*Math.tan(.5*o),h=l*(i.getWidth()/i.getHeight()),c=new e.Xfo;c.tr=a.scale(-t.x/i.getWidth()*h),c.tr.addInPlace(r.scale(t.y/i.getHeight()*l));const d=s*n;i.getCamera().setFocalDistance(this.__mouseDownFocalDist+d),c.tr.z+=d,i.getCamera().setGlobalXfo(this.__mouseDownCameraXfo.multiply(c));}initDrag(e){const t=e.getCamera().getFocalDistance();this.__mouseDragDelta.set(0,0),this.__mouseDownCameraXfo=e.getCamera().getGlobalXfo().clone(),this.__mouseDownZaxis=e.getCamera().getGlobalXfo().ori.getZaxis();const s=this.__mouseDownZaxis.scale(-t);this.__mouseDownCameraTarget=e.getCamera().getGlobalXfo().tr.add(s),this.__mouseDownFocalDist=t;}aimFocus(t,s){this.__focusIntervalId&&clearInterval(this.__focusIntervalId);let i=0;const n=()=>{const o=t.getGlobalXfo(),a=t.getFocalDistance(),r=s.subtract(o.tr),l=r.normalizeInPlace(),h=new e.Quat,c=new e.Quat;{const e=o.ori.getZaxis().clone();e.z=0;const t=r.negate();t.z=0,h.setFrom2Vectors(e,t);}{const e=o.ori.getZaxis().clone(),t=r.negate();e.x=t.x,e.y=t.y,e.normalizeInPlace(),e.cross(t).dot(o.ori.getXaxis())>0?c.rotateX(e.angleTo(t)):c.rotateX(-e.angleTo(t));}const d=o.clone();d.ori=h.multiply(d.ori),d.ori.multiplyInPlace(c);const m=Math.pow(i/20,2),u=o.clone();u.ori=o.ori.lerp(d.ori,m),t.setFocalDistance(a+(l-a)*m),t.setGlobalXfo(u),i++,i<=20?this.__focusIntervalId=setTimeout(n,20):(this.__focusIntervalId=void 0,this.movementFinished.emit());};n(),this.__manipulationState="focussing";}onMouseMove(e){}onDragStart(e){this.__mouseDownPos=e.mousePos,this.initDrag(e.viewport),2==e.button?this.__mode="pan":e.ctrlKey&&2==e.button?this.__mode="dolly":e.shiftKey||2==e.button?this.__mode="look":this.__mode=this.__defaultMode;}onDrag(e){switch(this.__keyboardMovement?this.__mouseDragDelta=e.mousePos:this.__mouseDragDelta=e.mousePos.subtract(this.__mouseDownPos),this.__mode){case"orbit":this.orbit(this.__mouseDragDelta,e.viewport);break;case"look":this.look(this.__mouseDragDelta,e.viewport);break;case"pan":this.pan(this.__mouseDragDelta,e.viewport);break;case"dolly":this.dolly(this.__mouseDragDelta,e.viewport);}}onDragEnd(e){return this.movementFinished.emit(),!1}onMouseDown(e){return !(this.__maipulationModel==U.DCC&&!e.altKey)&&(this.dragging=!0,this.__mouseDownPos=e.mousePos,this.onDragStart(e),!0)}onMouseUp(e){if(this.dragging)return this.onDragEnd(e),this.dragging=!1,!0}onMouseMove(e){if(this.dragging)return this.onDrag(e),e.showPointerOnAvatar=!1,!0}onDoubleClick(e){if(e.intersectionData){const t=e.viewport.getCamera(),s=t.getGlobalXfo().tr.add(e.intersectionData.mouseRay.dir.scale(e.intersectionData.dist));this.aimFocus(t,s);}}onWheel(e){if(this.__maipulationModel==U.DCC&&!e.altKey)return !1;const t=e.viewport,s=t.getCamera().getGlobalXfo(),i=s.ori.getZaxis();this.__mouseWheelZoomIntervalId&&clearInterval(this.__mouseWheelZoomIntervalId);let n=0;const o=()=>{const a=t.getCamera().getFocalDistance(),r=this.__mouseWheelDollySpeedParam.getValue(),l=e.deltaY*r*a*.2;s.tr.addInPlace(i.scale(l)),"orbit"==this.__defaultMode&&t.getCamera().setFocalDistance(a+l),t.getCamera().setGlobalXfo(s),n++,n<5?this.__mouseWheelZoomIntervalId=setTimeout(o,20):(this.__mouseWheelZoomIntervalId=void 0,this.movementFinished.emit(),e.viewport.renderGeomDataFbo());};o();}__integrateVelocityChange(t,s){const i=new e.Xfo;i.tr=this.__velocity.normalize().scale(this.__maxVel),s.getCamera().setGlobalXfo(s.getCamera().getGlobalXfo().multiply(i));}onKeyPressed(e,t){return !1}onKeyDown(e,t){}onKeyUp(e,t){return !0}__startTouch(t,s){this.__ongoingTouches[t.identifier]={identifier:t.identifier,pos:new e.Vec2(t.pageX,t.pageY)};}__endTouch(e,t){delete this.__ongoingTouches[e.identifier];}onTouchStart(e){e.preventDefault(),e.stopPropagation(),0==Object.keys(this.__ongoingTouches).length&&(this.__manipMode=void 0);const t=e.changedTouches;for(let e=0;e<t.length;e++)this.__startTouch(t[e]);return this.initDrag(e.viewport),!0}onTouchMove(t){t.preventDefault(),t.stopPropagation();const s=t.changedTouches;if(1==s.length&&"panAndZoom"!=this.__manipMode){const i=s[0],n=new e.Vec2(i.pageX,i.pageY),o=this.__ongoingTouches[i.identifier].pos.subtract(n);return "look"==this.__defaultMode?(o.scaleInPlace(6),this.look(o,t.viewport)):this.orbit(o,t.viewport),this.__manipMode="orbit",!0}if(2==s.length){const i=s[0],n=this.__ongoingTouches[i.identifier],o=s[1],a=this.__ongoingTouches[o.identifier],r=new e.Vec2(i.pageX,i.pageY),l=new e.Vec2(o.pageX,o.pageY),h=a.pos.subtract(n.pos).length()-l.subtract(r).length(),c=r.subtract(n.pos),d=l.subtract(a.pos),m=c.add(d);return m.scaleInPlace(.5),this.panAndZoom(m,.002*h,t.viewport),this.__manipMode="panAndZoom",!0}}onTouchEnd(e){e.preventDefault(),e.stopPropagation();const t=e.changedTouches;switch(this.__manipMode){case"orbit":case"panAndZoom":this.movementFinished.emit();}for(let e=0;e<t.length;e++)this.__endTouch(t[e]);return 0==Object.keys(this.__ongoingTouches).length&&(this.__manipMode=void 0),!0}onTouchCancel(e){console.log("touchcancel.");const t=e.changedTouches;for(let e=0;e<t.length;e++)this.__endTouch(t[e]);return !0}onDoubleTap(e){const t=e.changedTouches;for(let e=0;e<t.length;e++)this.__startTouch(t[e]);if(e.intersectionData){const t=e.viewport.getCamera(),s=t.getGlobalXfo().tr.add(e.intersectionData.mouseRay.dir.scale(e.intersectionData.dist));this.aimFocus(t,s);}}__initMoveStage(e){if(1==this.__controllerTriggersHeld.length)this.__grabPos=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr.clone(),this.stageXfo__GrabStart=e.getXfo().clone(),this.__invOri=this.stageXfo__GrabStart.ori.inverse();else if(2==this.__controllerTriggersHeld.length){const t=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr,s=this.__controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr;this.__grabDir=s.subtract(t),this.__grabPos=t.lerp(s,.5),this.__grabDir.y=0,this.__grabDist=this.__grabDir.length(),this.__grabDir.scaleInPlace(1/this.__grabDist),this.stageXfo__GrabStart=e.getXfo().clone(),this.__grab_to_stage=this.__grabPos.subtract(this.stageXfo__GrabStart.tr);}}onVRControllerButtonDown(e){if(1==e.button)return this.__controllerTriggersHeld.push(e.controller),this.__initMoveStage(e.vrviewport),!0}onVRControllerButtonUp(e){if(1!=e.button)return;const t=this.__controllerTriggersHeld.indexOf(e.controller);return this.__controllerTriggersHeld.splice(t,1),this.__initMoveStage(e.vrviewport),!0}onVRControllerDoubleClicked(e){console.log("onVRControllerDoubleClicked:",this.__controllerTriggersHeld.length);const t=e.vrviewport.getXfo().clone();t.sc.set(1,1,1),e.vrviewport.setXfo(t);}onVRPoseChanged(t){if(1==this.__controllerTriggersHeld.length){const s=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr,i=new e.Xfo;i.tr=this.__grabPos.subtract(s);const n=this.stageXfo__GrabStart.multiply(i);return t.vrviewport.setXfo(n),!0}if(2==this.__controllerTriggersHeld.length){const s=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr,i=this.__controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr,n=s.lerp(i,.5),o=i.subtract(s);o.y=0;const a=o.length();o.scaleInPlace(1/a);const r=new e.Xfo,l=Math.max(Math.min(this.__grabDist/a,10),.1);r.sc.set(l,l,l);let h=this.__grabDir.angleTo(o);this.__grabDir.cross(o).y>0&&(h=-h),r.ori.rotateY(h);const c=r.ori.rotateVec3(this.__grabPos);r.tr.addInPlace(this.__grabPos.subtract(c));const d=this.__grabPos.scale(1-l);r.tr.addInPlace(r.ori.rotateVec3(d));const m=this.__grabPos.subtract(n).scale(l);r.tr.addInPlace(r.ori.rotateVec3(m));const u=this.stageXfo__GrabStart.multiply(r);return t.vrviewport.setXfo(u),!0}}},exports.uxFactory=V;
});

const zeaTreeItemElementCss = ":host{display:block;font-size:14px}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.wrap{opacity:0.7;cursor:default;user-select:none}.wrap.visible{opacity:1}.header{display:flex;align-items:center;margin:4px 0;position:relative;left:-7px}.arrow{display:flex;justify-content:center;align-items:center;cursor:pointer;padding:2px}.label{white-space:nowrap}.toggle{display:flex;justify-content:center;align-items:center;font-size:1.2em;margin:0 1px 0 4px}.children{padding-left:19px;border-left:1px dotted gray}zea-tree-item-element{margin-left:16px}zea-tree-item-element.has-children{margin-left:0}.zea-tree-item-label{padding:3px 5px;border-radius:4px;border:1px solid transparent;margin-left:22px;white-space:nowrap}.is-tree-item .zea-tree-item-label{margin-left:0}.highlighted .zea-tree-item-label{background-color:var(\n    --treeview-highlight-bg-color,\n    var(--color-secondary-3)\n  );border:1px solid var(--treeview-highlight-color, var(--color-secondary-1))}.selected .zea-tree-item-label{background-color:var(--treeview-highlight-color, var(--color-secondary-1));border:1px solid var(--treeview-highlight-color, var(--color-secondary-1))}";

const ZeaTreeItemElement = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.label = 'Loading...';
    this.isRoot = false;
    this.isTreeItem = false;
    this.isSelected = false;
    this.isVisible = false;
    this.isHighlighted = false;
    this.isExpanded = false;
    this.childItems = [];
  }
  /**
   * Placeholder comment
   */
  treeItemChanged() {
    if (this.treeItem) {
      this.initTreeItem();
    }
  }
  /**
   * Placeholder comment
   */
  componentWillLoad() {
    if (this.treeItem) {
      this.initTreeItem();
      this.updateSelected();
      this.updateVisibility();
      this.updateHighlight();
      if (this.childItems.length)
        this.rootElement.classList.add('has-children');
      else
        this.rootElement.classList.remove('has-children');
      this.treeItem.titleElement = this.rootElement;
    }
  }
  /**
   * Placeholder comment
   */
  initTreeItem() {
    // Name
    this.label = this.treeItem.getName();
    this.nameChangedId = this.treeItem.on('nameChanged', () => {
      this.label = this.treeItem.getName();
    });
    // Selection
    this.updateSelectedId = this.treeItem.on('selectedChanged', this.updateSelected.bind(this));
    if (typeof this.treeItem.getChildren === 'function') {
      this.isTreeItem = true;
      this.childItems = [...this.treeItem.getChildren()];
      this.childAddedId = this.treeItem.on('childAdded', () => {
        this.childItems = [...this.treeItem.getChildren()];
      });
      this.childRemovedId = this.treeItem.on('childRemoved', () => {
        this.childItems = [...this.treeItem.getChildren()];
      });
      // Visibility
      this.updateVisibilityId = this.treeItem.on('visibilityChanged', this.updateVisibility.bind(this));
    }
    else {
      this.isTreeItem = false;
      this.isVisible = true;
    }
    // Highlights
    this.updateHighlightId = this.treeItem.on('highlightChanged', this.updateHighlight.bind(this));
  }
  /**
   * Placeholder comment
   */
  updateSelected() {
    if (this.treeItem && 'isSelected' in this.treeItem)
      this.isSelected = this.treeItem.isSelected();
  }
  /**
   * Placeholder comment
   */
  updateVisibility() {
    if (this.treeItem && 'isVisible' in this.treeItem) {
      this.isVisible = this.treeItem.isVisible();
    }
  }
  /**
   * Placeholder comment
   */
  updateHighlight() {
    var _a, _b;
    if (this.treeItem && 'isHighlighted' in this.treeItem) {
      this.isHighlighted = this.treeItem.isHighlighted();
      if (this.isHighlighted && 'getHighlight' in this.treeItem) {
        const highlightColor = this.treeItem.getHighlight();
        const bgColor = highlightColor.lerp(new zeaEngine_cjs.Color(0.75, 0.75, 0.75, 0), 0.5);
        console.log('this.itemContainer', this.itemContainer);
        (_a = this.itemContainer) === null || _a === void 0 ? void 0 : _a.style.setProperty('--treeview-highlight-bg-color', `${bgColor.toHex()}60` // add transparency
        );
        (_b = this.itemContainer) === null || _b === void 0 ? void 0 : _b.style.setProperty('--treeview-highlight-color', highlightColor.toHex());
      }
    }
  }
  /**
   * Placeholder comment
   */
  toggleChildren() {
    this.isExpanded = !this.isExpanded;
  }
  /**
   * Placeholder comment
   */
  onVisibilityToggleClick() {
    const visibleParam = this.treeItem.getParameter('Visible');
    if (this.appData && this.appData.undoRedoManager) {
      const change = new zeaUx_cjs.ParameterValueChange(visibleParam, !visibleParam.getValue());
      this.appData.undoRedoManager.addChange(change);
    }
    else {
      visibleParam.setValue(!visibleParam.getValue());
    }
  }
  /**
   * Placeholder comment
   * @param {any} e The event object
   */
  onLabelClick(e) {
    if (!this.appData || !this.appData.selectionManager) {
      this.treeItem.setSelected(!this.treeItem.getSelected());
      return;
    }
    if (this.appData.selectionManager.pickingModeActive()) {
      this.appData.selectionManager.pick(this.treeItem);
      return;
    }
    this.appData.selectionManager.toggleItemSelection(this.treeItem, !e.ctrlKey);
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4("div", { class: {
        wrap: true,
        'has-children': this.childItems.length,
        selected: this.isSelected,
        visible: this.isVisible,
        highlighted: this.isHighlighted,
        'is-tree-item': this.isTreeItem,
      }, style: { display: 'block' }, ref: (el) => (this.itemContainer = el) }, h$4("div", { class: "header" }, h$4("div", { class: "arrow", style: { display: this.childItems.length > 0 ? 'block' : 'none' }, onClick: () => this.toggleChildren() }, h$4("span", null, this.isExpanded ? (h$4("zea-icon", { name: "caret-down", size: 12 })) : (h$4("zea-icon", { name: "caret-forward", size: 12 })))), this.isTreeItem && (h$4("div", { class: "toggle", onClick: this.onVisibilityToggleClick.bind(this) }, h$4("zea-icon", { name: this.isVisible ? 'eye-outline' : 'eye-off-outline', ref: (el) => (this.visibilityIcon = el), size: 16 }))), h$4("div", { class: "zea-tree-item-label", onClick: this.onLabelClick.bind(this) }, this.label)), this.isTreeItem && (h$4("div", { class: "children", style: { display: this.isExpanded ? 'block' : 'none' } }, this.isExpanded &&
      this.childItems.map((child) => (h$4("zea-tree-item-element", { treeItem: child, appData: this.appData })))))));
  }
  get rootElement() { return this; }
  static get watchers() { return {
    "treeItem": ["treeItemChanged"]
  }; }
  static get style() { return zeaTreeItemElementCss; }
};

const zeaTreeViewCss = ":host{display:block;height:100%}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.wrap{height:100%;padding:0.5em;overflow:auto;box-sizing:border-box;color:var(--color-foreground-1)}";

const ZeaTreeView = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
  }
  /**
   * onKeyDown
   * @param {any} event the event data
   */
  onKeyDown(event) {
    if (!this.mouseIsOver)
      return;
    const { selectionManager } = this.appData;
    if (!selectionManager)
      return;
    if (event.key == 'ArrowLeft') {
      const selectedItem = Array.from(selectionManager.getSelection())[0];
      this.collapseSelection(selectedItem);
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if (event.key == 'ArrowRight') {
      const selectedItem = Array.from(selectionManager.getSelection())[0];
      this.expandSelection(selectedItem);
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if (event.key == 'ArrowUp') {
      const item = Array.from(selectionManager.getSelection())[0];
      const newSelection = new Set();
      const owner = item.getOwner();
      if (owner) {
        const index = owner.getChildIndex(item);
        const prevSibling = owner.getChild(index - 1);
        if (index == 0)
          newSelection.add(owner);
        else if (prevSibling &&
          prevSibling.getNumChildren &&
          prevSibling.titleElement.isExpanded) {
          newSelection.add(prevSibling.getChild(prevSibling.getNumChildren() - 1));
        }
        else {
          newSelection.add(item.getOwner().getChild(index - 1));
        }
      }
      if (newSelection.size > 0) {
        selectionManager.setSelection(newSelection);
      }
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if (event.key == 'ArrowDown') {
      const item = Array.from(selectionManager.getSelection())[0];
      const newSelection = new Set();
      if (item && item.getChild && item.titleElement.isExpanded) {
        newSelection.add(item.getChild(0));
      }
      else if (item.getOwner) {
        const index = item.getOwner().getChildIndex(item);
        const isLast = index == item.getOwner().getNumChildren() - 1;
        if (!isLast)
          newSelection.add(item.getOwner().getChild(index + 1));
        else {
          const owner = item.getOwner();
          const ownerOwner = owner.getOwner();
          if (owner && ownerOwner) {
            const ownerIndex = ownerOwner.getChildIndex(owner);
            const ownerIsLast = ownerIndex == ownerOwner.getNumChildren() - 1;
            if (!ownerIsLast) {
              newSelection.add(ownerOwner.getChild(ownerIndex + 1));
            }
          }
        }
      }
      if (newSelection.size > 0) {
        selectionManager.setSelection(newSelection);
      }
      event.preventDefault();
      event.stopPropagation();
      return;
    }
  }
  /**
   * The expandSelection method.
   * @param {Map} item - The item we wish to expand to show.
   * @param {boolean} scrollToView - Whether to scroll the item into view
   */
  expandSelection(item, scrollToView = true) {
    if (item.getNumChildren() &&
      item.titleElement &&
      !item.titleElement.isExpanded)
      item.titleElement.isExpanded = true;
    // causes the element to be always at the top of the view.
    if (scrollToView)
      this.scrollItemIntoView(item);
  }
  /**
   * The collapseSelection method.
   * @param {Map} item - The item we wish to expand to show.
   * @param {boolean} scrollToView - Whether to scroll the item into view
   */
  collapseSelection(item, scrollToView = true) {
    if (item.getNumChildren() && item.titleElement.isExpanded)
      item.titleElement.isExpanded = false;
    if (scrollToView)
      this.scrollItemIntoView(item);
  }
  /**
   * Placeholder comment
   * @param {any} item The item
   */
  scrollItemIntoView(item) {
    // causes the element to be always at the top of the view.
    if (item && item.titleElement)
      item.titleElement.scrollIntoView({
        behavior: 'auto',
        block: 'nearest',
        inline: 'nearest',
      });
  }
  /**
   * onMouseEnter
   */
  onMouseEnter() {
    this.mouseIsOver = true;
  }
  /**
   * onMouseLeave
   */
  onMouseLeave() {
    this.mouseIsOver = false;
  }
  /**
   * Main render method for the component
   * @return {JSX} The generated markup
   */
  render() {
    return (h$4(Host, null, h$4("div", { class: "wrap", onMouseEnter: this.onMouseEnter.bind(this), onMouseLeave: this.onMouseLeave.bind(this) }, h$4("zea-tree-item-element", { ref: (el) => {
        if (this.rootItem) {
          this.rootItem.titleElement = el;
        }
      }, "is-root": "true", "expand-on-load": "true", treeItem: this.rootItem, appData: this.appData, isExpanded: true }))));
  }
  static get style() { return zeaTreeViewCss; }
};

const zeaUserCardCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-user-card{color:var(--color-foreground-1);font-size:13px}.zea-user-card{min-width:290px;background-color:var(--color-background-2);display:grid;grid-template-columns:min-content auto min-content;align-items:flex-start;position:relative;z-index:10000000}.zea-user-card.small{min-width:280px}.user-chip-container,.user-focuser-container{display:flex;align-items:center;justify-content:center}.user-focuser-container zea-icon{}.user-focuser{padding:8px;cursor:pointer}.user-focuser:hover{color:white}.zea-user-card .user-info{padding-left:0}.user-name{padding-top:5px;padding-bottom:4px}.user-company{color:var(--color-foreground-3)}.zea-user-card>*{padding:10px}.additional-data{grid-column-start:1;grid-column-end:4;grid-gap:1em;padding:1em;border-top:1px solid var(--color-grey-3);display:none}.additional-data.shown{display:grid}.user-phone,.user-email{display:flex;align-items:center}.user-phone zea-icon,.user-email zea-icon{flex-grow:0;width:32px}.profile-link{font-size:13px;color:var(--color-secondary-1);margin-top:3px;cursor:pointer}.additional-data-collapser{display:flex;align-items:center;grid-column-start:span 3;padding-left:15px;padding-top:5px}.collapser-label{flex-grow:1}.small{font-size:12px}.small .additional-data{display:none !important}.small .user-company{display:none}.small .user-chip-container{padding:5px}.small .user-focuser-container{padding:0}:host-context(.overflow-entry.shown){box-sizing:border-box;border:1px solid var(--color-grey-3);margin-right:10px}.user-focuser-container{visibility:hidden}:host-context(.overflow-entry:hover) .user-focuser-container,:host-context(.overflow-entry.shown) .user-focuser-container{visibility:visible}:host-context(.overflow-entry:hover) .zea-user-card{background-color:var(--color-grey-2)}:host-context(.overflow-entry.shown:hover) .zea-user-card{background-color:transparent}zea-dialog-profile{z-index:100000000}@media only screen and (max-width: 667px){.zea-user-card{width:100%;position:fixed;left:0}}";

const ZeaUserCard = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Whether the card is for the current user session
     */
    this.isCurrentUser = false;
    /**
     * Whether to show the collpase control for additional data
     */
    this.collapsible = true;
    /**
     * Density and size of elements
     */
    this.density = 'normal';
  }
  /**
   * Initialize the shown state of additional data
   * according to whether collapsing is allowed or not
   */
  componentWillLoad() {
    this.additionalDataShown = !this.collapsible;
  }
  /**
   * Show the profile editor form
   */
  onProfileLinkClick() {
    this.profileDialog.shown = true;
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    const firstName = this.userData.firstName || this.userData.given_name;
    const lastName = this.userData.lastName || this.userData.family_name;
    const company = this.userData.company;
    const phone = this.userData.phone;
    const email = this.userData.email;
    return (h$4("div", { class: `zea-user-card ${this.density}` }, h$4("div", { class: "user-chip-container" }, h$4("zea-user-chip", { showProfileCard: false, showTooltip: false, userData: this.userData, density: this.density == 'normal' ? 'large' : this.density })), h$4("div", { class: "user-info" }, h$4("div", { class: "user-name" }, firstName, " ", lastName), h$4("div", { class: "user-company" }, company), this.isCurrentUser && (h$4("div", { onClick: this.onProfileLinkClick.bind(this), class: "profile-link" }, "My Profile"))), !this.isCurrentUser && (h$4("div", { class: "user-focuser-container" }, h$4("div", { class: "user-focuser", onClick: (e) => {
        e.preventDefault();
        e.stopPropagation();
      } }, h$4("zea-icon", { name: "find-user", type: "zea", size: 28 })))), !this.isCurrentUser && this.collapsible && (phone || email) && (h$4("div", { class: "additional-data-collapser", onClick: () => (this.additionalDataShown = !this.additionalDataShown) }, h$4("span", { class: "collapser-label" }, this.additionalDataShown ? 'Less' : 'More'), h$4("span", { class: "collapser-icon" }, h$4("zea-icon", { name: this.additionalDataShown
        ? 'chevron-up-outline'
        : 'chevron-down-outline', size: 14 })))), !this.isCurrentUser && (phone || email) && (h$4("div", { class: {
        'additional-data': true,
        shown: this.additionalDataShown,
      } }, phone && (h$4("div", { class: "user-phone" }, h$4("zea-icon", { name: "phone-portrait-outline" }), h$4("span", null, phone))), email && (h$4("div", { class: "user-email" }, h$4("zea-icon", { name: "mail-outline" }), h$4("span", null, email))))), this.isCurrentUser && (h$4("zea-dialog-profile", { ref: (el) => (this.profileDialog = el), userData: this.userData }))));
  }
  static get style() { return zeaUserCardCss; }
};

const zeaUserChipCss = ":host{z-index:100000000}:host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-chip{color:var(--color-foreground-1);user-select:none}.zea-chip-avatar{border:2px solid var(--color-background-2);width:32px;height:32px;border-radius:18px;color:white;display:flex;align-items:center;justify-content:center;position:relative;font-size:13px}.active .zea-chip-avatar{box-shadow:0px 0px 1px 2px var(--color-primary-1)}.avatar-image{position:absolute;top:0;left:0;bottom:0;right:0;border-radius:18px;background-size:cover;background-position:center center}.empty-user-chip{display:none}.small .zea-chip-avatar{width:28px;height:28px;border-radius:36px;font-size:13px}.small .avatar-image{border-radius:36px}.large .zea-chip-avatar{width:60px;height:60px;border-radius:36px;font-size:18px}.large .avatar-image{border-radius:36px}zea-user-card{position:absolute;margin-top:3px}zea-user-card.align-right{margin-left:-256px}.tooltip{position:absolute;padding:4px 7px;border-radius:4px;font-size:12px;color:var(--color-foreground-1);background-color:var(--color-grey-3);z-index:100000000;white-space:nowrap;margin-left:18px;transform:translateX(-50%);display:none}.zea-chip:hover .tooltip{display:block}.tooltip.bleeded-right{right:0;transform:none}.tooltip.bleeded-left{left:0;margin-left:0;transform:none}@media only screen and (max-width: 667px){zea-user-card{position:fixed;width:100%;left:0}}@media only screen and (max-width: 667px), only screen and (max-height: 667px){.tooltip{display:none !important}}";

const ZeaUserChip = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    this.zeaUserClicked = createEvent(this, "zeaUserClicked", 7);
    /**
     * Whether the chip is for the current user session
     */
    this.isCurrentUser = false;
    /**
     * Whether the chip is currently active
     */
    this.isActive = false;
    /**
     * Whether avatar images should be shown or not
     */
    this.showImages = true;
    /**
     * The density of the chip (large|normal|small|tiny)
     */
    this.density = 'normal';
    /**
     * Whether the tooltip should be shown
     */
    this.showTooltip = true;
    /**
     * Whether to ever show the profile card
     */
    this.showProfileCard = true;
    /**
     * Whether the profile card is currently shown
     */
    this.profileCardShown = false;
    /**
     * Alignment of the profile card (right|left)
     */
    this.profileCardAlign = 'left';
    /**
     * Used as background color for the chip
     */
    this.randomColor = '#000000'.replace(/0/g, () => {
      // limit the random number range so that colors
      // are not too dark nor too bright
      // eslint-disable-next-line no-bitwise
      return (~~(5 + Math.random() * 7)).toString(16);
    });
  }
  /**
   * Listen to click events on the whole document
   * @param {any} e The event
   */
  handleClick(e) {
    if (e.composedPath().includes(this.chipElement)) {
      if (!e.composedPath().includes(this.profileCardElement)) {
        this.profileCardShown = !this.profileCardShown;
      }
    }
    else {
      this.profileCardShown = false;
    }
  }
  /**
   * Handle click on user chip: emit custom zeaUserClicked event
   */
  onChipClick(e) {
    this.zeaUserClicked.emit(this.userData);
    e.stopPropagation();
  }
  /**
   * On avatar over, fix tooltip position when its out of the screen
   */
  onAvatarOver() {
    this.fixTooltipPosition();
  }
  /**
   * On component render, fix tooltip position when its out of the screen
   */
  componentDidRender() {
    this.fixTooltipPosition();
  }
  /**
   * Fix the tooltip position if it goes out of screen
   */
  fixTooltipPosition() {
    if (!this.tooltipElement)
      return;
    const bbox = this.tooltipElement.getBoundingClientRect();
    if (bbox.x + bbox.width > window.innerWidth) {
      this.tooltipElement.classList.add('bleeded-right');
    }
    else {
      this.tooltipElement.classList.remove('bleeded-right');
    }
    if (bbox.x < 0) {
      this.tooltipElement.classList.add('bleeded-left');
    }
    else {
      this.tooltipElement.classList.remove('bleeded-left');
    }
  }
  /**
   * Main render function
   * @return {JSX} The generated html
   */
  render() {
    if (!this.userData)
      return h$4("span", { class: "empty-user-chip" });
    // Ensure that the zea-user-chip is compatible with a variety of userData values.
    const firstName = this.userData.firstName || this.userData.given_name;
    const lastName = this.userData.lastName || this.userData.family_name;
    const avatar = this.userData.avatar || this.userData.picture;
    let initials = '';
    let backgroundColor = this.userData.color;
    {
      let firstLetter = '';
      let secondLetter = '';
      if (firstName) {
        firstLetter = firstName.charAt(0);
      }
      if (lastName) {
        secondLetter = lastName.charAt(0);
      }
      else if (firstLetter) {
        // if no last name but it does have a firstName,
        // use the firstName's second letter
        secondLetter = firstName.charAt(1);
      }
      initials = String(firstLetter + secondLetter).toUpperCase();
    }
    if (!backgroundColor) {
      backgroundColor = this.randomColor;
      this.userData.color = this.randomColor;
    }
    const containerClass = { active: this.isActive, 'zea-chip': true };
    containerClass[this.density] = true;
    return (h$4("div", { ref: (el) => (this.chipElement = el), class: containerClass, onClick: this.onChipClick.bind(this) }, h$4("div", { class: "zea-chip-avatar", onMouseOver: this.onAvatarOver.bind(this), style: {
        backgroundColor: backgroundColor,
      } }, h$4("span", null, initials), this.showImages && !!avatar && (h$4("div", { class: "avatar-image", style: {
        backgroundImage: `url(${avatar})`,
      } }))), this.showTooltip && !this.profileCardShown && (h$4("div", { ref: (el) => (this.tooltipElement = el), class: "tooltip" }, `${firstName} ${lastName ? lastName : ''}`)), this.showProfileCard && (h$4("zea-user-card", { collapsible: true, isCurrentUser: this.isCurrentUser, ref: (el) => (this.profileCardElement = el), class: `align-${this.profileCardAlign}`, style: { display: this.profileCardShown ? 'block' : 'none' }, userData: this.userData }))));
  }
  static get style() { return zeaUserChipCss; }
};

const zeaUserChipSetCss = ":host,input,button,select,textarea{font-family:'Roboto', sans-serif}.zea-chip-set{color:var(--color-foreground-1);display:flex;position:relative}zea-user-chip{margin-left:-8px;width:36px;height:36px;border:1px solid transparent;border-radius:19px}.overflow-thumb{border:2px solid var(--color-background-3);background-color:var(--color-background-3);width:36px;height:36px;color:var(--color-foreground-2);display:flex;align-items:center;justify-content:center;position:relative;font-size:13px;margin-left:-8px;border-radius:19px;box-sizing:border-box;user-select:none}.overflow-tooltip{position:absolute;top:35px;padding:4px 7px;border-radius:4px;font-size:12px;color:var(--color-foreground-1);background-color:var(--color-grey-3);z-index:10000;white-space:nowrap;display:none}.overflow-thumb:hover .overflow-tooltip{display:block}.overflow-list{max-height:calc(100vh - 60px);width:min-content;overflow-y:auto;background-color:var(--color-background-2);display:none}.overflow-list.shown{display:block;position:absolute}.overflow-list zea-user-card{display:block;}.overflow-entry{display:flex;align-items:stretch}.overflow-entry:hover{background-color:var(--color-grey-2)}.overflow-entry.shown:hover{background-color:transparent}.overflow-entry-collapser{margin:7px 3px 0 5px;width:30px;height:30px;justify-content:center;align-items:center;display:flex;background-color:transparent;border-radius:18px}.overflow-entry.shown .overflow-entry-collapser:hover{background-color:var(--color-grey-2)}";

const ZeaUserChipSet = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    attachShadow(this);
    /**
     * Whether avatar images should be shown or not
     */
    this.showImages = true;
    /**
     * The initial z-index for chip overlapping
     */
    this.initialZIndex = 1000;
    /**
     * Number of chips to show before overflow happens
     */
    this.overflowLimit = 5;
    /**
     * Number of chips to show before overflow happens
     */
    this.overflowShown = false;
    /**
     * Object containing entries in the overflow
     */
    this.shownOverflowEntry = null;
  }
  /**
   * Watch for changes in the session property
   */
  sessionChanged() {
    this.setupSession();
  }
  /**
   * Called when the component first loads
   */
  componentWillLoad() {
    setTimeout(() => {
      this.setupSession();
    }, 500);
  }
  /**
   * Set up the sesion subscriptions
   */
  setupSession() {
    if (this.session && 'sub' in this.session) {
      // Initialize the data array with any users already in the meeting.
      const userDatas = [];
      for (let u in this.session.users) {
        if (this.session.users.hasOwnProperty(u)) {
          userDatas.push(this.session.users[u]);
        }
      }
      this.userDatas = userDatas;
      // Maintaint the order which users join.
      // New users should be on the left.
      this.session.sub('user-joined', (userData) => {
        if (!this.userDatas.find((sessionUserData) => sessionUserData.id == userData.id)) {
          this.userDatas = [userData, ...this.userDatas];
        }
      });
      this.session.sub('user-left', (userData) => {
        const index = this.userDatas.findIndex((sessionUserData) => sessionUserData.id == userData.id);
        if (index == -1) {
          console.warn('User id not in session:', userData.id);
          return;
        }
        const userDatas = [...this.userDatas];
        // Remove the user from our array.
        userDatas.splice(index, 1);
        this.userDatas = userDatas;
      });
      this.session.sub('userChanged', (newUserData) => {
        this.session.users[newUserData.id] = newUserData;
        const userDatas = [];
        for (let u in this.session.users) {
          if (this.session.users.hasOwnProperty(u)) {
            userDatas.push(this.session.users[u]);
          }
        }
        this.userDatas = userDatas;
      });
    }
    else {
      this.userDatas = [];
    }
  }
  /**
   * Activate the current item
   * @param {any} e The event
   */
  onChipClick(e) {
    e.stopPropagation();
  }
  /**
   * Render method.
   * @return {JSX} The generated html
   */
  render() {
    if (!this.userDatas)
      return;
    const shownChips = this.userDatas.slice(0, this.overflowLimit);
    const overflownChips = this.userDatas.slice(this.overflowLimit);
    // let currentZIndex = this.initialZIndex
    return (h$4("div", { class: "zea-chip-set" }, shownChips &&
      shownChips.map((userData) => {
        return (h$4("zea-user-chip", { showImages: this.showImages, key: userData.id, userData: userData,
          // style={{ zIndex: `${--currentZIndex}` }}
          onClick: this.onChipClick.bind(this) }));
      }), overflownChips.length > 0 && (h$4("div", { class: "overflow" }, h$4("div", { class: "overflow-thumb", onClick: (e) => {
        this.overflowShown = !this.overflowShown;
        e.stopPropagation();
      } }, [
      `+${this.userDatas.length - this.overflowLimit}`,
      !this.overflowShown && (h$4("div", { class: "overflow-tooltip" }, "Show All")),
    ]), h$4("div", { class: { 'overflow-list': true, shown: this.overflowShown } }, overflownChips.map((userData) => {
      return (h$4("div", { key: userData.id, class: {
          'overflow-entry': true,
          shown: this.shownOverflowEntry == userData.id,
        }, onClick: (e) => {
          if (this.shownOverflowEntry != userData.id) {
            this.shownOverflowEntry = userData.id;
            e.currentTarget.scrollIntoView();
            e.preventDefault();
            e.stopPropagation();
          }
        } }, h$4("div", { class: "overflow-entry-collapser", onClick: (e) => {
          this.shownOverflowEntry =
            this.shownOverflowEntry == userData.id
              ? null
              : userData.id;
          e.currentTarget.scrollIntoView();
          e.preventDefault();
          e.stopPropagation();
        } }, h$4("zea-icon", { name: this.shownOverflowEntry == userData.id
          ? 'chevron-up-outline'
          : 'chevron-down-outline', size: 14 })), h$4("zea-user-card", { userData: userData, collapsible: false, density: this.shownOverflowEntry == userData.id
          ? 'normal'
          : 'small' })));
    }))))));
  }
  static get watchers() { return {
    "session": ["sessionChanged"]
  }; }
  static get style() { return zeaUserChipSetCss; }
};

const IonIcon = /*@__PURE__*/proxyCustomElement(Icon, [1,"ion-icon",{"mode":[1025],"color":[1],"ariaLabel":[1537,"aria-label"],"ios":[1],"md":[1],"flipRtl":[4,"flip-rtl"],"name":[1],"src":[1],"icon":[8],"size":[1],"lazy":[4],"svgContent":[32],"isVisible":[32]}]);
const ZeaButton$1 = /*@__PURE__*/proxyCustomElement(ZeaButton, [1,"zea-button",{"htmlContent":[1,"html-content"],"variant":[1],"disabled":[4],"color":[4],"density":[1]}]);
const ZeaCheckbox$1 = /*@__PURE__*/proxyCustomElement(ZeaCheckbox, [1,"zea-checkbox",{"name":[1],"disabled":[4],"checked":[4],"isRadio":[4,"is-radio"],"elementClass":[32]}]);
const ZeaCopyLink$1 = /*@__PURE__*/proxyCustomElement(ZeaCopyLink, [1,"zea-copy-link",{"link":[1],"tooltipIsVisible":[4,"tooltip-is-visible"],"tooltipText":[1,"tooltip-text"]}]);
const ZeaDialog$1 = /*@__PURE__*/proxyCustomElement(ZeaDialog, [1,"zea-dialog",{"shown":[4],"width":[1],"allowClose":[4,"allow-close"],"showBackdrop":[4,"show-backdrop"],"addPadding":[4,"add-padding"],"showTitle":[4,"show-title"],"fullScreenMobile":[4,"full-screen-mobile"]}]);
const ZeaDropdownMenu$1 = /*@__PURE__*/proxyCustomElement(ZeaDropdownMenu, [1,"zea-dropdown-menu",{"appData":[8,"app-data"],"actions":[32],"menuItems":[32]},[[4,"keydown","keydownHandler"]]]);
const ZeaFabButton$1 = /*@__PURE__*/proxyCustomElement(ZeaFabButton, [1,"zea-fab-button",{"disabled":[4]}]);
const ZeaForm$1 = /*@__PURE__*/proxyCustomElement(ZeaForm, [1,"zea-form",{"submitText":[1,"submit-text"],"validate":[4],"isValid":[4,"is-valid"],"formValue":[8,"form-value"],"submitCallback":[8,"submit-callback"]}]);
const ZeaIcon$1 = /*@__PURE__*/proxyCustomElement(ZeaIcon, [1,"zea-icon",{"type":[1],"name":[1],"size":[2]}]);
const ZeaImagesGallery$1 = /*@__PURE__*/proxyCustomElement(ZeaImagesGallery, [1,"zea-images-gallery",{"featured":[2],"columns":[2],"folder":[16],"zoomedImageClass":[32],"zoomedImageUrl":[32],"zoomedTop":[32],"zoomedLeft":[32],"zoomedWidth":[32],"zoomedHeight":[32],"zoomedOpacity":[32],"bbox":[32]}]);
const ZeaInput$1 = /*@__PURE__*/proxyCustomElement(ZeaInput, [1,"zea-input",{"name":[1],"type":[1],"value":[8],"label":[1],"invalidMessage":[1,"invalid-message"],"required":[4],"isValid":[4,"is-valid"],"autoValidate":[4,"auto-validate"],"invalidMessageShown":[4,"invalid-message-shown"],"showLabel":[4,"show-label"],"photoBase64":[1,"photo-base-6-4"],"colorPopupShown":[4,"color-popup-shown"],"colorPopupAlign":[1,"color-popup-align"],"colorOptions":[16],"selectedColor":[8,"selected-color"]},[[6,"click","handleClick"]]]);
const ZeaInputColor$1 = /*@__PURE__*/proxyCustomElement(ZeaInputColor, [1,"zea-input-color",{"showLabel":[4,"show-label"],"selectedColor":[8,"selected-color"],"invalidMessage":[1,"invalid-message"],"invalidMessageShown":[4,"invalid-message-shown"],"required":[4],"isValid":[4,"is-valid"],"colorPopupShown":[4,"color-popup-shown"],"colorPopupAlign":[1,"color-popup-align"],"label":[1],"value":[8],"name":[1],"colorOptions":[16]},[[6,"click","handleClick"]]]);
const ZeaInputDate$1 = /*@__PURE__*/proxyCustomElement(ZeaInputDate, [1,"zea-input-date",{"test":[1]}]);
const ZeaInputPhoto$1 = /*@__PURE__*/proxyCustomElement(ZeaInputPhoto, [1,"zea-input-photo",{"test":[1]}]);
const ZeaInputSearch$1 = /*@__PURE__*/proxyCustomElement(ZeaInputSearch, [1,"zea-input-search",{"placeholder":[1]}]);
const ZeaInputSelect$1 = /*@__PURE__*/proxyCustomElement(ZeaInputSelect, [1,"zea-input-select",{"name":[1],"value":[8],"label":[1],"invalidMessage":[1,"invalid-message"],"required":[4],"isValid":[4,"is-valid"],"autoValidate":[4,"auto-validate"],"invalidMessageShown":[4,"invalid-message-shown"],"showLabel":[4,"show-label"],"optionsShown":[4,"options-shown"],"selectCallback":[8,"select-callback"]},[[6,"click","handleClick"]]]);
const ZeaInputSelectItem$1 = /*@__PURE__*/proxyCustomElement(ZeaInputSelectItem, [1,"zea-input-select-item",{"value":[8]}]);
const ZeaInputText$1 = /*@__PURE__*/proxyCustomElement(ZeaInputText, [1,"zea-input-text",{"name":[1],"value":[8],"label":[1],"invalidMessage":[1,"invalid-message"],"required":[4],"disabled":[4],"isValid":[4,"is-valid"],"autoValidate":[4,"auto-validate"],"invalidMessageShown":[4,"invalid-message-shown"],"showLabel":[4,"show-label"],"hidden":[4]}]);
const ZeaLayout$1 = /*@__PURE__*/proxyCustomElement(ZeaLayout, [1,"zea-layout",{"cellCount":[2,"cell-count"],"orientation":[1],"resizeCellA":[4,"resize-cell-a"],"resizeCellC":[4,"resize-cell-c"],"cellASize":[2,"cell-a-size"],"cellCSize":[2,"cell-c-size"],"resizeInterval":[2,"resize-interval"],"showBorders":[4,"show-borders"],"error":[32],"prevOffset":[32],"minimumGap":[32],"maximunGap":[32],"activeHandle":[32]},[[5,"mouseup","onMouseUp"],[5,"touchend","onTouchEnd"],[5,"mousemove","onMouseMove"],[5,"touchmove","onTouchMove"]]]);
const ZeaMarkdownViewer$1 = /*@__PURE__*/proxyCustomElement(ZeaMarkdownViewer, [1,"zea-markdown-viewer",{"mdText":[1,"md-text"]}]);
const ZeaMenu$1 = /*@__PURE__*/proxyCustomElement(ZeaMenu, [1,"zea-menu",{"leftOffset":[1,"left-offset"],"topOffset":[1,"top-offset"],"type":[1],"orientation":[1],"shown":[4],"showAnchor":[4,"show-anchor"],"anchorIcon":[1,"anchor-icon"],"contextualAlign":[1,"contextual-align"],"anchorIconSize":[2,"anchor-icon-size"]},[[1,"mouseup","handleClick"],[8,"zeaMenuItemClick","handleItemClick"],[1,"mousedown","mousedownHandler"],[5,"mousemove","mousemoveHandler"]]]);
const ZeaMenuColor$1 = /*@__PURE__*/proxyCustomElement(ZeaMenuColor, [1,"zea-menu-color",{"bgColor":[1,"bg-color"],"fgColor":[1,"fg-color"]}]);
const ZeaMenuColorpicker$1 = /*@__PURE__*/proxyCustomElement(ZeaMenuColorpicker, [1,"zea-menu-colorpicker",{"shown":[4],"userColor":[1,"user-color"]}]);
const ZeaMenuItem$1 = /*@__PURE__*/proxyCustomElement(ZeaMenuItem, [1,"zea-menu-item",{"switch":[4],"active":[4],"hasCheckbox":[4,"has-checkbox"],"hasRadio":[4,"has-radio"],"checked":[4],"callback":[8],"shown":[4],"allowHover":[4,"allow-hover"],"hotkey":[1],"type":[1],"hasSubitems":[4,"has-subitems"],"rootMenu":[16],"isPushButton":[4,"is-push-button"]},[[8,"zeaMenuItemClick","windowClickHandler"],[9,"mouseup","handleWindowMouseup"],[9,"touchend","handleWindowTouchend"],[4,"keydown","keydownHandler"]]]);
const ZeaMenuSeparator$1 = /*@__PURE__*/proxyCustomElement(ZeaMenuSeparator, [1,"zea-menu-separator",{"class":[1],"orientation":[1]}]);
const ZeaMenuSubitems$1 = /*@__PURE__*/proxyCustomElement(ZeaMenuSubitems, [1,"zea-menu-subitems",{"shown":[4],"type":[1],"parentItem":[8,"parent-item"],"radioSelect":[4,"radio-select"],"rootMenu":[16]},[[8,"zeaMenuItemClick","windowClickHandler"],[8,"zeaMenuItemPressed","windowItemPressHandler"],[9,"mouseup","handleWindowMouseup"]]]);
const ZeaNavigationDrawer$1 = /*@__PURE__*/proxyCustomElement(ZeaNavigationDrawer, [1,"zea-navigation-drawer",{"shown":[4]},[[4,"click","handleClick"]]]);
const ZeaPanelProgressBar$1 = /*@__PURE__*/proxyCustomElement(ZeaPanelProgressBar, [1,"zea-panel-progress-bar",{"progressBar":[8,"progress-bar"]}]);
const ZeaParamWidgetBbox = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetBBox, [1,"zea-param-widget-bbox",{"parameter":[8],"appData":[1040]}]);
const ZeaParamWidgetBoolean$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetBoolean, [1,"zea-param-widget-boolean",{"parameter":[8],"checked":[4],"appData":[8,"app-data"]}]);
const ZeaParamWidgetCode$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetCode, [0,"zea-param-widget-code",{"parameter":[8],"appData":[8,"app-data"],"editorHeight":[32]},[[0,"keydown","keydownHandler"]]]);
const ZeaParamWidgetColor$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetColor, [1,"zea-param-widget-color",{"parameter":[8],"appData":[8,"app-data"],"sampleColor":[32]},[[9,"resize","handleWindowResize"]]]);
const ZeaParamWidgetMaterialColor$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetMaterialColor, [1,"zea-param-widget-material-color",{"parameter":[8],"appData":[8,"app-data"],"sampleColor":[32]},[[9,"resize","handleWindowResize"]]]);
const ZeaParamWidgetNumber$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetNumber, [1,"zea-param-widget-number",{"parameter":[8],"inputType":[1,"input-type"],"appData":[8,"app-data"],"value":[8],"range":[32],"step":[32]}]);
const ZeaParamWidgetString$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetString, [1,"zea-param-widget-string",{"parameter":[8],"appData":[8,"app-data"]}]);
const ZeaParamWidgetVec2$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetVec2, [1,"zea-param-widget-vec2",{"parameter":[8],"appData":[8,"app-data"],"xValue":[32],"yValue":[32]}]);
const ZeaParamWidgetVec3$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetVec3, [1,"zea-param-widget-vec3",{"parameter":[8],"appData":[8,"app-data"],"xValue":[32],"yValue":[32],"zValue":[32]}]);
const ZeaParamWidgetVec4$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetVec4, [1,"zea-param-widget-vec4",{"parameter":[8],"appData":[8,"app-data"],"xValue":[32],"yValue":[32],"zValue":[32],"tValue":[32]}]);
const ZeaParamWidgetXfo$1 = /*@__PURE__*/proxyCustomElement(ZeaParamWidgetXfo, [1,"zea-param-widget-xfo",{"parameter":[8],"appData":[8,"app-data"]}]);
const ZeaParameterContainer$1 = /*@__PURE__*/proxyCustomElement(ZeaParameterContainer, [1,"zea-parameter-container",{"parameterOwner":[8,"parameter-owner"],"appData":[8,"app-data"]}]);
const ZeaPopupMenu$1 = /*@__PURE__*/proxyCustomElement(ZeaPopupMenu, [1,"zea-popup-menu",{"anchorElement":[16],"shown":[4],"topOffset":[1,"top-offset"],"leftOffset":[1,"left-offset"],"bbox":[32],"node":[32]},[[8,"click","handleClick"]]]);
const ZeaPopupMenuItem$1 = /*@__PURE__*/proxyCustomElement(ZeaPopupMenuItem, [1,"zea-popup-menu-item",{"clickHandler":[16],"startIcon":[1,"start-icon"],"endIcon":[1,"end-icon"]}]);
const ZeaProgressBar$1 = /*@__PURE__*/proxyCustomElement(ZeaProgressBar, [1,"zea-progress-bar",{"type":[1],"percent":[8],"size":[8],"color":[8],"backgroundColor":[8,"background-color"],"indeterminateAnimation":[8,"indeterminate-animation"]}]);
const ZeaQrCode$1 = /*@__PURE__*/proxyCustomElement(ZeaQrCode, [1,"zea-qr-code",{"content":[1],"scale":[2]}]);
const ZeaScrollPane$1 = /*@__PURE__*/proxyCustomElement(ZeaScrollPane, [1,"zea-scroll-pane",null,[[9,"resize","onResize"],[8,"orientationchange","onOrientationchange"],[9,"mouseup","onMouseUp"],[9,"mousemove","onMouseMove"]]]);
const ZeaSwitch$1 = /*@__PURE__*/proxyCustomElement(ZeaSwitch, [1,"zea-switch",{"name":[1],"disabled":[4],"checked":[4],"stateLabel":[1,"state-label"],"elementClass":[32]}]);
const ZeaTabs$1 = /*@__PURE__*/proxyCustomElement(ZeaTabs, [1,"zea-tabs",{"orientation":[1],"density":[1]},[[0,"click","clickHandler"]]]);
const ZeaToolbar$2 = /*@__PURE__*/proxyCustomElement(ZeaToolbar, [1,"zea-toolbar",{"tools":[8]},[[1,"mousedown","mousedownHandler"],[5,"mouseup","mouseupHandler"],[5,"mousemove","mousemoveHandler"]]]);
const ZeaToolbarColorpicker$1 = /*@__PURE__*/proxyCustomElement(ZeaToolbarColorpicker, [1,"zea-toolbar-colorpicker",{"data":[8],"displayChildren":[4,"display-children"]}]);
const ZeaToolbarTool$1 = /*@__PURE__*/proxyCustomElement(ZeaToolbarTool, [1,"zea-toolbar-tool",{"data":[8],"isActive":[4,"is-active"]},[[8,"zeaToolbarToolClick","zeaToolbarToolClickHandler"]]]);
const ZeaToolbarToolset = /*@__PURE__*/proxyCustomElement(ZeaToolbar$1, [1,"zea-toolbar-toolset",{"data":[8]},[[8,"zeaToolbarToolClick","zeaToolbarToolClickHandler"]]]);
const ZeaTreeItemElement$1 = /*@__PURE__*/proxyCustomElement(ZeaTreeItemElement, [1,"zea-tree-item-element",{"label":[1],"isRoot":[4,"is-root"],"isTreeItem":[4,"is-tree-item"],"isSelected":[4,"is-selected"],"isVisible":[4,"is-visible"],"isHighlighted":[4,"is-highlighted"],"treeItem":[8,"tree-item"],"appData":[8,"app-data"],"isExpanded":[4,"is-expanded"],"childItems":[32]}]);
const ZeaTreeView$1 = /*@__PURE__*/proxyCustomElement(ZeaTreeView, [1,"zea-tree-view",{"rootItem":[8,"root-item"],"appData":[8,"app-data"],"mouseIsOver":[32]},[[8,"keydown","onKeyDown"]]]);
const ZeaUserCard$1 = /*@__PURE__*/proxyCustomElement(ZeaUserCard, [1,"zea-user-card",{"userData":[8,"user-data"],"isCurrentUser":[4,"is-current-user"],"collapsible":[4],"additionalDataShown":[4,"additional-data-shown"],"density":[1]}]);
const ZeaUserChip$1 = /*@__PURE__*/proxyCustomElement(ZeaUserChip, [1,"zea-user-chip",{"isCurrentUser":[4,"is-current-user"],"isActive":[4,"is-active"],"showImages":[4,"show-images"],"userData":[8,"user-data"],"density":[1],"showTooltip":[4,"show-tooltip"],"showProfileCard":[4,"show-profile-card"],"profileCardShown":[4,"profile-card-shown"],"profileCardAlign":[1,"profile-card-align"]},[[6,"click","handleClick"]]]);
const ZeaUserChipSet$1 = /*@__PURE__*/proxyCustomElement(ZeaUserChipSet, [1,"zea-user-chip-set",{"showImages":[4,"show-images"],"initialZIndex":[2,"initial-z-index"],"session":[8],"overflowLimit":[8,"overflow-limit"],"overflowShown":[32],"userDatas":[32],"shownOverflowEntry":[32]}]);
const defineCustomElements = (opts) => {
  if (typeof customElements !== 'undefined') {
    [
      IonIcon,
  ZeaButton$1,
  ZeaCheckbox$1,
  ZeaCopyLink$1,
  ZeaDialog$1,
  ZeaDropdownMenu$1,
  ZeaFabButton$1,
  ZeaForm$1,
  ZeaIcon$1,
  ZeaImagesGallery$1,
  ZeaInput$1,
  ZeaInputColor$1,
  ZeaInputDate$1,
  ZeaInputPhoto$1,
  ZeaInputSearch$1,
  ZeaInputSelect$1,
  ZeaInputSelectItem$1,
  ZeaInputText$1,
  ZeaLayout$1,
  ZeaMarkdownViewer$1,
  ZeaMenu$1,
  ZeaMenuColor$1,
  ZeaMenuColorpicker$1,
  ZeaMenuItem$1,
  ZeaMenuSeparator$1,
  ZeaMenuSubitems$1,
  ZeaNavigationDrawer$1,
  ZeaPanelProgressBar$1,
  ZeaParamWidgetBbox,
  ZeaParamWidgetBoolean$1,
  ZeaParamWidgetCode$1,
  ZeaParamWidgetColor$1,
  ZeaParamWidgetMaterialColor$1,
  ZeaParamWidgetNumber$1,
  ZeaParamWidgetString$1,
  ZeaParamWidgetVec2$1,
  ZeaParamWidgetVec3$1,
  ZeaParamWidgetVec4$1,
  ZeaParamWidgetXfo$1,
  ZeaParameterContainer$1,
  ZeaPopupMenu$1,
  ZeaPopupMenuItem$1,
  ZeaProgressBar$1,
  ZeaQrCode$1,
  ZeaScrollPane$1,
  ZeaSwitch$1,
  ZeaTabs$1,
  ZeaToolbar$2,
  ZeaToolbarColorpicker$1,
  ZeaToolbarTool$1,
  ZeaToolbarToolset,
  ZeaTreeItemElement$1,
  ZeaTreeView$1,
  ZeaUserCard$1,
  ZeaUserChip$1,
  ZeaUserChipSet$1
    ].forEach(cmp => {
      if (!customElements.get(cmp.is)) {
        customElements.define(cmp.is, cmp, opts);
      }
    });
  }
};

export { IonIcon, ZeaButton$1 as ZeaButton, ZeaCheckbox$1 as ZeaCheckbox, ZeaCopyLink$1 as ZeaCopyLink, ZeaDialog$1 as ZeaDialog, ZeaDropdownMenu$1 as ZeaDropdownMenu, ZeaFabButton$1 as ZeaFabButton, ZeaForm$1 as ZeaForm, ZeaIcon$1 as ZeaIcon, ZeaImagesGallery$1 as ZeaImagesGallery, ZeaInput$1 as ZeaInput, ZeaInputColor$1 as ZeaInputColor, ZeaInputDate$1 as ZeaInputDate, ZeaInputPhoto$1 as ZeaInputPhoto, ZeaInputSearch$1 as ZeaInputSearch, ZeaInputSelect$1 as ZeaInputSelect, ZeaInputSelectItem$1 as ZeaInputSelectItem, ZeaInputText$1 as ZeaInputText, ZeaLayout$1 as ZeaLayout, ZeaMarkdownViewer$1 as ZeaMarkdownViewer, ZeaMenu$1 as ZeaMenu, ZeaMenuColor$1 as ZeaMenuColor, ZeaMenuColorpicker$1 as ZeaMenuColorpicker, ZeaMenuItem$1 as ZeaMenuItem, ZeaMenuSeparator$1 as ZeaMenuSeparator, ZeaMenuSubitems$1 as ZeaMenuSubitems, ZeaNavigationDrawer$1 as ZeaNavigationDrawer, ZeaPanelProgressBar$1 as ZeaPanelProgressBar, ZeaParamWidgetBbox, ZeaParamWidgetBoolean$1 as ZeaParamWidgetBoolean, ZeaParamWidgetCode$1 as ZeaParamWidgetCode, ZeaParamWidgetColor$1 as ZeaParamWidgetColor, ZeaParamWidgetMaterialColor$1 as ZeaParamWidgetMaterialColor, ZeaParamWidgetNumber$1 as ZeaParamWidgetNumber, ZeaParamWidgetString$1 as ZeaParamWidgetString, ZeaParamWidgetVec2$1 as ZeaParamWidgetVec2, ZeaParamWidgetVec3$1 as ZeaParamWidgetVec3, ZeaParamWidgetVec4$1 as ZeaParamWidgetVec4, ZeaParamWidgetXfo$1 as ZeaParamWidgetXfo, ZeaParameterContainer$1 as ZeaParameterContainer, ZeaPopupMenu$1 as ZeaPopupMenu, ZeaPopupMenuItem$1 as ZeaPopupMenuItem, ZeaProgressBar$1 as ZeaProgressBar, ZeaQrCode$1 as ZeaQrCode, ZeaScrollPane$1 as ZeaScrollPane, ZeaSwitch$1 as ZeaSwitch, ZeaTabs$1 as ZeaTabs, ZeaToolbar$2 as ZeaToolbar, ZeaToolbarColorpicker$1 as ZeaToolbarColorpicker, ZeaToolbarTool$1 as ZeaToolbarTool, ZeaToolbarToolset, ZeaTreeItemElement$1 as ZeaTreeItemElement, ZeaTreeView$1 as ZeaTreeView, ZeaUserCard$1 as ZeaUserCard, ZeaUserChip$1 as ZeaUserChip, ZeaUserChipSet$1 as ZeaUserChipSet, defineCustomElements };
